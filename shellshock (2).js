(() => {
	var e, t, i, s, n = Object.defineProperty,
		a = Object.getOwnPropertyNames,
		r = (e => "undefined" != typeof require ? require : "undefined" != typeof Proxy ? new Proxy(e, {
			get: (e, t) => ("undefined" != typeof require ? require : e)[t]
		}) : e)((function(e) {
			if ("undefined" != typeof require) return require.apply(this, arguments);
			throw Error('Dynamic require of "' + e + '" is not supported')
		})),
		o = (e, t) => function() {
			return e && (t = (0, e[a(e)[0]])(e = 0)), t
		},
		l = (e, t) => {
			for (var i in t) n(e, i, {
				get: t[i],
				enumerable: !0
			})
		},
		h = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Engines/shaderStore.js"() {
				(e = class e {
					static GetShadersStore(t = 0) {
						return 0 === t ? e.ShadersStore : e.ShadersStoreWGSL
					}
					static GetShadersRepository(t = 0) {
						return 0 === t ? e.ShadersRepository : e.ShadersRepositoryWGSL
					}
					static GetIncludesShadersStore(t = 0) {
						return 0 === t ? e.IncludesShadersStore : e.IncludesShadersStoreWGSL
					}
				}).ShadersRepository = "src/Shaders/", e.ShadersStore = {}, e.IncludesShadersStore = {}, e.ShadersRepositoryWGSL = "src/ShadersWGSL/", e.ShadersStoreWGSL = {}, e.IncludesShadersStoreWGSL = {}
			}
		}),
		c = {};
	l(c, {
		postprocessVertexShader: () => s
	});
	var u, m, d, f = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/postprocess.vertex.js"() {
				h(), t = "postprocessVertexShader", i = "attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStore[t] = i, s = {
					name: t,
					shader: i
				}
			}
		}),
		p = {};
	l(p, {
		postprocessVertexShaderWGSL: () => d
	});
	var _, g, v, y = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js"() {
				h(), u = "postprocessVertexShader", m = "attribute position: vec2<f32>;uniform scale: vec2<f32>;varying vUV: vec2<f32>;const madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vUV=(vertexInputs.position*madd+madd)*uniforms.scale;vertexOutputs.position=vec4(vertexInputs.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}\n", e.ShadersStoreWGSL[u] = m, d = {
					name: u,
					shader: m
				}
			}
		}),
		S = {};
	l(S, {
		passPixelShader: () => v
	});
	var E, A, b, x = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/pass.fragment.js"() {
				h(), _ = "passPixelShader", g = "varying vec2 vUV;uniform sampler2D textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=texture2D(textureSampler,vUV);}", e.ShadersStore[_] = g, v = {
					name: _,
					shader: g
				}
			}
		}),
		M = {};
	l(M, {
		bonesDeclarationWGSL: () => b
	});
	var C, T, w, R = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration.js"() {
				h(), E = "bonesDeclaration", A = "#if NUM_BONE_INFLUENCERS>0\nattribute matricesIndices : vec4<f32>;attribute matricesWeights : vec4<f32>;\n#if NUM_BONE_INFLUENCERS>4\nattribute matricesIndicesExtra : vec4<f32>;attribute matricesWeightsExtra : vec4<f32>;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nvar boneSampler : texture_2d<f32>;uniform boneTextureWidth : f32;\n#else\nuniform mBones : array<mat4x4,BonesPerMesh>;\n#ifdef BONES_VELOCITY_ENABLED\nuniform mPreviousBones : array<mat4x4,BonesPerMesh>;\n#endif\n#endif\n#ifdef BONETEXTURE\nfn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>\n{let offset=i32(index) *4; \nlet m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[E] = A, b = {
					name: E,
					shader: A
				}
			}
		}),
		N = {};
	l(N, {
		bonesVertexWGSL: () => w
	});
	var I, P, k, D = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js"() {
				h(), C = "bonesVertex", T = "#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nvar influence : mat4x4<f32>;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[0])*vertexInputs.matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[1])*vertexInputs.matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[2])*vertexInputs.matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndices[3])*vertexInputs.matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[0])*vertexInputs.matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[1])*vertexInputs.matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[2])*vertexInputs.matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+readMatrixFromRawSampler(boneSampler,vertexInputs.matricesIndicesExtra[3])*vertexInputs.matricesWeightsExtra[3];\n#endif \n#else \ninfluence=uniforms.mBones[int(vertexInputs.matricesIndices[0])]*vertexInputs.matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[1])]*vertexInputs.matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[2])]*vertexInputs.matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndices[3])]*vertexInputs.matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[0])]*vertexInputs.matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[1])]*vertexInputs.matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[2])]*vertexInputs.matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+uniforms.mBones[int(vertexInputs.matricesIndicesExtra[3])]*vertexInputs.matricesWeightsExtra[3];\n#endif \n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[C] = T, w = {
					name: C,
					shader: T
				}
			}
		}),
		O = {};
	l(O, {
		bonesDeclaration: () => k
	});
	var F, L, B, G = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js"() {
				h(), I = "bonesDeclaration", P = "#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n", e.IncludesShadersStore[I] = P, k = {
					name: I,
					shader: P
				}
			}
		}),
		H = {};
	l(H, {
		bonesVertex: () => B
	});
	var U, V, W, z = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js"() {
				h(), F = "bonesVertex", L = "#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n", e.IncludesShadersStore[F] = L, B = {
					name: F,
					shader: L
				}
			}
		}),
		X = {};
	l(X, {
		lightFragmentWGSL: () => W
	});
	var Y, j, K, $ = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightFragment.js"() {
				h(), U = "lightFragment", V = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,input.vPositionW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,input.vPositionW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},projectionLightTexture{X}Sampler,uniforms.textureProjectionMatrix{X},input.vPositionW);\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSMDEBUG{X} \nvar shadowDebug{X}: vec3f;\n#endif\n#ifdef SHADOWCSM{X}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nvar index{X}: i32=-1;\n#else\nvar index{X}: i32=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nvar diff{X}: f32=0.;vPositionFromLight{X}[0]=fragmentInputs.vPositionFromLight{X}_0;vPositionFromLight{X}[1]=fragmentInputs.vPositionFromLight{X}_1;vPositionFromLight{X}[2]=fragmentInputs.vPositionFromLight{X}_2;vPositionFromLight{X}[3]=fragmentInputs.vPositionFromLight{X}_3;vDepthMetric{X}[0]=fragmentInputs.vDepthMetric{X}_0;vDepthMetric{X}[1]=fragmentInputs.vDepthMetric{X}_1;vDepthMetric{X}[2]=fragmentInputs.vDepthMetric{X}_2;vDepthMetric{X}[3]=fragmentInputs.vDepthMetric{X}_3;for (var i:i32=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=uniforms.viewFrustumZ{X}[i]+fragmentInputs.vPositionFromCamera{X}.z;\n#else\ndiff{X}=uniforms.viewFrustumZ{X}[i]-fragmentInputs.vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3f(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nvar frustumLength:f32=uniforms.frustumLengths{X}[index{X}];var diffRatio:f32=clamp(diff{X}/frustumLength,0.,1.)*uniforms.cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;var nextShadow: f32=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],,shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,uniforms.lightSizeUVCorrection{X}[index{X}],uniforms.depthCorrection{X}[index{X}],uniforms.penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(index{X},vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},depthTexture{X},depthTexture{X}Sampler,shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(input.vPositionW,light{X}.vLightData.xyz,shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(fragmentInputs.vPositionFromLight{X},fragmentInputs.vDepthMetric{X},shadowTexture{X},shadowTexture{X}Sampler,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[U] = V, W = {
					name: U,
					shader: V
				}
			}
		}),
		J = {};
	l(J, {
		lightUboDeclarationWGSL: () => K
	});
	var q, Q, Z, ee = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightUboDeclaration.js"() {
				h(), Y = "lightUboDeclaration", j = "#ifdef LIGHT{X}\nstruct Light{X}\n{vLightData: vec4f,\nvLightDiffuse: vec4f,\nvLightSpecular: vec4f,\n#ifdef SPOTLIGHT{X}\nvLightDirection: vec4f,\nvLightFalloff: vec4f,\n#elif defined(POINTLIGHT{X})\nvLightFalloff: vec4f,\n#elif defined(HEMILIGHT{X})\nvLightGround: vec3f,\n#endif\nshadowsInfo: vec4f,\ndepthValues: vec2f} ;var<uniform> light{X} : Light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform textureProjectionMatrix{X}: mat4x4f;var projectionLightTexture{X}Sampler: sampler;var projectionLightTexture{X}: texture_2d<f32>;\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;uniform viewFrustumZ{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform frustumLengths{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform cascadeBlendFactor{X}: f32;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;var<private> vPositionFromLight{X}: array<vec4f,4>;var<private> vDepthMetric{X} : array<f32,4>;\n#if defined(SHADOWPCSS{X})\nvar shadowTexture{X}Sampler: sampler_comparison; \nvar shadowTexture{X}: texture_depth_2d_array;var depthTexture{X}Sampler: sampler;var depthTexture{X}: texture_2d_array<f32>;uniform lightSizeUVCorrection{X}: array<vec2f,SHADOWCSMNUM_CASCADES{X}>;uniform depthCorrection{X}: array<f32,SHADOWCSMNUM_CASCADES{X}>;uniform penumbraDarkness{X}: f32;\n#elif defined(SHADOWPCF{X})\nvar shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d_array;\n#else \nvar shadowTexture{X}Sampler: sampler; \nvar shadowTexture{X}: texture_2d_array<f32>;\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vCascadeColorsMultiplier{X}: array<vec3f,8>=array<vec3f,8>\n(\nvec3f ( 1.5,0.0,0.0 ),\nvec3f ( 0.0,1.5,0.0 ),\nvec3f ( 0.0,0.0,5.5 ),\nvec3f ( 1.5,0.0,5.5 ),\nvec3f ( 1.5,1.5,0.0 ),\nvec3f ( 1.0,1.0,1.0 ),\nvec3f ( 0.0,1.0,5.5 ),\nvec3f ( 0.5,3.5,0.75 )\n);\n#endif\n#elif defined(SHADOWCUBE{X})\nvar shadowTexture{X}Sampler: sampler;var shadowTexture{X}: texture_cube<f32>;\n#else\nvarying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;\n#if defined(SHADOWPCSS{X})\nvar shadowTexture{X}Sampler: sampler_comparison; \nvar shadowTexture{X}: texture_depth_2d;var depthTexture{X}Sampler: sampler; \nvar depthTexture{X}: texture_2d<f32>;\n#elif defined(SHADOWPCF{X})\nvar shadowTexture{X}Sampler: sampler_comparison;var shadowTexture{X}: texture_depth_2d;\n#else\nvar shadowTexture{X}Sampler: sampler; \nvar shadowTexture{X}: texture_2d<f32>;\n#endif\nuniform lightMatrix{X}: mat4x4f;\n#endif\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[Y] = j, K = {
					name: Y,
					shader: j
				}
			}
		}),
		te = {};
	l(te, {
		lightVxUboDeclarationWGSL: () => Z
	});
	var ie, se, ne, ae = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightVxUboDeclaration.js"() {
				h(), q = "lightVxUboDeclaration", Q = "#ifdef LIGHT{X}\nstruct Light{X}\n{vLightData: vec4f,\nvLightDiffuse: vec4f,\nvLightSpecular: vec4f,\n#ifdef SPOTLIGHT{X}\nvLightDirection: vec4f,\nvLightFalloff: vec4f,\n#elif defined(POINTLIGHT{X})\nvLightFalloff: vec4f,\n#elif defined(HEMILIGHT{X})\nvLightGround: vec3f,\n#endif\nshadowsInfo: vec4f,\ndepthValues: vec2f} ;var<uniform> light{X} : Light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform lightMatrix{X}: array<mat4x4f,SHADOWCSMNUM_CASCADES{X}>;varying vPositionFromLight{X}_0: vec4f;varying vDepthMetric{X}_0: f32;varying vPositionFromLight{X}_1: vec4f;varying vDepthMetric{X}_1: f32;varying vPositionFromLight{X}_2: vec4f;varying vDepthMetric{X}_2: f32;varying vPositionFromLight{X}_3: vec4f;varying vDepthMetric{X}_3: f32;varying vPositionFromCamera{X}: vec4f;\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vPositionFromLight{X}: vec4f;varying vDepthMetric{X}: f32;uniform lightMatrix{X}: mat4x4f;\n#endif\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[q] = Q, Z = {
					name: q,
					shader: Q
				}
			}
		}),
		re = {};
	l(re, {
		helperFunctionsWGSL: () => ne
	});
	var oe, le, he, ce = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js"() {
				h(), ie = "helperFunctions", se = "const PI: f32=3.1415926535897932384626433832795;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const HALF_MIN: f32=5.96046448e-08; \nconst LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3<f32>=vec3<f32> (0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}\nfn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}\nfn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(0.0),vec3f(1.0));}\nfn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);} \nfn maxEps(x: f32)->f32 {return max(x,Epsilon);}\nfn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}\nfn absEps(x: f32)->f32 {return abs(x)+Epsilon;}\nfn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3<f32>=inMatrix[0];let i1: vec3<f32>=inMatrix[1];let i2: vec3<f32>=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nfn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,\nb11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,\nb21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}\n#if USE_EXACT_SRGB_CONVERSIONS\nfn toLinearSpaceExact(color: vec3<f32>)->vec3<f32>\n{let nearZeroSection: vec3<f32>=0.0773993808*color;let remainingSection: vec3<f32>=pow(0.947867299*(color+vec3<f32>(0.055)),vec3<f32>(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.04045)));}\nfn toGammaSpaceExact(color: vec3<f32>)->vec3<f32>\n{let nearZeroSection: vec3<f32>=12.92*color;let remainingSection: vec3<f32>=1.055*pow(color,vec3<f32>(0.41666))-vec3<f32>(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3<f32>(0.0031308)));}\n#endif\nfn toLinearSpace(color: f32)->f32\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nvar nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nfn toLinearSpaceVec3(color: vec3<f32>)->vec3<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3<f32>(LinearEncodePowerApprox));\n#endif\n}\nfn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4f(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpace(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4<f32>(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4<f32>(pow(color.rgb,vec3<f32>(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpaceVec3(color: vec3<f32>)->vec3<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3<f32>(GammaEncodePowerApprox));\n#endif\n}\nfn squareVec3(value: vec3<f32>)->vec3<f32>\n{return value*value;}\nfn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}\nfn getLuminance(color: vec3<f32>)->f32\n{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}\nfn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}\nfn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}\nconst rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3<f32>)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3<f32> =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(clamp(rgb,vec3<f32>(0.,0.,0.),vec3<f32>(1.,1.,1.)),D); }\nfn fromRGBD(rgbd: vec4<f32>)->vec3<f32> {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}\nfn parallaxCorrectNormal(vertexPos: vec3<f32>,origVec: vec3<f32>,cubeSize: vec3<f32>,cubePos: vec3<f32>)->vec3<f32> {let invOrigVec: vec3<f32>=vec3<f32>(1.0,1.0,1.0)/origVec;let halfSize: vec3<f32>=cubeSize*0.5;let intersecAtMaxPlane: vec3<f32>=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3<f32>=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3<f32>=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3<f32>=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\n", e.IncludesShadersStoreWGSL[ie] = se, ne = {
					name: ie,
					shader: se
				}
			}
		}),
		ue = {};
	l(ue, {
		lightsFragmentFunctionsWGSL: () => he
	});
	var me, de, fe, pe = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightsFragmentFunctions.js"() {
				h(), oe = "lightsFragmentFunctions", le = "struct lightingInfo\n{diffuse: vec3f,\n#ifdef SPECULARTERM\nspecular: vec3f,\n#endif\n#ifdef NDOTL\nndl: f32,\n#endif\n};fn computeLighting(viewDirectionW: vec3f,vNormal: vec3f,lightData: vec4f,diffuseColor: vec3f,specularColor: vec3f,range: f32,glossiness: f32)->lightingInfo {var result: lightingInfo;var lightVectorW: vec3f;var attenuation: f32=1.0;if (lightData.w==0.)\n{var direction: vec3f=lightData.xyz-fragmentInputs.vPositionW;var attenuation: f32=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nvar ndl: f32=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvar angleW: vec3f=normalize(viewDirectionW+lightVectorW);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nfn computeSpotLighting(viewDirectionW: vec3f,vNormal: vec3f ,lightData: vec4f,lightDirection: vec4f,diffuseColor: vec3f,specularColor: vec3f,range: f32,glossiness: f32)->lightingInfo {var result: lightingInfo;var direction: vec3f=lightData.xyz-fragmentInputs.vPositionW;var lightVectorW: vec3f=normalize(direction);var attenuation: f32=max(0.,1.0-length(direction)/range);var cosAngle: f32=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;var ndl: f32=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvar angleW: vec3f=normalize(viewDirectionW+lightVectorW);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3f(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3f(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nfn computeHemisphericLighting(viewDirectionW: vec3f,vNormal: vec3f,lightData: vec4f,diffuseColor: vec3f,specularColor: vec3f,groundColor: vec3f,glossiness: f32)->lightingInfo {var result: lightingInfo;var ndl: f32=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvar angleW: vec3f=normalize(viewDirectionW+lightData.xyz);var specComp: f32=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\nfn computeProjectionTextureDiffuseLighting(projectionLightTexture: texture_2d<f32>,projectionLightSampler: sampler,textureProjectionMatrix: mat4x4f,posW: vec3f)->vec3f {var strq: vec4f=textureProjectionMatrix*vec4f(posW,1.0);strq/=strq.w;var textureColor: vec3f=textureSample(projectionLightTexture,projectionLightSampler,strq.xy).rgb;return textureColor;}", e.IncludesShadersStoreWGSL[oe] = le, he = {
					name: oe,
					shader: le
				}
			}
		}),
		_e = {};
	l(_e, {
		shadowsFragmentFunctionsWGSL: () => fe
	});
	var ge, ve, ye, Se = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsFragmentFunctions.js"() {
				h(), me = "shadowsFragmentFunctions", de = "#ifdef SHADOWS\n#ifndef SHADOWFLOAT\nfn unpack(color: vec4f)->f32\n{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfn computeFallOff(value: f32,clipSpace: vec2f,frustumEdgeFalloff: f32)->f32\n{var mask: f32=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\nfn computeShadowCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthValues: vec2f)->f32\n{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nvar shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));\n#else\nvar shadow: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;\n#endif\nreturn select(darkness,1.0,depth>shadow);}\nfn computeShadowWithPoissonSamplingCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,depthValues: vec2f)->f32\n{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;var visibility: f32=1.;var poissonDisk: array<vec3f,4>;poissonDisk[0]= vec3f(-1.0,1.0,-1.0);poissonDisk[1]= vec3f(1.0,-1.0,-1.0);poissonDisk[2]= vec3f(-1.0,-1.0,-1.0);poissonDisk[3]= vec3f(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) {visibility-=0.25;};if (unpack(textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) {visibility-=0.25;};\n#else\nif (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) {visibility-=0.25;};if (textureSample(shadowTexture,shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) {visibility-=0.25;};\n#endif\nreturn min(1.0,visibility+darkness);}\nfn computeShadowWithESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32\n{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nvar shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));\n#else\nvar shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;\n#endif\nvar esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\nfn computeShadowWithCloseESMCube(worldPos: vec3f,lightPosition: vec3f,shadowTexture: texture_cube<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,depthValues: vec2f)->f32\n{var directionToLight: vec3f=worldPos-lightPosition;var depth: f32=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);var shadowPixelDepth: f32=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nvar shadowMapSample: f32=unpack(textureSample(shadowTexture,shadowSampler,directionToLight));\n#else\nvar shadowMapSample: f32=textureSample(shadowTexture,shadowSampler,directionToLight).x;\n#endif\nvar esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\nfn computeShadowCSM(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d_array<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nvar shadow: f32=unpack(textureSample(shadowTexture,shadowSampler,uv,layer));\n#else\nvar shadow: f32=textureSample(shadowTexture,shadowSampler,uv,layer).x;\n#endif\nreturn select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}\nfn computeShadow(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nvar shadow: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));\n#else\nvar shadow: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;\n#endif\nreturn select(1.,computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff),shadowPixelDepth>shadow );}}\nfn computeShadowWithPoissonSampling(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,mapSize: f32,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);var visibility: f32=1.;var poissonDisk: array<vec2f,4>;poissonDisk[0]= vec2f(-0.94201624,-0.39906216);poissonDisk[1]= vec2f(0.94558609,-0.76890725);poissonDisk[2]= vec2f(-0.094184101,-0.92938870);poissonDisk[3]= vec2f(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}\nif (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}\nif (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}\nif (unpack(textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) {visibility-=0.25;}\n#else\nif (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}\nif (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}\nif (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}\nif (textureSampleLevel(shadowTexture,shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) {visibility-=0.25;}\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\nfn computeShadowWithESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nvar shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));\n#else\nvar shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;\n#endif\nvar esm: f32=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\nfn computeShadowWithCloseESM(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_2d<f32>,shadowSampler: sampler,darkness: f32,depthScale: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uv: vec2f=0.5*clipSpace.xy+ vec2f(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{var shadowPixelDepth: f32=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nvar shadowMapSample: f32=unpack(textureSampleLevel(shadowTexture,shadowSampler,uv,0.));\n#else\nvar shadowMapSample: f32=textureSampleLevel(shadowTexture,shadowSampler,uv,0.).x;\n#endif\nvar esm: f32=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\nfn getZInClip(clipSpace: vec3f,uvDepth: vec3f)->f32\n{\n#ifdef IS_NDC_HALF_ZRANGE\nreturn clipSpace.z;\n#else\nreturn uvDepth.z;\n#endif\n}\nconst GREATEST_LESS_THAN_ONE: f32=0.99999994;\n#define DISABLE_UNIFORMITY_ANALYSIS\nfn computeShadowWithCSMPCF1(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var shadow: f32=textureSampleCompare(shadowTexture,shadowSampler,uvDepth.xy,layer,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\nfn computeShadowWithCSMPCF3(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvar st: vec2f=fract(uv); \nvar base_uv: vec2f=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvar uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\nfn computeShadowWithCSMPCF5(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvar st: vec2f=fract(uv); \nvar base_uv: vec2f=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvar uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),layer,uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),layer,uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),layer,uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),layer,uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),layer,uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),layer,uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),layer,uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),layer,uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompare(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),layer,uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\nfn computeShadowWithPCF1(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,darkness: f32,frustumEdgeFalloff: f32)->f32\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var shadow: f32=textureSampleCompareLevel(shadowTexture,shadowSampler,uvDepth.xy,uvDepth.z);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nfn computeShadowWithPCF3(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvar st: vec2f=fract(uv); \nvar base_uv: vec2f=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvar uvw0: vec2f=3.-2.*st;var uvw1: vec2f=1.+2.*st;var u: vec2f= vec2f((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;var v: vec2f= vec2f((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nfn computeShadowWithPCF5(vPositionFromLight: vec4f,depthMetric: f32,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeAndInverse: vec2f,darkness: f32,frustumEdgeFalloff: f32)->f32\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var uv: vec2f=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvar st: vec2f=fract(uv); \nvar base_uv: vec2f=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvar uvw0: vec2f=4.-3.*st;var uvw1: vec2f= vec2f(7.);var uvw2: vec2f=1.+3.*st;var u: vec3f= vec3f((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;var v: vec3f= vec3f((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;var shadow: f32=0.;shadow+=uvw0.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[0]),uvDepth.z);shadow+=uvw1.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[0]),uvDepth.z);shadow+=uvw2.x*uvw0.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[0]),uvDepth.z);shadow+=uvw0.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[1]),uvDepth.z);shadow+=uvw1.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[1]),uvDepth.z);shadow+=uvw2.x*uvw1.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[1]),uvDepth.z);shadow+=uvw0.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[0],v[2]),uvDepth.z);shadow+=uvw1.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[1],v[2]),uvDepth.z);shadow+=uvw2.x*uvw2.y*textureSampleCompareLevel(shadowTexture,shadowSampler, base_uv.xy+ vec2f(u[2],v[2]),uvDepth.z);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst PoissonSamplers32: array<vec3f,64>=array<vec3f,64> (\nvec3f(0.06407013,0.05409927,0.),\nvec3f(0.7366577,0.5789394,0.),\nvec3f(-0.6270542,-0.5320278,0.),\nvec3f(-0.4096107,0.8411095,0.),\nvec3f(0.6849564,-0.4990818,0.),\nvec3f(-0.874181,-0.04579735,0.),\nvec3f(0.9989998,0.0009880066,0.),\nvec3f(-0.004920578,-0.9151649,0.),\nvec3f(0.1805763,0.9747483,0.),\nvec3f(-0.2138451,0.2635818,0.),\nvec3f(0.109845,0.3884785,0.),\nvec3f(0.06876755,-0.3581074,0.),\nvec3f(0.374073,-0.7661266,0.),\nvec3f(0.3079132,-0.1216763,0.),\nvec3f(-0.3794335,-0.8271583,0.),\nvec3f(-0.203878,-0.07715034,0.),\nvec3f(0.5912697,0.1469799,0.),\nvec3f(-0.88069,0.3031784,0.),\nvec3f(0.5040108,0.8283722,0.),\nvec3f(-0.5844124,0.5494877,0.),\nvec3f(0.6017799,-0.1726654,0.),\nvec3f(-0.5554981,0.1559997,0.),\nvec3f(-0.3016369,-0.3900928,0.),\nvec3f(-0.5550632,-0.1723762,0.),\nvec3f(0.925029,0.2995041,0.),\nvec3f(-0.2473137,0.5538505,0.),\nvec3f(0.9183037,-0.2862392,0.),\nvec3f(0.2469421,0.6718712,0.),\nvec3f(0.3916397,-0.4328209,0.),\nvec3f(-0.03576927,-0.6220032,0.),\nvec3f(-0.04661255,0.7995201,0.),\nvec3f(0.4402924,0.3640312,0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.),\nvec3f(0.)\n);const PoissonSamplers64: array<vec3f,64>=array<vec3f,64> (\nvec3f(-0.613392,0.617481,0.),\nvec3f(0.170019,-0.040254,0.),\nvec3f(-0.299417,0.791925,0.),\nvec3f(0.645680,0.493210,0.),\nvec3f(-0.651784,0.717887,0.),\nvec3f(0.421003,0.027070,0.),\nvec3f(-0.817194,-0.271096,0.),\nvec3f(-0.705374,-0.668203,0.),\nvec3f(0.977050,-0.108615,0.),\nvec3f(0.063326,0.142369,0.),\nvec3f(0.203528,0.214331,0.),\nvec3f(-0.667531,0.326090,0.),\nvec3f(-0.098422,-0.295755,0.),\nvec3f(-0.885922,0.215369,0.),\nvec3f(0.566637,0.605213,0.),\nvec3f(0.039766,-0.396100,0.),\nvec3f(0.751946,0.453352,0.),\nvec3f(0.078707,-0.715323,0.),\nvec3f(-0.075838,-0.529344,0.),\nvec3f(0.724479,-0.580798,0.),\nvec3f(0.222999,-0.215125,0.),\nvec3f(-0.467574,-0.405438,0.),\nvec3f(-0.248268,-0.814753,0.),\nvec3f(0.354411,-0.887570,0.),\nvec3f(0.175817,0.382366,0.),\nvec3f(0.487472,-0.063082,0.),\nvec3f(-0.084078,0.898312,0.),\nvec3f(0.488876,-0.783441,0.),\nvec3f(0.470016,0.217933,0.),\nvec3f(-0.696890,-0.549791,0.),\nvec3f(-0.149693,0.605762,0.),\nvec3f(0.034211,0.979980,0.),\nvec3f(0.503098,-0.308878,0.),\nvec3f(-0.016205,-0.872921,0.),\nvec3f(0.385784,-0.393902,0.),\nvec3f(-0.146886,-0.859249,0.),\nvec3f(0.643361,0.164098,0.),\nvec3f(0.634388,-0.049471,0.),\nvec3f(-0.688894,0.007843,0.),\nvec3f(0.464034,-0.188818,0.),\nvec3f(-0.440840,0.137486,0.),\nvec3f(0.364483,0.511704,0.),\nvec3f(0.034028,0.325968,0.),\nvec3f(0.099094,-0.308023,0.),\nvec3f(0.693960,-0.366253,0.),\nvec3f(0.678884,-0.204688,0.),\nvec3f(0.001801,0.780328,0.),\nvec3f(0.145177,-0.898984,0.),\nvec3f(0.062655,-0.611866,0.),\nvec3f(0.315226,-0.604297,0.),\nvec3f(-0.780145,0.486251,0.),\nvec3f(-0.371868,0.882138,0.),\nvec3f(0.200476,0.494430,0.),\nvec3f(-0.494552,-0.711051,0.),\nvec3f(0.612476,0.705252,0.),\nvec3f(-0.578845,-0.768792,0.),\nvec3f(-0.772454,-0.090976,0.),\nvec3f(0.504440,0.372295,0.),\nvec3f(0.155736,0.065157,0.),\nvec3f(0.391522,0.849605,0.),\nvec3f(-0.620106,-0.328104,0.),\nvec3f(0.789239,-0.419965,0.),\nvec3f(-0.545396,0.538133,0.),\nvec3f(-0.178564,-0.596057,0.)\n);fn computeShadowWithCSMPCSS(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=clamp(getZInClip(clipSpace,uvDepth),0.,GREATEST_LESS_THAN_ONE);var uvDepthLayer: vec4f= vec4f(uvDepth.x,uvDepth.y,f32(layer),uvDepth.z);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;for (var i: i32=0; i<searchTapCount; i ++) {blockerDepth=textureSample(depthTexture,depthSampler, uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}\nvar avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);var filterRadius: vec4f= vec4f(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {var offset: vec4f= vec4f(poissonSamplers[i],0.);offset= vec4f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);let coords=uvDepthLayer+offset*filterRadius;shadow+=textureSampleCompare(shadowTexture,shadowSampler,coords.xy,i32(coords.z),coords.w);}\nshadow/= f32(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,numBlocker<1.0);}\nfn computeShadowWithPCSS(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,searchTapCount: i32,pcfTapCount: i32,poissonSamplers: array<vec3f,64>)->f32\n{var clipSpace: vec3f=vPositionFromLight.xyz/vPositionFromLight.w;var uvDepth: vec3f= vec3f(0.5*clipSpace.xyz+ vec3f(0.5));uvDepth.z=getZInClip(clipSpace,uvDepth);var blockerDepth: f32=0.0;var sumBlockerDepth: f32=0.0;var numBlocker: f32=0.0;var exitCondition: bool=depthMetric>1.0 || depthMetric<0.0;for (var i: i32=0; i<searchTapCount; i ++) {if (exitCondition) {break;}\nblockerDepth=textureSampleLevel(depthTexture,depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0).r;numBlocker+=select(0.,1.,blockerDepth<depthMetric);sumBlockerDepth+=select(0.,blockerDepth,blockerDepth<depthMetric);}\nexitCondition=exitCondition || numBlocker<1.0;var avgBlockerDepth: f32=sumBlockerDepth/numBlocker;var AAOffset: f32=shadowMapSizeInverse*10.;var penumbraRatio: f32=((depthMetric-avgBlockerDepth)+AAOffset);var filterRadius: f32=penumbraRatio*lightSizeUV*shadowMapSizeInverse;var random: f32=getRand(vPositionFromLight.xy);var rotationAngle: f32=random*3.1415926;var rotationVector: vec2f= vec2f(cos(rotationAngle),sin(rotationAngle));var shadow: f32=0.;for (var i: i32=0; i<pcfTapCount; i++) {if (exitCondition) {break;}\nvar offset: vec3f=poissonSamplers[i];offset= vec3f(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);let coords=uvDepth+offset*filterRadius;shadow+=textureSampleCompareLevel(shadowTexture,shadowSampler,coords.xy,coords.z);}\nshadow/= f32(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return select(computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff),1.0,exitCondition);}\nfn computeShadowWithPCSS16(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\nfn computeShadowWithPCSS32(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\nfn computeShadowWithPCSS64(vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32)->f32\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\nfn computeShadowWithCSMPCSS16(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\nfn computeShadowWithCSMPCSS32(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\nfn computeShadowWithCSMPCSS64(layer: i32,vPositionFromLight: vec4f,depthMetric: f32,depthTexture: texture_2d_array<f32>,depthSampler: sampler,shadowTexture: texture_depth_2d_array,shadowSampler: sampler_comparison,shadowMapSizeInverse: f32,lightSizeUV: f32,darkness: f32,frustumEdgeFalloff: f32,lightSizeUVCorrection: vec2f,depthCorrection: f32,penumbraDarkness: f32)->f32\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthTexture,depthSampler,shadowTexture,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n", e.IncludesShadersStoreWGSL[me] = de, fe = {
					name: me,
					shader: de
				}
			}
		}),
		Ee = {};
	l(Ee, {
		shadowsVertexWGSL: () => ye
	});
	var Ae, be, xe, Me = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowsVertex.js"() {
				h(), ge = "shadowsVertex", ve = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvertexOutputs.vPositionFromCamera{X}=scene.view*worldPos;\n#if SHADOWCSMNUM_CASCADES{X}>0\nvertexOutputs.vPositionFromLight{X}_0=uniforms.lightMatrix{X}[0]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric{X}_0=(-vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvertexOutputs.vDepthMetric{X}_0= (vertexOutputs.vPositionFromLight{X}_0.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#if SHADOWCSMNUM_CASCADES{X}>1\nvertexOutputs.vPositionFromLight{X}_1=uniforms.lightMatrix{X}[1]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric{X}_1=(-vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvertexOutputs.vDepthMetric{X}_1= (vertexOutputs.vPositionFromLight{X}_1.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif \n#if SHADOWCSMNUM_CASCADES{X}>2\nvertexOutputs.vPositionFromLight{X}_2=uniforms.lightMatrix{X}[2]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric{X}_2=(-vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvertexOutputs.vDepthMetric{X}_2= (vertexOutputs.vPositionFromLight{X}_2.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif \n#if SHADOWCSMNUM_CASCADES{X}>3\nvertexOutputs.vPositionFromLight{X}_3=uniforms.lightMatrix{X}[3]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric{X}_3=(-vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvertexOutputs.vDepthMetric{X}_3= (vertexOutputs.vPositionFromLight{X}_3.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif \n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvertexOutputs.vPositionFromLight{X}=uniforms.lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric{X}=(-vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvertexOutputs.vDepthMetric{X}=(vertexOutputs.vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[ge] = ve, ye = {
					name: ge,
					shader: ve
				}
			}
		}),
		Ce = {};
	l(Ce, {
		lightFragmentDeclaration: () => xe
	});
	var Te, we, Re, Ne = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js"() {
				h(), Ae = "lightFragmentDeclaration", be = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowTexture{X};\n#else\nuniform highp sampler2DArray shadowTexture{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowTexture{X};\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowTexture{X};\n#else\nuniform sampler2D shadowTexture{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};\n#endif\n#endif\n", e.IncludesShadersStore[Ae] = be, xe = {
					name: Ae,
					shader: be
				}
			}
		}),
		Ie = {};
	l(Ie, {
		lightFragment: () => Re
	});
	var Pe, ke, De, Oe = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js"() {
				h(), Te = "lightFragment", we = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW,vPositionW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightTexture{X},textureProjectionMatrix{X},vPositionW);\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;float nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthTexture{X},shadowTexture{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowTexture{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowTexture{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n", e.IncludesShadersStore[Te] = we, Re = {
					name: Te,
					shader: we
				}
			}
		}),
		Fe = {};
	l(Fe, {
		lightUboDeclaration: () => De
	});
	var Le, Be, Ge, He = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js"() {
				h(), Pe = "lightUboDeclaration", ke = "#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightTexture{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowTexture{X};uniform highp sampler2DArray depthTexture{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowTexture{X};\n#else\nuniform highp sampler2DArray shadowTexture{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowTexture{X}; \n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowTexture{X};uniform highp sampler2D depthTexture{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowTexture{X};\n#else\nuniform sampler2D shadowTexture{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n", e.IncludesShadersStore[Pe] = ke, De = {
					name: Pe,
					shader: ke
				}
			}
		}),
		Ue = {};
	l(Ue, {
		lightVxUboDeclaration: () => Ge
	});
	var Ve, We, ze, Xe = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js"() {
				h(), Le = "lightVxUboDeclaration", Be = "#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n", e.IncludesShadersStore[Le] = Be, Ge = {
					name: Le,
					shader: Be
				}
			}
		}),
		Ye = {};
	l(Ye, {
		lightVxFragmentDeclaration: () => ze
	});
	var je, Ke, $e, Je = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js"() {
				h(), Ve = "lightVxFragmentDeclaration", We = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n", e.IncludesShadersStore[Ve] = We, ze = {
					name: Ve,
					shader: We
				}
			}
		}),
		qe = {};
	l(qe, {
		helperFunctions: () => $e
	});
	var Qe, Ze, et, tt = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js"() {
				h(), je = "helperFunctions", Ke = "const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\n", e.IncludesShadersStore[je] = Ke, $e = {
					name: je,
					shader: Ke
				}
			}
		}),
		it = {};
	l(it, {
		lightsFragmentFunctions: () => et
	});
	var st, nt, at, rt = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js"() {
				h(), Qe = "lightsFragmentFunctions", Ze = "struct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)\n{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix,vec3 posW){vec4 strq=textureProjectionMatrix*vec4(posW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}", e.IncludesShadersStore[Qe] = Ze, et = {
					name: Qe,
					shader: Ze
				}
			}
		}),
		ot = {};
	l(ot, {
		shadowsFragmentFunctions: () => at
	});
	var lt, ht, ct, ut = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js"() {
				h(), st = "shadowsFragmentFunctions", nt = "#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\n#define inline\nfloat computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);}\n#define inline\nfloat computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define DISABLE_UNIFORMITY_ANALYSIS\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.)\n);const vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}\nelse\n{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nif (numBlocker<1.0) {return 1.0;}\nelse\n{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n#endif\n", e.IncludesShadersStore[st] = nt, at = {
					name: st,
					shader: nt
				}
			}
		}),
		mt = {};
	l(mt, {
		shadowsVertex: () => ct
	});
	var dt, ft, pt, _t = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js"() {
				h(), lt = "shadowsVertex", ht = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n", e.IncludesShadersStore[lt] = ht, ct = {
					name: lt,
					shader: ht
				}
			}
		}),
		gt = {};
	l(gt, {
		fogFragmentDeclarationWGSL: () => pt
	});
	var vt, yt, St, Et = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragmentDeclaration.js"() {
				h(), dt = "fogFragmentDeclaration", ft = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\nconst E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32\n{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n", e.IncludesShadersStoreWGSL[dt] = ft, pt = {
					name: dt,
					shader: ft
				}
			}
		}),
		At = {};
	l(At, {
		fogFragmentDeclaration: () => St
	});
	var bt, xt, Mt, Ct = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js"() {
				h(), vt = "fogFragmentDeclaration", yt = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n", e.IncludesShadersStore[vt] = yt, St = {
					name: vt,
					shader: yt
				}
			}
		}),
		Tt = {};
	l(Tt, {
		shadowMapVertexMetricWGSL: () => Mt
	});
	var wt, Rt, Nt, It = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexMetric.js"() {
				h(), bt = "shadowMapVertexMetric", xt = "#if SM_USEDISTANCE==1\nvertexOutputs.vPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE==1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.position.z-=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;\n#else\nvertexOutputs.position.z+=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;\n#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvertexOutputs.zSM=vertexOutputs.position.z;vertexOutputs.position.z=0.0;\n#elif SM_USEDISTANCE==0\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetricSM=(-vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#else\nvertexOutputs.vDepthMetricSM=(vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#endif\n#endif\n", e.IncludesShadersStoreWGSL[bt] = xt, Mt = {
					name: bt,
					shader: xt
				}
			}
		}),
		Pt = {};
	l(Pt, {
		packingFunctionsWGSL: () => Nt
	});
	var kt, Dt, Ot, Ft = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/packingFunctions.js"() {
				h(), wt = "packingFunctions", Rt = "fn pack(depth: f32)->vec4f\n{const bit_shift: vec4f= vec4f(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const bit_mask: vec4f= vec4f(0.0,1.0/255.0,1.0/255.0,1.0/255.0);var res: vec4f=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfn unpack(color: vec4f)->f32\n{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}", e.IncludesShadersStoreWGSL[wt] = Rt, Nt = {
					name: wt,
					shader: Rt
				}
			}
		}),
		Lt = {};
	l(Lt, {
		shadowMapFragmentWGSL: () => Ot
	});
	var Bt, Gt, Ht, Ut = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapFragment.js"() {
				h(), kt = "shadowMapFragment", Dt = "var depthSM: f32=fragmentInputs.vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#else\ndepthSM=(fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\nfragmentOutputs.fragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\nfragmentOutputs.fragDepth=clamp(depthSM,0.0,1.0); \n#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;\n#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,uniforms.biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT==1\nfragmentOutputs.color= vec4f(depthSM,1.0,1.0,1.0);\n#else\nfragmentOutputs.color=pack(depthSM);\n#endif\n", e.IncludesShadersStoreWGSL[kt] = Dt, Ot = {
					name: kt,
					shader: Dt
				}
			}
		}),
		Vt = {};
	l(Vt, {
		shadowMapVertexMetric: () => Ht
	});
	var Wt, zt, Xt, Yt = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexMetric.js"() {
				h(), Bt = "shadowMapVertexMetric", Gt = "#if SM_USEDISTANCE==1\nvPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE==1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#else\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nzSM=gl_Position.z;gl_Position.z=0.0;\n#elif SM_USEDISTANCE==0\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n", e.IncludesShadersStore[Bt] = Gt, Ht = {
					name: Bt,
					shader: Gt
				}
			}
		}),
		jt = {};
	l(jt, {
		packingFunctions: () => Xt
	});
	var Kt, $t, Jt, qt = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js"() {
				h(), Wt = "packingFunctions", zt = "vec4 pack(float depth)\n{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}", e.IncludesShadersStore[Wt] = zt, Xt = {
					name: Wt,
					shader: zt
				}
			}
		}),
		Qt = {};
	l(Qt, {
		shadowMapFragment: () => Jt
	});
	var Zt, ei, ti, ii = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js"() {
				h(), Kt = "shadowMapFragment", $t = "float depthSM=vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\ngl_FragDepth=clamp(depthSM,0.0,1.0); \n#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT==1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depthSM);\n#endif\nreturn;", e.IncludesShadersStore[Kt] = $t, Jt = {
					name: Kt,
					shader: $t
				}
			}
		}),
		si = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js"() {
				h(), e.IncludesShadersStore.kernelBlurVaryingDeclaration = "varying vec2 sampleCoord{X};"
			}
		}),
		ni = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment.js"() {
				h(), e.IncludesShadersStore.kernelBlurFragment = "#ifdef DOF\nfactor=sampleCoC(sampleCoord{X}); \ncomputedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif\n"
			}
		}),
		ai = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js"() {
				h(), e.IncludesShadersStore.kernelBlurFragment2 = "#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif\n"
			}
		}),
		ri = {};
	l(ri, {
		kernelBlurPixelShader: () => ti
	});
	var oi, li, hi, ci = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js"() {
				h(), si(), qt(), ni(), ai(), Zt = "kernelBlurPixelShader", ei = "uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{float computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT; \nfloat factor=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}", e.ShadersStore[Zt] = ei, ti = {
					name: Zt,
					shader: ei
				}
			}
		}),
		ui = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVertex.js"() {
				h(), e.IncludesShadersStore.kernelBlurVertex = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};"
			}
		}),
		mi = {};
	l(mi, {
		kernelBlurVertexShader: () => hi
	});
	var di, fi, pi, _i = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/kernelBlur.vertex.js"() {
				h(), si(), ui(), oi = "kernelBlurVertexShader", li = "attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStore[oi] = li, hi = {
					name: oi,
					shader: li
				}
			}
		}),
		gi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurVaryingDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.kernelBlurVaryingDeclaration = "varying sampleCoord{X}: vec2f;"
			}
		}),
		vi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.kernelBlurFragment = "#ifdef DOF\nfactor=sampleCoC(fragmentInputs.sampleCoord{X}); \ncomputedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X}))*computedWeight;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X})*computedWeight;\n#endif\n"
			}
		}),
		yi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment2.js"() {
				h(), e.IncludesShadersStoreWGSL.kernelBlurFragment2 = "#ifdef DOF\nfactor=sampleCoC(fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif\n"
			}
		}),
		Si = {};
	l(Si, {
		kernelBlurPixelShaderWGSL: () => pi
	});
	var Ei, Ai, bi, xi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.fragment.js"() {
				h(), gi(), Ft(), vi(), yi(), di = "kernelBlurPixelShader", fi = "var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;\n#ifdef DOF\nvar circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;\n#ifdef PACKEDFLOAT\nvar blend: f32=0.;\n#else\nvar blend: vec4f= vec4f(0.);\n#endif\n#ifdef DOF\nvar sumOfWeights: f32=CENTER_WEIGHT; \nvar factor: f32=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\nfragmentOutputs.color=pack(blend);\n#else\nfragmentOutputs.color=blend;\n#endif\n#ifdef DOF\nfragmentOutputs.color/=sumOfWeights;\n#endif\n}", e.ShadersStoreWGSL[di] = fi, pi = {
					name: di,
					shader: fi
				}
			}
		}),
		Mi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.kernelBlurVertex = "vertexOutputs.sampleCoord{X}=vertexOutputs.sampleCenter+uniforms.delta*KERNEL_OFFSET{X};"
			}
		}),
		Ci = {};
	l(Ci, {
		kernelBlurVertexShaderWGSL: () => bi
	});
	var Ti, wi, Ri, Ni = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.vertex.js"() {
				h(), gi(), Mi(), Ei = "kernelBlurVertexShader", Ai = "attribute position: vec2f;uniform delta: vec2f;varying sampleCenter: vec2f;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.sampleCenter=(input.position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\nvertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStoreWGSL[Ei] = Ai, bi = {
					name: Ei,
					shader: Ai
				}
			}
		}),
		Ii = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bayerDitherFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.bayerDitherFunctions = "fn bayerDither2(_P: vec2f)->f32 {return ((2.0*_P.y+_P.x+1.0)%(4.0));}\nfn bayerDither4(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); \nvar P2: vec2f=floor(0.5*((_P)%(4.0))); \nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);}\nfn bayerDither8(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); \nvar P2: vec2f=floor(0.5 *((_P)%(4.0))); \nvar P4: vec2f=floor(0.25*((_P)%(8.0))); \nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}\n"
			}
		}),
		Pi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapFragmentExtraDeclaration.js"() {
				h(), Ft(), Ii(), e.IncludesShadersStoreWGSL.shadowMapFragmentExtraDeclaration = "#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform softTransparentShadowSM: vec2f;\n#endif\nvarying vDepthMetricSM: f32;\n#if SM_USEDISTANCE==1\nuniform lightDataSM: vec3f;varying vPositionWSM: vec3f;\n#endif\nuniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying zSM: f32;\n#endif\n"
			}
		}),
		ki = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.clipPlaneFragmentDeclaration = "#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n"
			}
		}),
		Di = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.clipPlaneFragment = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n"
			}
		}),
		Oi = {};
	l(Oi, {
		shadowMapPixelShaderWGSL: () => Ri
	});
	var Fi, Li, Bi, Gi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/shadowMap.fragment.js"() {
				h(), Pi(), ki(), Di(), Ut(), Ti = "shadowMapPixelShader", wi = "#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nvar opacityMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV);var alphaFromAlphaTexture: f32=opacityMap.a;\n#if SM_SOFTTRANSPARENTSHADOW==1\nif (uniforms.softTransparentShadowSM.y==1.0) {opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}\n#endif\n#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE) {discard;}\n#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alphaFromAlphaTexture) {discard;}\n#else\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x) {discard;} \n#endif\n#endif\n#include<shadowMapFragment>\n}", e.ShadersStoreWGSL[Ti] = wi, Ri = {
					name: Ti,
					shader: wi
				}
			}
		}),
		Hi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.bakedVertexAnimationDeclaration = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform bakedVertexAnimationTime: f32;uniform bakedVertexAnimationTextureSizeInverted: vec2<f32>;uniform bakedVertexAnimationSettings: vec4<f32>;var bakedVertexAnimationTexture : texture_2d<f32>;\n#ifdef INSTANCES\nattribute bakedVertexAnimationSettingsInstanced : vec4<f32>;\n#endif\nfn readMatrixFromRawSamplerVAT(smp : texture_2d<f32>,index : f32,frame : f32)->mat4x4<f32>\n{let offset=i32(index)*4;let frameUV=i32(frame);let m0=textureLoad(smp,vec2<i32>(offset+0,frameUV),0);let m1=textureLoad(smp,vec2<i32>(offset+1,frameUV),0);let m2=textureLoad(smp,vec2<i32>(offset+2,frameUV),0);let m3=textureLoad(smp,vec2<i32>(offset+3,frameUV),0);return mat4x4<f32>(m0,m1,m2,m3);}\n#endif\n"
			}
		}),
		Ui = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.morphTargetsVertexGlobalDeclaration = "#ifdef MORPHTARGETS\nuniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;\n#ifdef MORPHTARGETS_TEXTURE \nuniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;uniform morphTargetTextureInfo : vec3<f32>;var morphTargets : texture_2d_array<f32>;var morphTargetsSampler : sampler;fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>\n{ \nlet y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);let x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;let textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);return textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;}\n#endif\n#endif\n"
			}
		}),
		Vi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.morphTargetsVertexDeclaration = "#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute position{X} : vec3<f32>;\n#ifdef MORPHTARGETS_NORMAL\nattribute normal{X} : vec3<f32>;\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute tangent{X} : vec3<f32>;\n#endif\n#ifdef MORPHTARGETS_UV\nattribute uv_{X} : vec2<f32>;\n#endif\n#elif {X}==0\nuniform morphTargetCount: i32;\n#endif\n#endif\n"
			}
		}),
		Wi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.sceneUboDeclaration = "struct Scene {viewProjection : mat4x4<f32>,\n#ifdef MULTIVIEW\nviewProjectionR : mat4x4<f32>,\n#endif \nview : mat4x4<f32>,\nprojection : mat4x4<f32>,\nvEyePosition : vec4<f32>,};var<uniform> scene : Scene;\n"
			}
		}),
		zi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.meshUboDeclaration = "struct Mesh {world : mat4x4<f32>,\nvisibility : f32,};var<uniform> mesh : Mesh;\n#define WORLD_UBO\n"
			}
		}),
		Xi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexExtraDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.shadowMapVertexExtraDeclaration = "#if SM_NORMALBIAS==1\nuniform lightDataSM: vec3f;\n#endif\nuniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;varying vDepthMetricSM: f32;\n#if SM_USEDISTANCE==1\nvarying vPositionWSM: vec3f;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying zSM: f32;\n#endif\n"
			}
		}),
		Yi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.clipPlaneVertexDeclaration = "#ifdef CLIPPLANE\nuniform vClipPlane: vec4<f32>;varying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nuniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nuniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nuniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nuniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nuniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;\n#endif\n"
			}
		}),
		ji = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js"() {
				h(), e.IncludesShadersStoreWGSL.morphTargetsVertexGlobal = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nvar vertexID : f32;\n#endif\n#endif\n"
			}
		}),
		Ki = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.morphTargetsVertex = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=uniforms.morphTargetCount) {break;}\nvertexID=f32(vertexInputs.vertexIndex)*uniforms.morphTargetTextureInfo.x;positionUpdated=positionUpdated+(readVector3FromRawSampler(i,vertexID)-vertexInputs.position)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated=normalUpdated+(readVector3FromRawSampler(i,vertexID) -vertexInputs.normal)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated=uvUpdated+(readVector3FromRawSampler(i,vertexID).xy-vertexInputs.uv)*uniforms.morphTargetInfluences[i];vertexID=vertexID+1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated=vec4f(tangentUpdated.xyz+(readVector3FromRawSampler(i,vertexID) -vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[i],tangentUpdated.a);\n#endif\n}\n#endif\n#else\npositionUpdated=positionUpdated+(vertexInputs.position{X}-vertexInputs.position)*uniforms.morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(vertexInputs.normal{X}-vertexInputs.normal)*uniforms.morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated=vec4f(tangentUpdated.xyz+(vertexInputs.tangent{X}-vertexInputs.tangent.xyz)*uniforms.morphTargetInfluences[{X}],tangentUpdated.a);\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated=uvUpdated+(vertexInputs.uv_{X}-vertexInputs.uv)*uniforms.morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n"
			}
		}),
		$i = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.instancesVertex = "#ifdef INSTANCES\nvar finalWorld=mat4x4<f32>(vertexInputs.world0,vertexInputs.world1,vertexInputs.world2,vertexInputs.world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nvar finalPreviousWorld=mat4x4<f32>(vertexInputs.previousWorld0,vertexInputs.previousWorld1,vertexInputs.previousWorld2,vertexInputs.previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\n#if !defined(WORLD_UBO)\nfinalWorld=uniforms.world*finalWorld;\n#else\nfinalWorld=mesh.world*finalWorld;\n#endif\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=uniforms.previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nvar finalWorld=uniforms.world;\n#else\nvar finalWorld=mesh.world;\n#endif\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nvar finalPreviousWorld=uniforms.previousWorld;\n#endif\n#endif\n"
			}
		}),
		Ji = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation.js"() {
				h(), e.IncludesShadersStoreWGSL.bakedVertexAnimation = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\nlet VATStartFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.x;let VATEndFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.y;let VATOffsetFrame: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.z;let VATSpeed: f32=vertexInputs.bakedVertexAnimationSettingsInstanced.w;\n#else\nlet VATStartFrame: f32=uniforms.bakedVertexAnimationSettings.x;let VATEndFrame: f32=uniforms.bakedVertexAnimationSettings.y;let VATOffsetFrame: f32=uniforms.bakedVertexAnimationSettings.z;let VATSpeed: f32=uniforms.bakedVertexAnimationSettings.w;\n#endif\nlet totalFrames: f32=VATEndFrame-VATStartFrame+1.0;let time: f32=uniforms.bakedVertexAnimationTime*VATSpeed/totalFrames;let frameCorrection: f32=select(1.0,0.0,time<1.0);let numOfFrames: f32=totalFrames-frameCorrection;var VATFrameNum: f32=fract(time)*numOfFrames;VATFrameNum=(VATFrameNum+VATOffsetFrame) % numOfFrames;VATFrameNum=floor(VATFrameNum);VATFrameNum=VATFrameNum+VATStartFrame+frameCorrection;var VATInfluence : mat4x4<f32>;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[0],VATFrameNum)*vertexInputs.matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[1],VATFrameNum)*vertexInputs.matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[2],VATFrameNum)*vertexInputs.matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndices[3],VATFrameNum)*vertexInputs.matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[0],VATFrameNum)*vertexInputs.matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[1],VATFrameNum)*vertexInputs.matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[2],VATFrameNum)*vertexInputs.matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,vertexInputs.matricesIndicesExtra[3],VATFrameNum)*vertexInputs.matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n"
			}
		}),
		qi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapVertexNormalBias.js"() {
				h(), e.IncludesShadersStoreWGSL.shadowMapVertexNormalBias = "#if SM_NORMALBIAS==1\n#if SM_DIRECTIONINLIGHTDATA==1\nvar worldLightDirSM: vec3f=normalize(-uniforms.lightDataSM.xyz);\n#else\nvar directionToLightSM: vec3f=uniforms.lightDataSM.xyz-worldPos.xyz;var worldLightDirSM: vec3f=normalize(directionToLightSM);\n#endif\nvar ndlSM: f32=dot(vNormalW,worldLightDirSM);var sinNLSM: f32=sqrt(1.0-ndlSM*ndlSM);var normalBiasSM: f32=uniforms.biasAndScaleSM.y*sinNLSM;worldPos=vec4f(worldPos.xyz-vNormalW*normalBiasSM,worldPos.w);\n#endif\n"
			}
		}),
		Qi = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.clipPlaneVertex = "#ifdef CLIPPLANE\nvertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nvertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nvertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nvertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nvertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nvertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);\n#endif\n"
			}
		}),
		Zi = {};
	l(Zi, {
		shadowMapVertexShaderWGSL: () => Bi
	});
	var es, ts, is, ss = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/shadowMap.vertex.js"() {
				h(), R(), Hi(), Ui(), Vi(), ce(), Wi(), zi(), Xi(), Yi(), ji(), Ki(), $i(), D(), Ji(), qi(), It(), Qi(), Fi = "shadowMapVertexShader", Li = "attribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;\n#endif\n#include<helperFunctions>\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#ifdef ALPHATEXTURE\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef NORMAL\nvar normalUpdated: vec3f=input.normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#ifdef NORMAL\nvar normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvar vNormalW: vec3f=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvar vNormalW: vec3f=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\nvertexOutputs.position=scene.viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEXTURE\n#ifdef UV1\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(input.uv2,1.0,0.0)).xy;\n#endif\n#endif\n#include<clipPlaneVertex>\n}", e.ShadersStoreWGSL[Fi] = Li, Bi = {
					name: Fi,
					shader: Li
				}
			}
		}),
		ns = {};
	l(ns, {
		depthBoxBlurPixelShaderWGSL: () => is
	});
	var as, rs, os, ls = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/depthBoxBlur.fragment.js"() {
				h(), es = "depthBoxBlurPixelShader", ts = "varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var colorDepth: vec4f=vec4f(0.0);for (var x: i32=-OFFSET; x<=OFFSET; x++) {for (var y: i32=-OFFSET; y<=OFFSET; y++) {colorDepth+=textureSample(textureSampler,textureSamplerSampler,input.vUV+ vec2f(f32(x),f32(y))/uniforms.screenSize);}}\nfragmentOutputs.color=(colorDepth/ f32((OFFSET*2+1)*(OFFSET*2+1)));}", e.ShadersStoreWGSL[es] = ts, is = {
					name: es,
					shader: ts
				}
			}
		}),
		hs = {};
	l(hs, {
		shadowMapFragmentSoftTransparentShadowWGSL: () => os
	});
	var cs, us, ms, ds = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js"() {
				h(), as = "shadowMapFragmentSoftTransparentShadow", rs = "#if SM_SOFTTRANSPARENTSHADOW==1\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alpha) {discard;}\n#endif\n", e.IncludesShadersStoreWGSL[as] = rs, os = {
					name: as,
					shader: rs
				}
			}
		}),
		fs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js"() {
				h(), e.IncludesShadersStore.bayerDitherFunctions = "float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}\nfloat bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5*mod(_P,4.0)); \nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);}\nfloat bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5 *mod(_P,4.0)); \nvec2 P4=floor(0.25*mod(_P,8.0)); \nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}\n"
			}
		}),
		ps = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js"() {
				h(), qt(), fs(), e.IncludesShadersStore.shadowMapFragmentExtraDeclaration = "#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform vec2 softTransparentShadowSM;\n#endif\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nuniform vec3 lightDataSM;varying vec3 vPositionWSM;\n#endif\nuniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n"
			}
		}),
		_s = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js"() {
				h(), e.IncludesShadersStore.clipPlaneFragmentDeclaration = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n"
			}
		}),
		gs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js"() {
				h(), e.IncludesShadersStore.clipPlaneFragment = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n"
			}
		}),
		vs = {};
	l(vs, {
		shadowMapPixelShader: () => ms
	});
	var ys, Ss, Es, As = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js"() {
				h(), ps(), _s(), gs(), ii(), cs = "shadowMapPixelShader", us = "#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nvec4 opacityMap=texture2D(diffuseSampler,vUV);float alphaFromAlphaTexture=opacityMap.a;\n#if SM_SOFTTRANSPARENTSHADOW==1\nif (softTransparentShadowSM.y==1.0) {opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}\n#endif\n#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE)\ndiscard;\n#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alphaFromAlphaTexture) discard;\n#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x) discard;\n#endif\n#endif\n#include<shadowMapFragment>\n}", e.ShadersStore[cs] = us, ms = {
					name: cs,
					shader: us
				}
			}
		}),
		bs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js"() {
				h(), e.IncludesShadersStore.bakedVertexAnimationDeclaration = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n"
			}
		}),
		xs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js"() {
				h(), e.IncludesShadersStore.morphTargetsVertexGlobalDeclaration = "#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\n#endif\n#endif\n"
			}
		}),
		Ms = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.morphTargetsVertexDeclaration = "#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#elif {X}==0\nuniform int morphTargetCount;\n#endif\n#endif\n"
			}
		}),
		Cs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.sceneVertexDeclaration = "uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\nuniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;\n"
			}
		}),
		Ts = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.meshVertexDeclaration = "uniform mat4 world;uniform float visibility;\n"
			}
		}),
		ws = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js"() {
				h(), Cs(), Ts(), e.IncludesShadersStore.shadowMapVertexDeclaration = "#include<sceneVertexDeclaration>\n#include<meshVertexDeclaration>\n"
			}
		}),
		Rs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js"() {
				h(), e.IncludesShadersStore.sceneUboDeclaration = "layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n"
			}
		}),
		Ns = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js"() {
				h(), e.IncludesShadersStore.meshUboDeclaration = "#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n"
			}
		}),
		Is = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js"() {
				h(), Rs(), Ns(), e.IncludesShadersStore.shadowMapUboDeclaration = "layout(std140,column_major) uniform;\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n"
			}
		}),
		Ps = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexExtraDeclaration.js"() {
				h(), e.IncludesShadersStore.shadowMapVertexExtraDeclaration = "#if SM_NORMALBIAS==1\nuniform vec3 lightDataSM;\n#endif\nuniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nvarying vec3 vPositionWSM;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n"
			}
		}),
		ks = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.clipPlaneVertexDeclaration = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n"
			}
		}),
		Ds = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js"() {
				h(), e.IncludesShadersStore.morphTargetsVertexGlobal = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n"
			}
		}),
		Os = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js"() {
				h(), e.IncludesShadersStore.morphTargetsVertex = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n"
			}
		}),
		Fs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js"() {
				h(), e.IncludesShadersStore.instancesVertex = "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n"
			}
		}),
		Ls = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js"() {
				h(), e.IncludesShadersStore.bakedVertexAnimation = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n"
			}
		}),
		Bs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js"() {
				h(), e.IncludesShadersStore.shadowMapVertexNormalBias = "#if SM_NORMALBIAS==1\n#if SM_DIRECTIONINLIGHTDATA==1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\n#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);\n#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;\n#endif\n"
			}
		}),
		Gs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js"() {
				h(), e.IncludesShadersStore.clipPlaneVertex = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n"
			}
		}),
		Hs = {};
	l(Hs, {
		shadowMapVertexShader: () => Es
	});
	var Us, Vs, Ws, zs = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js"() {
				h(), G(), bs(), xs(), Ms(), tt(), ws(), Is(), Ps(), ks(), Ds(), Os(), Fs(), z(), Ls(), Bs(), Yt(), Gs(), ys = "shadowMapVertexShader", Ss = "attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#endif\n#include<helperFunctions>\n#include<__decl__shadowMapVertex>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\ngl_Position=viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEXTURE\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n}", e.ShadersStore[ys] = Ss, Es = {
					name: ys,
					shader: Ss
				}
			}
		}),
		Xs = {};
	l(Xs, {
		depthBoxBlurPixelShader: () => Ws
	});
	var Ys, js, Ks, $s = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/depthBoxBlur.fragment.js"() {
				h(), Us = "depthBoxBlurPixelShader", Vs = "varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{vec4 colorDepth=vec4(0.0);for (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));}", e.ShadersStore[Us] = Vs, Ws = {
					name: Us,
					shader: Vs
				}
			}
		}),
		Js = {};
	l(Js, {
		shadowMapFragmentSoftTransparentShadow: () => Ks
	});
	var qs, Qs, Zs, en = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js"() {
				h(), Ys = "shadowMapFragmentSoftTransparentShadow", js = "#if SM_SOFTTRANSPARENTSHADOW==1\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alpha) discard;\n#endif\n", e.IncludesShadersStore[Ys] = js, Ks = {
					name: Ys,
					shader: js
				}
			}
		}),
		tn = {};
	l(tn, {
		passPixelShaderWGSL: () => Zs
	});
	var sn, nn, an, rn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/pass.fragment.js"() {
				h(), qs = "passPixelShader", Qs = "varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);}", e.ShadersStoreWGSL[qs] = Qs, Zs = {
					name: qs,
					shader: Qs
				}
			}
		}),
		on = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/defaultUboDeclaration.js"() {
				h(), Wi(), zi(), e.IncludesShadersStoreWGSL.defaultUboDeclaration = "uniform diffuseLeftColor: vec4f;uniform diffuseRightColor: vec4f;uniform opacityParts: vec4f;uniform reflectionLeftColor: vec4f;uniform reflectionRightColor: vec4f;uniform refractionLeftColor: vec4f;uniform refractionRightColor: vec4f;uniform emissiveLeftColor: vec4f;uniform emissiveRightColor: vec4f;uniform vDiffuseInfos: vec2f;uniform vAmbientInfos: vec2f;uniform vOpacityInfos: vec2f;uniform vReflectionInfos: vec2f;uniform vReflectionPosition: vec3f;uniform vReflectionSize: vec3f;uniform vEmissiveInfos: vec2f;uniform vLightmapInfos: vec2f;uniform vSpecularInfos: vec2f;uniform vBumpInfos: vec3f;uniform diffuseMatrix: mat4x4f;uniform ambientMatrix: mat4x4f;uniform opacityMatrix: mat4x4f;uniform reflectionMatrix: mat4x4f;uniform emissiveMatrix: mat4x4f;uniform lightmapMatrix: mat4x4f;uniform specularMatrix: mat4x4f;uniform bumpMatrix: mat4x4f;uniform vTangentSpaceParams: vec2f;uniform pointSize: f32;uniform alphaCutOff: f32;uniform refractionMatrix: mat4x4f;uniform vRefractionInfos: vec4f;uniform vRefractionPosition: vec3f;uniform vRefractionSize: vec3f;uniform vSpecularColor: vec4f;uniform vEmissiveColor: vec3f;uniform vDiffuseColor: vec4f;uniform vAmbientColor: vec3f;\n#define ADDITIONAL_UBO_DECLARATION\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n"
			}
		}),
		ln = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvAttributeDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.uvAttributeDeclaration = "#ifdef UV{X}\nattribute uv{X}: vec2f;\n#endif\n"
			}
		}),
		hn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.instancesDeclaration = "#ifdef INSTANCES\nattribute world0 : vec4<f32>;attribute world1 : vec4<f32>;attribute world2 : vec4<f32>;attribute world3 : vec4<f32>;\n#ifdef INSTANCESCOLOR\nattribute instanceColor : vec4<f32>;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform world : mat4x4<f32>;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute previousWorld0 : vec4<f32>;attribute previousWorld1 : vec4<f32>;attribute previousWorld2 : vec4<f32>;attribute previousWorld3 : vec4<f32>;\n#ifdef THIN_INSTANCES\nuniform previousWorld : mat4x4<f32>;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform world : mat4x4<f32>;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform previousWorld : mat4x4<f32>;\n#endif\n#endif\n"
			}
		}),
		cn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.prePassVertexDeclaration = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vViewPos: vec3f;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform previousViewProjection: mat4x4f;varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;\n#endif\n#endif\n"
			}
		}),
		un = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/mainUVVaryingDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.mainUVVaryingDeclaration = "#ifdef MAINUV{X}\nvarying vMainUV{X}: vec2f;\n#endif\n"
			}
		}),
		mn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.samplerVertexDeclaration = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying v_VARYINGNAME_UV: vec2f;\n#endif\n"
			}
		}),
		dn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.bumpVertexDeclaration = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;\n#endif\n#endif\n"
			}
		}),
		fn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertexDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.fogVertexDeclaration = "#ifdef FOG\nvarying vFogDistance: vec3f;\n#endif\n"
			}
		}),
		pn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/lightVxFragmentDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.lightVxFragmentDeclaration = "#ifdef LIGHT{X}\nuniform vLightData{X}: vec4f;uniform vLightDiffuse{X}: vec4f;\n#ifdef SPECULARTERM\nuniform vLightSpecular{X}: vec4f;\n#else\nvar vLightSpecular{X}: vec4f= vec4f(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform lightMatrix{X}: mat4x4f[SHADOWCSMNUM_CASCADES{X}];varying var vPositionFromLight{X}: vec4f[SHADOWCSMNUM_CASCADES{X}];varying var vDepthMetric{X}: f32[SHADOWCSMNUM_CASCADES{X}];varying var vPositionFromCamera{X}: vec4f;\n#elif defined(SHADOWCUBE{X})\n#else\nvarying var vPositionFromLight{X}: vec4f;varying var vDepthMetric{X}: f32;uniform lightMatrix{X}: mat4x4f;\n#endif\nuniform shadowsInfo{X}: vec4f;uniform depthValues{X}: vec2f;\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vLightDirection{X}: vec4f;uniform vLightFalloff{X}: vec4f;\n#elif defined(POINTLIGHT{X})\nuniform vLightFalloff{X}: vec4f;\n#elif defined(HEMILIGHT{X})\nuniform vLightGround{X}: vec3f;\n#endif\n#endif\n"
			}
		}),
		_n = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.logDepthDeclaration = "#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n"
			}
		}),
		gn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.prePassVertex = "#ifdef PREPASS_DEPTH\nvertexOutputs.vViewPos=(scene.view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nvar previousInfluence: mat4x4f;previousInfluence=mPreviousBones[ i32(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[ i32(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[ i32(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[ i32(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*previousInfluence* vec4f(positionUpdated,1.0);\n#else\nvertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);\n#endif\n#endif\n"
			}
		}),
		vn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/uvVariableDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.uvVariableDeclaration = "#ifdef MAINUV{X}\n#if !defined(UV{X})\nvar uv{X}: vec2f=vec2f(0.,0.);\n#else\nvar uv{X}: vec2f=vertexInputs.uv{X};\n#endif\nvertexOutputs.vMainUV{X}=uv{X};\n#endif\n"
			}
		}),
		yn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerVertexImplementation.js"() {
				h(), e.IncludesShadersStoreWGSL.samplerVertexImplementation = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (uniforms.v_INFONAME_==0.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(uvUpdated,1.0,0.0)).xy;}\n#ifdef UV2\nelse if (uniforms.v_INFONAME_==1.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv2,1.0,0.0)).xy;}\n#endif\n#ifdef UV3\nelse if (uniforms.v_INFONAME_==2.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv3,1.0,0.0)).xy;}\n#endif\n#ifdef UV4\nelse if (uniforms.v_INFONAME_==3.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv4,1.0,0.0)).xy;}\n#endif\n#ifdef UV5\nelse if (uniforms.v_INFONAME_==4.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv5,1.0,0.0)).xy;}\n#endif\n#ifdef UV6\nelse if (uniforms.v_INFONAME_==5.)\n{vertexOutputs.v_VARYINGNAME_UV= (uniforms._MATRIXNAME_Matrix* vec4f(vertexInputs.uv6,1.0,0.0)).xy;}\n#endif\n#endif\n"
			}
		}),
		Sn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.bumpVertex = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvar tbnNormal: vec3f=normalize(normalUpdated);var tbnTangent: vec3f=normalize(tangentUpdated.xyz);var tbnBitangent: vec3f=cross(tbnNormal,tbnTangent)*tangentUpdated.w;var matTemp= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz)* mat3x3f(tbnTangent,tbnBitangent,tbnNormal);vertexOutputs.vTBN0=matTemp[0];vertexOutputs.vTBN1=matTemp[1];vertexOutputs.vTBN2=matTemp[2];\n#endif\n#endif\n"
			}
		}),
		En = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.fogVertex = "#ifdef FOG\nvertexOutputs.vFogDistance=(scene.view*worldPos).xyz;\n#endif\n"
			}
		}),
		An = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/vertexColorMixing.js"() {
				h(), e.IncludesShadersStoreWGSL.vertexColorMixing = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvertexOutputs.vColor=vec4f(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvertexOutputs.vColor*=vertexInputs.color;\n#else\nvertexOutputs.vColor=vec4f(vertexOutputs.vColor.rgb*vertexInputs.color.rgb,vertexOutputs.vColor.a);\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvertexOutputs.vColor*=vertexInputs.instanceColor;\n#endif\n#endif\n"
			}
		}),
		bn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthVertex.js"() {
				h(), e.IncludesShadersStoreWGSL.logDepthVertex = "#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n"
			}
		}),
		xn = {};
	l(xn, {
		defaultVertexShaderWGSL: () => an
	});
	var Mn, Cn, Tn, wn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/default.vertex.js"() {
				h(), on(), ln(), ce(), R(), Hi(), hn(), cn(), un(), mn(), dn(), Yi(), fn(), pn(), ae(), Ui(), Vi(), _n(), ji(), Ki(), $i(), D(), Ji(), gn(), vn(), yn(), Sn(), Qi(), En(), Me(), An(), bn(), sn = "defaultVertexShader", nn = "#include<defaultUboDeclaration>\n#define CUSTOM_VERTEX_BEGIN\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#ifdef TANGENT\nattribute tangent: vec4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vPositionW: vec3f;\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar positionUpdated: vec3f=vertexInputs.position;\n#ifdef NORMAL\nvar normalUpdated: vec3f=vertexInputs.normal;\n#endif\n#ifdef TANGENT\nvar tangentUpdated: vec4f=vertexInputs.tangent;\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld*vec4f(positionUpdated,1.0);\n#ifdef NORMAL\nvar normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}\n#else\nvertexOutputs.position=scene.viewProjection*worldPos;\n#endif\nvertexOutputs.vPositionW= worldPos.xyz;\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld* vec4f(positionUpdated,0.0)).xyz);\n#endif\n#ifndef UV1\nvar uvUpdated: vec2f=vec2f(0.,0.);\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n", e.ShadersStoreWGSL[sn] = nn, an = {
					name: sn,
					shader: nn
				}
			}
		}),
		Rn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/prePassDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.prePassDeclaration = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vViewPos: vec3f;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;\n#endif\n#endif\n"
			}
		}),
		Nn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.oitDeclaration = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#define MAX_DEPTH 99999.0\nvar oitDepthSamplerSampler: sampler;var oitDepthSampler: texture_2d<f32>;var oitFrontColorSamplerSampler: sampler;var oitFrontColorSampler: texture_2d<f32>;\n#endif\n"
			}
		}),
		In = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerFragmentDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.samplerFragmentDeclaration = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying v_VARYINGNAME_UV: vec2f;\n#endif\nvar _SAMPLERNAME_SamplerSampler: sampler;var _SAMPLERNAME_Sampler: texture_2d<f32>;\n#endif\n"
			}
		}),
		Pn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fresnelFunction.js"() {
				h(), e.IncludesShadersStoreWGSL.fresnelFunction = "#ifdef FRESNEL\nfn computeFresnelTerm(viewDirection: vec3f,worldNormal: vec3f,bias: f32,power: f32)->f32\n{let fresnelTerm: f32=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}\n#endif\n"
			}
		}),
		kn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/reflectionFunction.js"() {
				h(), e.IncludesShadersStoreWGSL.reflectionFunction = "fn computeFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f\n{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0); }\nfn computeMirroredFixedEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,direction: vec3f)->vec3f\n{var lon: f32=atan2(direction.z,direction.x);var lat: f32=acos(direction.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(1.0-s,t,0); }\nfn computeEquirectangularCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f\n{var cameraToVertex: vec3f=normalize(worldPos.xyz-eyePosition);var r: vec3f=normalize(reflect(cameraToVertex,worldNormal));r= (reflectionMatrix* vec4f(r,0)).xyz;var lon: f32=atan2(r.z,r.x);var lat: f32=acos(r.y);var sphereCoords: vec2f= vec2f(lon,lat)*RECIPROCAL_PI2*2.0;var s: f32=sphereCoords.x*0.5+0.5;var t: f32=sphereCoords.y;return vec3f(s,t,0);}\nfn computeSphericalCoords(worldPos: vec4f,worldNormal: vec3f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f\n{var viewDir: vec3f=normalize((view*worldPos).xyz);var viewNormal: vec3f=normalize((view* vec4f(worldNormal,0.0)).xyz);var r: vec3f=reflect(viewDir,viewNormal);r= (reflectionMatrix* vec4f(r,0)).xyz;r.z=r.z-1.0;var m: f32=2.0*length(r);return vec3f(r.x/m+0.5,1.0-r.y/m-0.5,0);}\nfn computePlanarCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f\n{var viewDir: vec3f=worldPos.xyz-eyePosition;var coords: vec3f=normalize(reflect(viewDir,worldNormal));return (reflectionMatrix* vec4f(coords,1)).xyz;}\nfn computeCubicCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f)->vec3f\n{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords= (reflectionMatrix* vec4f(coords,0)).xyz;\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nfn computeCubicLocalCoords(worldPos: vec4f,worldNormal: vec3f,eyePosition: vec3f,reflectionMatrix: mat4x4f,reflectionSize: vec3f,reflectionPosition: vec3f)->vec3f\n{var viewDir: vec3f=normalize(worldPos.xyz-eyePosition);var coords: vec3f=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=(reflectionMatrix* vec4f(coords,0)).xyz;\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nfn computeProjectionCoords(worldPos: vec4f,view: mat4x4f,reflectionMatrix: mat4x4f)->vec3f\n{return (reflectionMatrix*(view*worldPos)).xyz;}\nfn computeSkyBoxCoords(positionW: vec3f,reflectionMatrix: mat4x4f)->vec3f\n{return (reflectionMatrix* vec4f(positionW,1.)).xyz;}\n#ifdef REFLECTION\nfn computeReflectionCoords(worldPos: vec4f,worldNormal: vec3f)->vec3f\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvar direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvar direction: vec3f=normalize(fragmentInputs.vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,scene.view,uniforms.reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix,uniforms.vReflectionSize,uniforms.vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,scene.vEyePosition.xyz,uniforms.reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,scene.view,uniforms.reflectionMatrix);\n#endif\n#ifndef REFLECTIONMAP_CUBIC\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(fragmentInputs.vPositionUVW,uniforms.reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3f(0,0,0);\n#endif\n}\n#endif\n"
			}
		}),
		Dn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.imageProcessingDeclaration = "#ifdef EXPOSURE\nuniform exposureLinear: f32;\n#endif\n#ifdef CONTRAST\nuniform contrast: f32;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vInverseScreenSize: vec2f;\n#endif\n#ifdef VIGNETTE\nuniform vignetteSettings1: vec4f;uniform vignetteSettings2: vec4f;\n#endif\n#ifdef COLORCURVES\nuniform vCameraColorCurveNegative: vec4f;uniform vCameraColorCurveNeutral: vec4f;uniform vCameraColorCurvePositive: vec4f;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nvar txColorTransformSampler: sampler;var txColorTransform: texture_3d<f32>;\n#else\nvar txColorTransformSampler: sampler;var txColorTransform: texture_2d<f32>;\n#endif\nuniform colorTransformSettings: vec4f;\n#endif\n#ifdef DITHER\nuniform ditherIntensity: f32;\n#endif\n"
			}
		}),
		On = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.imageProcessingFunctions = "#if TONEMAPPING==3\nconst PBRNeutralStartCompression: f32=0.8-0.04;const PBRNeutralDesaturation: f32=0.15;fn PBRNeutralToneMapping( color: vec3f )->vec3f {var x: f32=min(color.r,min(color.g,color.b));var offset: f32=select(0.04,x-6.25*x*x,x<0.08);var result=color;result-=offset;var peak: f32=max(result.r,max(result.g,result.b));if (peak<PBRNeutralStartCompression) {return result;}\nvar d: f32=1.-PBRNeutralStartCompression;var newPeak: f32=1.-d*d/(peak+d-PBRNeutralStartCompression);result*=newPeak/peak;var g: f32=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(result,newPeak* vec3f(1,1,1),g);}\n#endif\n#if TONEMAPPING==2\nconst ACESInputMat: mat3x3f= mat3x3f(\nvec3f(0.59719,0.07600,0.02840),\nvec3f(0.35458,0.90834,0.13383),\nvec3f(0.04823,0.01566,0.83777)\n);const ACESOutputMat: mat3x3f= mat3x3f(\nvec3f( 1.60475,-0.10208,-0.00327),\nvec3f(-0.53108, 1.10813,-0.07276),\nvec3f(-0.07367,-0.00605, 1.07602)\n);fn RRTAndODTFit(v: vec3f)->vec3f\n{var a: vec3f=v*(v+0.0245786)-0.000090537;var b: vec3f=v*(0.983729*v+0.4329510)+0.238081;return a/b;}\nfn ACESFitted(color: vec3f)->vec3f\n{var output=ACESInputMat*color;output=RRTAndODTFit(output);output=ACESOutputMat*output;output=saturateVec3(output);return output;}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nfn applyImageProcessing(result: vec4f)->vec4f {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\nvar rgb=result.rgb;;\n#ifdef EXPOSURE\nrgb*=uniforms.exposureLinear;\n#endif\n#ifdef VIGNETTE\nvar viewportXY: vec2f=fragmentInputs.position.xy*uniforms.vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;var vignetteXY1: vec3f= vec3f(viewportXY*uniforms.vignetteSettings1.xy+uniforms.vignetteSettings1.zw,1.0);var vignetteTerm: f32=dot(vignetteXY1,vignetteXY1);var vignette: f32=pow(vignetteTerm,uniforms.vignetteSettings2.w);var vignetteColor: vec3f=uniforms.vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvar vignetteColorMultiplier: vec3f=mix(vignetteColor, vec3f(1,1,1),vignette);rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nrgb=mix(vignetteColor,rgb,vignette);\n#endif\n#endif\n#if TONEMAPPING==3\nrgb=PBRNeutralToneMapping(rgb);\n#elif TONEMAPPING==2\nrgb=ACESFitted(rgb);\n#elif TONEMAPPING==1\nconst tonemappingCalibration: f32=1.590579;rgb=1.0-exp2(-tonemappingCalibration*rgb);\n#endif\nrgb=toGammaSpaceVec3(rgb);rgb=saturateVec3(rgb);\n#ifdef CONTRAST\nvar resultHighContrast: vec3f=rgb*rgb*(3.0-2.0*rgb);if (uniforms.contrast<1.0) {rgb=mix( vec3f(0.5,0.5,0.5),rgb,uniforms.contrast);} else {rgb=mix(rgb,resultHighContrast,uniforms.contrast-1.0);}\n#endif\n#ifdef COLORGRADING\nvar colorTransformInput: vec3f=rgb*uniforms.colorTransformSettings.xxx+uniforms.colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvar colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput).rgb;\n#else\nvar colorTransformOutput: vec3f=textureSample(txColorTransform,txColorTransformSampler,colorTransformInput,uniforms.colorTransformSettings.yz).rgb;\n#endif\nrgb=mix(rgb,colorTransformOutput,uniforms.colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nvar luma: f32=getLuminance(rgb);var curveMix: vec2f=clamp( vec2f(luma*3.0-1.5,luma*-3.0+1.5), vec2f(0.0), vec2f(1.0));var colorCurve: vec4f=uniforms.vCameraColorCurveNeutral+curveMix.x*uniforms.vCameraColorCurvePositive-curveMix.y*uniforms.vCameraColorCurveNegative;rgb*=colorCurve.rgb;rgb=mix( vec3f(luma),rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nvar rand: f32=getRand(fragmentInputs.position.xy*uniforms.vInverseScreenSize);var dither: f32=mix(-uniforms.ditherIntensity,uniforms.ditherIntensity,rand);rgb=saturateVec3(rgb+ vec3f(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn vec4f(rgb,result.a);}"
			}
		}),
		Fn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentMainFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.bumpFragmentMainFunctions = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying vTBN0: vec3f;varying vTBN1: vec3f;varying vTBN2: vec3f;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform normalMatrix: mat4x4f;fn toNormalMatrix(m: mat4x4f)->mat4x4f\n{var a00=m[0][0];var a01=m[0][1];var a02=m[0][2];var a03=m[0][3];var a10=m[1][0];var a11=m[1][1];var a12=m[1][2];var a13=m[1][3];var a20=m[2][0]; \nvar a21=m[2][1];var a22=m[2][2];var a23=m[2][3];var a30=m[3][0]; \nvar a31=m[3][1];var a32=m[3][2];var a33=m[3][3];var b00=a00*a11-a01*a10;var b01=a00*a12-a02*a10;var b02=a00*a13-a03*a10;var b03=a01*a12-a02*a11;var b04=a01*a13-a03*a11;var b05=a02*a13-a03*a12;var b06=a20*a31-a21*a30;var b07=a20*a32-a22*a30;var b08=a20*a33-a23*a30;var b09=a21*a32-a22*a31;var b10=a21*a33-a23*a31;var b11=a22*a33-a23*a32;var det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;var mi=mat4x4<f32>(\n(a11*b11-a12*b10+a13*b09)/det,\n(a02*b10-a01*b11-a03*b09)/det,\n(a31*b05-a32*b04+a33*b03)/det,\n(a22*b04-a21*b05-a23*b03)/det,\n(a12*b08-a10*b11-a13*b07)/det,\n(a00*b11-a02*b08+a03*b07)/det,\n(a32*b02-a30*b05-a33*b01)/det,\n(a20*b05-a22*b02+a23*b01)/det,\n(a10*b10-a11*b08+a13*b06)/det,\n(a01*b08-a00*b10-a03*b06)/det,\n(a30*b04-a31*b02+a33*b00)/det,\n(a21*b02-a20*b04-a23*b00)/det,\n(a11*b07-a10*b09-a12*b06)/det,\n(a00*b09-a01*b07+a02*b06)/det,\n(a31*b01-a30*b03-a32*b00)/det,\n(a20*b03-a21*b01+a22*b00)/det);return mat4x4<f32>(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\nfn perturbNormalBase(cotangentFrame: mat3x3f,normal: vec3f,scale: f32)->vec3f\n{var output=normal;\n#ifdef NORMALXYSCALE\noutput=normalize(output* vec3f(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*output);}\nfn perturbNormal(cotangentFrame: mat3x3f,textureSample: vec3f,scale: f32)->vec3f\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nfn cotangent_frame(normal: vec3f,p: vec3f,uv: vec2f,tangentSpaceParams: vec2f)->mat3x3f\n{var dp1: vec3f=dpdx(p);var dp2: vec3f=dpdy(p);var duv1: vec2f=dpdx(uv);var duv2: vec2f=dpdy(uv);var dp2perp: vec3f=cross(dp2,normal);var dp1perp: vec3f=cross(normal,dp1);var tangent: vec3f=dp2perp*duv1.x+dp1perp*duv2.x;var bitangent: vec3f=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;var det: f32=max(dot(tangent,tangent),dot(bitangent,bitangent));var invmax: f32=select(inverseSqrt(det),0.0,det==0.0);return mat3x3f(tangent*invmax,bitangent*invmax,normal);}\n#endif\n"
			}
		}),
		Ln = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragmentFunctions.js"() {
				h(), In(), e.IncludesShadersStoreWGSL.bumpFragmentFunctions = "#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst minSamples: f32=4.;const maxSamples: f32=15.;const iMaxSamples: i32=15;fn parallaxOcclusion(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32)->vec2f {var parallaxLimit: f32=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;var vOffsetDir: vec2f=normalize(vViewDirCoT.xy);var vMaxOffset: vec2f=vOffsetDir*parallaxLimit;var numSamples: f32=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));var stepSize: f32=1.0/numSamples;var currRayHeight: f32=1.0;var vCurrOffset: vec2f= vec2f(0,0);var vLastOffset: vec2f= vec2f(0,0);var lastSampledHeight: f32=1.0;var currSampledHeight: f32=1.0;var keepWorking: bool=true;for (var i: i32=0; i<iMaxSamples; i++)\n{currSampledHeight=textureSample(bumpSampler,bumpSamplerSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{var delta1: f32=currSampledHeight-currRayHeight;var delta2: f32=(currRayHeight+stepSize)-lastSampledHeight;var ratio: f32=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nfn parallaxOffset(viewDir: vec3f,heightScale: f32)->vec2f\n{var height: f32=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).w;var texCoordOffset: vec2f=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n"
			}
		}),
		Bn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bumpFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.bumpFragment = "var uvOffset: vec2f= vec2f(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nvar normalScale: f32=1.0;\n#elif defined(BUMP)\nvar normalScale: f32=uniforms.vBumpInfos.y;\n#else\nvar normalScale: f32=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nvar TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); \n#elif defined(BUMP)\nvar TBNUV: vec2f=select(-fragmentInputs.vBumpUV,fragmentInputs.vBumpUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV,uniforms.vTangentSpaceParams);\n#else\nvar TBNUV: vec2f=select(-fragmentInputs.vDetailUV,fragmentInputs.vDetailUV,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW*normalScale,input.vPositionW,TBNUV, vec2f(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvar TBN: mat3x3f=mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2); \n#else\nvar TBNUV: vec2f=select( -fragmentInputs.vMainUV1,fragmentInputs.vMainUV1,fragmentInputs.frontFacing);var TBN: mat3x3f=cotangent_frame(normalW,input.vPositionW,TBNUV, vec2f(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nvar invTBN: mat3x3f=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,fragmentInputs.vBumpUV,uniforms.vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,uniforms.vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvar detailColor: vec4f=textureSample(detailSampler,detailSamplerSampler,fragmentInputs.vDetailUV+uvOffset);var detailNormalRG: vec2f=detailColor.wy*2.0-1.0;var detailNormalB: f32=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));var detailNormal: vec3f= vec3f(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3x3f(uniforms.normalMatrix[0].xyz,uniforms.normalMatrix[1].xyz,uniforms.normalMatrix[2].xyz)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV+uvOffset).xyz,uniforms.vBumpInfos.y);\n#else\nvar bumpNormal: vec3f=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);var blendedNormal: vec3f=normalize( vec3f(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);bumpNormal+= vec3f(0.0,0.0,1.0);detailNormal*= vec3f(-1.0,-1.0,1.0);var blendedNormal: vec3f=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,uniforms.vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal=vec3f(detailNormal.xy*uniforms.vDetailInfos.z,detailNormal.z);normalW=perturbNormalBase(TBN,detailNormal,uniforms.vDetailInfos.z);\n#endif\n"
			}
		}),
		Gn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/decalFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.decalFragment = "#ifdef DECAL\nvar decalTempColor=decalColor.rgb;var decalTempAlpha=decalColor.a;\n#ifdef GAMMADECAL\ndecalTempColor=toLinearSpaceVec3(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalTempAlpha=decalColor.a*decalColor.a;\n#endif\nsurfaceAlbedo=mix(surfaceAlbedo.rgb,decalTempColor,decalTempAlpha);\n#endif\n"
			}
		}),
		Hn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/depthPrePass.js"() {
				h(), e.IncludesShadersStoreWGSL.depthPrePass = "#ifdef DEPTHPREPASS\nfragmentOutputs.color= vec4f(0.,0.,0.,1.0);return fragmentOutputs;\n#endif\n"
			}
		}),
		Un = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/logDepthFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.logDepthFragment = "#ifdef LOGARITHMICDEPTH\nfragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;\n#endif\n"
			}
		}),
		Vn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/fogFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.fogFragment = "#ifdef FOG\nvar fog: f32=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);\n#endif\n"
			}
		}),
		Wn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/oitFragment.js"() {
				h(), e.IncludesShadersStoreWGSL.oitFragment = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nvar fragDepth: f32=fragmentInputs.position.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nvar halfFloat: i32=packHalf2x16( vec2f(fragDepth));var full: vec2f=unpackHalf2x16(halfFloat);fragDepth=full.x;\n#endif\nvar fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var lastDepth: vec2f=textureLoad(oitDepthSampler,fragCoord,0).rg;var lastFrontColor: vec4f=textureLoad(oitFrontColorSampler,fragCoord,0);fragmentOutputs.depth=vec2f(-MAX_DEPTH);fragmentOutputs.frontColor=lastFrontColor;fragmentOutputs.backColor= vec4f(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nvar furthestDepth: f32=-lastDepth.x;var nearestDepth: f32=lastDepth.y;\n#else\nvar nearestDepth: f32=-lastDepth.x;var furthestDepth: f32=lastDepth.y;\n#endif\nvar alphaMultiplier: f32=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn fragmentOutputs;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\nfragmentOutputs.depth=vec2f(-fragDepth,fragDepth);return fragmentOutputs;}\n#endif\n"
			}
		}),
		zn = {};
	l(zn, {
		defaultPixelShaderWGSL: () => Tn
	});
	var Xn, Yn, jn, Kn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/default.fragment.js"() {
				h(), on(), Rn(), Nn(), un(), ce(), ee(), pe(), Se(), In(), Pn(), kn(), Dn(), On(), Fn(), Ln(), ki(), _n(), Et(), Di(), Bn(), Gn(), Hn(), $(), Un(), Vn(), Wn(), Mn = "defaultPixelShader", Cn = "#include<defaultUboDeclaration>\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\nvarying vPositionW: vec3f;\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nvar refractionCubeSamplerSampler: sampler;var refractionCubeSampler: texture_cube<f32>;\n#else\nvar refraction2DSamplerSampler: sampler;var refraction2DSampler: texture_2d<f32>;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nvar reflectionCubeSamplerSampler: sampler;var reflectionCubeSampler: texture_cube<f32>;\n#else\nvar reflection2DSamplerSampler: sampler;var reflection2DSampler: texture_2d<f32>;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-fragmentInputs.vPositionW);var baseColor: vec4f= vec4f(1.,1.,1.,1.);var diffuseColor: vec3f=uniforms.vDiffuseColor.rgb;var alpha: f32=uniforms.vDiffuseColor.a;\n#ifdef NORMAL\nvar normalW: vec3f=normalize(fragmentInputs.vNormalW);\n#else\nvar normalW: vec3f=normalize(-cross(dpdx(fragmentInputs.vPositionW),dpdy(fragmentInputs.vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=select(-normalW,normalW,fragmentInputs.frontFacing);\n#endif\n#ifdef DIFFUSE\nbaseColor=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<uniforms.alphaCutOff) {discard;}\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor=vec4f(baseColor.rgb*uniforms.vDiffuseInfos.y,baseColor.a);\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor=vec4f(baseColor.rgb*fragmentInputs.vColor.rgb,baseColor.a);\n#endif\n#ifdef DETAIL\nbaseColor=vec4f(baseColor.rgb*2.0*mix(0.5,detailColor.r,uniforms.vDetailInfos.y),baseColor.a);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvar baseAmbientColor: vec3f= vec3f(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=textureSample(ambientSampler,ambientSamplerSampler,fragmentInputs.vAmbientUV+uvOffset).rgb*uniforms.vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nvar glossiness: f32=uniforms.vSpecularColor.a;var specularColor: vec3f=uniforms.vSpecularColor.rgb;\n#ifdef SPECULAR\nvar specularMapColor: vec4f=textureSample(specularSampler,specularSamplerSampler,fragmentInputs.vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nvar glossiness: f32=0.;\n#endif\nvar diffuseBase: vec3f= vec3f(0.,0.,0.);var info: lightingInfo;\n#ifdef SPECULARTERM\nvar specularBase: vec3f= vec3f(0.,0.,0.);\n#endif\nvar shadow: f32=1.;var aggShadow: f32=0.;var numLights: f32=0.;\n#ifdef LIGHTMAP\nvar lightmapColor: vec4f=textureSample(lightmapSampler,lightmapSamplerSampler,fragmentInputs.vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor=vec4f(fromRGBD(lightmapColor),lightmapColor.a);\n#endif\nlightmapColor=vec4f(lightmapColor.rgb*vLightmapInfos.y,lightmapColor.a);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;var refractionColor: vec4f= vec4f(0.,0.,0.,1.);\n#ifdef REFRACTION\nvar refractionVector: vec3f=normalize(refract(-viewDirectionW,normalW,uniforms.vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(fragmentInputs.vPositionW,refractionVector,uniforms.vRefractionSize,uniforms.vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*uniforms.vRefractionInfos.w;var refractionLookup: vec4f=textureSample(refractionCubeSampler,refractionCubeSamplerSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvar vRefractionUVW: vec3f= (uniforms.refractionMatrix*(scene.view* vec4f(fragmentInputs.vPositionW+refractionVector*uniforms.vRefractionInfos.z,1.0))).xyz;var refractionCoords: vec2f=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=textureSample(refraction2DSampler,refraction2DSamplerSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor=vec4f(fromRGBD(refractionColor),refractionColor.a);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor=vec4f(toGammaSpaceVec3(refractionColor.rgb),refractionColor.a);\n#endif\nrefractionColor=vec4f(refractionColor.rgb*uniforms.vRefractionInfos.x,refractionColor.a);\n#endif\nvar reflectionColor: vec4f= vec4f(0.,0.,0.,1.);\n#ifdef REFLECTION\nvar vReflectionUVW: vec3f=computeReflectionCoords( vec4f(fragmentInputs.vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW=vec3f(vReflectionUVW.x,vReflectionUVW.y,vReflectionUVW.z*-1.0);\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nvar bias: f32=uniforms.vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureSample(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureSample(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW);\n#endif\n#else\nvar coords: vec2f=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=textureSample(reflection2DSampler,reflection2DSamplerSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor=vec4f(fromRGBD(reflectionColor),reflectionColor.a);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor=vec4f(toGammaSpaceVec3(reflectionColor.rgb),reflectionColor.a);\n#endif\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.vReflectionInfos.x,reflectionColor.a);\n#ifdef REFLECTIONFRESNEL\nvar reflectionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.reflectionRightColor.a,uniforms.reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor=vec4f(reflectionColor.rgb*specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#else\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#endif\n#else\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nvar refractionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.refractionRightColor.a,uniforms.refractionLeftColor.a);refractionColor=vec4f(refractionColor.rgb*uniforms.refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*uniforms.refractionRightColor.rgb,refractionColor.a);\n#endif\n#ifdef OPACITY\nvar opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* uniforms.vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*uniforms.vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=fragmentInputs.vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nvar opacityFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.opacityParts.z,uniforms.opacityParts.w);alpha+=uniforms.opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*uniforms.opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<uniforms.alphaCutOff) {discard;}\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvar emissiveColor: vec3f=uniforms.vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vEmissiveUV+uvOffset).rgb*uniforms.vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nvar emissiveFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.emissiveRightColor.a,uniforms.emissiveLeftColor.a);emissiveColor*=uniforms.emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*uniforms.emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nvar diffuseFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.diffuseRightColor.a,uniforms.diffuseLeftColor.a);diffuseBase*=uniforms.diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*uniforms.diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvar finalDiffuse: vec3f=clamp((diffuseBase+emissiveColor)*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#else\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+emissiveColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvar finalSpecular: vec3f=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular, vec3f(0.3,0.59,0.11)),0.0,1.0);\n#endif\n#else\nvar finalSpecular: vec3f= vec3f(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb, vec3f(0.3,0.59,0.11)),0.0,1.0);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvar color: vec4f= vec4f(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvar color: vec4f= vec4f(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor=vec4f(color.rgb*lightmapColor.rgb,color.a);\n#else\ncolor=vec4f(color.rgb+lightmapColor.rgb,color.a);\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor=vec4f(max(color.rgb,vec3f(0.)),color.a);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor=vec4f(toLinearSpaceVec3(color.rgb),color.a);\n#else\n#ifdef IMAGEPROCESSING\ncolor=vec4f(toLinearSpaceVec3(color.rgb),color.a);color=applyImageProcessing(color);\n#endif\n#endif\ncolor=vec4f(color.rgb,color.a*mesh.visibility);\n#ifdef PREMULTIPLYALPHA\ncolor=vec4f(color.rgb*color.a, color.a);\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nvar writeGeometryInfo: f32=select(0.0,1.0,color.a>0.4);var fragData: array<vec4<f32>,SCENE_MRT_COUNT>;fragData[0]=color; \n#ifdef PREPASS_POSITION\nfragData[PREPASS_POSITION_INDEX]= vec4f(fragmentInputs.vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvar a: vec2f=(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[PREPASS_VELOCITY_INDEX]= vec4f(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\nfragData[PREPASS_IRRADIANCE_INDEX]= vec4f(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\nfragData[PREPASS_DEPTH_INDEX]= vec4f(fragmentInputs.vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\nfragData[PREPASS_NORMAL_INDEX]= vec4f(normalW,writeGeometryInfo); \n#else\nfragData[PREPASS_NORMAL_INDEX]= vec4f(normalize((scene.view* vec4f(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nfragData[PREPASS_ALBEDO_SQRT_INDEX]= vec4f(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\nfragData[PREPASS_REFLECTIVITY_INDEX]= vec4f(toLinearSpaceVec4(specularMapColor))*writeGeometryInfo; \n#else\nfragData[PREPASS_REFLECTIVITY_INDEX]= vec4f(toLinearSpaceVec3(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\nfragData[PREPASS_REFLECTIVITY_INDEX]= vec4f(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#if SCENE_MRT_COUNT>0\nfragmentOutputs.fragData0= fragData[0];\n#endif\n#if SCENE_MRT_COUNT>1\nfragmentOutputs.fragData1= fragData[1];\n#endif\n#if SCENE_MRT_COUNT>2\nfragmentOutputs.fragData2= fragData[2];\n#endif\n#if SCENE_MRT_COUNT>3\nfragmentOutputs.fragData3= fragData[3];\n#endif\n#if SCENE_MRT_COUNT>4\nfragmentOutputs.fragData4= fragData[4];\n#endif\n#if SCENE_MRT_COUNT>5\nfragmentOutputs.fragData5= fragData[5];\n#endif\n#if SCENE_MRT_COUNT>6\nfragmentOutputs.fragData6= fragData[6];\n#endif\n#if SCENE_MRT_COUNT>7\nfragmentOutputs.fragData7= fragData[7];\n#endif\n#endif\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+color.rgb*color.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-color.a));} else {fragmentOutputs.backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n", e.ShadersStoreWGSL[Mn] = Cn, Tn = {
					name: Mn,
					shader: Cn
				}
			}
		}),
		$n = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.decalVertexDeclaration = "#ifdef DECAL\nuniform vec4 vDecalInfos;uniform mat4 decalMatrix;\n#endif\n"
			}
		}),
		Jn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js"() {
				h(), $n(), e.IncludesShadersStore.defaultVertexDeclaration = "uniform mat4 viewProjection;uniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;uniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n"
			}
		}),
		qn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js"() {
				h(), Rs(), Ns(), e.IncludesShadersStore.defaultUboDeclaration = "layout(std140,column_major) uniform;uniform Material\n{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n"
			}
		}),
		Qn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js"() {
				h(), e.IncludesShadersStore.uvAttributeDeclaration = "#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n"
			}
		}),
		Zn = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js"() {
				h(), e.IncludesShadersStore.instancesDeclaration = "#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n"
			}
		}),
		ea = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.prePassVertexDeclaration = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#endif\n"
			}
		}),
		ta = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js"() {
				h(), e.IncludesShadersStore.mainUVVaryingDeclaration = "#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n"
			}
		}),
		ia = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.samplerVertexDeclaration = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n"
			}
		}),
		sa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.bumpVertexDeclaration = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n"
			}
		}),
		na = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.fogVertexDeclaration = "#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n"
			}
		}),
		aa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js"() {
				h(), e.IncludesShadersStore.logDepthDeclaration = "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n"
			}
		}),
		ra = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js"() {
				h(), e.IncludesShadersStore.prePassVertex = "#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n"
			}
		}),
		oa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js"() {
				h(), e.IncludesShadersStore.uvVariableDeclaration = "#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n"
			}
		}),
		la = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js"() {
				h(), e.IncludesShadersStore.samplerVertexImplementation = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}\n#endif\n#endif\n"
			}
		}),
		ha = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js"() {
				h(), e.IncludesShadersStore.bumpVertex = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n"
			}
		}),
		ca = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js"() {
				h(), e.IncludesShadersStore.fogVertex = "#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n"
			}
		}),
		ua = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js"() {
				h(), e.IncludesShadersStore.vertexColorMixing = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\n#else\nvColor.rgb*=color.rgb;\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\n#endif\n#endif\n"
			}
		}),
		ma = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js"() {
				h(), e.IncludesShadersStore.pointCloudVertex = "#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n"
			}
		}),
		da = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js"() {
				h(), e.IncludesShadersStore.logDepthVertex = "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n"
			}
		}),
		fa = {};
	l(fa, {
		defaultVertexShader: () => jn
	});
	var pa, _a, va, ya = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/default.vertex.js"() {
				h(), Jn(), qn(), Qn(), tt(), G(), bs(), Zn(), ea(), ta(), ia(), sa(), ks(), na(), Je(), Xe(), xs(), Ms(), aa(), Ds(), Os(), Fs(), z(), Ls(), ra(), oa(), la(), ha(), Gs(), ca(), _t(), ua(), ma(), da(), Xn = "defaultVertexShader", Yn = "#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n", e.ShadersStore[Xn] = Yn, jn = {
					name: Xn,
					shader: Yn
				}
			}
		}),
		Sa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js"() {
				h(), e.IncludesShadersStore.decalFragmentDeclaration = "#ifdef DECAL\nuniform vec4 vDecalInfos;\n#endif\n"
			}
		}),
		Ea = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js"() {
				h(), Sa(), e.IncludesShadersStore.defaultFragmentDeclaration = "uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n"
			}
		}),
		Aa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js"() {
				h(), e.IncludesShadersStore.prePassDeclaration = "#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n"
			}
		}),
		ba = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js"() {
				h(), e.IncludesShadersStore.oitDeclaration = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;\n#endif\n"
			}
		}),
		xa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js"() {
				h(), e.IncludesShadersStore.samplerFragmentDeclaration = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n"
			}
		}),
		Ma = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js"() {
				h(), e.IncludesShadersStore.fresnelFunction = "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}\n#endif\n"
			}
		}),
		Ca = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js"() {
				h(), e.IncludesShadersStore.reflectionFunction = "vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*(view*worldPos));}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*vec4(positionW,1.));}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n"
			}
		}),
		Ta = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js"() {
				h(), e.IncludesShadersStore.imageProcessingDeclaration = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\n#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n#ifdef DITHER\nuniform float ditherIntensity;\n#endif\n"
			}
		}),
		wa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js"() {
				h(), e.IncludesShadersStore.imageProcessingFunctions = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{float sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;}\n#endif\n#if TONEMAPPING==3\nconst float PBRNeutralStartCompression=0.8-0.04;const float PBRNeutralDesaturation=0.15;vec3 PBRNeutralToneMapping( vec3 color ) {float x=min(color.r,min(color.g,color.b));float offset=x<0.08 ? x-6.25*x*x : 0.04;color-=offset;float peak=max(color.r,max(color.g,color.b));if (peak<PBRNeutralStartCompression) return color;float d=1.-PBRNeutralStartCompression;float newPeak=1.-d*d/(peak+d-PBRNeutralStartCompression);color*=newPeak/peak;float g=1.-1./(PBRNeutralDesaturation*(peak-newPeak)+1.);return mix(color,newPeak*vec3(1,1,1),g);}\n#endif\n#if TONEMAPPING==2\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);const mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);vec3 RRTAndODTFit(vec3 v)\n{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}\nvec3 ACESFitted(vec3 color)\n{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#if TONEMAPPING==3\nresult.rgb=PBRNeutralToneMapping(result.rgb);\n#elif TONEMAPPING==2\nresult.rgb=ACESFitted(result.rgb);\n#elif TONEMAPPING==1\nconst float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\nresult.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;}"
			}
		}),
		Ra = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js"() {
				h(), e.IncludesShadersStore.bumpFragmentMainFunctions = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}\n#else\nmat4 toNormalMatrix(mat4 m)\n{float\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}\n#endif\n"
			}
		}),
		Na = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js"() {
				h(), xa(), e.IncludesShadersStore.bumpFragmentFunctions = "#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)\n{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n"
			}
		}),
		Ia = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js"() {
				h(), e.IncludesShadersStore.bumpFragment = "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n"
			}
		}),
		Pa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js"() {
				h(), e.IncludesShadersStore.decalFragment = "#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\n#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\n#endif\n"
			}
		}),
		ka = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js"() {
				h(), e.IncludesShadersStore.depthPrePass = "#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);return;\n#endif\n"
			}
		}),
		Da = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js"() {
				h(), e.IncludesShadersStore.logDepthFragment = "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n"
			}
		}),
		Oa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js"() {
				h(), e.IncludesShadersStore.fogFragment = "#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n"
			}
		}),
		Fa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js"() {
				h(), e.IncludesShadersStore.oitFragment = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);return;}\n#endif\n"
			}
		}),
		La = {};
	l(La, {
		defaultPixelShader: () => va
	});
	var Ba, Ga, Ha, Ua = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/default.fragment.js"() {
				h(), Ea(), qn(), Aa(), ba(), ta(), tt(), Ne(), He(), rt(), ut(), xa(), Ma(), Ca(), Ta(), wa(), Ra(), Na(), _s(), aa(), Ct(), gs(), Ia(), Pa(), ka(), Oe(), Da(), Oa(), Fa(), pa = "defaultPixelShader", _a = "#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n", e.ShadersStore[pa] = _a, va = {
					name: pa,
					shader: _a
				}
			}
		}),
		Va = {};
	l(Va, {
		spritesVertexShaderWGSL: () => Ha
	});
	var Wa, za, Xa, Ya = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/sprites.vertex.js"() {
				h(), fn(), _n(), bn(), Ba = "spritesVertexShader", Ga = "attribute position: vec4f;attribute options: vec2f;attribute offsets: vec2f;attribute inverts: vec2f;attribute cellInfo: vec4f;attribute color: vec4f;uniform view: mat4x4f;uniform projection: mat4x4f;varying vUV: vec2f;varying vColor: vec4f;\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar viewPos: vec3f=(uniforms.view* vec4f(input.position.xyz,1.0)).xyz; \nvar cornerPos: vec2f;var angle: f32=input.position.w;var size: vec2f= vec2f(input.options.x,input.options.y);var offset: vec2f=input.offsets.xy;cornerPos= vec2f(offset.x-0.5,offset.y -0.5)*size;var rotatedCorner: vec3f;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0); \nvertexOutputs.vColor=input.color;var uvOffset: vec2f= vec2f(abs(offset.x-input.inverts.x),abs(1.0-offset.y-input.inverts.y));var uvPlace: vec2f=input.cellInfo.xy;var uvSize: vec2f=input.cellInfo.zw;vertexOutputs.vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vertexOutputs.vUV.y=uvPlace.y+uvSize.y*uvOffset.y;\n#ifdef FOG\nvertexOutputs.vFogDistance=viewPos;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStoreWGSL[Ba] = Ga, Ha = {
					name: Ba,
					shader: Ga
				}
			}
		}),
		ja = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/imageProcessingCompatibility.js"() {
				h(), e.IncludesShadersStoreWGSL.imageProcessingCompatibility = "#ifdef IMAGEPROCESSINGPOSTPROCESS\nfragmentOutputs.color=vec4f(pow(fragmentOutputs.color.rgb, vec3f(2.2)),fragmentOutputs.color.a);\n#endif\n"
			}
		}),
		Ka = {};
	l(Ka, {
		spritesPixelShaderWGSL: () => Xa
	});
	var $a, Ja, qa, Qa = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/sprites.fragment.js"() {
				h(), Et(), _n(), Un(), Vn(), ja(), Wa = "spritesPixelShader", za = "uniform alphaTest: i32;varying vColor: vec4f;varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#include<fogFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#ifdef PIXEL_PERFECT\nfn uvPixelPerfect(uv: vec2f)->vec2f {var res: vec2f= vec2f(textureDimensions(diffuseSampler,0));var uvTemp=uv*res;var seam: vec2f=floor(uvTemp+0.5);uvTemp=seam+clamp((uvTemp-seam)/fwidth(uvTemp),vec2f(-0.5),vec2f(0.5));return uvTemp/res;}\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#ifdef PIXEL_PERFECT\nvar uv: vec2f=uvPixelPerfect(input.vUV);\n#else\nvar uv: vec2f=input.vUV;\n#endif\nvar color: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,uv);var fAlphaTest: f32= f32(uniforms.alphaTest);if (fAlphaTest != 0.)\n{if (color.a<0.95) {discard;}}\ncolor*=input.vColor;\n#include<logDepthFragment>\n#include<fogFragment>\nfragmentOutputs.color=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}", e.ShadersStoreWGSL[Wa] = za, Xa = {
					name: Wa,
					shader: za
				}
			}
		}),
		Za = {};
	l(Za, {
		spritesVertexShader: () => qa
	});
	var er, tr, ir, sr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/sprites.vertex.js"() {
				h(), na(), aa(), da(), $a = "spritesVertexShader", Ja = "attribute vec4 position;attribute vec2 options;attribute vec2 offsets;attribute vec2 inverts;attribute vec4 cellInfo;attribute vec4 color;uniform mat4 view;uniform mat4 projection;varying vec2 vUV;varying vec4 vColor;\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \nvec2 cornerPos;float angle=position.w;vec2 size=vec2(options.x,options.y);vec2 offset=offsets.xy;cornerPos=vec2(offset.x-0.5,offset.y -0.5)*size;vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;gl_Position=projection*vec4(viewPos,1.0); \nvColor=color;vec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));vec2 uvPlace=cellInfo.xy;vec2 uvSize=cellInfo.zw;vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vUV.y=uvPlace.y+uvSize.y*uvOffset.y;\n#ifdef FOG\nvFogDistance=viewPos;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStore[$a] = Ja, qa = {
					name: $a,
					shader: Ja
				}
			}
		}),
		nr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js"() {
				h(), e.IncludesShadersStore.imageProcessingCompatibility = "#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif\n"
			}
		}),
		ar = {};
	l(ar, {
		spritesPixelShader: () => ir
	});
	var rr, or, lr, hr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/sprites.fragment.js"() {
				h(), Ct(), aa(), Da(), Oa(), nr(), er = "spritesPixelShader", tr = "#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform bool alphaTest;varying vec4 vColor;varying vec2 vUV;uniform sampler2D diffuseSampler;\n#include<fogFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#ifdef PIXEL_PERFECT\nvec2 uvPixelPerfect(vec2 uv) {vec2 res=vec2(textureSize(diffuseSampler,0));uv=uv*res;vec2 seam=floor(uv+0.5);uv=seam+clamp((uv-seam)/fwidth(uv),-0.5,0.5);return uv/res;}\n#endif\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#ifdef PIXEL_PERFECT\nvec2 uv=uvPixelPerfect(vUV);\n#else\nvec2 uv=vUV;\n#endif\nvec4 color=texture2D(diffuseSampler,uv);float fAlphaTest=float(alphaTest);if (fAlphaTest != 0.)\n{if (color.a<0.95)\ndiscard;}\ncolor*=vColor;\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}", e.ShadersStore[er] = tr, ir = {
					name: er,
					shader: tr
				}
			}
		}),
		cr = {};
	l(cr, {
		colorVertexShaderWGSL: () => lr
	});
	var ur, mr, dr, fr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/color.vertex.js"() {
				h(), R(), Hi(), Yi(), fn(), hn(), $i(), D(), Ji(), Qi(), En(), An(), rr = "colorVertexShader", or = "attribute position: vec3f;\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform view: mat4x4f;\n#endif\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStoreWGSL[rr] = or, lr = {
					name: rr,
					shader: or
				}
			}
		}),
		pr = {};
	l(pr, {
		colorPixelShaderWGSL: () => dr
	});
	var _r, gr, vr, yr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/color.fragment.js"() {
				h(), ki(), Et(), Di(), Vn(), ur = "colorPixelShader", mr = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vColor: vec4f;\n#else\nuniform color: vec4f;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nfragmentOutputs.color=input.vColor;\n#else\nfragmentOutputs.color=uniforms.color;\n#endif\n#include<fogFragment>(color,fragmentOutputs.color)\n#define CUSTOM_FRAGMENT_MAIN_END\n}", e.ShadersStoreWGSL[ur] = mr, dr = {
					name: ur,
					shader: mr
				}
			}
		}),
		Sr = {};
	l(Sr, {
		colorVertexShader: () => vr
	});
	var Er, Ar, br, xr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/color.vertex.js"() {
				h(), G(), bs(), ks(), na(), Zn(), Fs(), z(), Ls(), Gs(), ca(), ua(), _r = "colorVertexShader", gr = "attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform mat4 view;\n#endif\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStore[_r] = gr, vr = {
					name: _r,
					shader: gr
				}
			}
		}),
		Mr = {};
	l(Mr, {
		colorPixelShader: () => br
	});
	var Cr, Tr, wr, Rr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/color.fragment.js"() {
				h(), _s(), Ct(), gs(), Oa(), Er = "colorPixelShader", Ar = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#include<fogFragment>(color,gl_FragColor)\n#define CUSTOM_FRAGMENT_MAIN_END\n}", e.ShadersStore[Er] = Ar, br = {
					name: Er,
					shader: Ar
				}
			}
		}),
		Nr = {};
	l(Nr, {
		depthPixelShader: () => wr
	});
	var Ir, Pr, kr, Dr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/depth.fragment.js"() {
				h(), _s(), qt(), gs(), Cr = "depthPixelShader", Tr = "#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}", e.ShadersStore[Cr] = Tr, wr = {
					name: Cr,
					shader: Tr
				}
			}
		}),
		Or = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertexDeclaration.js"() {
				h(), e.IncludesShadersStore.pointCloudVertexDeclaration = "#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n"
			}
		}),
		Fr = {};
	l(Fr, {
		depthVertexShader: () => kr
	});
	var Lr, Br, Gr, Hr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/depth.vertex.js"() {
				h(), G(), bs(), xs(), Ms(), ks(), Zn(), Or(), Ds(), Os(), Fs(), z(), Ls(), Gs(), ma(), Ir = "depthVertexShader", Pr = "attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;varying vec4 vViewPos;\n#endif\n#include<pointCloudVertexDeclaration>\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<pointCloudVertex>\n}\n", e.ShadersStore[Ir] = Pr, kr = {
					name: Ir,
					shader: Pr
				}
			}
		}),
		Ur = {};
	l(Ur, {
		depthVertexShaderWGSL: () => Gr
	});
	var Vr, Wr, zr, Xr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/depth.vertex.js"() {
				h(), R(), Hi(), Ui(), Vi(), Yi(), hn(), ji(), Ki(), $i(), D(), Ji(), Qi(), Lr = "depthVertexShader", Br = "attribute position: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;uniform depthValues: vec2f;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform view: mat4x4f;varying vViewPos: vec4f;\n#endif\nvarying vDepthMetric: f32;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#include<clipPlaneVertex>\nvertexOutputs.position=uniforms.viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvertexOutputs.vViewPos=uniforms.view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#else\nvertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(input.uv2,1.0,0.0)).xy;\n#endif\n#endif\n}\n", e.ShadersStoreWGSL[Lr] = Br, Gr = {
					name: Lr,
					shader: Br
				}
			}
		}),
		Yr = {};
	l(Yr, {
		depthPixelShaderWGSL: () => zr
	});
	var jr, Kr, $r, Jr = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/depth.fragment.js"() {
				h(), ki(), Ft(), Di(), Vr = "depthPixelShader", Wr = "#ifdef ALPHATEST\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying vDepthMetric: f32;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vViewPos: vec4f;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\nfragmentOutputs.color=pack(input.vViewPos.z);\n#else\nfragmentOutputs.color= vec4f(input.vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\nfragmentOutputs.color=pack(input.position.z);\n#else\nfragmentOutputs.color= vec4f(input.position.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\nfragmentOutputs.color=pack(input.vDepthMetric);\n#else\nfragmentOutputs.color= vec4f(input.vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}", e.ShadersStoreWGSL[Vr] = Wr, zr = {
					name: Vr,
					shader: Wr
				}
			}
		}),
		qr = {};
	l(qr, {
		rgbdDecodePixelShaderWGSL: () => $r
	});
	var Qr, Zr, eo, to = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js"() {
				h(), ce(), jr = "rgbdDecodePixelShader", Kr = "varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(fromRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV)),1.0);}", e.ShadersStoreWGSL[jr] = Kr, $r = {
					name: jr,
					shader: Kr
				}
			}
		}),
		io = {};
	l(io, {
		rgbdEncodePixelShaderWGSL: () => eo
	});
	var so, no, ao, ro = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js"() {
				h(), ce(), Qr = "rgbdEncodePixelShader", Zr = "varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=toRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb);}", e.ShadersStoreWGSL[Qr] = Zr, eo = {
					name: Qr,
					shader: Zr
				}
			}
		}),
		oo = {};
	l(oo, {
		rgbdDecodePixelShader: () => ao
	});
	var lo, ho, co, uo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js"() {
				h(), tt(), so = "rgbdDecodePixelShader", no = "varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}", e.ShadersStore[so] = no, ao = {
					name: so,
					shader: no
				}
			}
		}),
		mo = {};
	l(mo, {
		rgbdEncodePixelShader: () => co
	});
	var fo, po, _o, go = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js"() {
				h(), tt(), lo = "rgbdEncodePixelShader", ho = "varying vec2 vUV;uniform sampler2D textureSampler;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}", e.ShadersStore[lo] = ho, co = {
					name: lo,
					shader: ho
				}
			}
		}),
		vo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrUboDeclaration.js"() {
				h(), Wi(), zi(), e.IncludesShadersStoreWGSL.pbrUboDeclaration = "uniform vAlbedoInfos: vec2f;uniform vAmbientInfos: vec4f;uniform vOpacityInfos: vec2f;uniform vEmissiveInfos: vec2f;uniform vLightmapInfos: vec2f;uniform vReflectivityInfos: vec3f;uniform vMicroSurfaceSamplerInfos: vec2f;uniform vReflectionInfos: vec2f;uniform vReflectionFilteringInfo: vec2f;uniform vReflectionPosition: vec3f;uniform vReflectionSize: vec3f;uniform vBumpInfos: vec3f;uniform albedoMatrix: mat4x4f;uniform ambientMatrix: mat4x4f;uniform opacityMatrix: mat4x4f;uniform emissiveMatrix: mat4x4f;uniform lightmapMatrix: mat4x4f;uniform reflectivityMatrix: mat4x4f;uniform microSurfaceSamplerMatrix: mat4x4f;uniform bumpMatrix: mat4x4f;uniform vTangentSpaceParams: vec2f;uniform reflectionMatrix: mat4x4f;uniform vReflectionColor: vec3f;uniform vAlbedoColor: vec4f;uniform vLightingIntensity: vec4f;uniform vReflectionMicrosurfaceInfos: vec3f;uniform pointSize: f32;uniform vReflectivityColor: vec4f;uniform vEmissiveColor: vec3f;uniform vAmbientColor: vec3f;uniform vDebugMode: vec2f;uniform vMetallicReflectanceFactors: vec4f;uniform vMetallicReflectanceInfos: vec2f;uniform metallicReflectanceMatrix: mat4x4f;uniform vReflectanceInfos: vec2f;uniform reflectanceMatrix: mat4x4f;uniform vSphericalL00: vec3f;uniform vSphericalL1_1: vec3f;uniform vSphericalL10: vec3f;uniform vSphericalL11: vec3f;uniform vSphericalL2_2: vec3f;uniform vSphericalL2_1: vec3f;uniform vSphericalL20: vec3f;uniform vSphericalL21: vec3f;uniform vSphericalL22: vec3f;uniform vSphericalX: vec3f;uniform vSphericalY: vec3f;uniform vSphericalZ: vec3f;uniform vSphericalXX_ZZ: vec3f;uniform vSphericalYY_ZZ: vec3f;uniform vSphericalZZ: vec3f;uniform vSphericalXY: vec3f;uniform vSphericalYZ: vec3f;uniform vSphericalZX: vec3f;\n#define ADDITIONAL_UBO_DECLARATION\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n"
			}
		}),
		yo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/harmonicsFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.harmonicsFunctions = "#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nfn computeEnvironmentIrradiance(normal: vec3f)->vec3f {return uniforms.vSphericalL00\n+ uniforms.vSphericalL1_1*(normal.y)\n+ uniforms.vSphericalL10*(normal.z)\n+ uniforms.vSphericalL11*(normal.x)\n+ uniforms.vSphericalL2_2*(normal.y*normal.x)\n+ uniforms.vSphericalL2_1*(normal.y*normal.z)\n+ uniforms.vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ uniforms.vSphericalL21*(normal.z*normal.x)\n+ uniforms.vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}\n#else\nfn computeEnvironmentIrradiance(normal: vec3f)->vec3f {var Nx: f32=normal.x;var Ny: f32=normal.y;var Nz: f32=normal.z;var C1: vec3f=uniforms.vSphericalZZ.rgb;var Cx: vec3f=uniforms.vSphericalX.rgb;var Cy: vec3f=uniforms.vSphericalY.rgb;var Cz: vec3f=uniforms.vSphericalZ.rgb;var Cxx_zz: vec3f=uniforms.vSphericalXX_ZZ.rgb;var Cyy_zz: vec3f=uniforms.vSphericalYY_ZZ.rgb;var Cxy: vec3f=uniforms.vSphericalXY.rgb;var Cyz: vec3f=uniforms.vSphericalYZ.rgb;var Czx: vec3f=uniforms.vSphericalZX.rgb;var a1: vec3f=Cyy_zz*Ny+Cy;var a2: vec3f=Cyz*Nz+a1;var b1: vec3f=Czx*Nz+Cx;var b2: vec3f=Cxy*Ny+b1;var b3: vec3f=Cxx_zz*Nx+b2;var t1: vec3f=Cz *Nz+C1;var t2: vec3f=a2 *Ny+t1;var t3: vec3f=b3 *Nx+t2;return t3;}\n#endif\n#endif\n"
			}
		}),
		So = {};
	l(So, {
		pbrVertexShaderWGSL: () => _o
	});
	var Eo, Ao, bo, xo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/pbr.vertex.js"() {
				h(), vo(), ln(), un(), ce(), R(), Hi(), hn(), cn(), mn(), yo(), dn(), Yi(), fn(), ae(), Ui(), Vi(), _n(), ji(), Ki(), $i(), D(), Ji(), gn(), vn(), yn(), Sn(), Qi(), En(), Me(), An(), bn(), fo = "pbrVertexShader", po = "#include<pbrUboDeclaration>\n#define CUSTOM_VERTEX_BEGIN\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#ifdef TANGENT\nattribute tangent: vec4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor)\n#endif\nvarying vPositionW: vec3f;\n#if DEBUGMODE>0\nvarying vClipSpacePosition: vec4f;\n#endif\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vEnvironmentIrradiance: vec3f;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<lightVxUboDeclaration>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar positionUpdated: vec3f=vertexInputs.position;\n#ifdef NORMAL\nvar normalUpdated: vec3f=vertexInputs.normal;\n#endif\n#ifdef TANGENT\nvar tangentUpdated: vec4f=vertexInputs.tangent;\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);vertexOutputs.vPositionW= worldPos.xyz;\n#include<prePassVertex>\n#ifdef NORMAL\nvar normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvar reflectionVector: vec3f= (uniforms.reflectionMatrix* vec4f(vertexOutputs.vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvertexOutputs.vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}\n#else\nvertexOutputs.position=scene.viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvertexOutputs.vClipSpacePosition=vertexOutputs.position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld*vec4f(positionUpdated,0.0)).xyz);\n#endif\n#ifndef UV1\nvar uvUpdated: vec2f= vec2f(0.,0.);\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheenRoughness,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_MATRIXNAME_,translucencyColor,_INFONAME_,TranslucencyColorInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStoreWGSL[fo] = po, _o = {
					name: fo,
					shader: po
				}
			}
		}),
		Mo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrFragmentExtraDeclaration.js"() {
				h(), un(), e.IncludesShadersStoreWGSL.pbrFragmentExtraDeclaration = "varying vPositionW: vec3f;\n#if DEBUGMODE>0\nvarying vClipSpacePosition: vec4f;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vEnvironmentIrradiance: vec3f;\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n"
			}
		}),
		Co = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/samplerFragmentAlternateDeclaration.js"() {
				h(), e.IncludesShadersStoreWGSL.samplerFragmentAlternateDeclaration = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying v_VARYINGNAME_UV: vec2f;\n#endif\n#endif\n"
			}
		}),
		To = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrFragmentSamplersDeclaration.js"() {
				h(), In(), Co(), e.IncludesShadersStoreWGSL.pbrFragmentSamplersDeclaration = "#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nvar clearCoatRoughnessSamplerSampler: sampler;var clearCoatRoughnessSampler: texture_2d<f32>;\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS)\nvar sheenRoughnessSamplerSampler: sampler;var sheenRoughnessSampler: texture_2d<f32>;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nvar reflectionSamplerSampler: sampler;var reflectionSampler: texture_cube<f32>;\n#ifdef LODBASEDMICROSFURACE\n#else\nvar reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_cube<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_cube<f32>;\n#endif\n#ifdef USEIRRADIANCEMAP\nvar irradianceSamplerSampler: sampler;var irradianceSampler: texture_cube<f32>;\n#endif\n#else\nvar reflectionSamplerSampler: sampler;var reflectionSampler: texture_2d<f32>;\n#ifdef LODBASEDMICROSFURACE\n#else\nvar reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_2d<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_2d<f32>;\n#endif\n#ifdef USEIRRADIANCEMAP\nvar irradianceSamplerSampler: sampler;var irradianceSampler: texture_2d<f32>;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nvar environmentBrdfSamplerSampler: sampler;var environmentBrdfSampler: texture_2d<f32>;\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\nvar refractionSamplerSampler: sampler;var refractionSampler: texture_cube<f32>;\n#ifdef LODBASEDMICROSFURACE\n#else\nvar refractionLowSamplerSampler: sampler;var refractionLowSampler: texture_cube<f32>;var refractionHighSamplerSampler: sampler;var refractionHighSampler: texture_cube<f32>;\n#endif\n#else\nvar refractionSamplerSampler: sampler;var refractionSampler: texture_2d<f32>;\n#ifdef LODBASEDMICROSFURACE\n#else\nvar refractionLowSamplerSampler: sampler;var refractionLowSampler: texture_2d<f32>;var refractionHighSamplerSampler: sampler;var refractionHighSampler: texture_2d<f32>;\n#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_SAMPLERNAME_,translucencyColor)\n#endif\n"
			}
		}),
		wo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/subSurfaceScatteringFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.subSurfaceScatteringFunctions = "fn testLightingForSSS(diffusionProfile: f32)->bool\n{return diffusionProfile<1.;}"
			}
		}),
		Ro = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/importanceSampling.js"() {
				h(), e.IncludesShadersStoreWGSL.importanceSampling = "fn hemisphereCosSample(u: vec2f)->vec3f {var phi: f32=2.*PI*u.x;var cosTheta2: f32=1.-u.y;var cosTheta: f32=sqrt(cosTheta2);var sinTheta: f32=sqrt(1.-cosTheta2);return vec3f(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nfn hemisphereImportanceSampleDggx(u: vec2f,a: f32)->vec3f {var phi: f32=2.*PI*u.x;var cosTheta2: f32=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));var cosTheta: f32=sqrt(cosTheta2);var sinTheta: f32=sqrt(1.-cosTheta2);return vec3f(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nfn hemisphereImportanceSampleDCharlie(u: vec2f,a: f32)->vec3f { \nvar phi: f32=2.*PI*u.x;var sinTheta: f32=pow(u.y,a/(2.*a+1.));var cosTheta: f32=sqrt(1.-sinTheta*sinTheta);return vec3f(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}"
			}
		}),
		No = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrHelperFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrHelperFunctions = "#define MINIMUMVARIANCE 0.0005\nfn convertRoughnessToAverageSlope(roughness: f32)->f32\n{return roughness*roughness+MINIMUMVARIANCE;}\nfn fresnelGrazingReflectance(reflectance0: f32)->f32 {var reflectance90: f32=saturate(reflectance0*25.0);return reflectance90;}\nfn getAARoughnessFactors(normalVector: vec3f)->vec2f {\n#ifdef SPECULARAA\nvar nDfdx: vec3f=dpdx(normalVector.xyz);var nDfdy: vec3f=dpdy(normalVector.xyz);var slopeSquare: f32=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));var geometricRoughnessFactor: f32=pow(saturate(slopeSquare),0.333);var geometricAlphaGFactor: f32=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2f(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2f(0.);\n#endif\n}\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_LEGACY\nfn getAnisotropicRoughness(alphaG: f32,anisotropy: f32)->vec2f {var alphaT: f32=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);var alphaB: f32=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2f(alphaT,alphaB);}\nfn getAnisotropicBentNormals(T: vec3f,B: vec3f,N: vec3f,V: vec3f,anisotropy: f32,roughness: f32)->vec3f {var anisotropicFrameDirection: vec3f=select(T,B,anisotropy>=0.0);var anisotropicFrameTangent: vec3f=cross(normalize(anisotropicFrameDirection),V);var anisotropicFrameNormal: vec3f=cross(anisotropicFrameTangent,anisotropicFrameDirection);var anisotropicNormal: vec3f=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}\n#else\nfn getAnisotropicRoughness(alphaG: f32,anisotropy: f32)->vec2f {var alphaT: f32=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);var alphaB: f32=max(alphaG,MINIMUMVARIANCE);return vec2f(alphaT,alphaB);}\nfn getAnisotropicBentNormals(T: vec3f,B: vec3f,N: vec3f,V: vec3f,anisotropy: f32,roughness: f32)->vec3f {var bentNormal: vec3f=cross(B,V);bentNormal=normalize(cross(bentNormal,B));var sq=1.0-anisotropy*(1.0-roughness);var a: f32=sq*sq*sq*sq;bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}\n#endif\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nfn cocaLambertVec3(alpha: vec3f,distance: f32)->vec3f {return exp(-alpha*distance);}\nfn cocaLambert(NdotVRefract: f32,NdotLRefract: f32,alpha: vec3f,thickness: f32)->vec3f {return cocaLambertVec3(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}\nfn computeColorAtDistanceInMedia(color: vec3f,distance: f32)->vec3f {return -log(color)/distance;}\nfn computeClearCoatAbsorption(NdotVRefract: f32,NdotLRefract: f32,clearCoatColor: vec3f,clearCoatThickness: f32,clearCoatIntensity: f32)->vec3f {var clearCoatAbsorption: vec3f=mix( vec3f(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);return clearCoatAbsorption;}\n#endif\n#ifdef MICROSURFACEAUTOMATIC\nfn computeDefaultMicroSurface(microSurface: f32,reflectivityColor: vec3f)->f32\n{const kReflectivityNoAlphaWorkflow_SmoothnessMax: f32=0.95;var reflectivityLuminance: f32=getLuminance(reflectivityColor);var reflectivityLuma: f32=sqrt(reflectivityLuminance);var resultMicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return resultMicroSurface;}\n#endif\n"
			}
		}),
		Io = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrDirectLightingSetupFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrDirectLightingSetupFunctions = "struct preLightingInfo\n{lightOffset: vec3f,\nlightDistanceSquared: f32,\nlightDistance: f32,\nattenuation: f32,\nL: vec3f,\nH: vec3f,\nNdotV: f32,\nNdotLUnclamped: f32,\nNdotL: f32,\nVdotH: f32,\nroughness: f32,\n#ifdef IRIDESCENCE\niridescenceIntensity: f32\n#endif\n};fn computePointAndSpotPreLightingInfo(lightData: vec4f,V: vec3f,N: vec3f,posW: vec3f)->preLightingInfo {var result: preLightingInfo;result.lightOffset=lightData.xyz-posW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\nfn computeDirectionalPreLightingInfo(lightData: vec4f,V: vec3f,N: vec3f)->preLightingInfo {var result: preLightingInfo;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\nfn computeHemisphericPreLightingInfo(lightData: vec4f,V: vec3f,N: vec3f)->preLightingInfo {var result: preLightingInfo;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;}"
			}
		}),
		Po = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrDirectLightingFalloffFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrDirectLightingFalloffFunctions = "fn computeDistanceLightFalloff_Standard(lightOffset: vec3f,range: f32)->f32\n{return max(0.,1.0-length(lightOffset)/range);}\nfn computeDistanceLightFalloff_Physical(lightDistanceSquared: f32)->f32\n{return 1.0/maxEps(lightDistanceSquared);}\nfn computeDistanceLightFalloff_GLTF(lightDistanceSquared: f32,inverseSquaredRange: f32)->f32\n{var lightDistanceFalloff: f32=1.0/maxEps(lightDistanceSquared);var factor: f32=lightDistanceSquared*inverseSquaredRange;var attenuation: f32=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}\nfn computeDistanceLightFalloff(lightOffset: vec3f,lightDistanceSquared: f32,range: f32,inverseSquaredRange: f32)->f32\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfn computeDirectionalLightFalloff_Standard(lightDirection: vec3f,directionToLightCenterW: vec3f,cosHalfAngle: f32,exponent: f32)->f32\n{var falloff: f32=0.0;var cosAngle: f32=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)\n{falloff=max(0.,pow(cosAngle,exponent));}\nreturn falloff;}\nfn computeDirectionalLightFalloff_Physical(lightDirection: vec3f,directionToLightCenterW: vec3f,cosHalfAngle: f32)->f32\n{const kMinusLog2ConeAngleIntensityRatio: f32=6.64385618977; \nvar concentrationKappa: f32=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);var lightDirectionSpreadSG: vec4f= vec4f(-lightDirection*concentrationKappa,-concentrationKappa);var falloff: f32=exp2(dot( vec4f(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}\nfn computeDirectionalLightFalloff_GLTF(lightDirection: vec3f,directionToLightCenterW: vec3f,lightAngleScale: f32,lightAngleOffset: f32)->f32\n{var cd: f32=dot(-lightDirection,directionToLightCenterW);var falloff: f32=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}\nfn computeDirectionalLightFalloff(lightDirection: vec3f,directionToLightCenterW: vec3f,cosHalfAngle: f32,exponent: f32,lightAngleScale: f32,lightAngleOffset: f32)->f32\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}"
			}
		}),
		ko = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBRDFFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBRDFFunctions = "#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nfn getEnergyConservationFactor(specularEnvironmentR0: vec3f,environmentBrdf: vec3f)->vec3f {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}\n#endif\n#ifdef ENVIRONMENTBRDF\nfn getBRDFLookup(NdotV: f32,perceptualRoughness: f32)->vec3f {var UV: vec2f= vec2f(NdotV,perceptualRoughness);var brdfLookup: vec4f= textureSample(environmentBrdfSampler,environmentBrdfSamplerSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup=vec4f(fromRGBD(brdfLookup.rgba),brdfLookup.a);\n#endif\nreturn brdfLookup.rgb;}\nfn getReflectanceFromBRDFWithEnvLookup(specularEnvironmentR0: vec3f,specularEnvironmentR90: vec3f,environmentBrdf: vec3f)->vec3f {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvar reflectance: vec3f=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvar reflectance: vec3f=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;}\nfn getReflectanceFromBRDFLookup(specularEnvironmentR0: vec3f,environmentBrdf: vec3f)->vec3f {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvar reflectance: vec3f=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvar reflectance: vec3f=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfn getBRDFLookupCharlieSheen(NdotV: f32,perceptualRoughness: f32)->f32\n{var c: f32=1.0-NdotV;var c3: f32=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nfn getReflectanceFromAnalyticalBRDFLookup_Jones(VdotN: f32,reflectance0: vec3f,reflectance90: vec3f,smoothness: f32)->vec3f\n{var weight: f32=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nfn getSheenReflectanceFromBRDFLookup(reflectance0: vec3f,environmentBrdf: vec3f)->vec3f {var sheenEnvironmentReflectance: vec3f=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}\n#endif\nfn fresnelSchlickGGXVec3(VdotH: f32,reflectance0: vec3f,reflectance90: vec3f)->vec3f\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\nfn fresnelSchlickGGX(VdotH: f32,reflectance0: f32,reflectance90: f32)->f32\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\n#ifdef CLEARCOAT\nfn getR0RemappedForClearCoat(f0: vec3f)->vec3f {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturateVec3(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturateVec3(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvar s: vec3f=sqrt(f0);var t: vec3f=(uniforms.vClearCoatRefractionParams.z+uniforms.vClearCoatRefractionParams.w*s)/(uniforms.vClearCoatRefractionParams.w+uniforms.vClearCoatRefractionParams.z*s);return squareVec3(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst XYZ_TO_REC709: mat3x3f= mat3x3f(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);fn getIORTfromAirToSurfaceR0(f0: vec3f)->vec3f {var sqrtF0: vec3f=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}\nfn getR0fromIORsVec3(iorT: vec3f,iorI: f32)->vec3f {return squareVec3((iorT- vec3f(iorI))/(iorT+ vec3f(iorI)));}\nfn getR0fromIORs(iorT: f32,iorI: f32)->f32 {return square((iorT-iorI)/(iorT+iorI));}\nfn evalSensitivity(opd: f32,shift: vec3f)->vec3f {var phase: f32=2.0*PI*opd*1.0e-9;const val: vec3f= vec3f(5.4856e-13,4.4201e-13,5.2481e-13);const pos: vec3f= vec3f(1.6810e+06,1.7953e+06,2.2084e+06);const vr: vec3f= vec3f(4.3278e+09,9.3046e+09,6.6121e+09);var xyz: vec3f=val*sqrt(2.0*PI*vr)*cos(pos*phase+shift)*exp(-square(phase)*vr);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;var srgb: vec3f=XYZ_TO_REC709*xyz;return srgb;}\nfn evalIridescence(outsideIOR: f32,eta2: f32,cosTheta1: f32,thinFilmThickness: f32,baseF0: vec3f)->vec3f {var I: vec3f= vec3f(1.0);var iridescenceIOR: f32=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));var sinTheta2Sq: f32=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));var cosTheta2Sq: f32=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}\nvar cosTheta2: f32=sqrt(cosTheta2Sq);var R0: f32=getR0fromIORs(iridescenceIOR,outsideIOR);var R12: f32=fresnelSchlickGGX(cosTheta1,R0,1.);var R21: f32=R12;var T121: f32=1.0-R12;var phi12: f32=0.0;if (iridescenceIOR<outsideIOR) {phi12=PI;}\nvar phi21: f32=PI-phi12;var baseIOR: vec3f=getIORTfromAirToSurfaceR0(clamp(baseF0,vec3f(0.0),vec3f(0.9999))); \nvar R1: vec3f=getR0fromIORsVec3(baseIOR,iridescenceIOR);var R23: vec3f=fresnelSchlickGGXVec3(cosTheta2,R1, vec3f(1.));var phi23: vec3f= vec3f(0.0);if (baseIOR[0]<iridescenceIOR) {phi23[0]=PI;}\nif (baseIOR[1]<iridescenceIOR) {phi23[1]=PI;}\nif (baseIOR[2]<iridescenceIOR) {phi23[2]=PI;}\nvar opd: f32=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;var phi: vec3f= vec3f(phi21)+phi23;var R123: vec3f=clamp(R12*R23,vec3f(1e-5),vec3f(0.9999));var r123: vec3f=sqrt(R123);var Rs: vec3f=(T121*T121)*R23/( vec3f(1.0)-R123);var C0: vec3f=R12+Rs;I=C0;var Cm: vec3f=Rs-T121;for (var m: i32=1; m<=2; m++)\n{Cm*=r123;var Sm: vec3f=2.0*evalSensitivity( f32(m)*opd, f32(m)*phi);I+=Cm*Sm;}\nreturn max(I, vec3f(0.0));}\n#endif\nfn normalDistributionFunction_TrowbridgeReitzGGX(NdotH: f32,alphaG: f32)->f32\n{var a2: f32=alphaG*alphaG;var d: f32=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}\n#ifdef SHEEN\nfn normalDistributionFunction_CharlieSheen(NdotH: f32,alphaG: f32)->f32\n{var invR: f32=1./alphaG;var cos2h: f32=NdotH*NdotH;var sin2h: f32=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}\n#endif\n#ifdef ANISOTROPIC\nfn normalDistributionFunction_BurleyGGX_Anisotropic(NdotH: f32,TdotH: f32,BdotH: f32,alphaTB: vec2f)->f32 {var a2: f32=alphaTB.x*alphaTB.y;var v: vec3f= vec3f(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);var v2: f32=dot(v,v);var w2: f32=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfn smithVisibility_GGXCorrelated(NdotL: f32,NdotV: f32,alphaG: f32)->f32 {\n#ifdef MOBILE\nvar GGXV: f32=NdotL*(NdotV*(1.0-alphaG)+alphaG);var GGXL: f32=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);\n#else\nvar a2: f32=alphaG*alphaG;var GGXV: f32=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);var GGXL: f32=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfn smithVisibilityG1_TrowbridgeReitzGGXFast(dot: f32,alphaG: f32)->f32\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nvar alphaSquared: f32=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfn smithVisibility_TrowbridgeReitzGGXFast(NdotL: f32,NdotV: f32,alphaG: f32)->f32\n{var visibility: f32=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}\n#endif\n#ifdef ANISOTROPIC\nfn smithVisibility_GGXCorrelated_Anisotropic(NdotL: f32,NdotV: f32,TdotV: f32,BdotV: f32,TdotL: f32,BdotL: f32,alphaTB: vec2f)->f32 {var lambdaV: f32=NdotL*length( vec3f(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));var lambdaL: f32=NdotV*length( vec3f(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));var v: f32=0.5/(lambdaV+lambdaL);return v;}\n#endif\n#ifdef CLEARCOAT\nfn visibility_Kelemen(VdotH: f32)->f32 {return 0.25/(VdotH*VdotH); }\n#endif\n#ifdef SHEEN\nfn visibility_Ashikhmin(NdotL: f32,NdotV: f32)->f32\n{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfn l(x: f32,alphaG: f32)->f32\n{var oneMinusAlphaSq: f32=(1.0-alphaG)*(1.0-alphaG);var a: f32=mix(21.5473,25.3245,oneMinusAlphaSq);var b: f32=mix(3.82987,3.32435,oneMinusAlphaSq);var c: f32=mix(0.19823,0.16801,oneMinusAlphaSq);var d: f32=mix(-1.97760,-1.27393,oneMinusAlphaSq);var e: f32=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}\nfn lambdaSheen(cosTheta: f32,alphaG: f32)->f32\n{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}\nfn visibility_CharlieSheen(NdotL: f32,NdotV: f32,alphaG: f32)->f32\n{var G: f32=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}\n#endif\n*/\n#endif\nfn diffuseBRDF_Burley(NdotL: f32,NdotV: f32,VdotH: f32,roughness: f32)->f32 {var diffuseFresnelNV: f32=pow5(saturateEps(1.0-NdotL));var diffuseFresnelNL: f32=pow5(saturateEps(1.0-NdotV));var diffuseFresnel90: f32=0.5+2.0*VdotH*VdotH*roughness;var fresnel: f32 =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}\n#ifdef SS_TRANSLUCENCY\nfn transmittanceBRDF_Burley(tintColor: vec3f,diffusionDistance: vec3f,thickness: f32)->vec3f {var S: vec3f=1./maxEpsVec3(diffusionDistance);var temp: vec3f=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}\nfn computeWrappedDiffuseNdotL(NdotL: f32,w: f32)->f32 {var t: f32=1.0+w;var invt2: f32=1.0/(t*t);return saturate((NdotL+w)*invt2);}\n#endif\n"
			}
		}),
		Do = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/hdrFilteringFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.hdrFilteringFunctions = "#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\nfn radicalInverse_VdC(value: u32)->f32 \n{var bits=(value<<16u) | (value>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return f32(bits)*2.3283064365386963e-10; }\nfn hammersley(i: u32,N: u32)->vec2f\n{return vec2f( f32(i)/ f32(N),radicalInverse_VdC(i));}\nfn log4(x: f32)->f32 {return log2(x)/2.;}\nconst NUM_SAMPLES_FLOAT: f32= f32(NUM_SAMPLES);const NUM_SAMPLES_FLOAT_INVERSED: f32=1./NUM_SAMPLES_FLOAT;const K: f32=4.;fn irradiance(inputTexture: texture_cube<f32>,inputSampler: sampler,inputN: vec3f,filteringInfo: vec2f)->vec3f\n{var n: vec3f=normalize(inputN);var result: vec3f= vec3f(0.0);var tangent: vec3f=select(vec3f(1.,0.,0.),vec3f(0.,0.,1.),abs(n.z)<0.999);tangent=normalize(cross(tangent,n));var bitangent: vec3f=cross(n,tangent);var tbn: mat3x3f= mat3x3f(tangent,bitangent,n);var maxLevel: f32=filteringInfo.y;var dim0: f32=filteringInfo.x;var omegaP: f32=(4.*PI)/(6.*dim0*dim0);for(var i: u32=0u; i<NUM_SAMPLES; i++)\n{var Xi: vec2f=hammersley(i,NUM_SAMPLES);var Ls: vec3f=hemisphereCosSample(Xi);Ls=normalize(Ls);var Ns: vec3f= vec3f(0.,0.,1.);var NoL: f32=dot(Ns,Ls);if (NoL>0.) {var pdf_inversed: f32=PI/NoL;var omegaS: f32=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;var l: f32=log4(omegaS)-log4(omegaP)+log4(K);var mipLevel: f32=clamp(l,0.0,maxLevel);var c: vec3f=textureSampleLevel(inputTexture,inputSampler,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpaceVec3(c);\n#endif\nresult+=c;}}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}\nfn radiance(alphaG: f32,inputTexture: texture_cube<f32>,inputSampler: sampler,inputN: vec3f,filteringInfo: vec2f)->vec3f\n{var n: vec3f=normalize(inputN);var c: vec3f=textureSample(inputTexture,inputSampler,n).rgb; \nif (alphaG==0.) {\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;} else {var result: vec3f= vec3f(0.);var tangent: vec3f=select(vec3f(1.,0.,0.),vec3f(0.,0.,1.),abs(n.z)<0.999);tangent=normalize(cross(tangent,n));var bitangent: vec3f=cross(n,tangent);var tbn: mat3x3f= mat3x3f(tangent,bitangent,n);var maxLevel: f32=filteringInfo.y;var dim0: f32=filteringInfo.x;var omegaP: f32=(4.*PI)/(6.*dim0*dim0);var weight: f32=0.;for(var i: u32=0u; i<NUM_SAMPLES; i++)\n{var Xi: vec2f=hammersley(i,NUM_SAMPLES);var H: vec3f=hemisphereImportanceSampleDggx(Xi,alphaG);var NoV: f32=1.;var NoH: f32=H.z;var NoH2: f32=H.z*H.z;var NoL: f32=2.*NoH2-1.;var L: vec3f= vec3f(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {var pdf_inversed: f32=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);var omegaS: f32=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;var l: f32=log4(omegaS)-log4(omegaP)+log4(K);var mipLevel: f32=clamp( f32(l),0.0,maxLevel);weight+=NoL;var c: vec3f=textureSampleLevel(inputTexture,inputSampler,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;}}\nresult=result/weight;return result;}}\n#endif\n#endif\n"
			}
		}),
		Oo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrDirectLightingFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrDirectLightingFunctions = "#define CLEARCOATREFLECTANCE90 1.0\nstruct lightingInfo\n{diffuse: vec3f,\n#ifdef SPECULARTERM\nspecular: vec3f,\n#endif\n#ifdef CLEARCOAT\nclearCoat: vec4f,\n#endif\n#ifdef SHEEN\nsheen: vec3f\n#endif\n};fn adjustRoughnessFromLightProperties(roughness: f32,lightRadius: f32,lightDistance: f32)->f32 {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\nvar lightRoughness: f32=lightRadius/lightDistance;var totalRoughness: f32=saturate(lightRoughness+roughness);return totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nfn computeHemisphericDiffuseLighting(info: preLightingInfo,lightColor: vec3f,groundColor: vec3f)->vec3f {return mix(groundColor,lightColor,info.NdotL);}\nfn computeDiffuseLighting(info: preLightingInfo,lightColor: vec3f)->vec3f {var diffuseTerm: f32=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}\nfn computeProjectionTextureDiffuseLighting(projectionLightTexture: texture_2d<f32>,projectionLightSampler: sampler,textureProjectionMatrix: mat4x4f,posW: vec3f)->vec3f{var strq: vec4f=textureProjectionMatrix* vec4f(posW,1.0);strq/=strq.w;var textureColor: vec3f=textureSample(projectionLightTexture,projectionLightSampler,strq.xy).rgb;return toLinearSpaceVec3(textureColor);}\n#ifdef SS_TRANSLUCENCY\nfn computeDiffuseAndTransmittedLighting(info: preLightingInfo,lightColor: vec3f,transmittance: vec3f)->vec3f {var NdotL: f32=absEps(info.NdotLUnclamped);var wrapNdotL: f32=computeWrappedDiffuseNdotL(NdotL,0.02);var trAdapt: f32=step(0.,info.NdotLUnclamped);var transmittanceNdotL: vec3f=mix(transmittance*wrapNdotL, vec3f(wrapNdotL),trAdapt);var diffuseTerm: f32=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}\n#endif\n#ifdef SPECULARTERM\nfn computeSpecularLighting(info: preLightingInfo,N: vec3f,reflectance0: vec3f,reflectance90: vec3f,geometricRoughnessFactor: f32,lightColor: vec3f)->vec3f {var NdotH: f32=saturateEps(dot(N,info.H));var roughness: f32=max(info.roughness,geometricRoughnessFactor);var alphaG: f32=convertRoughnessToAverageSlope(roughness);var fresnel: vec3f=fresnelSchlickGGXVec3(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nvar distribution: f32=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvar smithVisibility: f32=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nvar smithVisibility: f32=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvar specTerm: vec3f=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef ANISOTROPIC\nfn computeAnisotropicSpecularLighting(info: preLightingInfo,V: vec3f,N: vec3f,T: vec3f,B: vec3f,anisotropy: f32,reflectance0: vec3f,reflectance90: vec3f,geometricRoughnessFactor: f32,lightColor: vec3f)->vec3f {var NdotH: f32=saturateEps(dot(N,info.H));var TdotH: f32=dot(T,info.H);var BdotH: f32=dot(B,info.H);var TdotV: f32=dot(T,V);var BdotV: f32=dot(B,V);var TdotL: f32=dot(T,info.L);var BdotL: f32=dot(B,info.L);var alphaG: f32=convertRoughnessToAverageSlope(info.roughness);var alphaTB: vec2f=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,vec2f(geometricRoughnessFactor*geometricRoughnessFactor));var fresnel: vec3f=fresnelSchlickGGXVec3(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nvar distribution: f32=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);var smithVisibility: f32=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);var specTerm: vec3f=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef CLEARCOAT\nfn computeClearCoatLighting(info: preLightingInfo,Ncc: vec3f,geometricRoughnessFactor: f32,clearCoatIntensity: f32,lightColor: vec3f)->vec4f {var NccdotL: f32=saturateEps(dot(Ncc,info.L));var NccdotH: f32=saturateEps(dot(Ncc,info.H));var clearCoatRoughness: f32=max(info.roughness,geometricRoughnessFactor);var alphaG: f32=convertRoughnessToAverageSlope(clearCoatRoughness);var fresnel: f32=fresnelSchlickGGX(info.VdotH,uniforms.vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;var distribution: f32=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);var kelemenVisibility: f32=visibility_Kelemen(info.VdotH);var clearCoatTerm: f32=fresnel*distribution*kelemenVisibility;return vec4f(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);}\nfn computeClearCoatLightingAbsorption(NdotVRefract: f32,L: vec3f,Ncc: vec3f,clearCoatColor: vec3f,clearCoatThickness: f32,clearCoatIntensity: f32)->vec3f {var LRefract: vec3f=-refract(L,Ncc,uniforms.vClearCoatRefractionParams.y);var NdotLRefract: f32=saturateEps(dot(Ncc,LRefract));var absorption: vec3f=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}\n#endif\n#ifdef SHEEN\nfn computeSheenLighting(info: preLightingInfo,N: vec3f,reflectance0: vec3f,reflectance90: vec3f,geometricRoughnessFactor: f32,lightColor: vec3f)->vec3f {var NdotH: f32=saturateEps(dot(N,info.H));var roughness: f32=max(info.roughness,geometricRoughnessFactor);var alphaG: f32=convertRoughnessToAverageSlope(roughness);var fresnel: f32=1.;var distribution: f32=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER\nvar visibility: f32=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\n#else */\nvar visibility: f32=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */\nvar sheenTerm: f32=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n"
			}
		}),
		Fo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrIBLFunctions.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrIBLFunctions = "#if defined(REFLECTION) || defined(SS_REFRACTION)\nfn getLodFromAlphaG(cubeMapDimensionPixels: f32,microsurfaceAverageSlope: f32)->f32 {var microsurfaceAverageSlopeTexels: f32=cubeMapDimensionPixels*microsurfaceAverageSlope;var lod: f32=log2(microsurfaceAverageSlopeTexels);return lod;}\nfn getLinearLodFromRoughness(cubeMapDimensionPixels: f32,roughness: f32)->f32 {var lod: f32=log2(cubeMapDimensionPixels)*roughness;return lod;}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfn environmentRadianceOcclusion(ambientOcclusion: f32,NdotVUnclamped: f32)->f32 {var temp: f32=NdotVUnclamped+ambientOcclusion;return saturate(temp*temp-1.0+ambientOcclusion);}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfn environmentHorizonOcclusion(view: vec3f,normal: vec3f,geometricNormal: vec3f)->f32 {var reflection: vec3f=reflect(view,normal);var temp: f32=saturate(1.0+1.1*dot(reflection,geometricNormal));return temp*temp;}\n#endif\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\nfn UNPACK_LOD(x: f32)->f32 {return (1.0-x)*255.0;}\nfn getLodFromAlphaGNdotV(cubeMapDimensionPixels: f32,alphaG: f32,NdotV: f32)->f32 {var microsurfaceAverageSlope: f32=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}\n#endif\n"
			}
		}),
		Lo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockAlbedoOpacity.js"() {
				h(), Gn(), e.IncludesShadersStoreWGSL.pbrBlockAlbedoOpacity = "struct albedoOpacityOutParams\n{surfaceAlbedo: vec3f,\nalpha: f32};\n#define pbr_inline\nfn albedoOpacityBlock(\nvAlbedoColor: vec4f\n#ifdef ALBEDO\n,albedoTexture: vec4f\n,albedoInfos: vec2f\n#endif\n#ifdef OPACITY\n,opacityMap: vec4f\n,vOpacityInfos: vec2f\n#endif\n#ifdef DETAIL\n,detailColor: vec4f\n,vDetailInfos: vec4f\n#endif\n#ifdef DECAL\n,decalColor: vec4f\n,vDecalInfos: vec4f\n#endif\n)->albedoOpacityOutParams\n{var outParams: albedoOpacityOutParams;var surfaceAlbedo: vec3f=vAlbedoColor.rgb;var alpha: f32=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpaceVec3(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#ifndef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nsurfaceAlbedo*=fragmentInputs.vColor.rgb;\n#endif\n#ifdef DETAIL\nvar detailAlbedo: f32=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \n#endif\n#ifdef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=fragmentInputs.vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST \n#if DEBUGMODE != 88\nif (alpha<ALPHATESTVALUE) {discard;}\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;return outParams;}\n"
			}
		}),
		Bo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockReflectivity.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockReflectivity = "struct reflectivityOutParams\n{microSurface: f32,\nroughness: f32,\nsurfaceReflectivityColor: vec3f,\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo: vec3f,\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nambientOcclusionColor: vec3f,\n#endif\n#if DEBUGMODE>0\n#ifdef METALLICWORKFLOW\nmetallicRoughness: vec2f,\n#ifdef REFLECTIVITY\nsurfaceMetallicColorMap: vec4f,\n#endif\n#ifndef FROSTBITE_REFLECTANCE\nmetallicF0: vec3f,\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColorMap: vec4f,\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nfn reflectivityBlock(\nvReflectivityColor: vec4f\n#ifdef METALLICWORKFLOW\n,surfaceAlbedo: vec3f\n,metallicReflectanceFactors: vec4f\n#endif\n#ifdef REFLECTIVITY\n,reflectivityInfos: vec3f\n,surfaceMetallicOrReflectivityColorMap: vec4f\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n,ambientOcclusionColorIn: vec3f\n#endif\n#ifdef MICROSURFACEMAP\n,microSurfaceTexel: vec4f\n#endif\n#ifdef DETAIL\n,detailColor: vec4f\n,vDetailInfos: vec4f\n#endif\n)->reflectivityOutParams\n{var outParams: reflectivityOutParams;var microSurface: f32=vReflectivityColor.a;var surfaceReflectivityColor: vec3f=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvar metallicRoughness: vec2f=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvar aoStoreInMetalMap: vec3f= vec3f(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nvar detailRoughness: f32=mix(0.5,detailColor.b,vDetailInfos.w);var loLerp: f32=mix(0.,metallicRoughness.g,detailRoughness*2.);var hiLerp: f32=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;var baseColor: vec3f=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvar metallicF0: vec3f=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0), vec3f(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);var roughness: f32=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;return outParams;}\n"
			}
		}),
		Go = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockAmbientOcclusion.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockAmbientOcclusion = "struct ambientOcclusionOutParams\n{ambientOcclusionColor: vec3f,\n#if DEBUGMODE>0 && defined(AMBIENT)\nambientOcclusionColorMap: vec3f\n#endif\n};\n#define pbr_inline\nfn ambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap_: vec3f,\nvAmbientInfos: vec4f\n#endif\n)->ambientOcclusionOutParams\n{ \nvar outParams: ambientOcclusionOutParams;var ambientOcclusionColor: vec3f= vec3f(1.,1.,1.);\n#ifdef AMBIENT\nvar ambientOcclusionColorMap: vec3f=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap= vec3f(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;return outParams;}\n"
			}
		}),
		Ho = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockAlphaFresnel.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockAlphaFresnel = "#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{alpha: f32};fn faceforward(N: vec3<f32>,I: vec3<f32>,Nref: vec3<f32>)->vec3<f32> {return select(N,-N,dot(Nref,I)>0.0);}\n#define pbr_inline\nfn alphaFresnelBlock(\nnormalW: vec3f,\nviewDirectionW: vec3f,\nalpha: f32,\nmicroSurface: f32\n)->alphaFresnelOutParams\n{var outParams: alphaFresnelOutParams;var opacityPerceptual: f32=alpha;\n#ifdef LINEARALPHAFRESNEL\nvar opacity0: f32=opacityPerceptual;\n#else\nvar opacity0: f32=opacityPerceptual*opacityPerceptual;\n#endif\nvar opacity90: f32=fresnelGrazingReflectance(opacity0);var normalForward: vec3f=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)), vec3f(opacity0), vec3f(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE) {discard;}\n#ifndef ALPHABLEND\noutParams.alpha=1.0;\n#endif\n#endif\nreturn outParams;}\n#endif\n#endif\n"
			}
		}),
		Uo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockAnisotropic.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockAnisotropic = "#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{anisotropy: f32,\nanisotropicTangent: vec3f,\nanisotropicBitangent: vec3f,\nanisotropicNormal: vec3f,\n#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)\nanisotropyMapData: vec3f\n#endif\n};\n#define pbr_inline\nfn anisotropicBlock(\nvAnisotropy: vec3f,\nroughness: f32,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData: vec3f,\n#endif\nTBN: mat3x3f,\nnormalW: vec3f,\nviewDirectionW: vec3f\n)->anisotropicOutParams\n{ \nvar outParams: anisotropicOutParams;var anisotropy: f32=vAnisotropy.b;var anisotropyDirection: vec3f= vec3f(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nvar amd=anisotropyMapData.rg;anisotropy*=anisotropyMapData.b;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\namd=amd*2.0-1.0;\n#ifdef ANISOTROPIC_LEGACY\nanisotropyDirection=vec3f(anisotropyDirection.xy*amd,anisotropyDirection.z);\n#else\nanisotropyDirection=vec3f(mat2x2f(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(amd),anisotropyDirection.z);\n#endif\n#endif\nvar anisoTBN: mat3x3f= mat3x3f(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));var anisotropicTangent: vec3f=normalize(anisoTBN*anisotropyDirection);var anisotropicBitangent: vec3f=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);return outParams;}\n#endif\n"
			}
		}),
		Vo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockReflection.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockReflection = "#ifdef REFLECTION\nstruct reflectionOutParams\n{environmentRadiance: vec4f\n,environmentIrradiance: vec3f\n#ifdef REFLECTIONMAP_3D\n,reflectionCoords: vec3f\n#else\n,reflectionCoords: vec2f\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,irradianceVector: vec3f\n#endif\n#endif\n#endif\n};\n#define pbr_inline\n#ifdef REFLECTIONMAP_3D\nfn createReflectionCoords(\nvPositionW: vec3f,\nnormalW: vec3f,\n#ifdef ANISOTROPIC\nanisotropicOut: anisotropicOutParams,\n#endif\n)->vec3f\n{var reflectionCoords: vec3f;\n#else\nfn createReflectionCoords(\nvPositionW: vec3f,\nnormalW: vec3f,\n#ifdef ANISOTROPIC\nanisotropicOut: anisotropicOutParams,\n#endif\n)->vec2f\n{ \nvar reflectionCoords: vec2f;\n#endif\n#ifdef ANISOTROPIC\nvar reflectionVector: vec3f=computeReflectionCoords( vec4f(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvar reflectionVector: vec3f=computeReflectionCoords( vec4f(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\nreturn reflectionCoords;}\n#define pbr_inline\nfn sampleReflectionTexture(\nalphaG: f32\n,vReflectionMicrosurfaceInfos: vec3f\n,vReflectionInfos: vec2f\n,vReflectionColor: vec3f\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped: f32\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness: f32\n#endif\n#ifdef REFLECTIONMAP_3D\n,reflectionSampler: texture_cube<f32>\n,reflectionSamplerSampler: sampler\n,reflectionCoords: vec3f\n#else\n,reflectionSampler: texture_2d<f32>\n,reflectionSamplerSampler: sampler\n,reflectionCoords: vec2f\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,reflectionLowSampler: texture_cube<f32>\n,reflectionLowSamplerSampler: sampler\n,reflectionHighSampler: texture_cube<f32>\n,reflectionHighSamplerSampler: sampler\n#else\n,reflectionLowSampler: texture_2d<f32>\n,reflectionLowSamplerSampler: sampler\n,reflectionHighSampler: texture_2d<f32>\n,reflectionHighSamplerSampler: sampler\n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo: vec2f\n#endif \n)->vec4f\n{var environmentRadiance: vec4f;\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nvar reflectionLOD: f32=getLodFromAlphaGNdotV(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nvar reflectionLOD: f32=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nvar reflectionLOD: f32=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\nvar automaticReflectionLOD: f32=UNPACK_LOD(textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords).a);var requestedReflectionLOD: f32=max(automaticReflectionLOD,reflectionLOD);\n#else\nvar requestedReflectionLOD: f32=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance= vec4f(radiance(alphaG,reflectionSampler,reflectionSamplerSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=textureSampleLevel(reflectionSampler,reflectionSamplerSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nvar lodReflectionNormalized: f32=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));var lodReflectionNormalizedDoubled: f32=lodReflectionNormalized*2.0;var environmentMid: vec4f=textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(\ntextureSample(reflectionHighSampler,reflectionHighSamplerSampler,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);} else {environmentRadiance=mix(\nenvironmentMid,\ntextureSample(reflectionLowSampler,reflectionLowSamplerSampler,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\nvar envRadiance=environmentRadiance.rgb;\n#ifdef RGBDREFLECTION\nenvRadiance=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvRadiance=toLinearSpaceVec3(environmentRadiance.rgb);\n#endif\nenvRadiance*=vReflectionInfos.x;envRadiance*=vReflectionColor.rgb;return vec4f(envRadiance,environmentRadiance.a);}\n#define pbr_inline\nfn reflectionBlock(\nvPositionW: vec3f\n,normalW: vec3f\n,alphaG: f32\n,vReflectionMicrosurfaceInfos: vec3f\n,vReflectionInfos: vec2f\n,vReflectionColor: vec3f\n#ifdef ANISOTROPIC\n,anisotropicOut: anisotropicOutParams\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped: f32\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness: f32\n#endif\n#ifdef REFLECTIONMAP_3D\n,reflectionSampler: texture_cube<f32>\n,reflectionSamplerSampler: sampler\n#else\n,reflectionSampler: texture_2d<f32>\n,reflectionSamplerSampler: sampler\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n,vEnvironmentIrradiance: vec3f\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,reflectionMatrix: mat4x4f\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\n,irradianceSampler: texture_cube<f32>\n,irradianceSamplerSampler: sampler \n#else\n,irradianceSampler: texture_2d<f32>\n,irradianceSamplerSampler: sampler \n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,reflectionLowSampler: texture_cube<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_cube<f32>\n,reflectionHighSamplerSampler: sampler \n#else\n,reflectionLowSampler: texture_2d<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_2d<f32>\n,reflectionHighSamplerSampler: sampler \n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo: vec2f\n#endif\n)->reflectionOutParams\n{var outParams: reflectionOutParams;var environmentRadiance: vec4f= vec4f(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvar reflectionCoords: vec3f= vec3f(0.);\n#else\nvar reflectionCoords: vec2f= vec2f(0.);\n#endif\nreflectionCoords=createReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif \n);environmentRadiance=sampleReflectionTexture(\nalphaG\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness\n#endif\n#ifdef REFLECTIONMAP_3D\n,reflectionSampler\n,reflectionSamplerSampler\n,reflectionCoords\n#else\n,reflectionSampler\n,reflectionSamplerSampler\n,reflectionCoords\n#endif\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif \n);var environmentIrradiance: vec3f= vec3f(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvar irradianceVector: vec3f= (reflectionMatrix* vec4f(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvar irradianceVector: vec3f= (reflectionMatrix* vec4f(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,reflectionSamplerSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvar environmentIrradiance4: vec4f=textureSample(irradianceSampler,irradianceSamplerSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance=toLinearSpaceVec3(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;return outParams;}\n#endif\n"
			}
		}),
		Wo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockSheen.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockSheen = "#ifdef SHEEN\nstruct sheenOutParams\n{sheenIntensity: f32\n,sheenColor: vec3f\n,sheenRoughness: f32\n#ifdef SHEEN_LINKWITHALBEDO\n,surfaceAlbedo: vec3f\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\n,sheenAlbedoScaling: f32\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,finalSheenRadianceScaled: vec3f\n#endif\n#if DEBUGMODE>0\n#ifdef SHEEN_TEXTURE\n,sheenMapData: vec4f\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,sheenEnvironmentReflectance: vec3f\n#endif\n#endif\n};\n#define pbr_inline\nfn sheenBlock(\nvSheenColor: vec4f\n#ifdef SHEEN_ROUGHNESS\n,vSheenRoughness: f32\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,sheenMapRoughnessData: vec4f\n#endif\n#endif\n,roughness: f32\n#ifdef SHEEN_TEXTURE\n,sheenMapData: vec4f\n,sheenMapLevel: f32\n#endif\n,reflectance: f32\n#ifdef SHEEN_LINKWITHALBEDO\n,baseColor: vec3f\n,surfaceAlbedo: vec3f\n#endif\n#ifdef ENVIRONMENTBRDF\n,NdotV: f32\n,environmentBrdf: vec3f\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,AARoughnessFactors: vec2f\n,vReflectionMicrosurfaceInfos: vec3f\n,vReflectionInfos: vec2f\n,vReflectionColor: vec3f\n,vLightingIntensity: vec4f\n#ifdef REFLECTIONMAP_3D\n,reflectionSampler: texture_cube<f32>\n,reflectionSamplerSampler: sampler\n,reflectionCoords: vec3f\n#else\n,reflectionSampler: texture_2d<f32>\n,reflectionSamplerSampler: sampler\n,reflectionCoords: vec2f\n#endif\n,NdotVUnclamped: f32\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,reflectionLowSampler: texture_cube<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_cube<f32>\n,reflectionHighSamplerSampler: sampler \n#else\n,reflectionLowSampler: texture_2d<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_2d<f32>\n,reflectionHighSamplerSampler: sampler \n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo: vec2f\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\n,seo: f32\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\n,eho: f32\n#endif\n#endif\n)->sheenOutParams\n{var outParams: sheenOutParams;var sheenIntensity: f32=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nvar sheenFactor: f32=pow5(1.0-sheenIntensity);var sheenColor: vec3f=baseColor.rgb*(1.0-sheenFactor);var sheenRoughness: f32=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvar sheenColor: vec3f=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor*=toLinearSpaceVec3(sheenMapData.rgb);\n#else\nsheenColor*=sheenMapData.rgb;\n#endif\nsheenColor*=sheenMapLevel;\n#endif\n#ifdef SHEEN_ROUGHNESS\nvar sheenRoughness: f32=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#else\nvar sheenRoughness: f32=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\nsheenColor*=sheenIntensity;\n#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\nvar environmentSheenBrdf: vec3f= vec3f(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\n#else*/\n#ifdef SHEEN_ROUGHNESS\nvar environmentSheenBrdf: vec3f=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvar environmentSheenBrdf: vec3f=environmentBrdf;\n#endif\n/*#endif*/\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvar sheenAlphaG: f32=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvar environmentSheenRadiance: vec4f= vec4f(0.,0.,0.,0.);environmentSheenRadiance=sampleReflectionTexture(\nsheenAlphaG\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,sheenRoughness\n#endif\n,reflectionSampler\n,reflectionSamplerSampler\n,reflectionCoords\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif\n);var sheenEnvironmentReflectance: vec3f=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\noutParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;return outParams;}\n#endif\n"
			}
		}),
		zo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockClearcoat.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockClearcoat = "struct clearcoatOutParams\n{specularEnvironmentR0: vec3f,\nconservationFactor: f32,\nclearCoatNormalW: vec3f,\nclearCoatAARoughnessFactors: vec2f,\nclearCoatIntensity: f32,\nclearCoatRoughness: f32,\n#ifdef REFLECTION\nfinalClearCoatRadianceScaled: vec3f,\n#endif\n#ifdef CLEARCOAT_TINT\nabsorption: vec3f,\nclearCoatNdotVRefract: f32,\nclearCoatColor: vec3f,\nclearCoatThickness: f32,\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nenergyConservationFactorClearCoat: vec3f,\n#endif\n#if DEBUGMODE>0\n#ifdef CLEARCOAT_BUMP\nTBNClearCoat: mat3x3f,\n#endif\n#ifdef CLEARCOAT_TEXTURE\nclearCoatMapData: vec2f,\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nclearCoatTintMapData: vec4f,\n#endif\n#ifdef REFLECTION\nenvironmentClearCoatRadiance: vec4f,\nclearCoatEnvironmentReflectance: vec3f,\n#endif\nclearCoatNdotV: f32\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\nfn clearcoatBlock(\nvPositionW: vec3f\n,geometricNormalW: vec3f\n,viewDirectionW: vec3f\n,vClearCoatParams: vec2f\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,clearCoatMapRoughnessData: vec4f\n#endif\n,specularEnvironmentR0: vec3f\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData: vec2f\n#endif\n#ifdef CLEARCOAT_TINT\n,vClearCoatTintParams: vec4f\n,clearCoatColorAtDistance: f32\n,vClearCoatRefractionParams: vec4f\n#ifdef CLEARCOAT_TINT_TEXTURE\n,clearCoatTintMapData: vec4f\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\n,vClearCoatBumpInfos: vec2f\n,clearCoatBumpMapData: vec4f\n,vClearCoatBumpUV: vec2f\n#if defined(TANGENT) && defined(NORMAL)\n,vTBN: mat3x3f\n#else\n,vClearCoatTangentSpaceParams: vec2f\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n,normalMatrix: mat4x4f\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\n,faceNormal: vec3f\n#endif\n#ifdef REFLECTION\n,vReflectionMicrosurfaceInfos: vec3f\n,vReflectionInfos: vec2f\n,vReflectionColor: vec3f\n,vLightingIntensity: vec4f\n#ifdef REFLECTIONMAP_3D\n,reflectionSampler: texture_cube<f32>\n,reflectionSamplerSampler: sampler\n#else\n,reflectionSampler: texture_2d<f32>\n,reflectionSamplerSampler: sampler\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,reflectionLowSampler: texture_cube<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_cube<f32>\n,reflectionHighSamplerSampler: sampler \n#else\n,reflectionLowSampler: texture_2d<f32>\n,reflectionLowSamplerSampler: sampler \n,reflectionHighSampler: texture_2d<f32>\n,reflectionHighSamplerSampler: sampler \n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo: vec2f\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n,ambientMonochrome: f32\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n,frontFacingMultiplier: f32\n#endif \n)->clearcoatOutParams\n{var outParams: clearcoatOutParams;var clearCoatIntensity: f32=vClearCoatParams.x;var clearCoatRoughness: f32=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvar clearCoatColor: vec3f=vClearCoatTintParams.rgb;var clearCoatThickness: f32=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpaceVec3(clearCoatTintMapData.rgb);\n#else\nclearCoatColor*=clearCoatTintMapData.rgb;\n#endif\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;\n#endif\n#ifdef CLEARCOAT_REMAP_F0\nvar specularEnvironmentR0Updated: vec3f=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvar specularEnvironmentR0Updated: vec3f=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);var clearCoatNormalW: vec3f=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nvar clearCoatNormalScale: f32=1.0;\n#else\nvar clearCoatNormalScale: f32=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nvar TBNClearCoat: mat3x3f=vTBN;\n#else\nvar TBNClearCoatUV: vec2f=vClearCoatBumpUV*frontFacingMultiplier;var TBNClearCoat: mat3x3f=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize( mat3x3f(normalMatrix[0].xyz,normalMatrix[1].xyz,normalMatrix[2].xyz)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);var clearCoatNdotVUnclamped: f32=dot(clearCoatNormalW,viewDirectionW);var clearCoatNdotV: f32=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\nvar clearCoatVRefract: vec3f=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvar environmentClearCoatBrdf: vec3f=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n#if defined(REFLECTION)\nvar clearCoatAlphaG: f32=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvar environmentClearCoatRadiance: vec4f= vec4f(0.,0.,0.,0.);var clearCoatReflectionVector: vec3f=computeReflectionCoords( vec4f(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvar clearCoatReflectionCoords: vec3f=clearCoatReflectionVector;\n#else\nvar clearCoatReflectionCoords: vec2f=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nenvironmentClearCoatRadiance=sampleReflectionTexture(\nclearCoatAlphaG\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,clearCoatNdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,clearCoatRoughness\n#endif\n,reflectionSampler\n,reflectionSamplerSampler\n,clearCoatReflectionCoords\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif \n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvar clearCoatEnvironmentReflectance: vec3f=getReflectanceFromBRDFLookup(vec3f(uniforms.vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nvar clearCoatEho: f32=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\nvar clearCoatEnvironmentReflectance: vec3f=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV, vec3f(1.), vec3f(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\nvar fresnelIBLClearCoat: f32=fresnelSchlickGGX(clearCoatNdotV,uniforms.vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\nreturn outParams;}\n#endif\n"
			}
		}),
		Xo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockIridescence.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockIridescence = "struct iridescenceOutParams\n{iridescenceIntensity: f32,\niridescenceIOR: f32,\niridescenceThickness: f32,\nspecularEnvironmentR0: vec3f};\n#ifdef IRIDESCENCE\nfn iridescenceBlock(\nvIridescenceParams: vec4f\n,viewAngle: f32\n,specularEnvironmentR0: vec3f\n#ifdef IRIDESCENCE_TEXTURE\n,iridescenceMapData: vec2f\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\n,iridescenceThicknessMapData: vec2f\n#endif\n#ifdef CLEARCOAT\n,NdotVUnclamped: f32\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData: vec2f\n#endif\n#endif\n)->iridescenceOutParams\n{var outParams: iridescenceOutParams;var iridescenceIntensity: f32=vIridescenceParams.x;var iridescenceIOR: f32=vIridescenceParams.y;var iridescenceThicknessMin: f32=vIridescenceParams.z;var iridescenceThicknessMax: f32=vIridescenceParams.w;var iridescenceThicknessWeight: f32=1.;\n#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\n#endif\nvar iridescenceThickness: f32=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);var topIor: f32=1.; \n#ifdef CLEARCOAT\nvar clearCoatIntensity: f32=vClearCoatParams.x;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#endif\ntopIor=mix(1.0,uniforms.vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+((1.0/topIor)*(1.0/topIor))*((NdotVUnclamped*NdotVUnclamped)-1.0));\n#endif\nvar iridescenceFresnel: vec3f=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;return outParams;}\n#endif\n"
			}
		}),
		Yo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockSubSurface.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockSubSurface = "struct subSurfaceOutParams\n{specularEnvironmentReflectance: vec3f,\n#ifdef SS_REFRACTION\nfinalRefraction: vec3f,\nsurfaceAlbedo: vec3f,\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha: f32,\n#endif\n#ifdef REFLECTION\nrefractionFactorForIrradiance: f32,\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\ntransmittance: vec3f,\ntranslucencyIntensity: f32,\n#ifdef REFLECTION\nrefractionIrradiance: vec3f,\n#endif\n#endif\n#if DEBUGMODE>0\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nthicknessMap: vec4f,\n#endif\n#ifdef SS_REFRACTION\nenvironmentRefraction: vec4f,\nrefractionTransmittance: vec3f\n#endif\n#endif\n};\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#define pbr_inline\nfn sampleEnvironmentRefraction(\nior: f32\n,thickness: f32\n,refractionLOD: f32\n,normalW: vec3f\n,vPositionW: vec3f\n,viewDirectionW: vec3f\n,view: mat4x4f\n,vRefractionInfos: vec4f\n,refractionMatrix: mat4x4f\n,vRefractionMicrosurfaceInfos: vec4f\n,alphaG: f32\n#ifdef SS_REFRACTIONMAP_3D\n,refractionSampler: texture_cube<f32>\n,refractionSamplerSampler: sampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler: texture_cube<f32>\n,refractionLowSamplerSampler: sampler\n,refractionHighSampler: texture_cube<f32>\n,refractionHighSamplerSampler: sampler \n#endif\n#else\n,refractionSampler: texture_2d<f32>\n,refractionSamplerSampler: sampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler: texture_2d<f32>\n,refractionLowSamplerSampler: sampler\n,refractionHighSampler: texture_2d<f32>\n,refractionHighSamplerSampler: sampler \n#endif\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut: anisotropicOutParams\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo: vec2f\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,refractionPosition: vec3f\n,refractionSize: vec3f\n#endif\n)->vec4f {var environmentRefraction: vec4f= vec4f(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvar refractionVector: vec3f=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);\n#else\nvar refractionVector: vec3f=refract(-viewDirectionW,normalW,ior);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;var refractionCoords: vec3f=refractionVector;refractionCoords= (refractionMatrix* vec4f(refractionCoords,0)).xyz;\n#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvar vRefractionUVW: vec3f= (refractionMatrix*(view* vec4f(vPositionW+refractionVector*thickness,1.0))).xyz;\n#else\nvar vRefractionUVW: vec3f= (refractionMatrix*(view* vec4f(vPositionW+refractionVector*vRefractionInfos.z,1.0))).xyz;\n#endif\nvar refractionCoords: vec2f=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef LODBASEDMICROSFURACE\nvar lod=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\nvar automaticRefractionLOD: f32=UNPACK_LOD(textureSample(refractionSampler,refractionSamplerSampler,refractionCoords).a);var requestedRefractionLOD: f32=max(automaticRefractionLOD,lod);\n#else\nvar requestedRefractionLOD: f32=lod;\n#endif\n#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)\nenvironmentRefraction= vec4f(radiance(alphaG,refractionSampler,refractionSamplerSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=textureSampleLevel(refractionSampler,refractionSamplerSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nvar lodRefractionNormalized: f32=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));var lodRefractionNormalizedDoubled: f32=lodRefractionNormalized*2.0;var environmentRefractionMid: vec4f=textureSample(refractionSampler,refractionSamplerSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(\ntextureSample(refractionHighSampler,refractionHighSamplerSampler,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);} else {environmentRefraction=mix(\nenvironmentRefractionMid,\ntextureSample(refractionLowSampler,refractionLowSamplerSampler,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);}\n#endif\nvar refraction=environmentRefraction.rgb;\n#ifdef SS_RGBDREFRACTION\nrefraction=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nrefraction=toLinearSpaceVec3(environmentRefraction.rgb);\n#endif\nreturn vec4f(refraction,environmentRefraction.a);}\n#endif\n#define pbr_inline\nfn subSurfaceBlock(\nvSubSurfaceIntensity: vec3f\n,vThicknessParam: vec2f\n,vTintColor: vec4f\n,normalW: vec3f\n,specularEnvironmentReflectance: vec3f\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n,thicknessMap: vec4f\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n,refractionIntensityMap: vec4f\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\n,translucencyIntensityMap: vec4f\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\n,reflectionMatrix: mat4x4f\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,irradianceVector_: vec3f\n#endif\n#if defined(REALTIME_FILTERING)\n,reflectionSampler: texture_cube<f32>\n,reflectionSamplerSampler: sampler\n,vReflectionFilteringInfo: vec2f\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\n,irradianceSampler: texture_cube<f32>\n,irradianceSamplerSampler: sampler\n#else\n,irradianceSampler: texture_2d<f32>\n,irradianceSamplerSampler: sampler\n#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n,surfaceAlbedo: vec3f\n#endif\n#ifdef SS_REFRACTION\n,vPositionW: vec3f\n,viewDirectionW: vec3f\n,view: mat4x4f\n,vRefractionInfos: vec4f\n,refractionMatrix: mat4x4f\n,vRefractionMicrosurfaceInfos: vec4f\n,vLightingIntensity: vec4f\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n,alpha: f32\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\n,NdotVUnclamped: f32\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\n,roughness: f32\n#endif\n,alphaG: f32\n#ifdef SS_REFRACTIONMAP_3D\n,refractionSampler: texture_cube<f32>\n,refractionSamplerSampler: sampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler: texture_cube<f32>\n,refractionLowSamplerSampler: sampler\n,refractionHighSampler: texture_cube<f32>\n,refractionHighSamplerSampler: sampler \n#endif\n#else\n,refractionSampler: texture_2d<f32>\n,refractionSamplerSampler: sampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler: texture_2d<f32>\n,refractionLowSamplerSampler: sampler\n,refractionHighSampler: texture_2d<f32>\n,refractionHighSamplerSampler: sampler \n#endif\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut: anisotropicOutParams\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo: vec2f\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,refractionPosition: vec3f\n,refractionSize: vec3f\n#endif\n#ifdef SS_DISPERSION\n,dispersion: f32\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\n,vDiffusionDistance: vec3f\n,vTranslucencyColor: vec4f\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\n,translucencyColorMap: vec4f\n#endif\n#endif\n)->subSurfaceOutParams\n{var outParams: subSurfaceOutParams;outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvar refractionIntensity: f32=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);outParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvar translucencyIntensity: f32=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nvar thickness: f32=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#else\nvar thickness: f32=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS)\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=thicknessMap.r;\n#else\nrefractionIntensity*=thicknessMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS)\n#ifdef SS_USE_GLTF_TEXTURES\ntranslucencyIntensity*=thicknessMap.a;\n#else\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#endif\n#else\nvar thickness: f32=vThicknessParam.y;\n#endif\n#if defined(SS_REFRACTION) && defined(SS_REFRACTIONINTENSITY_TEXTURE)\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\n#else\nrefractionIntensity*=refractionIntensityMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCYINTENSITY_TEXTURE)\n#ifdef SS_USE_GLTF_TEXTURES\ntranslucencyIntensity*=translucencyIntensityMap.a;\n#else\ntranslucencyIntensity*=translucencyIntensityMap.b;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);var translucencyColor: vec4f=vTranslucencyColor;\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\ntranslucencyColor*=translucencyColorMap;\n#endif\nvar transmittance: vec3f=transmittanceBRDF_Burley(translucencyColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;\n#endif\n#ifdef SS_REFRACTION\nvar environmentRefraction: vec4f= vec4f(0.,0.,0.,0.);\n#ifdef SS_HAS_THICKNESS\nvar ior: f32=vRefractionInfos.y;\n#else\nvar ior: f32=vRefractionMicrosurfaceInfos.w;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nvar refractionAlphaG: f32=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));var refractionLOD: f32=getLodFromAlphaGNdotV(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nvar refractionRoughness: f32=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));var refractionLOD: f32=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\n#else\nvar refractionAlphaG: f32=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));var refractionLOD: f32=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\n#endif\nvar refraction_ior: f32=vRefractionInfos.y;\n#ifdef SS_DISPERSION\nvar realIOR: f32=1.0/refraction_ior;var iorDispersionSpread: f32=0.04*dispersion*(realIOR-1.0);var iors: vec3f= vec3f(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (var i: i32=0; i<3; i++) {refraction_ior=iors[i];\n#endif\nvar envSample: vec4f=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,refractionSampler\n,refractionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler\n,refractionLowSamplerSampler\n,refractionHighSampler\n,refractionHighSamplerSampler\n#endif\n#else\n,refractionSampler\n,refractionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler\n,refractionLowSamplerSampler\n,refractionHighSampler\n,refractionHighSamplerSampler\n#endif\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,refractionPosition\n,refractionSize\n#endif\n);\n#ifdef SS_DISPERSION\nenvironmentRefraction[i]=envSample[i];}\n#else\nenvironmentRefraction=envSample;\n#endif\nenvironmentRefraction=vec4f(environmentRefraction.rgb*vRefractionInfos.x,environmentRefraction.a);\n#endif\n#ifdef SS_REFRACTION\nvar refractionTransmittance: vec3f= vec3f(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvar volumeAlbedo: vec3f=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambertVec3(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nvar maxChannel: f32=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);var volumeAlbedo: vec3f=saturateVec3(maxChannel*surfaceAlbedo);environmentRefraction=vec4f(environmentRefraction.rgb*volumeAlbedo,environmentRefraction.a);\n#else\nvar volumeAlbedo: vec3f=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambertVec3(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction=vec4f(environmentRefraction.rgb*surfaceAlbedo.rgb,environmentRefraction.a);\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvar bounceSpecularEnvironmentReflectance: vec3f=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvar irradianceVector: vec3f= (reflectionMatrix* vec4f(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvar irradianceVector: vec3f=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvar refractionIrradiance: vec3f=irradiance(reflectionSampler,reflectionSamplerSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvar refractionIrradiance: vec3f=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvar irradianceCoords: vec3f=irradianceVector;\n#else\nvar irradianceCoords: vec2f=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvar temp: vec4f=textureSample(irradianceSampler,irradianceSamplerSampler,-irradianceCoords);var refractionIrradiance=temp.rgb;\n#ifdef RGBDREFLECTION\nrefractionIrradiance=fromRGBD(temp).rgb;\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance=toLinearSpaceVec3(refractionIrradiance);\n#endif\n#else\nvar refractionIrradiance: vec3f= vec3f(0.);\n#endif\nrefractionIrradiance*=transmittance;\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance*=surfaceAlbedo.rgb;\n#endif\noutParams.refractionIrradiance=refractionIrradiance;\n#endif\nreturn outParams;}\n#endif\n"
			}
		}),
		jo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockNormalGeometric.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockNormalGeometric = "var viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-input.vPositionW);\n#ifdef NORMAL\nvar normalW: vec3f=normalize(input.vNormalW);\n#else\nvar normalW: vec3f=normalize(cross(dpdx(input.vPositionW),dpdy(input.vPositionW)))*scene.vEyePosition.w;\n#endif\nvar geometricNormalW: vec3f=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=select(-geometricNormalW,geometricNormalW,fragmentInputs.frontFacing);\n#endif\n"
			}
		}),
		Ko = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockNormalFinal.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockNormalFinal = "#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvar faceNormal: vec3f=normalize(cross(dpdx(fragmentInputs.vPositionW),dpdy(fragmentInputs.vPositionW)))*scene.vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=select(-faceNormal,faceNormal,fragmentInputs.frontFacing);\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=select(-normalW,normalW,fragmentInputs.frontFacing);\n#endif\n"
			}
		}),
		$o = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockLightmapInit.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockLightmapInit = "#ifdef LIGHTMAP\nvar lightmapColor: vec4f=textureSample(lightmapSampler,lightmapSamplerSampler,fragmentInputs.vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor=vec4f(fromRGBD(lightmapColor),lightmapColor.a);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor=vec4f(toLinearSpaceVec3(lightmapColor.rgb),lightmapColor.a);\n#endif\nlightmapColor=vec4f(lightmapColor.rgb*uniforms.vLightmapInfos.y,lightmapColor.a);\n#endif\n"
			}
		}),
		Jo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockGeometryInfo.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockGeometryInfo = "var NdotVUnclamped: f32=dot(normalW,viewDirectionW);var NdotV: f32=absEps(NdotVUnclamped);var alphaG: f32=convertRoughnessToAverageSlope(roughness);var AARoughnessFactors: vec2f=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\nvar environmentBrdf: vec3f=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nvar ambientMonochrome: f32=aoOut.ambientOcclusionColor.r;\n#else\nvar ambientMonochrome: f32=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nvar seo: f32=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nvar eho: f32=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n"
			}
		}),
		qo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockReflectance0.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockReflectance0 = "var reflectance: f32=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);var specularEnvironmentR0: vec3f=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvar specularEnvironmentR90: vec3f= vec3f(metallicReflectanceFactors.a);\n#else \nvar specularEnvironmentR90: vec3f= vec3f(1.0,1.0,1.0);\n#endif\n#ifdef ALPHAFRESNEL\nvar reflectance90: f32=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n"
			}
		}),
		Qo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockReflectance.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockReflectance = "#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvar specularEnvironmentReflectance: vec3f=getReflectanceFromBRDFWithEnvLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\nvar specularEnvironmentReflectance: vec3f=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n"
			}
		}),
		Zo = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockDirectLighting.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockDirectLighting = "var diffuseBase: vec3f=vec3f(0.,0.,0.);\n#ifdef SPECULARTERM\nvar specularBase: vec3f=vec3f(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvar clearCoatBase: vec3f=vec3f(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvar sheenBase: vec3f=vec3f(0.,0.,0.);\n#endif\nvar preInfo: preLightingInfo;var info: lightingInfo;var shadow: f32=1.; \nvar aggShadow: f32=0.;var numLights: f32=0.;\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvar absorption: vec3f=vec3f(0.);\n#endif\n"
			}
		}),
		el = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockFinalLitComponents.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockFinalLitComponents = "aggShadow=aggShadow/numLights;\n#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvar energyConservationFactor: vec3f=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n#ifdef REFLECTION\nvar finalIrradiance: vec3f=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=uniforms.vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n#ifdef SPECULARTERM\nvar finalSpecular: vec3f=specularBase;finalSpecular=max(finalSpecular,vec3f(0.0));var finalSpecularScaled: vec3f=finalSpecular*uniforms.vLightingIntensity.x*uniforms.vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef REFLECTION\nvar finalRadiance: vec3f=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;var finalRadianceScaled: vec3f=finalRadiance*uniforms.vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef SHEEN\nvar finalSheen: vec3f=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,vec3f(0.0));var finalSheenScaled: vec3f=finalSheen*uniforms.vLightingIntensity.x*uniforms.vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef CLEARCOAT\nvar finalClearCoat: vec3f=clearCoatBase;finalClearCoat=max(finalClearCoat,vec3f(0.0));var finalClearCoatScaled: vec3f=finalClearCoat*uniforms.vLightingIntensity.x*uniforms.vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef ALPHABLEND\nvar luminanceOverAlpha: f32=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n"
			}
		}),
		tl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockFinalUnlitComponents.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockFinalUnlitComponents = "var finalDiffuse: vec3f=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,vec3f(0.0));finalDiffuse*=uniforms.vLightingIntensity.x;var finalAmbient: vec3f=uniforms.vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;var finalEmissive: vec3f=uniforms.vEmissiveColor;\n#ifdef EMISSIVE\nvar emissiveColorTex: vec3f=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vEmissiveUV+uvOffset).rgb;\n#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpaceVec3(emissiveColorTex.rgb);\n#else\nfinalEmissive*=emissiveColorTex.rgb;\n#endif\nfinalEmissive*= uniforms.vEmissiveInfos.y;\n#endif\nfinalEmissive*=uniforms.vLightingIntensity.y;\n#ifdef AMBIENT\nvar ambientOcclusionForDirectDiffuse: vec3f=mix( vec3f(1.),aoOut.ambientOcclusionColor,uniforms.vAmbientInfos.w);\n#else\nvar ambientOcclusionForDirectDiffuse: vec3f=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;\n"
			}
		}),
		il = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockFinalColorComposition.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockFinalColorComposition = "var finalColor: vec4f= vec4f(\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalAmbient +\nfinalDiffuse,\nalpha);\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor=vec4f(finalColor.rgb*lightmapColor.rgb,finalColor.a);\n#else\nfinalColor=vec4f(finalColor.rgb+lightmapColor.rgb,finalColor.a);\n#endif\n#endif\n#endif\nfinalColor=vec4f(finalColor.rgb+finalEmissive,finalColor.a);\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,vec4f(0.0));\n"
			}
		}),
		sl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrBlockImageProcessing.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrBlockImageProcessing = "#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\n#if !defined(SKIPFINALCOLORCLAMP)\nfinalColor=vec4f(clamp(finalColor.rgb,vec3f(0.),vec3f(30.0)),finalColor.a);\n#endif\n#else\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor=vec4f(finalColor.rgb,finalColor.a*mesh.visibility);\n#ifdef PREMULTIPLYALPHA\nfinalColor=vec4f(finalColor.rgb*finalColor.a,finalColor.a);;\n#endif\n"
			}
		}),
		nl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/pbrDebug.js"() {
				h(), e.IncludesShadersStoreWGSL.pbrDebug = "#if DEBUGMODE>0\nif (input.vClipSpacePosition.x/input.vClipSpacePosition.w>=uniforms.vDebugMode.x) {var color: vec3f;\n#if DEBUGMODE==1\ncolor=fragmentInputs.vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ncolor=fragmentInputs.vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ncolor=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ncolor=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ncolor=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ncolor= vec3f(input.vMainUV1,0.0);\n#elif DEBUGMODE==7 && defined(MAINUV2)\ncolor= vec3f(input.vMainUV2,0.0);\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ncolor=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ncolor=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ncolor=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ncolor=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ncolor=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ncolor=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ncolor=albedoTexture.rgb;\n#ifndef GAMMAALBEDO\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==21 && defined(AMBIENT)\ncolor=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE==22 && defined(OPACITY)\ncolor=opacityMap.rgb;\n#elif DEBUGMODE==23 && defined(EMISSIVE)\ncolor=emissiveColorTex.rgb;\n#ifndef GAMMAEMISSIVE\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ncolor=lightmapColor;\n#ifndef GAMMALIGHTMAP\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ncolor=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ncolor=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ncolor= vec3f(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ncolor=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ncolor=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ncolor=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ncolor=subSurfaceOut.thicknessMap.rgb;\n#elif DEBUGMODE==32 && defined(BUMP)\ncolor=textureSample(bumpSampler,bumpSamplerSampler,fragmentInputs.vBumpUV).rgb;\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ncolor=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ncolor=reflectionOut.environmentRadiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ncolor=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ncolor=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ncolor=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ncolor=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ncolor=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ncolor=reflectionOut.environmentIrradiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==60\ncolor=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ncolor=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ncolor= vec3f(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ncolor=reflectivityOut.metallicF0;\n#elif DEBUGMODE==63\ncolor= vec3f(roughness);\n#elif DEBUGMODE==64\ncolor= vec3f(alphaG);\n#elif DEBUGMODE==65\ncolor= vec3f(NdotV);\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ncolor=clearcoatOut.clearCoatColor;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ncolor= vec3f(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\ncolor= vec3f(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ncolor=subSurfaceOut.transmittance;\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ncolor=subSurfaceOut.refractionTransmittance;\n#elif DEBUGMODE==72\ncolor= vec3f(microSurface);\n#elif DEBUGMODE==73\ncolor=uniforms.vAlbedoColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)\ncolor=uniforms.vReflectivityColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==75\ncolor=uniforms.vEmissiveColor;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ncolor= vec3f(seo);\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\ncolor= vec3f(eho);\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ncolor= vec3f(energyConservationFactor);\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ncolor=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ncolor=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ncolor=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ncolor= vec3f(luminanceOverAlpha);\n#elif DEBUGMODE==87\ncolor= vec3f(alpha);\n#elif DEBUGMODE==88 && defined(ALBEDO)\ncolor= vec3f(albedoTexture.a);\n#elif DEBUGMODE==89\ncolor=aoOut.ambientOcclusionColor;\n#else\nvar stripeWidth: f32=30.;var stripePos: f32=abs(floor(input.position.x/stripeWidth));var whichColor: f32=((stripePos)%(2.));var color1: vec3f= vec3f(.6,.2,.2);var color2: vec3f= vec3f(.3,.1,.1);color=mix(color1,color2,whichColor);\n#endif\ncolor*=uniforms.vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ncolor=normalize(color)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ncolor=toGammaSpaceVec3(color);\n#endif\nfragmentOutputs.color=vec4f(color,1.0);\n#ifdef PREPASS\nfragmentOutputs.fragData0=toLinearSpaceVec3(color); \nfragmentOutputs.fragData1=vec4f(0.,0.,0.,0.); \n#endif\n#ifdef DEBUGMODE_FORCERETURN\nreturn fragmentOutputs;\n#endif\n}\n#endif\n"
			}
		}),
		al = {};
	l(al, {
		pbrPixelShaderWGSL: () => bo
	});
	var rl, ol, ll, hl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/ShadersWGSL/pbr.fragment.js"() {
				h(), Rn(), Nn(), vo(), Mo(), ee(), To(), Dn(), ki(), _n(), Et(), ce(), wo(), Ro(), No(), On(), Se(), yo(), Io(), Po(), ko(), Do(), Oo(), Fo(), Fn(), Ln(), kn(), Lo(), Bo(), Go(), Ho(), Uo(), Vo(), Wo(), zo(), Xo(), Yo(), Di(), jo(), Bn(), Ko(), Hn(), $o(), Jo(), qo(), Qo(), Zo(), $(), el(), tl(), il(), Un(), Vn(), sl(), Wn(), nl(), Eo = "pbrPixelShader", Ao = "#define CUSTOM_FRAGMENT_BEGIN\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<pbrUboDeclaration>\n#include<pbrFragmentExtraDeclaration>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nvar albedoOpacityOut: albedoOpacityOutParams;\n#ifdef ALBEDO\nvar albedoTexture: vec4f=textureSample(albedoSampler,albedoSamplerSampler,fragmentInputs.vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvar opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vOpacityUV+uvOffset);\n#endif\n#ifdef DECAL\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#endif\nalbedoOpacityOut=albedoOpacityBlock(\nuniforms.vAlbedoColor\n#ifdef ALBEDO\n,albedoTexture\n,uniforms.vAlbedoInfos\n#endif\n#ifdef OPACITY\n,opacityMap\n,uniforms.vOpacityInfos\n#endif\n#ifdef DETAIL\n,detailColor\n,uniforms.vDetailInfos\n#endif\n#ifdef DECAL\n,decalColor\n,uniforms.vDecalInfos\n#endif\n);var surfaceAlbedo: vec3f=albedoOpacityOut.surfaceAlbedo;var alpha: f32=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nvar aoOut: ambientOcclusionOutParams;\n#ifdef AMBIENT\nvar ambientOcclusionColorMap: vec3f=textureSample(ambientSampler,ambientSamplerSampler,fragmentInputs.vAmbientUV+uvOffset).rgb;\n#endif\naoOut=ambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nuniforms.vAmbientInfos\n#endif \n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvar diffuseBase: vec3f= vec3f(1.,1.,1.);\n#else\nvar baseColor: vec3f=surfaceAlbedo;var reflectivityOut: reflectivityOutParams;\n#if defined(REFLECTIVITY)\nvar surfaceMetallicOrReflectivityColorMap: vec4f=textureSample(reflectivitySampler,reflectivitySamplerSampler,fragmentInputs.vReflectivityUV+uvOffset);var baseReflectivity: vec4f=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpaceVec4(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap=vec4f(surfaceMetallicOrReflectivityColorMap.rgb*uniforms.vReflectivityInfos.y,surfaceMetallicOrReflectivityColorMap.a);\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvar microSurfaceTexel: vec4f=textureSample(microSurfaceSampler,microSurfaceSamplerSampler,fragmentInputs.vMicroSurfaceSamplerUV+uvOffset)*uniforms.vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvar metallicReflectanceFactors: vec4f=uniforms.vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvar reflectanceFactorsMap: vec4f=textureSample(reflectanceSampler,reflectanceSamplerSampler,fragmentInputs.vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpaceVec4(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors=vec4f(metallicReflectanceFactors.rgb*reflectanceFactorsMap.rgb,metallicReflectanceFactors.a);\n#endif\n#ifdef METALLIC_REFLECTANCE\nvar metallicReflectanceFactorsMap: vec4f=textureSample(metallicReflectanceSampler,metallicReflectanceSamplerSampler,fragmentInputs.vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpaceVec4(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors=vec4f(metallicReflectanceFactors.rgb*reflectanceFactorsMap.rgb,metallicReflectanceFactors.a);\n#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityOut=reflectivityBlock(\nuniforms.vReflectivityColor\n#ifdef METALLICWORKFLOW\n,surfaceAlbedo\n,metallicReflectanceFactors\n#endif\n#ifdef REFLECTIVITY\n,uniforms.vReflectivityInfos\n,surfaceMetallicOrReflectivityColorMap\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n,aoOut.ambientOcclusionColor\n#endif\n#ifdef MICROSURFACEMAP\n,microSurfaceTexel\n#endif\n#ifdef DETAIL\n,detailColor\n,uniforms.vDetailInfos\n#endif\n);var microSurface: f32=reflectivityOut.microSurface;var roughness: f32=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nvar alphaFresnelOut: alphaFresnelOutParams;alphaFresnelOut=alphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface\n);alpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nvar anisotropicOut: anisotropicOutParams;\n#ifdef ANISOTROPIC_TEXTURE\nvar anisotropyMapData: vec3f=textureSample(anisotropySampler,anisotropySamplerSampler,fragmentInputs.vAnisotropyUV+uvOffset).rgb*uniforms.vAnisotropyInfos.y;\n#endif\nanisotropicOut=anisotropicBlock(\nuniforms.vAnisotropy,\nroughness,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW \n);\n#endif\n#ifdef REFLECTION\nvar reflectionOut: reflectionOutParams;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionOut=reflectionBlock(\ninput.vPositionW\n,normalW\n,alphaG\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness\n#endif\n,reflectionSampler\n,reflectionSamplerSampler\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n,input.vEnvironmentIrradiance\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,uniforms.reflectionMatrix\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n,irradianceSamplerSampler\n#endif\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vReflectionFilteringInfo\n#endif\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nvar sheenOut: sheenOutParams;\n#ifdef SHEEN_TEXTURE\nvar sheenMapData: vec4f=textureSample(sheenSampler,sheenSamplerSampler,fragmentInputs.vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvar sheenMapRoughnessData: vec4f=textureSample(sheenRoughnessSampler,sheenRoughnessSamplerSampler,fragmentInputs.vSheenRoughnessUV+uvOffset)*uniforms.vSheenInfos.w;\n#endif\nsheenOut=sheenBlock(\nuniforms.vSheenColor\n#ifdef SHEEN_ROUGHNESS\n,uniforms.vSheenRoughness\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,sheenMapRoughnessData\n#endif\n#endif\n,roughness\n#ifdef SHEEN_TEXTURE\n,sheenMapData\n,uniforms.vSheenInfos.y\n#endif\n,reflectance\n#ifdef SHEEN_LINKWITHALBEDO\n,baseColor\n,surfaceAlbedo\n#endif\n#ifdef ENVIRONMENTBRDF\n,NdotV\n,environmentBrdf\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,AARoughnessFactors\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n,uniforms.vLightingIntensity\n,reflectionSampler\n,reflectionSamplerSampler\n,reflectionOut.reflectionCoords\n,NdotVUnclamped\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\n,seo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\n,eho\n#endif\n#endif\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvar clearCoatMapData: vec2f=textureSample(clearCoatSampler,clearCoatSamplerSampler,fragmentInputs.vClearCoatUV+uvOffset).rg*uniforms.vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\nvar iridescenceOut: iridescenceOutParams;\n#ifdef IRIDESCENCE_TEXTURE\nvar iridescenceMapData: vec2f=textureSample(iridescenceSampler,iridescenceSamplerSampler,fragmentInputs.vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvar iridescenceThicknessMapData: vec2f=textureSample(iridescenceThicknessSampler,iridescenceThicknessSamplerSampler,fragmentInputs.vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\n#endif\niridescenceOut=iridescenceBlock(\nuniforms.vIridescenceParams\n,NdotV\n,specularEnvironmentR0\n#ifdef IRIDESCENCE_TEXTURE\n,iridescenceMapData\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\n,iridescenceThicknessMapData\n#endif\n#ifdef CLEARCOAT\n,NdotVUnclamped\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#endif\n);var iridescenceIntensity: f32=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nvar clearcoatOut: clearcoatOutParams;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvar clearCoatMapRoughnessData: vec4f=textureSample(clearCoatRoughnessSampler,clearCoatRoughnessSamplerSampler,fragmentInputs.vClearCoatRoughnessUV+uvOffset)*uniforms.vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvar clearCoatTintMapData: vec4f=textureSample(clearCoatTintSampler,clearCoatTintSamplerSampler,fragmentInputs.vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvar clearCoatBumpMapData: vec4f=textureSample(clearCoatBumpSampler,clearCoatBumpSamplerSampler,fragmentInputs.vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatOut=clearcoatBlock(\ninput.vPositionW\n,geometricNormalW\n,viewDirectionW\n,uniforms.vClearCoatParams\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,clearCoatMapRoughnessData\n#endif\n,specularEnvironmentR0\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#ifdef CLEARCOAT_TINT\n,uniforms.vClearCoatTintParams\n,uniforms.clearCoatColorAtDistance\n,uniforms.vClearCoatRefractionParams\n#ifdef CLEARCOAT_TINT_TEXTURE\n,clearCoatTintMapData\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\n,uniforms.vClearCoatBumpInfos\n,clearCoatBumpMapData\n,fragmentInputs.vClearCoatBumpUV\n#if defined(TANGENT) && defined(NORMAL)\n,vTBN\n#else\n,uniforms.vClearCoatTangentSpaceParams\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n,uniforms.normalMatrix\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\n,faceNormal\n#endif\n#ifdef REFLECTION\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n,uniforms.vLightingIntensity\n,reflectionSampler\n,reflectionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vReflectionFilteringInfo\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n,ambientMonochrome\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n,select(-1.,1.,fragmentInputs.frontFacing)\n#endif\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nvar subSurfaceOut: subSurfaceOutParams;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvar thicknessMap: vec4f=textureSample(thicknessSampler,thicknessSamplerSampler,fragmentInputs.vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvar refractionIntensityMap: vec4f=textureSample(refractionIntensitySampler,refractionIntensitySamplerSampler,fragmentInputs.vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvar translucencyIntensityMap: vec4f=textureSample(translucencyIntensitySampler,translucencyIntensitySamplerSampler,fragmentInputs.vTranslucencyIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\nvar translucencyColorMap: vec4f=textureSample(translucencyColorSampler,translucencyColorSamplerSampler,fragmentInputs.vTranslucencyColorUV+uvOffset);\n#endif\nsubSurfaceOut=subSurfaceBlock(\nuniforms.vSubSurfaceIntensity\n,uniforms.vThicknessParam\n,uniforms.vTintColor\n,normalW\n,specularEnvironmentReflectance\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n,thicknessMap\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n,refractionIntensityMap\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\n,translucencyIntensityMap\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\n,uniforms.reflectionMatrix\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,reflectionOut.irradianceVector\n#endif\n#if defined(REALTIME_FILTERING)\n,reflectionSampler\n,reflectionSamplerSampler\n,vReflectionFilteringInfo\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n,irradianceSamplerSampler\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n,surfaceAlbedo\n#endif\n#ifdef SS_REFRACTION\n,input.vPositionW\n,viewDirectionW\n,scene.view\n,uniforms.vRefractionInfos\n,uniforms.refractionMatrix\n,uniforms.vRefractionMicrosurfaceInfos\n,uniforms.vLightingIntensity\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n,alpha\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\n,NdotVUnclamped\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\n,roughness\n#endif\n,alphaG\n,refractionSampler\n,refractionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler\n,refractionLowSamplerSampler\n,refractionHighSampler\n,refractionHighSamplerSampler\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,uniforms.vRefractionPosition\n,uniforms.vRefractionSize\n#endif\n#ifdef SS_DISPERSION\n,dispersion\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\n,uniforms.vDiffusionDistance\n,uniforms.vTranslucencyColor\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\n,translucencyColorMap\n#endif\n#endif\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nvar writeGeometryInfo: f32=select(0.0,1.0,finalColor.a>0.4);var fragData: array<vec4<f32>,SCENE_MRT_COUNT>;\n#ifdef PREPASS_POSITION\nfragData[PREPASS_POSITION_INDEX]= vec4f(input.vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvar a: vec2f=(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[PREPASS_VELOCITY_INDEX]= vec4f(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvar sqAlbedo: vec3f=sqrt(surfaceAlbedo); \n#endif\n#ifdef PREPASS_IRRADIANCE\nvar irradiance: vec3f=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\n#ifdef SS_SCATTERING\nfragData[0]= vec4f(finalColor.rgb-irradiance,finalColor.a); \nirradiance/=sqAlbedo;\n#else\nfragData[0]=finalColor; \nvar scatteringDiffusionProfile: f32=255.;\n#endif\nfragData[PREPASS_IRRADIANCE_INDEX]= vec4f(clamp(irradiance, vec3f(0.), vec3f(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \n#else\nfragData[0]= vec4f(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTH\nfragData[PREPASS_DEPTH_INDEX]= vec4f(fragmentInputs.vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\nfragData[PREPASS_NORMAL_INDEX]= vec4f(normalW,writeGeometryInfo); \n#else\nfragData[PREPASS_NORMAL_INDEX]= vec4f(normalize((scene.view* vec4f(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nfragData[PREPASS_ALBEDO_SQRT_INDEX]= vec4f(sqAlbedo,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#ifndef UNLIT\nfragData[PREPASS_REFLECTIVITY_INDEX]= vec4f(specularEnvironmentR0,microSurface)*writeGeometryInfo;\n#else\nfragData[PREPASS_REFLECTIVITY_INDEX]= vec4f( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;\n#endif\n#endif\n#if SCENE_MRT_COUNT>0\nfragmentOutputs.fragData0= fragData[0];\n#endif\n#if SCENE_MRT_COUNT>1\nfragmentOutputs.fragData1= fragData[1];\n#endif\n#if SCENE_MRT_COUNT>2\nfragmentOutputs.fragData2= fragData[2];\n#endif\n#if SCENE_MRT_COUNT>3\nfragmentOutputs.fragData3= fragData[3];\n#endif\n#if SCENE_MRT_COUNT>4\nfragmentOutputs.fragData4= fragData[4];\n#endif\n#if SCENE_MRT_COUNT>5\nfragmentOutputs.fragData5= fragData[5];\n#endif\n#if SCENE_MRT_COUNT>6\nfragmentOutputs.fragData6= fragData[6];\n#endif\n#if SCENE_MRT_COUNT>7\nfragmentOutputs.fragData7= fragData[7];\n#endif\n#endif\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+finalColor.rgb*finalColor.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-finalColor.a));} else {fragmentOutputs.backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n", e.ShadersStoreWGSL[Eo] = Ao, bo = {
					name: Eo,
					shader: Ao
				}
			}
		}),
		cl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js"() {
				h(), $n(), e.IncludesShadersStore.pbrVertexDeclaration = "uniform mat4 view;uniform mat4 viewProjection;\n#ifdef ALBEDO\nuniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#ifdef REFLECTIVITY \nuniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;\n#endif\n#ifdef METALLIC_REFLECTANCE\nuniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;\n#endif\n#ifdef REFLECTANCE\nuniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;\n#endif\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#ifdef IRIDESCENCE\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\nuniform vec2 vTranslucencyColorInfos;uniform mat4 translucencyColorMatrix;\n#endif\n#endif\n#ifdef NORMAL\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n"
			}
		}),
		ul = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js"() {
				h(), Rs(), Ns(), e.IncludesShadersStore.pbrUboDeclaration = "layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n"
			}
		}),
		ml = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js"() {
				h(), e.IncludesShadersStore.harmonicsFunctions = "#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00\n+ vSphericalL1_1*(normal.y)\n+ vSphericalL10*(normal.z)\n+ vSphericalL11*(normal.x)\n+ vSphericalL2_2*(normal.y*normal.x)\n+ vSphericalL2_1*(normal.y*normal.z)\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ vSphericalL21*(normal.z*normal.x)\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}\n#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}\n#endif\n#endif\n"
			}
		}),
		dl = {};
	l(dl, {
		pbrVertexShader: () => ll
	});
	var fl, pl, _l, gl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/pbr.vertex.js"() {
				h(), cl(), ul(), Qn(), ta(), tt(), G(), bs(), Zn(), ea(), ia(), ml(), sa(), ks(), na(), Je(), Xe(), xs(), Ms(), aa(), Ds(), Os(), Fs(), z(), Ls(), ra(), oa(), la(), ha(), Gs(), ca(), _t(), ua(), da(), rl = "pbrVertexShader", ol = "precision highp float;\n#include<__decl__pbrVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor)\n#endif\nvarying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);\n#include<prePassVertex>\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvClipSpacePosition=gl_Position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheenRoughness,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_MATRIXNAME_,translucencyColor,_INFONAME_,TranslucencyColorInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}", e.ShadersStore[rl] = ol, ll = {
					name: rl,
					shader: ol
				}
			}
		}),
		vl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js"() {
				h(), Sa(), e.IncludesShadersStore.pbrFragmentDeclaration = "uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;\n#ifdef ALBEDO\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nuniform vec4 vAmbientInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef REFLECTIVITY\nuniform vec3 vReflectivityInfos;\n#endif\n#ifdef MICROSURFACEMAP\nuniform vec2 vMicroSurfaceSamplerInfos;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REALTIME_FILTERING\nuniform vec2 vReflectionFilteringInfo;\n#endif\nuniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#ifdef CLEARCOAT\nuniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform vec4 vClearCoatInfos;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nuniform mat4 clearCoatMatrix;\n#endif\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\nuniform mat4 clearCoatRoughnessMatrix;\n#endif\n#ifdef CLEARCOAT_BUMP\nuniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;\n#endif\n#ifdef CLEARCOAT_TINT\nuniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;\n#ifdef CLEARCOAT_TINT_TEXTURE\nuniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;\n#endif\n#endif\n#endif\n#ifdef IRIDESCENCE\nuniform vec4 vIridescenceParams;\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\nuniform vec4 vIridescenceInfos;\n#endif\n#ifdef IRIDESCENCE_TEXTURE\nuniform mat4 iridescenceMatrix;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nuniform mat4 iridescenceThicknessMatrix;\n#endif\n#endif\n#ifdef ANISOTROPIC\nuniform vec3 vAnisotropy;\n#ifdef ANISOTROPIC_TEXTURE\nuniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;\n#endif\n#endif\n#ifdef SHEEN\nuniform vec4 vSheenColor;\n#ifdef SHEEN_ROUGHNESS\nuniform float vSheenRoughness;\n#endif\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform vec4 vSheenInfos;\n#endif\n#ifdef SHEEN_TEXTURE\nuniform mat4 sheenMatrix;\n#endif\n#ifdef SHEEN_TEXTURE_ROUGHNESS\nuniform mat4 sheenRoughnessMatrix;\n#endif\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\nuniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;\n#ifdef REALTIME_FILTERING\nuniform vec2 vRefractionFilteringInfo;\n#endif\n#ifdef SS_DISPERSION\nuniform float dispersion;\n#endif\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nuniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nuniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nuniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;\n#endif\nuniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;uniform vec4 vTranslucencyColor;\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\nuniform vec2 vTranslucencyColorInfos;uniform mat4 translucencyColorMatrix;\n#endif\n#endif\n#ifdef PREPASS\n#ifdef SS_SCATTERING\nuniform float scatteringDiffusionProfile;\n#endif\n#endif\n#if DEBUGMODE>0\nuniform vec2 vDebugMode;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nuniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;\n#else\nuniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;\n#endif\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n"
			}
		}),
		yl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js"() {
				h(), ta(), e.IncludesShadersStore.pbrFragmentExtraDeclaration = "varying vec3 vPositionW;\n#if DEBUGMODE>0\nvarying vec4 vClipSpacePosition;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vec3 vEnvironmentIrradiance;\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n"
			}
		}),
		Sl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js"() {
				h(), e.IncludesShadersStore.samplerFragmentAlternateDeclaration = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n#endif\n"
			}
		}),
		El = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js"() {
				h(), xa(), Sl(), e.IncludesShadersStore.pbrFragmentSamplersDeclaration = "#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef CLEARCOAT\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS)\nuniform sampler2D clearCoatRoughnessSampler;\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS)\nuniform sampler2D sheenRoughnessSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\n#define sampleReflection(s,c) textureCube(s,c)\nuniform samplerCube reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform samplerCube irradianceSampler;\n#endif\n#else\n#define sampleReflection(s,c) texture2D(s,c)\nuniform sampler2D reflectionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;\n#endif\n#ifdef USEIRRADIANCEMAP\nuniform sampler2D irradianceSampler;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#endif\n#ifdef ENVIRONMENTBRDF\nuniform sampler2D environmentBrdfSampler;\n#endif\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#ifdef SS_REFRACTIONMAP_3D\n#define sampleRefraction(s,c) textureCube(s,c)\nuniform samplerCube refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\n#else\nuniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;\n#endif\n#else\n#define sampleRefraction(s,c) texture2D(s,c)\nuniform sampler2D refractionSampler;\n#ifdef LODBASEDMICROSFURACE\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\n#else\nuniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;\n#endif\n#endif\n#endif\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_SAMPLERNAME_,translucencyColor)\n#endif\n"
			}
		}),
		Al = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js"() {
				h(), e.IncludesShadersStore.subSurfaceScatteringFunctions = "bool testLightingForSSS(float diffusionProfile)\n{return diffusionProfile<1.;}"
			}
		}),
		bl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js"() {
				h(), e.IncludesShadersStore.importanceSampling = "vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \nfloat phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}"
			}
		}),
		xl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js"() {
				h(), e.IncludesShadersStore.pbrHelperFunctions = "#define MINIMUMVARIANCE 0.0005\nfloat convertRoughnessToAverageSlope(float roughness)\n{return square(roughness)+MINIMUMVARIANCE;}\nfloat fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}\nvec2 getAARoughnessFactors(vec3 normalVector) {\n#ifdef SPECULARAA\nvec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);\n#else\nreturn vec2(0.);\n#endif\n}\n#ifdef ANISOTROPIC\n#ifdef ANISOTROPIC_LEGACY\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}\n#else\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}\n#endif\n#endif\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\nvec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\nclearCoatIntensity);return clearCoatAbsorption;}\n#endif\n#ifdef MICROSURFACEAUTOMATIC\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}\n#endif\n"
			}
		}),
		Ml = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js"() {
				h(), e.IncludesShadersStore.pbrDirectLightingSetupFunctions = "struct preLightingInfo\n{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;\n#ifdef IRIDESCENCE\nfloat iridescenceIntensity;\n#endif\n};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N,vec3 posW) {preLightingInfo result;result.lightOffset=lightData.xyz-posW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;\n#ifdef SPECULARTERM\nresult.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));\n#endif\nreturn result;}"
			}
		}),
		Cl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js"() {
				h(), e.IncludesShadersStore.pbrDirectLightingFalloffFunctions = "float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\n{return max(0.,1.0-length(lightOffset)/range);}\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n{return 1.0/maxEps(lightDistanceSquared);}\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\n{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\n#else\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\n#endif\n}\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\n{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)\n{falloff=max(0.,pow(cosAngle,exponent));}\nreturn falloff;}\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\n{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\n{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\n#elif defined(USEGLTFLIGHTFALLOFF)\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\n#else\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\n#endif\n}"
			}
		}),
		Tl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js"() {
				h(), e.IncludesShadersStore.pbrBRDFFunctions = "#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}\n#endif\n#ifdef ENVIRONMENTBRDF\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\n#ifdef ENVIRONMENTBRDF_RGBD\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\n#endif\nreturn brdfLookup.rgb;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\n#endif\nreturn reflectance;}\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\n#ifdef BRDF_V_HEIGHT_CORRELATED\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\n#else\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\n#endif\nreturn reflectance;}\n#endif\n/* NOT USED\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\n{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}\n#endif\n*/\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\n/**\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\n*/\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}\n#endif\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\n{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}\n#ifdef CLEARCOAT\nvec3 getR0RemappedForClearCoat(vec3 f0) {\n#ifdef CLEARCOAT_DEFAULTIOR\n#ifdef MOBILE\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\n#else\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\n#endif\n#else\nvec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);\n#endif\n}\n#endif\n#ifdef IRIDESCENCE\nconst mat3 XYZ_TO_REC709=mat3(\n3.2404542,-0.9692660, 0.0556434,\n-1.5371385, 1.8760108,-0.2040259,\n-0.4985314, 0.0415560, 1.0572252\n);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}\nvec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}\nfloat getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}\nvec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}\nfloat cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)\n{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}\nreturn max(I,vec3(0.0));}\n#endif\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}\n#ifdef SHEEN\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\n{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}\n#endif\n#ifdef ANISOTROPIC\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}\n#endif\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\n#ifdef MOBILE\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);\n#else\nfloat a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);\n#endif\n}\n#else\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\n{\n#ifdef MOBILE\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\n#else\nfloat alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\n#endif\n}\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\n{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}\n#endif\n#ifdef ANISOTROPIC\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}\n#endif\n#ifdef CLEARCOAT\nfloat visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }\n#endif\n#ifdef SHEEN\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\n{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}\n/* NOT USED\n#ifdef SHEEN_SOFTER\nfloat l(float x,float alphaG)\n{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}\nfloat lambdaSheen(float cosTheta,float alphaG)\n{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\n{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}\n#endif\n*/\n#endif\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}\n#ifdef SS_TRANSLUCENCY\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}\n#endif\n"
			}
		}),
		wl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js"() {
				h(), e.IncludesShadersStore.hdrFilteringFunctions = "#ifdef NUM_SAMPLES\n#if NUM_SAMPLES>0\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfloat radicalInverse_VdC(uint bits) \n{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }\nvec2 hammersley(uint i,uint N)\n{return vec2(float(i)/float(N),radicalInverse_VdC(i));}\n#else\nfloat vanDerCorpus(int n,int base)\n{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)\n{if(n>0)\n{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}\nreturn result;}\nvec2 hammersley(int i,int N)\n{return vec2(float(i)/float(N),vanDerCorpus(i,2));}\n#endif\nfloat log4(float x) {return log2(x)/2.;}\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;\n#define inline\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c;}}\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}\n#define inline\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\n{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; \nif (alphaG==0.) {\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nreturn c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\n#else\nfor(int i=0; i<NUM_SAMPLES; ++i)\n#endif\n{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\n#ifdef GAMMA_INPUT\nc=toLinearSpace(c);\n#endif\nresult+=c*NoL;}}\nresult=result/weight;return result;}}\n#endif\n#endif\n"
			}
		}),
		Rl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js"() {
				h(), e.IncludesShadersStore.pbrDirectLightingFunctions = "#define CLEARCOATREFLECTANCE90 1.0\nstruct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef CLEARCOAT\nvec4 clearCoat;\n#endif\n#ifdef SHEEN\nvec3 sheen;\n#endif\n};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\nfloat lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix,vec3 posW){vec4 strq=textureProjectionMatrix*vec4(posW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}\n#ifdef SS_TRANSLUCENCY\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}\n#endif\n#ifdef SPECULARTERM\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\n#ifdef BRDF_V_HEIGHT_CORRELATED\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\n#else\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\n#endif\nvec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef ANISOTROPIC\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\n#ifdef IRIDESCENCE\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\n#endif\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n#ifdef CLEARCOAT\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\n1.0-fresnel\n);}\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}\n#endif\n#ifdef SHEEN\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER\nfloat visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\n#else */\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */\nfloat sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}\n#endif\n"
			}
		}),
		Nl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js"() {
				h(), e.IncludesShadersStore.pbrIBLFunctions = "#if defined(REFLECTION) || defined(SS_REFRACTION)\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}\n#endif\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\n#define UNPACK_LOD(x) (1.0-x)*255.0\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}\n#endif\n"
			}
		}),
		Il = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js"() {
				h(), Pa(), e.IncludesShadersStore.pbrBlockAlbedoOpacity = "struct albedoOpacityOutParams\n{vec3 surfaceAlbedo;float alpha;};\n#define pbr_inline\nalbedoOpacityOutParams albedoOpacityBlock(\nin vec4 vAlbedoColor\n#ifdef ALBEDO\n,in vec4 albedoTexture\n,in vec2 albedoInfos\n#endif\n#ifdef OPACITY\n,in vec4 opacityMap\n,in vec2 vOpacityInfos\n#endif\n#ifdef DETAIL\n,in vec4 detailColor\n,in vec4 vDetailInfos\n#endif\n#ifdef DECAL\n,in vec4 decalColor\n,in vec4 vDecalInfos\n#endif \n)\n{albedoOpacityOutParams outParams;vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;\n#ifdef ALBEDO\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\nalpha*=albedoTexture.a;\n#endif\n#ifdef GAMMAALBEDO\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\n#else\nsurfaceAlbedo*=albedoTexture.rgb;\n#endif\nsurfaceAlbedo*=albedoInfos.y;\n#endif\n#ifndef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nsurfaceAlbedo*=vColor.rgb;\n#endif\n#ifdef DETAIL\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \n#endif\n#ifdef DECAL_AFTER_DETAIL\n#include<decalFragment>\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\n#ifdef OPACITY\n#ifdef OPACITYRGB\nalpha=getLuminance(opacityMap.rgb);\n#else\nalpha*=opacityMap.a;\n#endif\nalpha*=vOpacityInfos.y;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n#ifdef ALPHATEST \n#if DEBUGMODE != 88\nif (alpha<ALPHATESTVALUE)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;return outParams;}\n"
			}
		}),
		Pl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js"() {
				h(), e.IncludesShadersStore.pbrBlockReflectivity = "struct reflectivityOutParams\n{float microSurface;float roughness;vec3 surfaceReflectivityColor;\n#ifdef METALLICWORKFLOW\nvec3 surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\nvec3 ambientOcclusionColor;\n#endif\n#if DEBUGMODE>0\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness;\n#ifdef REFLECTIVITY\nvec4 surfaceMetallicColorMap;\n#endif\n#ifndef FROSTBITE_REFLECTANCE\nvec3 metallicF0;\n#endif\n#else\n#ifdef REFLECTIVITY\nvec4 surfaceReflectivityColorMap;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nreflectivityOutParams reflectivityBlock(\nin vec4 vReflectivityColor\n#ifdef METALLICWORKFLOW\n,in vec3 surfaceAlbedo\n,in vec4 metallicReflectanceFactors\n#endif\n#ifdef REFLECTIVITY\n,in vec3 reflectivityInfos\n,in vec4 surfaceMetallicOrReflectivityColorMap\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n,in vec3 ambientOcclusionColorIn\n#endif\n#ifdef MICROSURFACEMAP\n,in vec4 microSurfaceTexel\n#endif\n#ifdef DETAIL\n,in vec4 detailColor\n,in vec4 vDetailInfos\n#endif\n)\n{reflectivityOutParams outParams;float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\n#ifdef REFLECTIVITY\n#if DEBUGMODE>0\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef AOSTOREINMETALMAPRED\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\n#endif\n#ifdef METALLNESSSTOREINMETALMAPBLUE\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\n#else\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\n#endif\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\n#else\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\n#endif\n#endif\n#endif\n#ifdef DETAIL\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\n#endif\n#ifdef MICROSURFACEMAP\nmetallicRoughness.g*=microSurfaceTexel.r;\n#endif\n#if DEBUGMODE>0\noutParams.metallicRoughness=metallicRoughness;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\nmicroSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;\n#ifdef FROSTBITE_REFLECTANCE\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\n#else\nvec3 metallicF0=metallicReflectanceFactors.rgb;\n#if DEBUGMODE>0\noutParams.metallicF0=metallicF0;\n#endif\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\n#endif\n#else\n#ifdef REFLECTIVITY\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\n#if DEBUGMODE>0\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#ifdef MICROSURFACEMAP\nmicroSurface*=microSurfaceTexel.r;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\n#endif\n#endif\n#endif\nmicroSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;return outParams;}\n"
			}
		}),
		kl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js"() {
				h(), e.IncludesShadersStore.pbrBlockAmbientOcclusion = "struct ambientOcclusionOutParams\n{vec3 ambientOcclusionColor;\n#if DEBUGMODE>0 && defined(AMBIENT)\nvec3 ambientOcclusionColorMap;\n#endif\n};ambientOcclusionOutParams ambientOcclusionBlock(\n#ifdef AMBIENT\nin vec3 ambientOcclusionColorMap_,\nin vec4 vAmbientInfos\n#endif\n)\n{ambientOcclusionOutParams outParams;vec3 ambientOcclusionColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\n#ifdef AMBIENTINGRAYSCALE\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\n#endif\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\n#if DEBUGMODE>0\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\n#endif\n#endif\noutParams.ambientOcclusionColor=ambientOcclusionColor;return outParams;}\n"
			}
		}),
		Dl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js"() {
				h(), e.IncludesShadersStore.pbrBlockAlphaFresnel = "#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nstruct alphaFresnelOutParams\n{float alpha;};\n#define pbr_inline\nalphaFresnelOutParams alphaFresnelBlock(\nin vec3 normalW,\nin vec3 viewDirectionW,\nin float alpha,\nin float microSurface\n)\n{alphaFresnelOutParams outParams;float opacityPerceptual=alpha;\n#ifdef LINEARALPHAFRESNEL\nfloat opacity0=opacityPerceptual;\n#else\nfloat opacity0=opacityPerceptual*opacityPerceptual;\n#endif\nfloat opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\n#ifdef ALPHATEST\nif (outParams.alpha<ALPHATESTVALUE)\ndiscard;\n#ifndef ALPHABLEND\noutParams.alpha=1.0;\n#endif\n#endif\nreturn outParams;}\n#endif\n#endif\n"
			}
		}),
		Ol = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js"() {
				h(), e.IncludesShadersStore.pbrBlockAnisotropic = "#ifdef ANISOTROPIC\nstruct anisotropicOutParams\n{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;\n#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)\nvec3 anisotropyMapData;\n#endif\n};\n#define pbr_inline\nanisotropicOutParams anisotropicBlock(\nin vec3 vAnisotropy,\nin float roughness,\n#ifdef ANISOTROPIC_TEXTURE\nin vec3 anisotropyMapData,\n#endif\nin mat3 TBN,\nin vec3 normalW,\nin vec3 viewDirectionW\n)\n{anisotropicOutParams outParams;float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\n#ifdef ANISOTROPIC_TEXTURE\nanisotropy*=anisotropyMapData.b;\n#if DEBUGMODE>0\noutParams.anisotropyMapData=anisotropyMapData;\n#endif\nanisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;\n#ifdef ANISOTROPIC_LEGACY\nanisotropyDirection.rg*=anisotropyMapData.rg;\n#else\nanisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);\n#endif\n#endif\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);return outParams;}\n#endif\n"
			}
		}),
		Fl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js"() {
				h(), e.IncludesShadersStore.pbrBlockReflection = "#ifdef REFLECTION\nstruct reflectionOutParams\n{vec4 environmentRadiance;vec3 environmentIrradiance;\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords;\n#else\nvec2 reflectionCoords;\n#endif\n#ifdef SS_TRANSLUCENCY\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\nvec3 irradianceVector;\n#endif\n#endif\n#endif\n};\n#define pbr_inline\nvoid createReflectionCoords(\nin vec3 vPositionW,\nin vec3 normalW,\n#ifdef ANISOTROPIC\nin anisotropicOutParams anisotropicOut,\n#endif\n#ifdef REFLECTIONMAP_3D\nout vec3 reflectionCoords\n#else\nout vec2 reflectionCoords\n#endif\n)\n{\n#ifdef ANISOTROPIC\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\n#else\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionCoords=reflectionVector;\n#else\nreflectionCoords=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n}\n#define pbr_inline\n#define inline\nvoid sampleReflectionTexture(\nin float alphaG,\nin vec3 vReflectionMicrosurfaceInfos,\nin vec2 vReflectionInfos,\nin vec3 vReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nin float NdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nin float roughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSampler,\nconst vec3 reflectionCoords,\n#else\nin sampler2D reflectionSampler,\nconst vec2 reflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\nin samplerCube reflectionSamplerLow,\nin samplerCube reflectionSamplerHigh,\n#else\nin sampler2D reflectionSamplerLow,\nin sampler2D reflectionSamplerHigh,\n#endif\n#endif\n#ifdef REALTIME_FILTERING\nin vec2 vReflectionFilteringInfo,\n#endif\nout vec4 environmentRadiance\n)\n{\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\n#elif defined(LINEARSPECULARREFLECTION)\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\n#else\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\n#endif\n#ifdef LODBASEDMICROSFURACE\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\n#ifdef LODINREFLECTIONALPHA\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\n#else\nfloat requestedReflectionLOD=reflectionLOD;\n#endif\n#ifdef REALTIME_FILTERING\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\n#else\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\n#endif\n#else\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\nenvironmentMid,\nlodReflectionNormalizedDoubled\n);} else {environmentRadiance=mix(\nenvironmentMid,\nsampleReflection(reflectionSamplerLow,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef RGBDREFLECTION\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\n#endif\nenvironmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}\n#define pbr_inline\n#define inline\nreflectionOutParams reflectionBlock(\nin vec3 vPositionW\n,in vec3 normalW\n,in float alphaG\n,in vec3 vReflectionMicrosurfaceInfos\n,in vec2 vReflectionInfos\n,in vec3 vReflectionColor\n#ifdef ANISOTROPIC\n,in anisotropicOutParams anisotropicOut\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,in float NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,in float roughness\n#endif\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSampler\n#else\n,in sampler2D reflectionSampler\n#endif\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n,in vec3 vEnvironmentIrradiance\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,in mat4 reflectionMatrix\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\n,in samplerCube irradianceSampler\n#else\n,in sampler2D irradianceSampler\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSamplerLow\n,in samplerCube reflectionSamplerHigh\n#else\n,in sampler2D reflectionSamplerLow\n,in sampler2D reflectionSamplerHigh\n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vReflectionFilteringInfo\n#endif\n)\n{reflectionOutParams outParams;vec4 environmentRadiance=vec4(0.,0.,0.,0.);\n#ifdef REFLECTIONMAP_3D\nvec3 reflectionCoords=vec3(0.);\n#else\nvec2 reflectionCoords=vec2(0.);\n#endif\ncreateReflectionCoords(\nvPositionW,\nnormalW,\n#ifdef ANISOTROPIC\nanisotropicOut,\n#endif\nreflectionCoords\n);sampleReflectionTexture(\nalphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nroughness,\n#endif\n#ifdef REFLECTIONMAP_3D\nreflectionSampler,\nreflectionCoords,\n#else\nreflectionSampler,\nreflectionCoords,\n#endif\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentRadiance\n);vec3 environmentIrradiance=vec3(0.,0.,0.);\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\nenvironmentIrradiance=vEnvironmentIrradiance;\n#else\n#ifdef ANISOTROPIC\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\n#else\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#if defined(REALTIME_FILTERING)\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\n#else\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\n#endif\n#ifdef SS_TRANSLUCENCY\noutParams.irradianceVector=irradianceVector;\n#endif\n#endif\n#elif defined(USEIRRADIANCEMAP)\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;\n#ifdef RGBDREFLECTION\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\n#endif\n#ifdef GAMMAREFLECTION\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\nenvironmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;return outParams;}\n#endif\n"
			}
		}),
		Ll = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js"() {
				h(), e.IncludesShadersStore.pbrBlockSheen = "#ifdef SHEEN\nstruct sheenOutParams\n{float sheenIntensity;vec3 sheenColor;float sheenRoughness;\n#ifdef SHEEN_LINKWITHALBEDO\nvec3 surfaceAlbedo;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfloat sheenAlbedoScaling;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 finalSheenRadianceScaled;\n#endif\n#if DEBUGMODE>0\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData;\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nvec3 sheenEnvironmentReflectance;\n#endif\n#endif\n};\n#define pbr_inline\n#define inline\nsheenOutParams sheenBlock(\nin vec4 vSheenColor\n#ifdef SHEEN_ROUGHNESS\n,in float vSheenRoughness\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,in vec4 sheenMapRoughnessData\n#endif\n#endif\n,in float roughness\n#ifdef SHEEN_TEXTURE\n,in vec4 sheenMapData\n,in float sheenMapLevel\n#endif\n,in float reflectance\n#ifdef SHEEN_LINKWITHALBEDO\n,in vec3 baseColor\n,in vec3 surfaceAlbedo\n#endif\n#ifdef ENVIRONMENTBRDF\n,in float NdotV\n,in vec3 environmentBrdf\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,in vec2 AARoughnessFactors\n,in vec3 vReflectionMicrosurfaceInfos\n,in vec2 vReflectionInfos\n,in vec3 vReflectionColor\n,in vec4 vLightingIntensity\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSampler\n,in vec3 reflectionCoords\n#else\n,in sampler2D reflectionSampler\n,in vec2 reflectionCoords\n#endif\n,in float NdotVUnclamped\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSamplerLow\n,in samplerCube reflectionSamplerHigh\n#else\n,in sampler2D reflectionSamplerLow\n,in sampler2D reflectionSamplerHigh\n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vReflectionFilteringInfo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\n,in float seo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\n,in float eho\n#endif\n#endif\n)\n{sheenOutParams outParams;float sheenIntensity=vSheenColor.a;\n#ifdef SHEEN_TEXTURE\n#if DEBUGMODE>0\noutParams.sheenMapData=sheenMapData;\n#endif\n#endif\n#ifdef SHEEN_LINKWITHALBEDO\nfloat sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#else\nvec3 sheenColor=vSheenColor.rgb;\n#ifdef SHEEN_TEXTURE\n#ifdef SHEEN_GAMMATEXTURE\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\n#else\nsheenColor.rgb*=sheenMapData.rgb;\n#endif\nsheenColor.rgb*=sheenMapLevel;\n#endif\n#ifdef SHEEN_ROUGHNESS\nfloat sheenRoughness=vSheenRoughness;\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\n#if defined(SHEEN_TEXTURE)\nsheenRoughness*=sheenMapData.a;\n#endif\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\nsheenRoughness*=sheenMapRoughnessData.a;\n#endif\n#else\nfloat sheenRoughness=roughness;\n#ifdef SHEEN_TEXTURE\nsheenIntensity*=sheenMapData.a;\n#endif\n#endif\n#if !defined(SHEEN_ALBEDOSCALING)\nsheenIntensity*=(1.-reflectance);\n#endif\nsheenColor*=sheenIntensity;\n#endif\n#ifdef ENVIRONMENTBRDF\n/*#ifdef SHEEN_SOFTER\nvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\n#else*/\n#ifdef SHEEN_ROUGHNESS\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\n#else\nvec3 environmentSheenBrdf=environmentBrdf;\n#endif\n/*#endif*/\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\n#ifdef SPECULARAA\nsheenAlphaG+=AARoughnessFactors.y;\n#endif\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(\nsheenAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nsheenRoughness,\n#endif\nreflectionSampler,\nreflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentSheenRadiance\n);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\nsheenEnvironmentReflectance*=seo;\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\nsheenEnvironmentReflectance*=eho;\n#endif\n#if DEBUGMODE>0\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\n#endif\noutParams.finalSheenRadianceScaled=\nenvironmentSheenRadiance.rgb *\nsheenEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\n#endif\noutParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;return outParams;}\n#endif\n"
			}
		}),
		Bl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js"() {
				h(), e.IncludesShadersStore.pbrBlockClearcoat = "struct clearcoatOutParams\n{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;\n#ifdef REFLECTION\nvec3 finalClearCoatRadianceScaled;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;\n#endif\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nvec3 energyConservationFactorClearCoat;\n#endif\n#if DEBUGMODE>0\n#ifdef CLEARCOAT_BUMP\nmat3 TBNClearCoat;\n#endif\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData;\n#endif\n#ifdef REFLECTION\nvec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;\n#endif\nfloat clearCoatNdotV;\n#endif\n};\n#ifdef CLEARCOAT\n#define pbr_inline\n#define inline\nclearcoatOutParams clearcoatBlock(\nin vec3 vPositionW\n,in vec3 geometricNormalW\n,in vec3 viewDirectionW\n,in vec2 vClearCoatParams\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,in vec4 clearCoatMapRoughnessData\n#endif\n,in vec3 specularEnvironmentR0\n#ifdef CLEARCOAT_TEXTURE\n,in vec2 clearCoatMapData\n#endif\n#ifdef CLEARCOAT_TINT\n,in vec4 vClearCoatTintParams\n,in float clearCoatColorAtDistance\n,in vec4 vClearCoatRefractionParams\n#ifdef CLEARCOAT_TINT_TEXTURE\n,in vec4 clearCoatTintMapData\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\n,in vec2 vClearCoatBumpInfos\n,in vec4 clearCoatBumpMapData\n,in vec2 vClearCoatBumpUV\n#if defined(TANGENT) && defined(NORMAL)\n,in mat3 vTBN\n#else\n,in vec2 vClearCoatTangentSpaceParams\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n,in mat4 normalMatrix\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\n,in vec3 faceNormal\n#endif\n#ifdef REFLECTION\n,in vec3 vReflectionMicrosurfaceInfos\n,in vec2 vReflectionInfos\n,in vec3 vReflectionColor\n,in vec4 vLightingIntensity\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSampler\n#else\n,in sampler2D reflectionSampler\n#endif\n#ifndef LODBASEDMICROSFURACE\n#ifdef REFLECTIONMAP_3D\n,in samplerCube reflectionSamplerLow\n,in samplerCube reflectionSamplerHigh\n#else\n,in sampler2D reflectionSamplerLow\n,in sampler2D reflectionSamplerHigh\n#endif\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vReflectionFilteringInfo\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n,in float ambientMonochrome\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n,in float frontFacingMultiplier\n#endif\n)\n{clearcoatOutParams outParams;float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\nclearCoatRoughness*=clearCoatMapData.y;\n#endif\n#if DEBUGMODE>0\noutParams.clearCoatMapData=clearCoatMapData;\n#endif\n#endif\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\n#endif\noutParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;\n#ifdef CLEARCOAT_TINT_TEXTURE\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\n#else\nclearCoatColor*=clearCoatTintMapData.rgb;\n#endif\nclearCoatThickness*=clearCoatTintMapData.a;\n#if DEBUGMODE>0\noutParams.clearCoatTintMapData=clearCoatTintMapData;\n#endif\n#endif\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;\n#endif\n#ifdef CLEARCOAT_REMAP_F0\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\n#else\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\n#endif\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;\n#ifdef CLEARCOAT_BUMP\n#ifdef NORMALXYSCALE\nfloat clearCoatNormalScale=1.0;\n#else\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBNClearCoat=vTBN;\n#else\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\n#endif\n#if DEBUGMODE>0\noutParams.TBNClearCoat=TBNClearCoat;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\n#else\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\n#endif\noutParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\n#if DEBUGMODE>0\noutParams.clearCoatNdotV=clearCoatNdotV;\n#endif\n#ifdef CLEARCOAT_TINT\nvec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\n#endif\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\n#endif\n#if defined(REFLECTION)\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\n#ifdef SPECULARAA\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\n#endif\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nclearCoatReflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\n#else\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\n#endif\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\n#endif\nsampleReflectionTexture(\nclearCoatAlphaG,\nvReflectionMicrosurfaceInfos,\nvReflectionInfos,\nvReflectionColor,\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\nclearCoatNdotVUnclamped,\n#endif\n#ifdef LINEARSPECULARREFLECTION\nclearCoatRoughness,\n#endif\nreflectionSampler,\nclearCoatReflectionCoords,\n#ifndef LODBASEDMICROSFURACE\nreflectionSamplerLow,\nreflectionSamplerHigh,\n#endif\n#ifdef REALTIME_FILTERING\nvReflectionFilteringInfo,\n#endif\nenvironmentClearCoatRadiance\n);\n#if DEBUGMODE>0\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;\n#endif\n#endif\n#endif\n#else\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\n#endif\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\n#if DEBUGMODE>0\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\n#endif\noutParams.finalClearCoatRadianceScaled=\nenvironmentClearCoatRadiance.rgb *\nclearCoatEnvironmentReflectance *\nvLightingIntensity.z;\n#endif\n#if defined(CLEARCOAT_TINT)\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\n#endif\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\n#endif\nreturn outParams;}\n#endif\n"
			}
		}),
		Gl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js"() {
				h(), e.IncludesShadersStore.pbrBlockIridescence = "struct iridescenceOutParams\n{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};\n#ifdef IRIDESCENCE\n#define pbr_inline\n#define inline\niridescenceOutParams iridescenceBlock(\nin vec4 vIridescenceParams\n,in float viewAngle\n,in vec3 specularEnvironmentR0\n#ifdef IRIDESCENCE_TEXTURE\n,in vec2 iridescenceMapData\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\n,in vec2 iridescenceThicknessMapData\n#endif\n#ifdef CLEARCOAT\n,in float NdotVUnclamped\n#ifdef CLEARCOAT_TEXTURE\n,in vec2 clearCoatMapData\n#endif\n#endif\n)\n{iridescenceOutParams outParams;float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;\n#ifdef IRIDESCENCE_TEXTURE\niridescenceIntensity*=iridescenceMapData.x;\n#endif\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\n#endif\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; \n#ifdef CLEARCOAT\nfloat clearCoatIntensity=vClearCoatParams.x;\n#ifdef CLEARCOAT_TEXTURE\nclearCoatIntensity*=clearCoatMapData.x;\n#endif\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\n#endif\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;return outParams;}\n#endif\n"
			}
		}),
		Hl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js"() {
				h(), e.IncludesShadersStore.pbrBlockSubSurface = "struct subSurfaceOutParams\n{vec3 specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nvec3 finalRefraction;vec3 surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nfloat alpha;\n#endif\n#ifdef REFLECTION\nfloat refractionFactorForIrradiance;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nvec3 transmittance;float translucencyIntensity;\n#ifdef REFLECTION\nvec3 refractionIrradiance;\n#endif\n#endif\n#if DEBUGMODE>0\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction;vec3 refractionTransmittance;\n#endif\n#endif\n};\n#ifdef SUBSURFACE\n#ifdef SS_REFRACTION\n#define pbr_inline\n#define inline\nvec4 sampleEnvironmentRefraction(\nin float ior\n,in float thickness\n,in float refractionLOD\n,in vec3 normalW\n,in vec3 vPositionW\n,in vec3 viewDirectionW\n,in mat4 view\n,in vec4 vRefractionInfos\n,in mat4 refractionMatrix\n,in vec4 vRefractionMicrosurfaceInfos\n,in float alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,in samplerCube refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in samplerCube refractionSamplerLow\n,in samplerCube refractionSamplerHigh\n#endif\n#else\n,in sampler2D refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in sampler2D refractionSamplerLow\n,in sampler2D refractionSamplerHigh\n#endif\n#endif\n#ifdef ANISOTROPIC\n,in anisotropicOutParams anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,in vec3 refractionPosition\n,in vec3 refractionSize\n#endif\n) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef ANISOTROPIC\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);\n#else\nvec3 refractionVector=refract(-viewDirectionW,normalW,ior);\n#endif\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\nrefractionVector.z*=-1.0;\n#endif\n#ifdef SS_REFRACTIONMAP_3D\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\n#else\n#ifdef SS_USE_THICKNESS_AS_DEPTH\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\n#endif\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;\n#endif\n#ifdef LODBASEDMICROSFURACE\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\n#ifdef SS_LODINREFRACTIONALPHA\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\n#else\nfloat requestedRefractionLOD=refractionLOD;\n#endif\n#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\n#else\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\n#endif\n#else\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(\nsampleRefraction(refractionSamplerHigh,refractionCoords),\nenvironmentRefractionMid,\nlodRefractionNormalizedDoubled\n);} else {environmentRefraction=mix(\nenvironmentRefractionMid,\nsampleRefraction(refractionSamplerLow,refractionCoords),\nlodRefractionNormalizedDoubled-1.0\n);}\n#endif\n#ifdef SS_RGBDREFRACTION\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\n#endif\n#ifdef SS_GAMMAREFRACTION\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\n#endif\nreturn environmentRefraction;}\n#endif\n#define pbr_inline\n#define inline\nsubSurfaceOutParams subSurfaceBlock(\nin vec3 vSubSurfaceIntensity\n,in vec2 vThicknessParam\n,in vec4 vTintColor\n,in vec3 normalW\n,in vec3 specularEnvironmentReflectance\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n,in vec4 thicknessMap\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n,in vec4 refractionIntensityMap\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\n,in vec4 translucencyIntensityMap\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\n,in mat4 reflectionMatrix\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,in vec3 irradianceVector_\n#endif\n#if defined(REALTIME_FILTERING)\n,in samplerCube reflectionSampler\n,in vec2 vReflectionFilteringInfo\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n#ifdef REFLECTIONMAP_3D\n,in samplerCube irradianceSampler\n#else\n,in sampler2D irradianceSampler\n#endif\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n,in vec3 surfaceAlbedo\n#endif\n#ifdef SS_REFRACTION\n,in vec3 vPositionW\n,in vec3 viewDirectionW\n,in mat4 view\n,in vec4 vRefractionInfos\n,in mat4 refractionMatrix\n,in vec4 vRefractionMicrosurfaceInfos\n,in vec4 vLightingIntensity\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n,in float alpha\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\n,in float NdotVUnclamped\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\n,in float roughness\n#endif\n,in float alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,in samplerCube refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in samplerCube refractionSamplerLow\n,in samplerCube refractionSamplerHigh\n#endif\n#else\n,in sampler2D refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,in sampler2D refractionSamplerLow\n,in sampler2D refractionSamplerHigh\n#endif\n#endif\n#ifdef ANISOTROPIC\n,in anisotropicOutParams anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,in vec2 vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,in vec3 refractionPosition\n,in vec3 refractionSize\n#endif\n#ifdef SS_DISPERSION\n,in float dispersion\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\n,in vec3 vDiffusionDistance\n,in vec4 vTranslucencyColor\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\n,in vec4 translucencyColorMap\n#endif\n#endif\n)\n{subSurfaceOutParams outParams;outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#ifdef SS_REFRACTION\nfloat refractionIntensity=vSubSurfaceIntensity.x;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nrefractionIntensity*=(1.0-alpha);outParams.alpha=1.0;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n#ifdef SS_USE_GLTF_TEXTURES\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\n#else\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\n#endif\n#if DEBUGMODE>0\noutParams.thicknessMap=thicknessMap;\n#endif\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS)\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=thicknessMap.r;\n#else\nrefractionIntensity*=thicknessMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS)\n#ifdef SS_USE_GLTF_TEXTURES\ntranslucencyIntensity*=thicknessMap.a;\n#else\ntranslucencyIntensity*=thicknessMap.b;\n#endif\n#endif\n#else\nfloat thickness=vThicknessParam.y;\n#endif\n#if defined(SS_REFRACTION) && defined(SS_REFRACTIONINTENSITY_TEXTURE)\n#ifdef SS_USE_GLTF_TEXTURES\nrefractionIntensity*=refractionIntensityMap.r;\n#else\nrefractionIntensity*=refractionIntensityMap.g;\n#endif\n#endif\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCYINTENSITY_TEXTURE)\n#ifdef SS_USE_GLTF_TEXTURES\ntranslucencyIntensity*=translucencyIntensityMap.a;\n#else\ntranslucencyIntensity*=translucencyIntensityMap.b;\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\nthickness=maxEps(thickness);vec4 translucencyColor=vTranslucencyColor;\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\ntranslucencyColor*=translucencyColorMap;\n#endif\nvec3 transmittance=transmittanceBRDF_Burley(translucencyColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;\n#endif\n#ifdef SS_REFRACTION\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\n#ifdef SS_HAS_THICKNESS\nfloat ior=vRefractionInfos.y;\n#else\nfloat ior=vRefractionMicrosurfaceInfos.w;\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\n#elif defined(SS_LINEARSPECULARREFRACTION)\nfloat refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\n#else\nfloat refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\n#endif\nfloat refraction_ior=vRefractionInfos.y;\n#ifdef SS_DISPERSION\nfloat realIOR=1.0/refraction_ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {refraction_ior=iors[i];\n#endif\nvec4 envSample=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG\n#ifdef SS_REFRACTIONMAP_3D\n,refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionSamplerLow\n,refractionSamplerHigh\n#endif\n#else\n,refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionSamplerLow\n,refractionSamplerHigh\n#endif\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,refractionPosition\n,refractionSize\n#endif\n);\n#ifdef SS_DISPERSION\nenvironmentRefraction[i]=envSample[i];}\n#else\nenvironmentRefraction=envSample;\n#endif\nenvironmentRefraction.rgb*=vRefractionInfos.x;\n#endif\n#ifdef SS_REFRACTION\nvec3 refractionTransmittance=vec3(refractionIntensity);\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;\n#else\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\n#endif\n#ifdef SS_ALBEDOFORREFRACTIONTINT\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\n#ifdef REFLECTION\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\n#endif\n#ifdef UNUSED_MULTIPLEBOUNCES\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\n#endif\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\n#if DEBUGMODE>0\noutParams.refractionTransmittance=refractionTransmittance;\n#endif\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\n#if DEBUGMODE>0\noutParams.environmentRefraction=environmentRefraction;\n#endif\n#endif\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\n#ifdef REFLECTIONMAP_OPPOSITEZ\nirradianceVector.z*=-1.0;\n#endif\n#ifdef INVERTCUBICMAP\nirradianceVector.y*=-1.0;\n#endif\n#else\nvec3 irradianceVector=irradianceVector_;\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP)\n#if defined(REALTIME_FILTERING)\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\n#else\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\n#endif\n#elif defined(USEIRRADIANCEMAP)\n#ifdef REFLECTIONMAP_3D\nvec3 irradianceCoords=irradianceVector;\n#else\nvec2 irradianceCoords=irradianceVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nirradianceCoords/=irradianceVector.z;\n#endif\nirradianceCoords.y=1.0-irradianceCoords.y;\n#endif\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\n#ifdef RGBDREFLECTION\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\n#endif\n#ifdef GAMMAREFLECTION\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\n#endif\n#else\nvec4 refractionIrradiance=vec4(0.);\n#endif\nrefractionIrradiance.rgb*=transmittance;\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\n#endif\noutParams.refractionIrradiance=refractionIrradiance.rgb;\n#endif\nreturn outParams;}\n#endif\n"
			}
		}),
		Ul = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js"() {
				h(), e.IncludesShadersStore.pbrBlockNormalGeometric = "vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#endif\nvec3 geometricNormalW=normalW;\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\n#endif\n"
			}
		}),
		Vl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js"() {
				h(), e.IncludesShadersStore.pbrBlockNormalFinal = "#if defined(FORCENORMALFORWARD) && defined(NORMAL)\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\n#if defined(TWOSIDEDLIGHTING)\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\n#endif\nnormalW*=sign(dot(normalW,faceNormal));\n#endif\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n"
			}
		}),
		Wl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js"() {
				h(), e.IncludesShadersStore.pbrBlockLightmapInit = "#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\n#ifdef GAMMALIGHTMAP\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n"
			}
		}),
		zl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js"() {
				h(), e.IncludesShadersStore.pbrBlockGeometryInfo = "float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\n#ifdef SPECULARAA\nalphaG+=AARoughnessFactors.y;\n#endif\n#if defined(ENVIRONMENTBRDF)\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n#ifdef AMBIENTINGRAYSCALE\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\n#else\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\n#endif\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\n#endif\n#endif\n#endif\n#endif\n"
			}
		}),
		Xl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js"() {
				h(), e.IncludesShadersStore.pbrBlockReflectance0 = "float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\n#ifdef METALLICWORKFLOW\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\n#else \nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\n#endif\n#ifdef ALPHAFRESNEL\nfloat reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;\n#endif\n"
			}
		}),
		Yl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js"() {
				h(), e.IncludesShadersStore.pbrBlockReflectance = "#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\n#ifdef RADIANCEOCCLUSION\nspecularEnvironmentReflectance*=seo;\n#endif\n#ifdef HORIZONOCCLUSION\n#ifdef BUMP\n#ifdef REFLECTIONMAP_3D\nspecularEnvironmentReflectance*=eho;\n#endif\n#endif\n#endif\n#else\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n#endif\n#ifdef CLEARCOAT\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\n#endif\n#endif\n"
			}
		}),
		jl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js"() {
				h(), e.IncludesShadersStore.pbrBlockDirectLighting = "vec3 diffuseBase=vec3(0.,0.,0.);\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatBase=vec3(0.,0.,0.);\n#endif\n#ifdef SHEEN\nvec3 sheenBase=vec3(0.,0.,0.);\n#endif\npreLightingInfo preInfo;lightingInfo info;float shadow=1.; \nfloat aggShadow=0.;float numLights=0.;\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\nvec3 absorption=vec3(0.);\n#endif\n"
			}
		}),
		Kl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js"() {
				h(), e.IncludesShadersStore.pbrBlockFinalLitComponents = "aggShadow=aggShadow/numLights;\n#if defined(ENVIRONMENTBRDF)\n#ifdef MS_BRDF_ENERGY_CONSERVATION\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\n#endif\n#endif\n#ifndef METALLICWORKFLOW\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\n#endif\n#endif\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\n#endif\n#ifdef REFLECTION\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\n#if defined(CLEARCOAT)\nfinalIrradiance*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nfinalIrradiance*=clearcoatOut.absorption;\n#endif\n#endif\n#if defined(SS_REFRACTION)\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\n#endif\n#if defined(SS_TRANSLUCENCY)\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;\n#endif\nfinalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalSpecularScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef REFLECTION\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalRadianceScaled*=energyConservationFactor;\n#endif\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\n#endif\n#endif\n#ifdef SHEEN\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\n#if defined(CLEARCOAT_TINT)\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef CLEARCOAT\nvec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\n#ifdef CLEARCOAT_TINT\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\n#endif\n#endif\n#endif\n#ifdef ALPHABLEND\nfloat luminanceOverAlpha=0.0;\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\n#if defined(CLEARCOAT)\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\n#endif\n#endif\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\n#endif\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\n#endif\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\n#endif\n#endif\n"
			}
		}),
		$l = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js"() {
				h(), e.IncludesShadersStore.pbrBlockFinalUnlitComponents = "vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\n#ifdef GAMMAEMISSIVE\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\n#else\nfinalEmissive*=emissiveColorTex.rgb;\n#endif\nfinalEmissive*= vEmissiveInfos.y;\n#endif\nfinalEmissive*=vLightingIntensity.y;\n#ifdef AMBIENT\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\n#else\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\n#endif\nfinalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;\n"
			}
		}),
		Jl = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js"() {
				h(), e.IncludesShadersStore.pbrBlockFinalColorComposition = "vec4 finalColor=vec4(\n#ifndef UNLIT\n#ifdef REFLECTION\nfinalIrradiance +\n#endif\n#ifdef SPECULARTERM\nfinalSpecularScaled +\n#endif\n#ifdef SHEEN\nfinalSheenScaled +\n#endif\n#ifdef CLEARCOAT\nfinalClearCoatScaled +\n#endif\n#ifdef REFLECTION\nfinalRadianceScaled +\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\nsheenOut.finalSheenRadianceScaled +\n#endif\n#ifdef CLEARCOAT\nclearcoatOut.finalClearCoatRadianceScaled +\n#endif\n#endif\n#ifdef SS_REFRACTION\nsubSurfaceOut.finalRefraction +\n#endif\n#endif\nfinalAmbient +\nfinalDiffuse,\nalpha);\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor.rgb;\n#else\nfinalColor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\nfinalColor.rgb+=finalEmissive;\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,0.0);\n"
			}
		}),
		ql = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js"() {
				h(), e.IncludesShadersStore.pbrBlockImageProcessing = "#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\n#if !defined(SKIPFINALCOLORCLAMP)\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\n#endif\n#else\nfinalColor=applyImageProcessing(finalColor);\n#endif\nfinalColor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\nfinalColor.rgb*=finalColor.a;\n#endif\n"
			}
		}),
		Ql = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js"() {
				h(), e.IncludesShadersStore.pbrDebug = "#if DEBUGMODE>0\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\n#if DEBUGMODE==1\ngl_FragColor.rgb=vPositionW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==2 && defined(NORMAL)\ngl_FragColor.rgb=vNormalW.rgb;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\ngl_FragColor.rgb=TBN[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==5\ngl_FragColor.rgb=normalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==6 && defined(MAINUV1)\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\n#elif DEBUGMODE==7 && defined(MAINUV2)\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\n#define DEBUGMODE_NORMALIZE\n#elif DEBUGMODE==20 && defined(ALBEDO)\ngl_FragColor.rgb=albedoTexture.rgb;\n#ifndef GAMMAALBEDO\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==21 && defined(AMBIENT)\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\n#elif DEBUGMODE==22 && defined(OPACITY)\ngl_FragColor.rgb=opacityMap.rgb;\n#elif DEBUGMODE==23 && defined(EMISSIVE)\ngl_FragColor.rgb=emissiveColorTex.rgb;\n#ifndef GAMMAEMISSIVE\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\ngl_FragColor.rgb=lightmapColor.rgb;\n#ifndef GAMMALIGHTMAP\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\n#elif DEBUGMODE==32 && defined(BUMP)\ngl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==41 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==50\ngl_FragColor.rgb=diffuseBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\ngl_FragColor.rgb=specularBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\ngl_FragColor.rgb=clearCoatBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==53 && defined(SHEEN)\ngl_FragColor.rgb=sheenBase.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==54 && defined(REFLECTION)\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\n#ifndef GAMMAREFLECTION\n#define DEBUGMODE_GAMMA\n#endif\n#elif DEBUGMODE==60\ngl_FragColor.rgb=surfaceAlbedo.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==61\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\ngl_FragColor.rgb=reflectivityOut.metallicF0;\n#elif DEBUGMODE==63\ngl_FragColor.rgb=vec3(roughness);\n#elif DEBUGMODE==64\ngl_FragColor.rgb=vec3(alphaG);\n#elif DEBUGMODE==65\ngl_FragColor.rgb=vec3(NdotV);\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\ngl_FragColor.rgb=subSurfaceOut.transmittance;\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\n#elif DEBUGMODE==72\ngl_FragColor.rgb=vec3(microSurface);\n#elif DEBUGMODE==73\ngl_FragColor.rgb=vAlbedoColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)\ngl_FragColor.rgb=vReflectivityColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==75\ngl_FragColor.rgb=vEmissiveColor.rgb;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\ngl_FragColor.rgb=vec3(seo);\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\ngl_FragColor.rgb=vec3(eho);\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\ngl_FragColor.rgb=vec3(energyConservationFactor);\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=specularEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\n#define DEBUGMODE_GAMMA\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\n#elif DEBUGMODE==87\ngl_FragColor.rgb=vec3(alpha);\n#elif DEBUGMODE==88 && defined(ALBEDO)\ngl_FragColor.rgb=vec3(albedoTexture.a);\n#elif DEBUGMODE==89\ngl_FragColor.rgb=aoOut.ambientOcclusionColor.rgb;\n#else\nfloat stripeWidth=30.;float stripePos=floor(gl_FragCoord.x/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);\n#endif\ngl_FragColor.rgb*=vDebugMode.y;\n#ifdef DEBUGMODE_NORMALIZE\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\n#endif\n#ifdef DEBUGMODE_GAMMA\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\n#endif\ngl_FragColor.a=1.0;\n#ifdef PREPASS\ngl_FragData[0]=toLinearSpace(gl_FragColor); \ngl_FragData[1]=vec4(0.,0.,0.,0.); \n#endif\n#ifdef DEBUGMODE_FORCERETURN\nreturn;\n#endif\n}\n#endif\n"
			}
		}),
		Zl = {};
	l(Zl, {
		pbrPixelShader: () => _l
	});
	var eh = o({
			"../node_modules/.pnpm/@babylonjs+core@7.21.1/node_modules/@babylonjs/core/Shaders/pbr.fragment.js"() {
				h(), Aa(), ba(), vl(), ul(), yl(), Ne(), He(), El(), Ta(), _s(), aa(), Ct(), tt(), Al(), bl(), xl(), wa(), ut(), ml(), Ml(), Cl(), Tl(), wl(), Rl(), Nl(), Ra(), Na(), Ca(), Il(), Pl(), kl(), Dl(), Ol(), Fl(), Ll(), Bl(), Gl(), Hl(), gs(), Ul(), Ia(), Vl(), ka(), Wl(), zl(), Xl(), Yl(), jl(), Oe(), Kl(), $l(), Jl(), Da(), Oa(), ql(), Fa(), Ql(), fl = "pbrPixelShader", pl = "#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\nprecision highp float;\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<__decl__pbrFragment>\n#include<pbrFragmentExtraDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nalbedoOpacityOutParams albedoOpacityOut;\n#ifdef ALBEDO\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#endif\n#ifdef DECAL\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#endif\nalbedoOpacityOut=albedoOpacityBlock(\nvAlbedoColor\n#ifdef ALBEDO\n,albedoTexture\n,vAlbedoInfos\n#endif\n#ifdef OPACITY\n,opacityMap\n,vOpacityInfos\n#endif\n#ifdef DETAIL\n,detailColor\n,vDetailInfos\n#endif\n#ifdef DECAL\n,decalColor\n,vDecalInfos\n#endif\n);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nambientOcclusionOutParams aoOut;\n#ifdef AMBIENT\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\n#endif\naoOut=ambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nvAmbientInfos\n#endif \n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;\n#if defined(REFLECTIVITY)\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef METALLICWORKFLOW\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\n#endif\n#ifdef METALLIC_REFLECTANCE\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\n#endif\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityOut=reflectivityBlock(\nvReflectivityColor\n#ifdef METALLICWORKFLOW\n,surfaceAlbedo\n,metallicReflectanceFactors\n#endif\n#ifdef REFLECTIVITY\n,vReflectivityInfos\n,surfaceMetallicOrReflectivityColorMap\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n,aoOut.ambientOcclusionColor\n#endif\n#ifdef MICROSURFACEMAP\n,microSurfaceTexel\n#endif\n#ifdef DETAIL\n,detailColor\n,vDetailInfos\n#endif\n);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nalphaFresnelOutParams alphaFresnelOut;alphaFresnelOut=alphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface\n);alpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nanisotropicOutParams anisotropicOut;\n#ifdef ANISOTROPIC_TEXTURE\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\n#endif\nanisotropicOut=anisotropicBlock(\nvAnisotropy,\nroughness,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW \n);\n#endif\n#ifdef REFLECTION\nreflectionOutParams reflectionOut;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionOut=reflectionBlock(\nvPositionW\n,normalW\n,alphaG\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness\n#endif\n,reflectionSampler\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n,vEnvironmentIrradiance\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,reflectionMatrix\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n#endif\n#ifndef LODBASEDMICROSFURACE\n,reflectionSamplerLow\n,reflectionSamplerHigh\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nsheenOutParams sheenOut;\n#ifdef SHEEN_TEXTURE\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\n#endif\nsheenOut=sheenBlock(\nvSheenColor\n#ifdef SHEEN_ROUGHNESS\n,vSheenRoughness\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,sheenMapRoughnessData\n#endif\n#endif\n,roughness\n#ifdef SHEEN_TEXTURE\n,sheenMapData\n,vSheenInfos.y\n#endif\n,reflectance\n#ifdef SHEEN_LINKWITHALBEDO\n,baseColor\n,surfaceAlbedo\n#endif\n#ifdef ENVIRONMENTBRDF\n,NdotV\n,environmentBrdf\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,AARoughnessFactors\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n,vLightingIntensity\n,reflectionSampler\n,reflectionOut.reflectionCoords\n,NdotVUnclamped\n#ifndef LODBASEDMICROSFURACE\n,reflectionSamplerLow\n,reflectionSamplerHigh\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\n,seo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\n,eho\n#endif\n#endif\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\niridescenceOutParams iridescenceOut;\n#ifdef IRIDESCENCE_TEXTURE\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\n#endif\niridescenceOut=iridescenceBlock(\nvIridescenceParams\n,NdotV\n,specularEnvironmentR0\n#ifdef IRIDESCENCE_TEXTURE\n,iridescenceMapData\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\n,iridescenceThicknessMapData\n#endif\n#ifdef CLEARCOAT\n,NdotVUnclamped\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#endif\n);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nclearcoatOutParams clearcoatOut;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatOut=clearcoatBlock(\nvPositionW\n,geometricNormalW\n,viewDirectionW\n,vClearCoatParams\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,clearCoatMapRoughnessData\n#endif\n,specularEnvironmentR0\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#ifdef CLEARCOAT_TINT\n,vClearCoatTintParams\n,clearCoatColorAtDistance\n,vClearCoatRefractionParams\n#ifdef CLEARCOAT_TINT_TEXTURE\n,clearCoatTintMapData\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\n,vClearCoatBumpInfos\n,clearCoatBumpMapData\n,vClearCoatBumpUV\n#if defined(TANGENT) && defined(NORMAL)\n,vTBN\n#else\n,vClearCoatTangentSpaceParams\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n,normalMatrix\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\n,faceNormal\n#endif\n#ifdef REFLECTION\n,vReflectionMicrosurfaceInfos\n,vReflectionInfos\n,vReflectionColor\n,vLightingIntensity\n,reflectionSampler\n#ifndef LODBASEDMICROSFURACE\n,reflectionSamplerLow\n,reflectionSamplerHigh\n#endif\n#ifdef REALTIME_FILTERING\n,vReflectionFilteringInfo\n#endif\n#endif\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n#ifdef RADIANCEOCCLUSION\n,ambientMonochrome\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n,(gl_FrontFacing ? 1. : -1.)\n#endif\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nsubSurfaceOutParams subSurfaceOut;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\nvec4 translucencyColorMap=texture2D(translucencyColorSampler,vTranslucencyColorUV+uvOffset);\n#endif\nsubSurfaceOut=subSurfaceBlock(\nvSubSurfaceIntensity\n,vThicknessParam\n,vTintColor\n,normalW\n,specularEnvironmentReflectance\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n,thicknessMap\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n,refractionIntensityMap\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\n,translucencyIntensityMap\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\n,reflectionMatrix\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,reflectionOut.irradianceVector\n#endif\n#if defined(REALTIME_FILTERING)\n,reflectionSampler\n,vReflectionFilteringInfo\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n,surfaceAlbedo\n#endif\n#ifdef SS_REFRACTION\n,vPositionW\n,viewDirectionW\n,view\n,vRefractionInfos\n,refractionMatrix\n,vRefractionMicrosurfaceInfos\n,vLightingIntensity\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n,alpha\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\n,NdotVUnclamped\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\n,roughness\n#endif\n,alphaG\n,refractionSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionSamplerLow\n,refractionSamplerHigh\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,vRefractionPosition\n,vRefractionSize\n#endif\n#ifdef SS_DISPERSION\n,dispersion\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\n,vDiffusionDistance\n,vTranslucencyColor\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\n,translucencyColorMap\n#endif\n#endif\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \n#endif\n#ifdef PREPASS_IRRADIANCE\nvec3 irradiance=finalDiffuse;\n#ifndef UNLIT\n#ifdef REFLECTION\nirradiance+=finalIrradiance;\n#endif\n#endif\n#ifdef SS_SCATTERING\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \nirradiance/=sqAlbedo;\n#else\ngl_FragData[0]=finalColor; \nfloat scatteringDiffusionProfile=255.;\n#endif\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \n#else\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#ifndef UNLIT\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n", e.ShadersStore[fl] = pl, _l = {
					name: fl,
					shader: pl
				}
			}
		}),
		th = {
			gameNotFound: 0,
			gameFull: 0,
			badName: 0,
			mainMenu: 0,
			gameIdleExceeded: 0,
			corruptedLoginData0: 0,
			corruptedLoginData1: 0,
			corruptedLoginData2: 0,
			corruptedLoginData3: 0,
			corruptedLoginData4: 0,
			corruptedLoginData5: 0,
			gameMaxPlayersExceeded: 0,
			gameDestroyUser: 0,
			joinGameOutOfOrder: 0,
			gameShuttingDown: 0,
			readyBeforeReady: 0,
			booted: 0,
			gameErrorOnUserSocket: 0,
			uuidNotFound: 0,
			sessionNotFound: 0,
			clusterFullCpu: 0,
			clusterFullMem: 0,
			noClustersAvailable: 0,
			locked: 0
		},
		ih = 4e3;
	Object.keys(th).forEach((e => {
		th[e] = ih++
	}));
	var sh = {
		k: 100,
		S: 101,
		U: 102,
		$: 103,
		W: 104,
		D: 105,
		F: 106,
		v: 107,
		V: 108,
		O: 109,
		G: 110,
		C: 111,
		t: 112,
		j: 113,
		M: 114,
		I: 115,
		K: 116,
		H: 117,
		u: 118,
		J: 119,
		i: 120,
		N: 121,
		P: 122,
		T: 123,
		_: 124,
		kk: 125,
		ak: 126,
		Sk: 127,
		xk: 128,
		pk: 129,
		rk: 130,
		Uk: 131,
		nk: 132,
		$k: 133,
		qk: 134,
		Wk: 135,
		fk: 136,
		lk: 137,
		Dk: 138,
		Fk: 139,
		Bk: 140,
		Xk: 141,
		bk: 142,
		vk: 143,
		Vk: 144,
		ek: 145,
		Ok: 146,
		ck: 147,
		Gk: 148,
		Qk: 149,
		yk: 150,
		hk: 151,
		Ck: 152,
		tk: 153,
		jk: 154,
		Mk: 155,
		Ek: 156,
		zk: 157,
		sk: 158,
		Ik: 159,
		Kk: 160,
		Hk: 161
	};
	ih = 0;
	Object.keys(sh).forEach((e => {
		sh[e] = ih++
	}));
	Object.keys(sh).reduce(((e, t) => (e[sh[t]] = t, e)), {});
	var nh = 0,
		ah = 2,
		rh = 4,
		oh = 1,
		lh = 2,
		hh = {
			ffa: 0,
			teams: 1,
			ctf: 2,
			king: 3
		},
		ch = [{
			shortName: "FFA",
			longName: "Free For All",
			value: 0
		}, {
			shortName: "Teams",
			longName: "Teams",
			value: 1
		}, {
			shortName: "Spatula",
			longName: "Captula the Spatula",
			value: 2
		}, {
			shortName: "King",
			longName: "King of the Coop",
			value: 3
		}],
		uh = [{
			name: "Eggk47"
		}, {
			name: "Scrambler"
		}, {
			name: "FreeRanger"
		}, {
			name: "Cluck9mm"
		}, {
			name: "Rpegg"
		}, {
			name: "Whipper"
		}, {
			name: "Crackshot"
		}, {
			name: "TriHard"
		}, {
			name: "Grenade"
		}, {
			name: "Melee"
		}, {
			name: "Fall"
		}],
		mh = Math.ceil(3),
		dh = {
			perKill: 10,
			video: 100,
			perKillModTwo: 20,
			discord: "rew_1200",
			tiktok: "rew_1208",
			Instagram: "rew_1219",
			Steam: "rew_1223",
			Facebook: "rew_1227",
			Twitter: "rew_1234",
			Twitch: "rew_twitch_social"
		},
		fh = 7,
		ph = {
			HardBoiled: 1,
			EggBreaker: 2,
			Restock: 4,
			OverHeal: 8,
			DoubleEggs: 16,
			MiniEgg: 32
		},
		_h = 3,
		gh = 240,
		vh = 86400,
		yh = 0,
		Sh = 1,
		Eh = {
			Hat: 1,
			Stamp: 2,
			Primary: 3,
			Secondary: 4,
			Grenade: 6,
			Melee: 7
		},
		Ah = {
			Soldier: 0,
			Scrambler: 1,
			Ranger: 2,
			Eggsploder: 3,
			Whipper: 4,
			Crackshot: 5,
			TriHard: 6
		};
	Ah.length = Object.keys(Ah).length;
	var bh = ["kills", "deaths", "streak", "killsCluck9mm", "killsGrenade", "killsRpegg", "killsEggk47", "killsScrambler", "killsFreeRanger", "killsWhipper", "killsCrackshot", "killsTriHard", "killsMelee", "killsPrivate", "killsPublic", "killsKing", "killsSpatula", "killsTeams", "killsFFA", "deathsCluck9mm", "deathsGrenade", "deathsRpegg", "deathsEggk47", "deathsScrambler", "deathsFreeRanger", "deathsWhipper", "deathsCrackshot", "deathsTriHard", "deathsMelee", "deathsFall", "deathsPrivate", "deathsPublic", "deathsKing", "deathsSpatula", "deathsTeams", "deathsFFA", "kotcCaptured", "kotcWins"],
		xh = 2633,
		Mh = {
			a: 20,
			b: 20,
			c: 20
		},
		Ch = "8b2234fc0",
		Th = class {
			retrieve(e) {
				if (null != e) {
					for (; e >= this.size;) this.expand(this.originalSize);
					return this.numActive++, this.objects[e].active = !0, this.objects[e]
				}
				var t = this.idx;
				do {
					t = (t + 1) % this.size;
					var i = this.objects[t];
					if (!i.active) return this.idx = t, this.numActive++, i.active = !0, i
				} while (t != this.idx);
				return this.expand(this.originalSize), console.log("Expanding pool for: " + this.objects[0].constructor.name + " to: " + this.size), this.retrieve()
			}
			forEachActive(e) {
				for (var t = 0; t < this.size; t++) {
					var i = this.objects[t];
					!0 === i.active && e(i, t)
				}
			}
			expand(e) {
				for (var t = 0; t < e; t++) {
					var i = this.constructorFn();
					i.id = t + this.size, i.active = !1, this.objects.push(i)
				}
				this.size += e
			}
			constructor(e, t) {
				this.size = 0, this.originalSize = t, this.constructorFn = e, this.objects = [], this.idx = 0, this.numActive = 0, this.expand(t)
			}
			recycle(e) {
				e.active = !1, this.numActive--
			}
		},
		wh = class {
			kKlQQwL(e) {
				this.ABkKlQQwL(8192 * (e + Math.PI))
			}
			AABkKlQQwL(e) {
				"string" != typeof e && (e = ""), this.BkKlQQwL(e.length);
				for (var t = 0; t < e.length; t++) this.ABkKlQQwL(e.charCodeAt(t))
			}
			ABkKlQQwL(e) {
				this.ABkKlQQwL(256 * e)
			}
			constructor(e) {
				this.idx = 0, this.arrayBuffer = new ArrayBuffer(e), this.buffer = new Uint8Array(this.arrayBuffer, 0, e)
			}
			AABkKlQQwL(e) {
				this.ABkKlQQwL(1048576 * e)
			}
			AAAAAABkKlQQwL(e) {
				"string" != typeof e && (e = ""), this.ABkKlQQwL(e.length);
				for (var t = 0; t < e.length; t++) this.ABkKlQQwL(e.charCodeAt(t))
			}
			BkKlQQwL(e) {
				this.buffer[this.idx] = 255 & e, this.idx++
			}
			send(e) {
				var t = new Uint8Array(this.arrayBuffer, 0, this.idx);
				e.send(t), Rh.bufferPool.recycle(this)
			}
			ABkKlQQwL(e) {
				this.buffer[this.idx] = 255 & e, this.buffer[this.idx + 1] = e >> 8 & 255, this.idx += 2
			}
			ABkKlQQwL(e) {
				this.buffer[this.idx] = 255 & e, this.buffer[this.idx + 1] = e >> 8 & 255, this.buffer[this.idx + 2] = e >> 16 & 255, this.idx += 3
			}
			ABkKlQQwL(e) {
				this.buffer[this.idx] = 255 & e, this.buffer[this.idx + 1] = e >> 8 & 255, this.buffer[this.idx + 2] = e >> 16 & 255, this.buffer[this.idx + 3] = e >> 24 & 255, this.idx += 4
			}
			BkKlQQwL(e) {
				this.ABkKlQQwL(2097152 * e)
			}
		},
		Rh = class {
			static getBuffer() {
				var e = this.bufferPool.retrieve();
				return e.idx = 0, e
			}
		};
	Rh.buffer = null, Rh.bufferPool = new Th((() => new wh(16384)), 2);
	var Nh = class {
			static unPackStringHelper(e) {
				if (this.isMoreDataAvailable() < e) return 0;
				for (var t = new String, i = 0; i < e; i++) {
					var s = this.unPackInt16U();
					s > 0 && (t += String.fromCodePoint(s))
				}
				return t
			}
			static unPackRad() {
				return this.unPackInt16U() / 8192 - Math.PI
			}
			static unPackInt32() {
				return (this.unPackInt32U() + 2147483648) % 4294967296 - 2147483648
			}
			static unPackInt8U() {
				var e = this.idx;
				return this.idx++, this.buffer[e]
			}
			static unPackInt32U() {
				var e = this.idx;
				return this.idx += 4, this.buffer[e] + 256 * this.buffer[e + 1] + 65536 * this.buffer[e + 2] + 16777216 * this.buffer[e + 3]
			}
			static init(e) {
				this.buffer = new Uint8Array(e), this.idx = 0
			}
			static unPackInt16U() {
				var e = this.idx;
				return this.idx += 2, this.buffer[e] + 256 * this.buffer[e + 1]
			}
			static unPackLongString(e) {
				e = e || 16383;
				var t = Math.min(this.unPackInt16U(), e);
				return this.unPackStringHelper(t)
			}
			static unPackFloat() {
				return this.unPackInt16() / 256
			}
			static unPackInt8() {
				return (this.unPackInt8U() + 128) % 256 - 128
			}
			static isMoreDataAvailable() {
				return Math.max(0, this.buffer.length - this.idx)
			}
			static unPackInt24U() {
				var e = this.idx;
				return this.idx += 3, this.buffer[e] + 256 * this.buffer[e + 1] + 65536 * this.buffer[e + 2]
			}
			static unPackString(e) {
				e = e || 255;
				var t = Math.min(this.unPackInt8U(), e);
				return this.unPackStringHelper(t)
			}
			static unPackRadU() {
				return this.unPackInt24U() / 2097152
			}
			static peekInt8U() {
				return this.buffer[this.idx]
			}
			static unPackInt16() {
				return (this.unPackInt16U() + 32768) % 65536 - 32768
			}
			static unPackDouble() {
				return this.unPackInt32() / 1048576
			}
		},
		Ih = class e {
			static resume() {
				e.audioCtx && e.audioCtx.resume()
			}
			static async loadSpriteBuffer(t, i) {
				for (var s of i.resources)
					if (s.endsWith(e.format)) break;
				var n = t.match(/.+\//) + s;
				return console.log("BAWK! loading " + n), await e.getAudioBuffer(n + "?" + Ch)
			}
			static request(e) {
				return new Promise(((t, i) => {
					let s = new XMLHttpRequest;
					s.open("GET", e, !0), s.responseType = "arraybuffer";
					let n = Loader.addTask();
					s.onprogress = e => {
						n = Loader.progress(n, e.loaded, e.total)
					}, s.onload = () => {
						200 != s.status ? (console.log("ERROR"), i()) : t(s.response), Loader.finish(n)
					}, s.send()
				}))
			}
			static addChild(t) {
				e.children.push(t)
			}
			static detach() {
				e.position = {
					x: e.position.x,
					y: e.position.y,
					z: e.position.z
				}, e.orientation = {
					x: e.orientation.x,
					y: e.orientation.y,
					z: e.orientation.z
				}
			}
			static dispose() {
				this.audioCtx.close()
			}
			static async getAudioBuffer(t) {
				var i = await e.request(t);
				return await new Promise(((t, s) => {
					e.audioCtx.decodeAudioData(i, t, s)
				}))
			}
			static setOrientation(t) {
				var i = e.audioCtx.listener;
				i.forwardX ? (i.forwardX.value = t.x, i.forwardY.value = t.y, i.forwardZ.value = t.z) : i.setOrientation(t.x, t.y, t.z, 0, 1, 0)
			}
			static play(t, i, s) {
				var n = e.audioCtx;
				i = i || e.inputNode, "suspended" === n.state && e.resume();
				var a = e.sounds[t];
				if (!a) {
					let i;
					if (s && (i = ` or ${s}`, a = e.sounds[s]), !a) return console.error(`BAWK! ${t} ${i} not found. Did you wait for it to load?`), !1
				}
				if (a.end) var r = a.start,
					o = a.end - r;
				var l = n.createBufferSource();
				return l.buffer = a.buffer, l.connect(i), o ? l.start(0, r, o) : l.start(), l
			}
			static setPosition(t) {
				var i = e.audioCtx.listener;
				i.positionX ? (i.positionX.value = t.x, i.positionY.value = t.y, i.positionZ.value = t.z) : i.setPosition(t.x, t.y, t.z)
			}
			static setFormats(e) {
				this.formats = e
			}
			static init() {
				console.log("BAWK! initializing...");
				var e = new AudioContext;
				this.audioCtx = e, this.children = [], this.sounds = {}, this.position = {
					x: 0,
					y: 0,
					z: 0
				}, this.orientation = {
					x: 0,
					y: 0,
					z: -1
				}, this.detectFormats(), this.gainNode = e.createGain(), this.compNode = e.createDynamicsCompressor(), this.compNode.connect(this.gainNode), this.gainNode.connect(e.destination), this.inputNode = this.compNode, null != this.volume && (this.gainNode.gain.value = this.volume)
			}
			static getVolume() {
				return e.volume
			}
			static async loadSprite(t) {
				var i = await fetch(t),
					s = await i.json(),
					n = await e.loadSpriteBuffer(t, s);
				Object.keys(s.spritemap).forEach((t => {
					var i = s.spritemap[t];
					e.sounds[t] = {
						buffer: n,
						start: i.start,
						end: i.end
					}
				}))
			}
			static async loadSound(t, i) {
				t = t.replace("*", e.format);
				var s = await e.getAudioBuffer(t);
				s && (e.sounds[i] && console.warn('BAWK! duplicate sound name, "' + i + '" will be over-written'), e.sounds[i] = {
					buffer: s
				})
			}
			static setVolume(t) {
				e.volume = t, e.gainNode && (e.gainNode.gain.value = t)
			}
			static suspend() {
				e.audioCtx && e.audioCtx.suspend()
			}
			static attach(t, i) {
				e.position = t, e.orientation = i
			}
			static update() {
				for (var t of (e.position && e.setPosition(e.position), e.orientation && e.setOrientation(e.orientation), e.children)) t.update()
			}
			static async load(t, i) {
				e.audioCtx || e.init();
				var s = t.match(/[^/\\&\?]+\..{1,4}(?=([\?\#&].*$|$))/)[0],
					n = s.match(/[^\.]*$/).join(""),
					a = s.replace("." + n, "");
				"json" == n ? await e.loadSprite(t) : await e.loadSound(t, i || a)
			}
			static detectFormats() {
				var t = e.formats || {
					webm: "audio/webm",
					ogg: "audio/ogg",
					mp3: "audio/mpeg"
				};
				/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && delete t.webm;
				var i = document.createElement("audio"),
					s = Object.keys(t);
				for (var n of s) {
					var a = i.canPlayType(t[n]);
					if (console.log("BAWK! testing " + n, a), a) {
						e.format = n, console.log("BAWK! selected " + n);
						break
					}
				}
			}
			static removeChild(t) {
				e.children.splice(e.children.indexOf(t), 1)
			}
		},
		Ph = class e {
			findFreeChannel(e) {
				var t = this.channels,
					i = this.numChannels,
					s = Ih.position;
				if (this.numPlaying < i)
					for (var n of t)
						if (!n.source) return n;
				var a, r = -1;
				for (var n of t) {
					var o = Math.pow(e.x - s.x, 2) + Math.pow(e.y - s.y, 2) + Math.pow(e.z - s.z, 2);
					o > r && (r = o, a = n)
				}
				return a
			}
			static onEnded(e) {
				e.target.channel.parent.numPlaying--, e.target.channel.source = null, e.target.channel = null
			}
			dispose() {
				this.gainNode.disconnect(), Ih.removeChild(this)
			}
			play(t, i, s) {
				if (Ih.sounds[t]) {
					var n = this.findFreeChannel(i);
					n.source && n.source.stop();
					var a = n.node;
					n.position = i, n.follow = s, e.setNodePosition(a, i), n.source = Ih.play(t, a), n.source.channel = n, n.source.onended = e.onEnded, this.numPlaying++
				} else console.error("BAWK! " + t + " not found. Did you wait for it to load?")
			}
			constructor(e, t) {
				Ih.addChild(this), e = e || {}, this.numChannels = e.numChannels || 16, this.numPlaying = 0, this.channels = [], this.nextChannelIdx = 0, this.gainNode = Ih.audioCtx.createGain(), this.gainNode.connect(Ih.inputNode);
				for (var i = 0; i < this.numChannels; i++) {
					var s = Ih.audioCtx.createPanner(t);
					s.connect(this.gainNode), this.channels.push({
						parent: this,
						source: null,
						position: {
							x: 0,
							y: 0,
							z: 0
						},
						follow: !1,
						node: s
					})
				}
			}
			getVolume() {
				return this.gainNode.gain.value
			}
			setVolume(e) {
				this.gainNode.gain.value = e
			}
			static setNodePosition(e, t) {
				var i = Ih.position.y + 4 * (t.y - Ih.position.y);
				e.positionX ? (e.positionX.value = t.x, e.positionY.value = i, e.positionZ.value = t.z) : e.setPosition(t.x, i, t.z)
			}
			update() {
				for (var t of this.channels) t.source && t.follow && e.setNodePosition(t.node, t.position)
			}
		};
	window.BAWK = Ih;
	var kh = {
			productBlockAds: !1,
			vipSubEnded: !1,
			passEnded: !1
		},
		Dh = class {
			constructor() {
				this.statStateTemp = {
					total: 0,
					mode: {
						public: 0,
						private: 0
					},
					dmgType: {
						pistol: 0,
						grenade: 0,
						rpegg: 0,
						eggk: 0,
						scrambler: 0,
						ranger: 0,
						whipper: 0,
						crackshot: 0,
						trihard: 0,
						melee: 0,
						fall: 0
					},
					gameType: {
						kotc: 0,
						spatula: 0,
						team: 0,
						ffa: 0
					},
					kdr: {
						private: 0,
						public: 0,
						ffa: 0,
						teams: 0,
						kotc: 0,
						spatula: 0
					}
				}, this.kills = Object.create(this.statStateTemp), this.deaths = Object.create(this.statStateTemp), this.gameType = {
					kotc: {
						captured: 0,
						wins: 0
					}
				}, this.streak = 0, this.dateReset = null
			}
			get() {
				return {
					kills: this.kills,
					deaths: this.deaths,
					gameType: this.gameType,
					streak: this.streak,
					dateReset: this.dateReset
				}
			}
			updateStats(e, t) {
				return {
					total: void 0 !== e.total ? e.total : this[t].deaths,
					mode: {
						public: void 0 !== e.mode.public ? e.mode.public : this[t].mode.public,
						private: void 0 !== e.mode.private ? e.mode.private : this[t].mode.private
					},
					dmgType: {
						pistol: void 0 !== e.dmgType.pistol ? e.dmgType.pistol : this[t].dmgType.pistol,
						grenade: void 0 !== e.dmgType.grenade ? e.dmgType.grenade : this[t].dmgType.grenade,
						rpegg: void 0 !== e.dmgType.rpegg ? e.dmgType.rpegg : this[t].dmgType.rpegg,
						eggk: void 0 !== e.dmgType.eggk ? e.dmgType.eggk : this[t].dmgType.eggk,
						scrambler: void 0 !== e.dmgType.scrambler ? e.dmgType.scrambler : this[t].dmgType.scrambler,
						ranger: void 0 !== e.dmgType.ranger ? e.dmgType.ranger : this[t].dmgType.ranger,
						whipper: void 0 !== e.dmgType.whipper ? e.dmgType.whipper : this[t].dmgType.whipper,
						crackshot: void 0 !== e.dmgType.crackshot ? e.dmgType.crackshot : this[t].dmgType.crackshot,
						trihard: void 0 !== e.dmgType.trihard ? e.dmgType.trihard : this[t].dmgType.trihard,
						melee: void 0 !== e.dmgType.melee ? e.dmgType.melee : this[t].dmgType.melee,
						fall: void 0 !== e.dmgType.fall ? e.dmgType.fall : this[t].dmgType.fall
					},
					gameType: {
						kotc: void 0 !== e.gameType.kotc ? e.gameType.kotc : this[t].gameType.kotc,
						spatula: void 0 !== e.gameType.spatula ? e.gameType.spatula : this[t].gameType.spatula,
						team: void 0 !== e.gameType.team ? e.gameType.team : this[t].gameType.team,
						ffa: void 0 !== e.gameType.ffa ? e.gameType.ffa : this[t].gameType.ffa
					}
				}
			}
			set(e) {
				if (!e || void 0 !== e.error) return vueApp.showGenericPopup("uh_oh", "auth_stat_error_msg", "ok");
				void 0 !== e.kills && (this.kills = this.updateStats(e.kills, "kills")), void 0 !== e.deaths && (this.deaths = this.updateStats(e.deaths, "deaths")), void 0 !== e.gameType && (this.gameType = {
					kotc: {
						captured: void 0 !== e.gameType.kotc.captured ? e.gameType.kotc.captured : this.gameType.kotc.captured,
						wins: void 0 !== e.gameType.kotc.wins ? e.gameType.kotc.wins : this.gameType.kotc.wins
					}
				}), e.streak && (this.streak = void 0 !== e.streak ? e.streak : this.streak)
			}
		},
		Oh = new Blob(["\nvar sessionId;\nvar servicesServer;\nvar timeout;\n\nonmessage = function (e) {\n\tservicesServer = e.data.servicesServer;\n\tsessionId = e.data.sessionId;\n\tconsole.log(getTime(), 'Session: worker received session ID:', sessionId);\n\tclearTimeout(timeout);\n\n\tif (sessionId !== null) {\n\t\ttimeout = setTimeout(() => renewSession(), 600000);\n\t}\n}\n\nfunction getTime () {\n\tlet d = new Date();\n\treturn d.toTimeString();\n}\n\nfunction renewSession () {\n\tcallRenew(res => {\n\t\tconsole.log(getTime(), 'Session: renew result:', res.data);\n\n\t\tif (res.data === 'renewed') {\n\t\t\tconsole.log(getTime(), 'Session: session renewed');\n\t\t\ttimeout = setTimeout(() => renewSession(), 600000);\n\t\t}\n\t\telse {\n\t\t\tconsole.log(getTime(), 'Session: session expired');\n\t\t\tpostMessage('expired');\n\t\t}\n\t},\n\t\t() => {\n\t\t\tconsole.log(getTime(), 'Session: failed to renew - Trying again in 30 seconds');\n\t\t\ttimeout = setTimeout(() => renewSession(), 30000);\n\t\t}\n\t);\n}\n\nfunction callRenew (successCallback, errorCallback) {\n\tconsole.log(getTime(), 'Session: callRenew');\n\n\ttry {\n        var servicesWs = new WebSocket(servicesServer);\n\t} catch (e) {\n\t\terrorCallback();\n\t}\n\n\tservicesWs.onopen = function (e) {\n\t\tservicesWs.send(JSON.stringify({\n\t\t\tcmd: 'renewSession',\n\t\t\tsessionId: sessionId\n\t\t}));\n\t};\n\n\tservicesWs.onmessage = function (e) {\n\t\tvar response = null;\n\t\ttry {\n\t\t\tresponse = JSON.parse(e.data);\n\t\t\tsuccessCallback(response);\n\t\t} catch (e) {\n\t\t\terrorCallback();\n\t\t}\n\n\t\tservicesWs.close();\n\t};\n\n\tservicesWs.onerror = function (e) {\n\t\terrorCallback();\n\t};\n}\n"]),
		Fh = window.URL.createObjectURL(Oh),
		Lh = new Worker(Fh);
	Lh.onmessage = e => {
		"expired" === e.data && vueApp.showGenericPopup("session_expired", "session_expired_msg", "reload", !0)
	};
	var Bh = class {
		getDifferenceIndexes(e, t, i) {
			const s = Math.max(e.length, t.length),
				n = [];
			for (let a = 0; a < s; a++) {
				const s = e[a],
					r = t[a];
				s && r ? i ? s[i] !== r[i] && n.push(a) : JSON.stringify(s) !== JSON.stringify(r) && n.push(a) : n.push(a)
			}
			return n
		}
		eggOrgRewardItem(e) {
			if (!e) return;
			const t = {
				ids: [xh],
				eggs: 0
			};
			this.notification ? (this.notification.type ??= {}, this.notification.type.eggOrg = t) : this.notification = {
				id: this.id,
				type: {
					eggOrg: t
				},
				read: !1
			}
		}
		generateLoadoutObject() {
			return {
				classIdx: this.classIdx,
				hatId: hasValue(this.hatItem) ? this.hatItem.id : null,
				stampId: hasValue(this.stampItem) ? this.stampItem.id : null,
				stampPositionX: this.stampPositionX,
				stampPositionY: this.stampPositionY,
				grenadeId: hasValue(this.grenadeItem) ? this.grenadeItem.id : null,
				meleeId: hasValue(this.meleeItem) ? this.meleeItem.id : null,
				colorIdx: this.colorIdx,
				primaryId: this.pickedWeapons.map((e => e[yh].id)),
				secondaryId: this.pickedWeapons.map((e => e[Sh].id))
			}
		}
		checkNotification(e) {
			e && !e.read && (this.notification = e)
		}
		convertLoadout(e) {
			e || (e = this.generateLoadoutObject());
			return {
				primaryId: [e.soldier_primary_item_id, e.scrambler_primary_item_id, e.ranger_primary_item_id, e.eggsploder_primary_item_id, e.whipper_primary_item_id, e.crackshot_primary_item_id, e.trihard_primary_item_id],
				secondaryId: [e.soldier_secondary_item_id, e.scrambler_secondary_item_id, e.ranger_secondary_item_id, e.eggsploder_secondary_item_id, e.whipper_secondary_item_id, e.crackshot_secondary_item_id, e.trihard_secondary_item_id],
				hatId: e.hat_id,
				stampId: e.stamp_id,
				stampPositionX: e.stamp_position_x,
				stampPositionY: e.stamp_position_y,
				grenadeId: e.grenade_id,
				meleeId: e.melee_id,
				classIdx: e.class_idx,
				colorIdx: e.color
			}
		}
		setUpgrade(e) {
			const {
				upgradeProductId: t,
				upgradeMultiplier: i = 1,
				upgradeExpiryDate: s = null,
				upgradeIsExpired: n = null,
				upgradeAdFree: a = !1,
				upgradeType: r,
				upgradePlanId: o,
				upgradeName: l
			} = e;
			this.upgradeProductId = t, this.upgradePlanId = o, this.multiplier = i, this.upgradeExpiryDate = s, this.upgradeIsExpired = n, this.hideAds = a && !n, this.isSubscriber = ("subscription" === r || "pass" === r) && !n, this.upgradeName = l;
			const h = this.isUpgraded(),
				c = h ? this.upgradeExpiryDate : null;
			this.colorIdx >= 7 && !h && (this.colorIdx = 0), vueApp.setAccountUpgraded(h, c)
		}
		applyLocalLoadout(e) {
			if (!hasValue(e)) return;
			let t = e;
			e.hasOwnProperty("primaryId") || (t = this.convertLoadout(e));
			let i = {
				items: t,
				kills: this.kills ? this.kills : 0,
				deaths: this.deaths ? this.deaths : 0,
				kdr: this.kdr ? this.kdr : 0,
				streak: this.streak ? this.streak : 0,
				balance: this._currentBalance
			};
			localStore.setItem("localLoadOut", JSON.stringify(i))
		}
		getEquippedItems() {
			return {
				[ItemType.Primary]: this.pickedWeapons[this.classIdx][yh],
				[ItemType.Secondary]: this.pickedWeapons[this.classIdx][Sh],
				[ItemType.Hat]: this.hatItem,
				[ItemType.Stamp]: this.stampItem,
				[ItemType.Grenade]: this.grenadeItem,
				[ItemType.Melee]: this.meleeItem
			}
		}
		isUpgraded() {
			return hasValue(this.upgradeProductId) && !this.upgradeIsExpired
		}
		constructor() {
			this.pickedWeapons = [];
			for (var e = 0; e < Ah.length; e++) {
				var t = [kh.catalog.forClass[e].primaryWeapons[0], kh.catalog.forClass[e].secondaryWeapons[0]];
				this.pickedWeapons.push(t)
			}
			this.firebaseId = null, this.session = null, this.maskedEmail = null, this.classIdx = 0, this.inventory = [], this.hatItem = null, this.stampItem = null, this.stampPositionX = 0, this.stampPositionY = 0, this.grenadeItem = kh.catalog.grenades[0], this.meleeItem = kh.catalog.melee[0], this.colorIdx = 0, this.kills = 0, this.deaths = 0, this.streak = 0, this.currentBalance = 0, this.upgradeProductId = null, this.killMultiplier = 1, this.hideAds = !1, this.maybeSchoolEmail = !1, this.upgradeExpiryDate = null, this.upgradeIsExpired = null, this.upgradeName = "", this.isSubscriber = !1, this.twitchLinked = !1, this.twitchName = "", this.contentCreator = !1, this.dateCreated = null, this.accountAge = null, this.notification = null, this.statsCurrent = new Dh, this.statsLifetime = new Dh, this.eggsSpent = 0, this.eggsSpentMonthly = 0, this.eggsEarnedBalance = 0, this.challenges = [], this.challengesDailyEnd = 0, this.faction = null, this.factionActivated = !1, this._firebaseId, Object.defineProperty(this, "firebaseId", {
				get: function() {
					return this._firebaseId
				},
				set: function(e) {
					this._firebaseId = e, vueApp.firebaseId = this._firebaseId
				}
			}), this._id, Object.defineProperty(this, "id", {
				get: function() {
					return this._id
				},
				set: function(e) {
					this._id = e, vueApp.id = this._id
				}
			}), this._isAnonymous, Object.defineProperty(this, "isAnonymous", {
				get: function() {
					return this._isAnonymous
				},
				set: function(e) {
					this._isAnonymous = e, vueApp.isAnonymous = this._isAnonymous, vueApp.googleAnalytics.isUser = this._isAnonymous ? "Unclaimed" : "Claimed", ga("set", "dimension1", vueData.googleAnalytics.isUser)
				}
			}), this._currentBalance, Object.defineProperty(this, "currentBalance", {
				get: function() {
					return this._currentBalance
				},
				set: function(e) {
					this._currentBalance = e, vueApp.eggs = this._currentBalance
				}
			}), this._kills, Object.defineProperty(this, "kills", {
				get: function() {
					return this._kills
				},
				set: function(e) {
					this._kills = e, vueApp.kills = this._kills
				}
			}), this._deaths, Object.defineProperty(this, "deaths", {
				get: function() {
					return this._deaths
				},
				set: function(e) {
					this._deaths = e, vueApp.deaths = this._deaths
				}
			}), this._kdr, Object.defineProperty(this, "kdr", {
				get: function() {
					return this._kdr
				},
				set: function(e) {
					this._kdr = e, vueApp.kdr = this._kdr
				}
			}), this._kdrLifetime, Object.defineProperty(this, "kdrLifetime", {
				get: function() {
					return this._kdrLifetime
				},
				set: function(e) {
					this._kdrLifetime = e, vueApp.kdrLifetime = this._kdrLifetime
				}
			}), this._streak, Object.defineProperty(this, "streak", {
				get: function() {
					return this._streak
				},
				set: function(e) {
					this._streak = e, vueApp.streak = this._streak
				}
			}), this._statsCurrent = new Dh, Object.defineProperty(this, "statsCurrent", {
				get: function() {
					return this._statsCurrent
				},
				set: function(e) {
					this._statsCurrent.set(e), this.kills = this._statsCurrent.kills.total, this.deaths = this._statsCurrent.deaths.total, this.streak = this._statsCurrent.streak, this.kdr = Math.floor(this._statsCurrent.kills.total / Math.max(this._statsCurrent.deaths.total, 1) * 100) / 100, vueApp.statsCurrent = this._statsCurrent
				}
			}), this._statsLifetime = new Dh, Object.defineProperty(this, "statsLifetime", {
				get: function() {
					return this._statsLifetime
				},
				set: function(e) {
					this._statsLifetime.set(e), this.kdrLifetime = Math.floor(this._statsLifetime.kills.total / Math.max(this._statsLifetime.deaths.total, 1) * 100) / 100, vueApp.statsLifetime = this._statsLifetime
				}
			}), this._eggsSpent, Object.defineProperty(this, "eggsSpent", {
				get: function() {
					return this._eggsSpent
				},
				set: function(e) {
					this._eggsSpent = null === e ? 0 : e, vueApp.eggsSpent = this._eggsSpent
				}
			}), this._eggsSpentMonthly, Object.defineProperty(this, "eggsSpentMonthly", {
				get: function() {
					return this._eggsSpentMonthly
				},
				set: function(e) {
					this._eggsSpentMonthly = e, vueApp.eggsSpentMonthly = this._eggsSpentMonthly
				}
			}), this._eggsEarnedBalance, Object.defineProperty(this, "eggsEarnedBalance", {
				get: function() {
					return this._eggsEarnedBalance
				},
				set: function(e) {
					void 0 !== e && (this._eggsEarnedBalance = null === e ? 0 : e, vueApp.eggsEarnedBalance = this._eggsEarnedBalance)
				}
			}), this._playerName, Object.defineProperty(this, "playerName", {
				get: function() {
					return this._playerName
				},
				set: function(e) {
					this._playerName = e, vueApp.playerName = this._playerName
				}
			}), this._maskedEmail, Object.defineProperty(this, "maskedEmail", {
				get: function() {
					return this._maskedEmail
				},
				set: function(e) {
					this._maskedEmail = e, vueApp.maskedEmail = this._maskedEmail
				}
			}), this._isEmailVerified, Object.defineProperty(this, "isEmailVerified", {
				get: function() {
					return this._isEmailVerified
				},
				set: function(e) {
					this._isEmailVerified = e, vueApp.isEmailVerified = this._isEmailVerified
				}
			}), this._isSubscriber, Object.defineProperty(this, "isSubscriber", {
				get: function() {
					return this._isSubscriber
				},
				set: function(e) {
					this._isSubscriber = e, vueApp.isSubscriber = e
				}
			}), this._upgradeName, Object.defineProperty(this, "upgradeName", {
				get: function() {
					return this._upgradeName
				},
				set: function(e) {
					this._upgradeName = e, vueApp.upgradeName = e
				}
			}), this._hideAds, Object.defineProperty(this, "hideAds", {
				get: function() {
					return this._hideAds
				},
				set: function(e) {
					vueApp.hideAds = !!e
				}
			}), this._twitchLinked, Object.defineProperty(this, "twitchLinked", {
				get() {
					return this._twitchLinked
				},
				set(e) {
					this._twitchLinked = e, vueApp.twitchLinked = e
				}
			}), this._twitchName, Object.defineProperty(this, "twitchName", {
				get() {
					return this._twitchName
				},
				set(e) {
					this._twitchName = e, vueApp.twitchName = e
				}
			}), this._challenges = [], Object.defineProperty(this, "challenges", {
				get() {
					return this._challenges
				},
				set(e) {
					if (e.length) {
						if (this._challenges.length > 0) {
							const [t, i] = this.getDifferenceIndexes(this._challenges, e, "challengeId");
							if (void 0 !== t && void 0 !== i) {
								const s = e.splice(i, 1)[0];
								e.splice(t, 0, s)
							}
						}
						this._challenges = e.slice(), vueApp.player.challenges = e.slice(), this.challengesSet()
					}
				}
			}), this._challengesClaimed = [], this.challengesClaimedUnique = [], Object.defineProperty(this, "challengesClaimed", {
				get: () => this._challengesClaimed,
				set: e => {
					this._challengesClaimed = e, this.challengesClaimedUnique = [...new Set(e)], vueApp.challengesClaimed.total = this._challengesClaimed.length, vueApp.challengesClaimed.unique = this.challengesClaimedUnique.length
				}
			}), this.isItemOwned, Object.defineProperty(this, "isItemOwned", {
				value: function(e) {
					if (!e) return !1;
					for (var t = 0; t < this.inventory.length; t++)
						if (this.inventory[t] && this.inventory[t].id === e.id) return !0;
					return !1
				}
			}), this._contentCreator, Object.defineProperty(this, "contentCreator", {
				get() {
					return this._contentCreator
				},
				set(e) {
					e && (this._contentCreator = !0, vueApp.contentCreator = this._contentCreator)
				}
			}), this._dateCreated, Object.defineProperty(this, "dateCreated", {
				get() {
					return this._dateCreated
				},
				set(e) {
					if (e) {
						const t = new Date(e).toLocaleDateString();
						this._dateCreated = t, vueApp.accountCreated = t
					} else vueApp.accountCreated = null
				}
			})
		}
		applyRandomLoadout() {
			let e = kh.catalog.hats.filter((e => 0 === e.price && "default" === e.unlock)),
				t = e[Math.randomInt(0, e.length)].id;
			this.hatItem = kh.catalog.findItemById(t), this.colorIdx = Math.randomInt(0, 7);
			let i = this.generateLoadoutObject();
			i.hatId = t, i.stampId = null, i.stampPositionX = 0, i.stampPositionY = 0, i.color = this.colorIdx, this.applyLocalLoadout(i), setTimeout((() => this.applyLoadoutObject(i)), 0)
		}
		loggedOut() {
			this.firebaseId = null, this.id = null, this.session = null, this.sessionId = null, this.kills = 0, this.deaths = 0, this.streak = 0, this.currentBalance = 0, this.classIdx = 0, this.inventory = [], this.pickedWeapons = [], this.stampItem = null, this.stampPositionX = 0, this.stampPositionY = 0, this.grenadeItem = kh.catalog.findItemById(16e3), this.meleeItem = kh.catalog.findItemById(15e3), this.hatItem = null, this.colorIdx = 0, this.killMultiplier = 1, this.hideAds = !1, this.maybeSchoolEmail = !1, this.isAnonymous = !0, this.upgradeIsExpired = null, this.upgradeExpiryDate = null, this.upgradeName = "", this.isSubscriber = !1, this.twitchLinked = !1, this.twitchName = "", this.contentCreator = !1, this.dateCreated = null, this.eggsSpent = 0, this.eggsSpentMonthly = 0, this.eggsEarnedBalance = 0, this.challenges = [], this.statsCurrent = new Dh, this.statsLifetime = new Dh, this.faction = null, this.factionActivated = !1;
			for (var e = 0; e < Ah.length; e++) {
				var t = [kh.catalog.forClass[e].primaryWeapons[0], kh.catalog.forClass[e].secondaryWeapons[0]];
				this.pickedWeapons.push(t)
			}
			Lh.postMessage({
				sessionId: null
			}), kh.adminRoles = 0
		}
		pickWeapon(e, t) {
			t.item_type_id === ItemType.Primary && this.setClass(t.exclusive_for_class), !1 === kh.catalog.findItemInListById(t, kh.catalog.forClass[this.classIdx].forWeaponSlot[e]) && (t = kh.catalog.forClass[this.classIdx].forWeaponSlot[e][0]), this.pickedWeapons[this.classIdx][e] = t
		}
		syncToServer(e) {
			var t = this.generateLoadoutObject();
			kh.api_saveLoadout(t, e), null !== t && this.applyLocalLoadout(t)
		}
		applyLoadoutObject(e) {
			if (hasValue(e)) {
				void 0 !== e.classIdx && null !== e.classIdx && this.setClass(e.classIdx);
				for (var t = this, i = function(e, i, s) {
						var n = kh.catalog.forClass[i].forWeaponSlot[s][0];
						if (hasValue(e)) {
							let t = kh.catalog.findItemById(e);
							t && (n = t)
						}
						t.pickedWeapons[i][s] = n
					}, s = 0; s < Ah.length; s++) i(e.primaryId[s], s, yh), i(e.secondaryId[s], s, Sh);
				if (hasValue(e.hatId)) {
					var n = kh.catalog.findItemById(e.hatId);
					this.isItemOwned(n) || (this.hatItem = null), this.hatItem = n
				}
				if (hasValue(e.stampId)) {
					var a = kh.catalog.findItemById(e.stampId);
					this.isItemOwned(a) || (this.stampItem = null), this.stampItem = a
				}
				if (hasValue(e.grenadeId)) {
					var r = kh.catalog.findItemById(e.grenadeId);
					this.isItemOwned(r) || (r = kh.catalog.findItemById(16e3)), this.grenadeItem = r
				}
				if (hasValue(e.meleeId)) {
					var o = kh.catalog.findItemById(e.meleeId);
					this.isItemOwned(o) || (o = kh.catalog.findItemById(15e3)), this.meleeItem = o
				}
				hasValue(e.colorIdx) && (this.colorIdx = e.colorIdx, this.colorIdx >= 7 && !1 === this.isUpgraded() && (this.colorIdx = 0)), hasValue(e.stampPositionX) && (this.stampPositionX = e.stampPositionX), hasValue(e.stampPositionY) && (this.stampPositionY = e.stampPositionY)
			}
			kh.resetPaperDoll()
		}
		tryEquipItem(e) {
			if (this.isItemOwned(e)) {
				switch (e.item_type_id) {
					case ItemType.Hat:
						this.hatItem = e;
						break;
					case ItemType.Stamp:
						this.stampItem = e;
						break;
					case ItemType.Primary:
						e.exclusive_for_class !== this.classIdx && this.setClass(e.exclusive_for_class), this.pickWeapon(yh, e);
						break;
					case ItemType.Secondary:
						this.pickWeapon(Sh, e);
						break;
					case ItemType.Grenade:
						this.grenadeItem = e;
						break;
					case ItemType.Melee:
						this.meleeItem = e
				}
				this.syncToServer()
			}
		}
		getPrimaryWeapon() {
			return this.getPickedWeaponInSlot(yh)
		}
		challengesSet() {
			if (this.challenges.length > 0) {
				let e = this.challenges.reduce(((e, t) => e && e.period > t.period ? e : t));
				null !== e && (this.challengesDailyEnd = Math.trunc(Date.now() / 1e3) + e.period)
			} else console.log("Player challenges empty. Most likely reason: No challenges available for this player")
		}
		getSecondaryWeapon() {
			return this.getPickedWeaponInSlot(Sh)
		}
		setClass(e) {
			(null == e || e >= kh.classes.length) && (e = 0), this.classIdx = e, vueApp && (vueApp.classIdx = this.classIdx)
		}
		calculateKdr() {
			this.kdr = Math.floor(this.statsCurrent.kills / Math.max(this.statsCurrent.deaths, 1) * 100) / 100, this.kdrLifetime = Math.floor(this.statslifetime.kills / Math.max(this.statslifetime.deaths, 1) * 100) / 100
		}
		challengesAutoClaimed(e) {
			const t = e.filter((e => "claimed" === e.status));
			if (t.length > 0) {
				for (const e of t) {
					const t = extern.playerChallenges.challengeGet(e.id);
					t && t.loc_ref ? ga("send", "event", "dailyChallenge", "auto_claim", t.loc_ref) : console.error("Challenge or loc_ref not found for id:", e.id)
				}
				return t
			}
			return !1
		}
		addToInventory(e, t) {
			this.isItemOwned(e) || this.inventory.push(e), !0 === t && this.tryEquipItem(e)
		}
		setStats(e, t) {
			this.statsLifetime = e, this.statsCurrent = t
		}
		getPickedWeaponInSlot(e) {
			return this.pickedWeapons[this.classIdx][e]
		}
		setEggBalances(e) {
			this.currentBalance = e, this.eggsEarnedBalance = this.eggsSpent + this.currentBalance
		}
		removeFromInventory(e) {
			const t = this.inventory.findIndex((t => t === e)); - 1 !== t && this.inventory.splice(t, 1)
		}
		loggingOut() {
			this.loggedOut(), this.applyLoadoutObject(), this.getPrimaryWeapon(), this.getSecondaryWeapon(), this.setClass(this.classIdx), vueApp.signOut()
		}
		signedIn(e, t) {
			if (e.uid === t.firebaseId) {
				if (this.isAnonymous = e.isAnonymous, this.isEmailVerified = !this.isAnonymous && t.emailVerified, this.id = t.id, this.firebaseId = t.firebaseId, this.sessionId = t.sessionId, this.session = t.session, this.maskedEmail = t.maskedEmail, this.kills = t.kills, this.deaths = t.deaths, this.streak = t.streak, this.currentBalance = t.currentBalance, this.maybeSchoolEmail = t.maybeSchoolEmail, this.subscriptionEnded = t.subscriptionEnded, this.passEnded = t.passEnded, this.twitchLinked = t.twitchLinked, this.twitchName = t.twitchName, this.contentCreator = t.social && t.social.length && t.social[0] ? t.social : "", this.checkNotification(t.notification), this.setStats(t.statsLifetime, t.statsCurrent), this.dateCreated = t.dateCreated, this.accountAge = t.accountAge, this.eggsSpent = t.eggsSpent, this.eggsSpentMonthly = t.eggsSpentMonthly, this.eggsEarnedBalance = this.setEggBalances(this.currentBalance), this.challengesHasAutoClaim = this.challengesAutoClaimed(t.unclaimedRewards), this.challengesClaimed = t.claimedChallenges, this.setUpgrade(t), this.challenges = t.challenges, kh.adminRoles = t.adminRoles, hasValue(t.ownedItemIds))
					for (var i = 0; i < t.ownedItemIds.length; i++) {
						var s = kh.catalog.findItemById(t.ownedItemIds[i]);
						this.inventory.push(s)
					}
				kh.productBlockAds = kh.playerAccount.isUpgraded(), this.subscriptionEnded && (kh.vipSubEnded = !0), t.passEnded && (kh.passEnded = !0), t.firstSignin && (kh.showSigninBonus = !0), this.applyLoadoutObject(t.loadout), this.applyLocalLoadout(t.loadout), Lh.postMessage({
					servicesServer: kh.servicesServer,
					sessionId: this.sessionId
				})
			} else console.log("Firebase user ID does not match account returned from API")
		}
	};

	function Gh(e, t, i, s) {
		var n, a = arguments.length,
			r = a < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(e, t, i, s);
		else
			for (var o = e.length - 1; o >= 0; o--)(n = e[o]) && (r = (a < 3 ? n(r) : a > 3 ? n(t, i, r) : n(t, i)) || r);
		return a > 3 && r && Object.defineProperty(t, i, r), r
	}
	var Hh = {},
		Uh = {};

	function Vh(e) {
		const t = e.getClassName();
		if (Hh[t]) return Hh[t];
		Hh[t] = {};
		const i = Hh[t];
		let s = e,
			n = t;
		for (; n;) {
			const e = Uh[n];
			for (const t in e) i[t] = e[t];
			let t, a = !1;
			do {
				if (t = Object.getPrototypeOf(s), !t.getClassName) {
					a = !0;
					break
				}
				if (t.getClassName() !== n) break;
				s = t
			} while (t);
			if (a) break;
			n = t.getClassName(), s = t
		}
		return i
	}

	function Wh(e, t) {
		return (i, s) => {
			const n = function(e) {
				const t = e.getClassName();
				return Uh[t] || (Uh[t] = {}), Uh[t]
			}(i);
			n[s] || (n[s] = {
				type: e,
				sourceName: t
			})
		}
	}

	function zh(e, t = null) {
		return function(e, t = null) {
			return (i, s) => {
				const n = t || "_" + s;
				Object.defineProperty(i, s, {
					get: function() {
						return this[n]
					},
					set: function(t) {
						"function" == typeof this.equals && this.equals(t) || this[n] !== t && (this[n] = t, i[e].apply(this))
					},
					enumerable: !0,
					configurable: !0
				})
			}
		}(e, t)
	}

	function Xh(e) {
		return Wh(0, e)
	}

	function Yh(e) {
		return Wh(1, e)
	}

	function jh(e) {
		return Wh(2, e)
	}

	function Kh(e) {
		return Wh(3, e)
	}

	function $h(e) {
		return Wh(4, e)
	}

	function Jh(e) {
		return Wh(5, e)
	}

	function qh(e) {
		return Wh(6, e)
	}

	function Qh(e) {
		return Wh(8, e)
	}

	function Zh(e) {
		return Wh(12, e)
	}

	function ec(e, t, i, s) {
		const n = i.value;
		i.value = (...i) => {
			let a = n;
			if ("undefined" != typeof _native && _native[t]) {
				const e = _native[t];
				a = s ? (...t) => s(...t) ? e(...t) : n(...t) : e
			}
			return e[t] = a, a(...i)
		}
	}
	ec.filter = function(e) {
		return (t, i, s) => ec(t, i, s, e)
	};
	var tc = {};

	function ic(e, t = !1) {
		if (!t || !tc[e]) return tc[e] = !0, `${e} needs to be imported before as it contains a side-effect required by your code.`
	}
	var sc = class e {
			static _SimplifyNegation(e) {
				return "!true" === (e = (e = e.replace(/^[\s!]+/, (e => (e = e.replace(/[\s]/g, (() => ""))).length % 2 ? "!" : ""))).trim()) ? e = "false" : "!false" === e && (e = "true"), e
			}
			static _HandleParenthesisContent(t, i) {
				let s;
				i = i || (e => "true" === e);
				const n = t.split("||");
				for (const t in n)
					if (Object.prototype.hasOwnProperty.call(n, t)) {
						let a = e._SimplifyNegation(n[t].trim());
						const r = a.split("&&");
						if (r.length > 1)
							for (let t = 0; t < r.length; ++t) {
								const n = e._SimplifyNegation(r[t].trim());
								if (s = "true" !== n && "false" !== n ? "!" === n[0] ? !i(n.substring(1)) : i(n) : "true" === n, !s) {
									a = "false";
									break
								}
							}
						if (s || "true" === a) {
							s = !0;
							break
						}
						s = "true" !== a && "false" !== a ? "!" === a[0] ? !i(a.substring(1)) : i(a) : "true" === a
					} return s ? "true" : "false"
			}
			static Eval(t, i) {
				return "true" === (t = t.match(/\([^()]*\)/g) ? t.replace(/\([^()]*\)/g, (t => (t = t.slice(1, t.length - 1), e._HandleParenthesisContent(t, i)))) : e._HandleParenthesisContent(t, i)) || "false" !== t && e.Eval(t, i)
			}
		},
		nc = class e {
			static HasTags(e) {
				if (!e._tags) return !1;
				const t = e._tags;
				for (const e in t)
					if (Object.prototype.hasOwnProperty.call(t, e)) return !0;
				return !1
			}
			static _RemoveTagFrom(e, t) {
				delete e._tags[t]
			}
			static GetTags(e, t = !0) {
				if (!e._tags) return null;
				if (t) {
					const t = [];
					for (const i in e._tags) Object.prototype.hasOwnProperty.call(e._tags, i) && !0 === e._tags[i] && t.push(i);
					return t.join(" ")
				}
				return e._tags
			}
			static _AddTagTo(t, i) {
				"" !== (i = i.trim()) && "true" !== i && "false" !== i && (i.match(/[\s]/) || i.match(/^([!]|([|]|[&]){2})/) || (e.EnableFor(t), t._tags[i] = !0))
			}
			static DisableFor(e) {
				delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery
			}
			static RemoveTagsFrom(t, i) {
				if (!e.HasTags(t)) return;
				const s = i.split(" ");
				for (const i in s) e._RemoveTagFrom(t, s[i])
			}
			static EnableFor(t) {
				t._tags = t._tags || {}, t.hasTags = () => e.HasTags(t), t.addTags = i => e.AddTagsTo(t, i), t.removeTags = i => e.RemoveTagsFrom(t, i), t.matchesTagsQuery = i => e.MatchesQuery(t, i)
			}
			static AddTagsTo(t, i) {
				if (!i) return;
				if ("string" != typeof i) return;
				i.split(" ").forEach((function(i) {
					e._AddTagTo(t, i)
				}))
			}
			static MatchesQuery(t, i) {
				return void 0 === i || ("" === i ? e.HasTags(t) : sc.Eval(i, (i => e.HasTags(t) && t._tags[i])))
			}
		};

	function ac(e, t) {
		const i = [];
		for (let s = 0; s < e; ++s) i.push(t());
		return i
	}

	function rc(e, t) {
		return ac(e, t)
	}
	var oc = ["push", "splice", "pop", "shift", "unshift"];

	function lc(e, t) {
		const i = oc.map((i => function(e, t, i) {
			const s = e[t];
			if ("function" != typeof s) return null;
			const n = function() {
				const s = e.length,
					a = n.previous.apply(e, arguments);
				return i(t, s), a
			};
			return s.next = n, n.previous = s, e[t] = n, () => {
				const i = n.previous;
				if (!i) return;
				const s = n.next;
				s ? (i.next = s, s.previous = i) : (i.next = void 0, e[t] = i), n.next = void 0, n.previous = void 0
			}
		}(e, i, t)));
		return () => {
			i.forEach((e => {
				e?.()
			}))
		}
	}
	var hc = {};

	function cc(e, t) {
		hc[e] = t
	}

	function uc(e) {
		return hc[e]
	}
	var mc = 1 / 2.2,
		dc = 2.2,
		fc = (1 + Math.sqrt(5)) / 2,
		pc = .001;

	function _c(e, t, i = 1401298e-51) {
		return Math.abs(e - t) <= i
	}

	function gc(e, t) {
		return e === t ? e : Math.random() * (t - e) + e
	}

	function vc(e, t, i) {
		return e + (t - e) * i
	}

	function yc(e, t = 0, i = 1) {
		return Math.min(i, Math.max(t, e))
	}

	function Sc(e) {
		return e -= 2 * Math.PI * Math.floor((e + Math.PI) / (2 * Math.PI))
	}

	function Ec(e) {
		const t = e.toString(16);
		return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase()
	}
	var Ac = class e {
		static HCF(t, i) {
			const s = t % i;
			return 0 === s ? i : e.HCF(i, s)
		}
		static MoveTowards(t, i, s) {
			let n = 0;
			return n = Math.abs(i - t) <= s ? i : t + e.Sign(i - t) * s, n
		}
		static RangeToPercent(e, t, i) {
			return (e - t) / (i - t)
		}
		static Normalize(e, t, i) {
			return (e - t) / (i - t)
		}
		static Log2(e) {
			return Math.log(e) * Math.LOG2E
		}
		static Sign(e) {
			return 0 === (e = +e) || isNaN(e) ? e : e > 0 ? 1 : -1
		}
		static Hermite1stDerivative(e, t, i, s, n) {
			const a = n * n;
			return 6 * (a - n) * e + (3 * a - 4 * n + 1) * t + 6 * (-a + n) * i + (3 * a - 2 * n) * s
		}
		static SmoothStep(t, i, s) {
			let n = e.Clamp(s);
			return n = -2 * n * n * n + 3 * n * n, i * n + t * (1 - n)
		}
		static Denormalize(e, t, i) {
			return e * (i - t) + t
		}
		static LerpAngle(t, i, s) {
			let n = e.Repeat(i - t, 360);
			return n > 180 && (n -= 360), t + n * yc(s)
		}
		static ILog2(e) {
			if (Math.log2) return Math.floor(Math.log2(e));
			if (e < 0) return NaN;
			if (0 === e) return -1 / 0;
			let t = 0;
			if (e < 1) {
				for (; e < 1;) t++, e *= 2;
				t = -t
			} else if (e > 1)
				for (; e > 1;) t++, e = Math.floor(e / 2);
			return t
		}
		static PercentToRange(e, t, i) {
			return (i - t) * e + t
		}
		static DeltaAngle(t, i) {
			let s = e.Repeat(i - t, 360);
			return s > 180 && (s -= 360), s
		}
		static PingPong(t, i) {
			const s = e.Repeat(t, 2 * i);
			return i - Math.abs(s - i)
		}
		static Repeat(e, t) {
			return e - Math.floor(e / t) * t
		}
		static MoveTowardsAngle(t, i, s) {
			const n = e.DeltaAngle(t, i);
			let a = 0;
			return -s < n && n < s ? a = i : (i = t + n, a = e.MoveTowards(t, i, s)), a
		}
		static InverseLerp(e, t, i) {
			let s = 0;
			return s = e != t ? yc((i - e) / (t - e)) : 0, s
		}
		static Hermite(e, t, i, s, n) {
			const a = n * n,
				r = n * a;
			return e * (2 * r - 3 * a + 1) + i * (-2 * r + 3 * a) + t * (r - 2 * a + n) + s * (r - a)
		}
	};

	function bc(e) {
		return Math.pow(e, dc)
	}

	function xc(e) {
		return e <= .04045 ? .0773993808 * e : Math.pow(.947867299 * (e + .055), 2.4)
	}

	function Mc(e) {
		return Math.pow(e, mc)
	}

	function Cc(e) {
		return e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
	}
	Ac.TwoPi = 2 * Math.PI, Ac.WithinEpsilon = _c, Ac.ToHex = Ec, Ac.Clamp = yc, Ac.Lerp = vc, Ac.RandomRange = gc, Ac.NormalizeRadians = Sc;
	var Tc = class e {
		equalsToFloats(e, t, i) {
			return this.r === e && this.g === t && this.b === i
		}
		scaleAndAddToRef(e, t) {
			return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t
		}
		multiplyInPlace(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
		}
		divide(e) {
			throw new ReferenceError("Can not divide a color")
		}
		static Gray() {
			return new e(.5, .5, .5)
		}
		fractToRef(e) {
			throw new ReferenceError("Can not fract a color")
		}
		static Yellow() {
			return new e(1, 1, 0)
		}
		multiply(t) {
			return new e(this.r * t.r, this.g * t.g, this.b * t.b)
		}
		negateToRef(e) {
			throw new ReferenceError("Can not negate a color")
		}
		subtractFromFloatsToRef(e, t, i, s) {
			return s.r = this.r - e, s.g = this.g - t, s.b = this.b - i, s
		}
		add(t) {
			return new e(this.r + t.r, this.g + t.g, this.b + t.b)
		}
		floor() {
			throw new ReferenceError("Can not floor a color")
		}
		toHSVToRef(e) {
			const t = this.r,
				i = this.g,
				s = this.b,
				n = Math.max(t, i, s),
				a = Math.min(t, i, s);
			let r = 0,
				o = 0;
			const l = n,
				h = n - a;
			return 0 !== n && (o = h / n), n != a && (n == t ? (r = (i - s) / h, i < s && (r += 6)) : n == i ? r = (s - t) / h + 2 : n == s && (r = (t - i) / h + 4), r *= 60), e.r = r, e.g = o, e.b = l, e
		}
		static FromHexString(t) {
			if ("#" !== t.substring(0, 1) || 7 !== t.length) return new e(0, 0, 0);
			const i = parseInt(t.substring(1, 3), 16),
				s = parseInt(t.substring(3, 5), 16),
				n = parseInt(t.substring(5, 7), 16);
			return e.FromInts(i, s, n)
		}
		equals(e) {
			return e && this.r === e.r && this.g === e.g && this.b === e.b
		}
		getClassName() {
			return "Color3"
		}
		multiplyByFloats(t, i, s) {
			return new e(this.r * t, this.g * i, this.b * s)
		}
		floorToRef(e) {
			throw new ReferenceError("Can not floor a color")
		}
		set(e, t, i) {
			return this.copyFromFloats(e, t, i)
		}
		static LerpToRef(e, t, i, s) {
			s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i
		}
		static Blue() {
			return new e(0, 0, 1)
		}
		toString() {
			return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}"
		}
		toGammaSpaceToRef(e, t = !1) {
			return t ? (e.r = Cc(this.r), e.g = Cc(this.g), e.b = Cc(this.b)) : (e.r = Mc(this.r), e.g = Mc(this.g), e.b = Mc(this.b)), this
		}
		equalsWithEpsilon(e, t = .001) {
			return Ac.WithinEpsilon(this.r, e.r, t) && Ac.WithinEpsilon(this.g, e.g, t) && Ac.WithinEpsilon(this.b, e.b, t)
		}
		minimizeInPlaceFromFloats(e, t, i) {
			return this.r = Math.min(e, this.r), this.g = Math.min(t, this.g), this.b = Math.min(i, this.b), this
		}
		static Red() {
			return new e(1, 0, 0)
		}
		asArray() {
			return [this.r, this.g, this.b]
		}
		fract() {
			throw new ReferenceError("Can not fract a color")
		}
		setAll(e) {
			return this.r = this.g = this.b = e, this
		}
		subtractToRef(e, t) {
			return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t
		}
		static FromArrayToRef(e, t = 0, i) {
			i.r = e[t], i.g = e[t + 1], i.b = e[t + 2]
		}
		maximizeInPlaceFromFloats(e, t, i) {
			return this.r = Math.max(e, this.r), this.g = Math.max(t, this.g), this.b = Math.max(i, this.b), this
		}
		toLinearSpace(t = !1) {
			const i = new e;
			return this.toLinearSpaceToRef(i, t), i
		}
		toHexString() {
			const e = Math.round(255 * this.r),
				t = Math.round(255 * this.g),
				i = Math.round(255 * this.b);
			return "#" + Ec(e) + Ec(t) + Ec(i)
		}
		static Hermite(t, i, s, n, a) {
			const r = a * a,
				o = a * r,
				l = 2 * o - 3 * r + 1,
				h = -2 * o + 3 * r,
				c = o - 2 * r + a,
				u = o - r,
				m = t.r * l + s.r * h + i.r * c + n.r * u,
				d = t.g * l + s.g * h + i.g * c + n.g * u,
				f = t.b * l + s.b * h + i.b * c + n.b * u;
			return new e(m, d, f)
		}
		addToRef(e, t) {
			return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, t
		}
		clampToRef(e = 0, t = 1, i) {
			return i.r = yc(this.r, e, t), i.g = yc(this.g, e, t), i.b = yc(this.b, e, t), i
		}
		static Teal() {
			return new e(0, 1, 1)
		}
		static Random() {
			return new e(Math.random(), Math.random(), Math.random())
		}
		copyFromFloats(e, t, i) {
			return this.r = e, this.g = t, this.b = i, this
		}
		toLuminance() {
			return .3 * this.r + .59 * this.g + .11 * this.b
		}
		multiplyToRef(e, t) {
			return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t
		}
		static HSVtoRGBToRef(e, t, i, s) {
			const n = i * t,
				a = e / 60,
				r = n * (1 - Math.abs(a % 2 - 1));
			let o = 0,
				l = 0,
				h = 0;
			a >= 0 && a <= 1 ? (o = n, l = r) : a >= 1 && a <= 2 ? (o = r, l = n) : a >= 2 && a <= 3 ? (l = n, h = r) : a >= 3 && a <= 4 ? (l = r, h = n) : a >= 4 && a <= 5 ? (o = r, h = n) : a >= 5 && a <= 6 && (o = n, h = r);
			const c = i - n;
			return s.r = o + c, s.g = l + c, s.b = h + c, s
		}
		subtractInPlace(e) {
			return this.r -= e.r, this.g -= e.g, this.b -= e.b, this
		}
		addInPlaceFromFloats(e, t, i) {
			return this.r += e, this.g += t, this.b += i, this
		}
		static Black() {
			return new e(0, 0, 0)
		}
		clone() {
			return new e(this.r, this.g, this.b)
		}
		constructor(e = 0, t = 0, i = 0) {
			this.r = e, this.g = t, this.b = i
		}
		fromArray(t, i = 0) {
			return e.FromArrayToRef(t, i, this), this
		}
		addInPlace(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this
		}
		minimizeInPlace(e) {
			return this.minimizeInPlaceFromFloats(e.r, e.g, e.b)
		}
		static Green() {
			return new e(0, 1, 0)
		}
		scaleToRef(e, t) {
			return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t
		}
		negate() {
			throw new ReferenceError("Can not negate a color")
		}
		toColor4(e = 1) {
			return new wc(this.r, this.g, this.b, e)
		}
		toGammaSpace(t = !1) {
			const i = new e;
			return this.toGammaSpaceToRef(i, t), i
		}
		subtract(t) {
			return new e(this.r - t.r, this.g - t.g, this.b - t.b)
		}
		scaleInPlace(e) {
			return this.r *= e, this.g *= e, this.b *= e, this
		}
		static FromArray(t, i = 0) {
			return new e(t[i], t[i + 1], t[i + 2])
		}
		static White() {
			return new e(1, 1, 1)
		}
		static Purple() {
			return new e(.5, 0, .5)
		}
		negateInPlace() {
			throw new ReferenceError("Can not negate a color")
		}
		divideToRef(e, t) {
			throw new ReferenceError("Can not divide a color")
		}
		scale(t) {
			return new e(this.r * t, this.g * t, this.b * t)
		}
		static Lerp(t, i, s) {
			const n = new e(0, 0, 0);
			return e.LerpToRef(t, i, s, n), n
		}
		divideInPlace(e) {
			throw new ReferenceError("Can not divide a color")
		}
		subtractFromFloats(t, i, s) {
			return new e(this.r - t, this.g - i, this.b - s)
		}
		toHSV() {
			return this.toHSVToRef(new e)
		}
		getHashCode() {
			let e = 255 * this.r | 0;
			return e = 397 * e ^ 255 * this.g, e = 397 * e ^ 255 * this.b, e
		}
		static Magenta() {
			return new e(1, 0, 1)
		}
		equalsFloats(e, t, i) {
			return this.equalsToFloats(e, t, i)
		}
		static FromHSV(t, i, s) {
			const n = new e(0, 0, 0);
			return e.HSVtoRGBToRef(t, i, s, n), n
		}
		static Hermite1stDerivative(t, i, s, n, a) {
			const r = e.Black();
			return this.Hermite1stDerivativeToRef(t, i, s, n, a, r), r
		}
		toLinearSpaceToRef(e, t = !1) {
			return t ? (e.r = xc(this.r), e.g = xc(this.g), e.b = xc(this.b)) : (e.r = bc(this.r), e.g = bc(this.g), e.b = bc(this.b)), this
		}
		static Hermite1stDerivativeToRef(e, t, i, s, n, a) {
			const r = n * n;
			a.r = 6 * (r - n) * e.r + (3 * r - 4 * n + 1) * t.r + 6 * (-r + n) * i.r + (3 * r - 2 * n) * s.r, a.g = 6 * (r - n) * e.g + (3 * r - 4 * n + 1) * t.g + 6 * (-r + n) * i.g + (3 * r - 2 * n) * s.g, a.b = 6 * (r - n) * e.b + (3 * r - 4 * n + 1) * t.b + 6 * (-r + n) * i.b + (3 * r - 2 * n) * s.b
		}
		static FromInts(t, i, s) {
			return new e(t / 255, i / 255, s / 255)
		}
		maximizeInPlace(e) {
			return this.maximizeInPlaceFromFloats(e.r, e.g, e.b)
		}
		static get BlackReadOnly() {
			return e._BlackReadOnly
		}
		copyFrom(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		}
		toArray(e, t = 0) {
			return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this
		}
	};
	Tc._BlackReadOnly = Tc.Black(), Object.defineProperties(Tc.prototype, {
		dimension: {
			value: [3]
		},
		rank: {
			value: 1
		}
	});
	var wc = class e {
		scale(t) {
			return new e(this.r * t, this.g * t, this.b * t, this.a * t)
		}
		subtract(t) {
			return new e(this.r - t.r, this.g - t.g, this.b - t.b, this.a - t.a)
		}
		negateInPlace() {
			throw new ReferenceError("Can not negate a color")
		}
		divideToRef(e, t) {
			throw new ReferenceError("Can not divide a color")
		}
		multiplyToRef(e, t) {
			return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t
		}
		copyFrom(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this
		}
		static FromArray(t, i = 0) {
			return new e(t[i], t[i + 1], t[i + 2], t[i + 3])
		}
		toHexString(e = !1) {
			const t = Math.round(255 * this.r),
				i = Math.round(255 * this.g),
				s = Math.round(255 * this.b);
			if (e) return "#" + Ec(t) + Ec(i) + Ec(s);
			const n = Math.round(255 * this.a);
			return "#" + Ec(t) + Ec(i) + Ec(s) + Ec(n)
		}
		static Lerp(t, i, s) {
			return e.LerpToRef(t, i, s, new e)
		}
		scaleToRef(e, t) {
			return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, t
		}
		subtractInPlace(e) {
			return this.r -= e.r, this.g -= e.g, this.b -= e.b, this.a -= e.a, this
		}
		multiplyInPlace(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this.a *= e.a, this
		}
		static FromHexString(t) {
			if ("#" !== t.substring(0, 1) || 9 !== t.length && 7 !== t.length) return new e(0, 0, 0, 0);
			const i = parseInt(t.substring(1, 3), 16),
				s = parseInt(t.substring(3, 5), 16),
				n = parseInt(t.substring(5, 7), 16),
				a = 9 === t.length ? parseInt(t.substring(7, 9), 16) : 255;
			return e.FromInts(i, s, n, a)
		}
		static FromInts(t, i, s, n) {
			return new e(t / 255, i / 255, s / 255, n / 255)
		}
		minimizeInPlace(e) {
			return this.r = Math.min(this.r, e.r), this.g = Math.min(this.g, e.g), this.b = Math.min(this.b, e.b), this.a = Math.min(this.a, e.a), this
		}
		divideInPlace(e) {
			throw new ReferenceError("Can not divide a color")
		}
		minimizeInPlaceFromFloats(e, t, i, s) {
			return this.r = Math.min(e, this.r), this.g = Math.min(t, this.g), this.b = Math.min(i, this.b), this.a = Math.min(s, this.a), this
		}
		toString() {
			return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}"
		}
		maximizeInPlaceFromFloats(e, t, i, s) {
			return this.r = Math.max(e, this.r), this.g = Math.max(t, this.g), this.b = Math.max(i, this.b), this.a = Math.max(s, this.a), this
		}
		static FromArrayToRef(e, t = 0, i) {
			i.r = e[t], i.g = e[t + 1], i.b = e[t + 2], i.a = e[t + 3]
		}
		setAll(e) {
			return this.r = this.g = this.b = this.a = e, this
		}
		static FromColor3(t, i = 1) {
			return new e(t.r, t.g, t.b, i)
		}
		equalsToFloats(e, t, i, s) {
			return this.r === e && this.g === t && this.b === i && this.a === s
		}
		copyFromFloats(e, t, i, s) {
			return this.r = e, this.g = t, this.b = i, this.a = s, this
		}
		static Hermite1stDerivative(t, i, s, n, a) {
			const r = new e;
			return this.Hermite1stDerivativeToRef(t, i, s, n, a, r), r
		}
		fractToRef(e) {
			throw new ReferenceError("Can not fract a color")
		}
		addInPlaceFromFloats(e, t, i, s) {
			return this.r += e, this.g += t, this.b += i, this.a += s, this
		}
		getHashCode() {
			let e = 255 * this.r | 0;
			return e = 397 * e ^ 255 * this.g, e = 397 * e ^ 255 * this.b, e = 397 * e ^ 255 * this.a, e
		}
		static LerpToRef(e, t, i, s) {
			return s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i, s.a = e.a + (t.a - e.a) * i, s
		}
		multiply(t) {
			return new e(this.r * t.r, this.g * t.g, this.b * t.b, this.a * t.a)
		}
		subtractToRef(e, t) {
			return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, t
		}
		asArray() {
			return [this.r, this.g, this.b, this.a]
		}
		fromArray(e, t = 0) {
			return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this.a = e[t + 3], this
		}
		add(t) {
			return new e(this.r + t.r, this.g + t.g, this.b + t.b, this.a + t.a)
		}
		clone() {
			return (new e).copyFrom(this)
		}
		subtractFromFloats(t, i, s, n) {
			return new e(this.r - t, this.g - i, this.b - s, this.a - n)
		}
		addInPlace(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this
		}
		static Hermite1stDerivativeToRef(e, t, i, s, n, a) {
			const r = n * n;
			a.r = 6 * (r - n) * e.r + (3 * r - 4 * n + 1) * t.r + 6 * (-r + n) * i.r + (3 * r - 2 * n) * s.r, a.g = 6 * (r - n) * e.g + (3 * r - 4 * n + 1) * t.g + 6 * (-r + n) * i.g + (3 * r - 2 * n) * s.g, a.b = 6 * (r - n) * e.b + (3 * r - 4 * n + 1) * t.b + 6 * (-r + n) * i.b + (3 * r - 2 * n) * s.b, a.a = 6 * (r - n) * e.a + (3 * r - 4 * n + 1) * t.a + 6 * (-r + n) * i.a + (3 * r - 2 * n) * s.a
		}
		clampToRef(e = 0, t = 1, i) {
			return i.r = yc(this.r, e, t), i.g = yc(this.g, e, t), i.b = yc(this.b, e, t), i.a = yc(this.a, e, t), i
		}
		toGammaSpaceToRef(e, t = !1) {
			return t ? (e.r = Cc(this.r), e.g = Cc(this.g), e.b = Cc(this.b)) : (e.r = Mc(this.r), e.g = Mc(this.g), e.b = Mc(this.b)), e.a = this.a, this
		}
		getClassName() {
			return "Color4"
		}
		fract() {
			throw new ReferenceError("Can not fract a color")
		}
		floor() {
			throw new ReferenceError("Can not floor a color")
		}
		toGammaSpace(t = !1) {
			const i = new e;
			return this.toGammaSpaceToRef(i, t), i
		}
		divide(e) {
			throw new ReferenceError("Can not divide a color")
		}
		negate() {
			throw new ReferenceError("Can not negate a color")
		}
		static Hermite(t, i, s, n, a) {
			const r = a * a,
				o = a * r,
				l = 2 * o - 3 * r + 1,
				h = -2 * o + 3 * r,
				c = o - 2 * r + a,
				u = o - r,
				m = t.r * l + s.r * h + i.r * c + n.r * u,
				d = t.g * l + s.g * h + i.g * c + n.g * u,
				f = t.b * l + s.b * h + i.b * c + n.b * u,
				p = t.a * l + s.a * h + i.a * c + n.a * u;
			return new e(m, d, f, p)
		}
		static CheckColors4(e, t) {
			if (e.length === 3 * t) {
				const t = [];
				for (let i = 0; i < e.length; i += 3) {
					const s = i / 3 * 4;
					t[s] = e[i], t[s + 1] = e[i + 1], t[s + 2] = e[i + 2], t[s + 3] = 1
				}
				return t
			}
			return e
		}
		toLinearSpace(t = !1) {
			const i = new e;
			return this.toLinearSpaceToRef(i, t), i
		}
		constructor(e = 0, t = 0, i = 0, s = 1) {
			this.r = e, this.g = t, this.b = i, this.a = s
		}
		scaleInPlace(e) {
			return this.r *= e, this.g *= e, this.b *= e, this.a *= e, this
		}
		toLinearSpaceToRef(e, t = !1) {
			return t ? (e.r = xc(this.r), e.g = xc(this.g), e.b = xc(this.b)) : (e.r = bc(this.r), e.g = bc(this.g), e.b = bc(this.b)), e.a = this.a, this
		}
		toArray(e, t = 0) {
			return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this
		}
		equals(e) {
			return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a
		}
		equalsWithEpsilon(e, t = .001) {
			return Ac.WithinEpsilon(this.r, e.r, t) && Ac.WithinEpsilon(this.g, e.g, t) && Ac.WithinEpsilon(this.b, e.b, t) && Ac.WithinEpsilon(this.a, e.a, t)
		}
		negateToRef(e) {
			throw new ReferenceError("Can not negate a color")
		}
		set(e, t, i, s) {
			return this.copyFromFloats(e, t, i, s)
		}
		maximizeInPlace(e) {
			return this.r = Math.max(this.r, e.r), this.g = Math.max(this.g, e.g), this.b = Math.max(this.b, e.b), this.a = Math.max(this.a, e.a), this
		}
		multiplyByFloats(t, i, s, n) {
			return new e(this.r * t, this.g * i, this.b * s, this.a * n)
		}
		scaleAndAddToRef(e, t) {
			return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, t
		}
		floorToRef(e) {
			throw new ReferenceError("Can not floor a color")
		}
		addToRef(e, t) {
			return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, t.a = this.a + e.a, t
		}
		subtractFromFloatsToRef(e, t, i, s, n) {
			return n.r = this.r - e, n.g = this.g - t, n.b = this.b - i, n.a = this.a - s, n
		}
	};
	Object.defineProperties(wc.prototype, {
		dimension: {
			value: [4]
		},
		rank: {
			value: 1
		}
	});
	var Rc = class {};
	Rc.Color3 = ac(3, Tc.Black), Rc.Color4 = ac(3, (() => new wc(0, 0, 0, 0))), cc("BABYLON.Color3", Tc), cc("BABYLON.Color4", wc);
	var Nc = class e {
		static SetMatrixPrecision(t) {
			if (e.MatrixTrackPrecisionChange = !1, t && !e.MatrixUse64Bits && e.MatrixTrackedMatrices)
				for (let t = 0; t < e.MatrixTrackedMatrices.length; ++t) {
					const i = e.MatrixTrackedMatrices[t],
						s = i._m;
					i._m = new Array(16);
					for (let e = 0; e < 16; ++e) i._m[e] = s[e]
				}
			e.MatrixUse64Bits = t, e.MatrixCurrentType = e.MatrixUse64Bits ? Array : Float32Array, e.MatrixTrackedMatrices = null
		}
	};
	Nc.MatrixUse64Bits = !1, Nc.MatrixTrackPrecisionChange = !0, Nc.MatrixCurrentType = Float32Array, Nc.MatrixTrackedMatrices = [];
	var Ic = class {
			initialize(e, t = !1, i, s) {
				return this.mask = e, this.skipNextObservers = t, this.target = i, this.currentTarget = s, this
			}
			constructor(e, t = !1, i, s) {
				this.initialize(e, t, i, s)
			}
		},
		Pc = class {
			remove() {
				this._remove && this._remove()
			}
			constructor(e, t, i = null) {
				this.callback = e, this.mask = t, this.scope = i, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1, this._remove = null
			}
		},
		kc = class e {
			add(e, t = -1, i = !1, s = null, n = !1) {
				if (!e) return null;
				const a = new Pc(e, t, s);
				return a.unregisterOnNextCall = n, i ? this._observers.unshift(a) : this._observers.push(a), this._onObserverAdded && this._onObserverAdded(a), this._hasNotified && this.notifyIfTriggered && void 0 !== this._lastNotifiedValue && this.notifyObserver(a, this._lastNotifiedValue), a._remove = () => {
					this.remove(a)
				}, a
			}
			notifyObserver(e, t, i = -1) {
				if (this.notifyIfTriggered && (this._hasNotified = !0, this._lastNotifiedValue = t), e._willBeUnregistered) return;
				const s = this._eventState;
				s.mask = i, s.skipNextObservers = !1, e.unregisterOnNextCall && this._deferUnregister(e), e.callback(t, s)
			}
			clone() {
				const t = new e;
				return t._observers = this._observers.slice(0), t
			}
			hasObservers() {
				return this._observers.length - this._numObserversMarkedAsDeleted > 0
			}
			notifyObservers(e, t = -1, i, s, n) {
				if (this.notifyIfTriggered && (this._hasNotified = !0, this._lastNotifiedValue = e), !this._observers.length) return !0;
				const a = this._eventState;
				a.mask = t, a.target = i, a.currentTarget = s, a.skipNextObservers = !1, a.lastReturnValue = e, a.userInfo = n;
				for (const i of this._observers)
					if (!i._willBeUnregistered && (i.mask & t && (i.unregisterOnNextCall && this._deferUnregister(i), i.scope ? a.lastReturnValue = i.callback.apply(i.scope, [e, a]) : a.lastReturnValue = i.callback(e, a)), a.skipNextObservers)) return !1;
				return !0
			}
			constructor(e, t = !1) {
				this.notifyIfTriggered = t, this._observers = new Array, this._numObserversMarkedAsDeleted = 0, this._hasNotified = !1, this._eventState = new Ic(0), e && (this._onObserverAdded = e)
			}
			_deferUnregister(e) {
				e._willBeUnregistered || (this._numObserversMarkedAsDeleted++, e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, setTimeout((() => {
					this._remove(e)
				}), 0))
			}
			addOnce(e) {
				return this.add(e, void 0, void 0, void 0, !0)
			}
			cleanLastNotifiedState() {
				this._hasNotified = !1, this._lastNotifiedValue = void 0
			}
			makeObserverBottomPriority(e) {
				this._remove(e, !1), this._observers.push(e)
			}
			makeObserverTopPriority(e) {
				this._remove(e, !1), this._observers.unshift(e)
			}
			hasSpecificMask(e = -1) {
				for (const t of this._observers)
					if (t.mask & e || t.mask === e) return !0;
				return !1
			}
			_remove(e, t = !0) {
				if (!e) return !1;
				const i = this._observers.indexOf(e);
				return -1 !== i && (t && this._numObserversMarkedAsDeleted--, this._observers.splice(i, 1), !0)
			}
			get observers() {
				return this._observers
			}
			remove(e) {
				if (!e) return !1;
				e._remove = null;
				return -1 !== this._observers.indexOf(e) && (this._deferUnregister(e), !0)
			}
			removeCallback(e, t) {
				for (let i = 0; i < this._observers.length; i++) {
					const s = this._observers[i];
					if (!s._willBeUnregistered && (s.callback === e && (!t || t === s.scope))) return this._deferUnregister(s), !0
				}
				return !1
			}
			static FromPromise(t, i) {
				const s = new e;
				return t.then((e => {
					s.notifyObservers(e)
				})).catch((e => {
					if (!i) throw e;
					i.notifyObservers(e)
				})), s
			}
			clear() {
				for (; this._observers.length;) {
					const e = this._observers.pop();
					e && (e._remove = null)
				}
				this._onObserverAdded = null, this._numObserversMarkedAsDeleted = 0, this.cleanLastNotifiedState()
			}
		},
		Dc = class {
			static get LastCreatedScene() {
				return this._LastCreatedScene
			}
			static get LastCreatedEngine() {
				return 0 === this.Instances.length ? null : this.Instances[this.Instances.length - 1]
			}
		};
	Dc.Instances = [], Dc.OnEnginesDisposedObservable = new kc, Dc._LastCreatedScene = null, Dc.UseFallbackTexture = !0, Dc.FallbackTexture = "";
	var Oc = e => parseInt(e.toString().replace(/\W/g, "")),
		Fc = class e {
			toString() {
				return `{X: ${this.x} Y: ${this.y}}`
			}
			scaleToRef(e, t) {
				return t.x = this.x * e, t.y = this.y * e, t
			}
			maximizeInPlaceFromFloats(e, t) {
				return this.x = Math.max(e, this.x), this.y = Math.max(t, this.y), this
			}
			rotateToRef(e, t) {
				const i = Math.cos(e),
					s = Math.sin(e),
					n = i * this.x - s * this.y,
					a = s * this.x + i * this.y;
				return t.x = n, t.y = a, t
			}
			static Random(t = 0, i = 1) {
				return new e(gc(t, i), gc(t, i))
			}
			addInPlace(e) {
				return this.x += e.x, this.y += e.y, this
			}
			static DistanceSquared(e, t) {
				const i = e.x - t.x,
					s = e.y - t.y;
				return i * i + s * s
			}
			static get ZeroReadOnly() {
				return e._ZeroReadOnly
			}
			divideInPlace(e) {
				return this.x = this.x / e.x, this.y = this.y / e.y, this
			}
			normalize() {
				return this.normalizeFromLength(this.length())
			}
			static Hermite1stDerivative(t, i, s, n, a) {
				return this.Hermite1stDerivativeToRef(t, i, s, n, a, new e)
			}
			static Zero() {
				return new e(0, 0)
			}
			static FromFloatsToRef(e, t, i) {
				return i.copyFromFloats(e, t), i
			}
			setAll(e) {
				return this.copyFromFloats(e, e)
			}
			copyFromFloats(e, t) {
				return this.x = e, this.y = t, this
			}
			minimizeInPlaceFromFloats(e, t) {
				return this.x = Math.min(e, this.x), this.y = Math.min(t, this.y), this
			}
			scale(t) {
				return new e(this.x * t, this.y * t)
			}
			equalsWithEpsilon(e, t = .001) {
				return e && _c(this.x, e.x, t) && _c(this.y, e.y, t)
			}
			static Clamp(t, i, s) {
				const n = yc(t.x, i.x, s.x),
					a = yc(t.y, i.y, s.y);
				return new e(n, a)
			}
			subtractToRef(e, t) {
				return t.x = this.x - e.x, t.y = this.y - e.y, t
			}
			maximizeInPlace(e) {
				return this.maximizeInPlaceFromFloats(e.x, e.y)
			}
			normalizeToRef(e) {
				const t = this.length();
				return 0 === t && (e.x = this.x, e.y = this.y), this.scaleToRef(1 / t, e)
			}
			static Minimize(t, i) {
				const s = t.x < i.x ? t.x : i.x,
					n = t.y < i.y ? t.y : i.y;
				return new e(s, n)
			}
			static Dot(e, t) {
				return e.x * t.x + e.y * t.y
			}
			toArray(e, t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, this
			}
			set(e, t) {
				return this.copyFromFloats(e, t)
			}
			static Maximize(t, i) {
				const s = t.x > i.x ? t.x : i.x,
					n = t.y > i.y ? t.y : i.y;
				return new e(s, n)
			}
			negateInPlace() {
				return this.x *= -1, this.y *= -1, this
			}
			multiply(t) {
				return new e(this.x * t.x, this.y * t.y)
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y)
			}
			floorToRef(e) {
				return e.x = Math.floor(this.x), e.y = Math.floor(this.y), e
			}
			negate() {
				return new e(-this.x, -this.y)
			}
			static FromArray(t, i = 0) {
				return new e(t[i], t[i + 1])
			}
			getClassName() {
				return "Vector2"
			}
			subtract(t) {
				return new e(this.x - t.x, this.y - t.y)
			}
			static Distance(t, i) {
				return Math.sqrt(e.DistanceSquared(t, i))
			}
			static NormalizeToRef(e, t) {
				return e.normalizeToRef(t), t
			}
			divideToRef(e, t) {
				return t.x = this.x / e.x, t.y = this.y / e.y, t
			}
			add(t) {
				return new e(this.x + t.x, this.y + t.y)
			}
			constructor(e = 0, t = 0) {
				this.x = e, this.y = t
			}
			minimizeInPlace(e) {
				return this.minimizeInPlaceFromFloats(e.x, e.y)
			}
			fractToRef(e) {
				return e.x = this.x - Math.floor(this.x), e.y = this.y - Math.floor(this.y), e
			}
			static PointInTriangle(e, t, i, s) {
				const n = .5 * (-i.y * s.x + t.y * (-i.x + s.x) + t.x * (i.y - s.y) + i.x * s.y),
					a = n < 0 ? -1 : 1,
					r = (t.y * s.x - t.x * s.y + (s.y - t.y) * e.x + (t.x - s.x) * e.y) * a,
					o = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * a;
				return r > 0 && o > 0 && r + o < 2 * n * a
			}
			addInPlaceFromFloats(e, t) {
				return this.x += e, this.y += t, this
			}
			scaleInPlace(e) {
				return this.x *= e, this.y *= e, this
			}
			equals(e) {
				return e && this.x === e.x && this.y === e.y
			}
			getHashCode() {
				let e = Oc(this.x);
				return e = 397 * e ^ Oc(this.y), e
			}
			static DistanceOfPointFromSegment(t, i, s) {
				const n = e.DistanceSquared(i, s);
				if (0 === n) return e.Distance(t, i);
				const a = s.subtract(i),
					r = Math.max(0, Math.min(1, e.Dot(t.subtract(i), a) / n)),
					o = i.add(a.multiplyByFloats(r, r));
				return e.Distance(t, o)
			}
			addVector3(t) {
				return new e(this.x + t.x, this.y + t.y)
			}
			clone() {
				return new e(this.x, this.y)
			}
			normalizeFromLength(e) {
				return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
			}
			static Lerp(t, i, s) {
				return e.LerpToRef(t, i, s, new e)
			}
			divide(t) {
				return new e(this.x / t.x, this.y / t.y)
			}
			asArray() {
				return [this.x, this.y]
			}
			static Hermite(t, i, s, n, a) {
				const r = a * a,
					o = a * r,
					l = 2 * o - 3 * r + 1,
					h = -2 * o + 3 * r,
					c = o - 2 * r + a,
					u = o - r,
					m = t.x * l + s.x * h + i.x * c + n.x * u,
					d = t.y * l + s.y * h + i.y * c + n.y * u;
				return new e(m, d)
			}
			static One() {
				return new e(1, 1)
			}
			static CatmullRom(t, i, s, n, a) {
				const r = a * a,
					o = a * r,
					l = .5 * (2 * i.x + (-t.x + s.x) * a + (2 * t.x - 5 * i.x + 4 * s.x - n.x) * r + (-t.x + 3 * i.x - 3 * s.x + n.x) * o),
					h = .5 * (2 * i.y + (-t.y + s.y) * a + (2 * t.y - 5 * i.y + 4 * s.y - n.y) * r + (-t.y + 3 * i.y - 3 * s.y + n.y) * o);
				return new e(l, h)
			}
			equalsToFloats(e, t) {
				return this.x === e && this.y === t
			}
			static RandomToRef(e = 0, t = 1, i) {
				return i.copyFromFloats(gc(e, t), gc(e, t))
			}
			static Normalize(t) {
				return e.NormalizeToRef(t, new e)
			}
			multiplyToRef(e, t) {
				return t.x = this.x * e.x, t.y = this.y * e.y, t
			}
			floor() {
				return new e(Math.floor(this.x), Math.floor(this.y))
			}
			static LerpToRef(e, t, i, s) {
				return s.x = e.x + (t.x - e.x) * i, s.y = e.y + (t.y - e.y) * i, s
			}
			normalizeToNew() {
				const t = new e;
				return this.normalizeToRef(t), t
			}
			static Transform(t, i) {
				return e.TransformToRef(t, i, new e)
			}
			static Center(t, i) {
				return e.CenterToRef(t, i, new e)
			}
			lengthSquared() {
				return this.x * this.x + this.y * this.y
			}
			static TransformToRef(e, t, i) {
				const s = t.m,
					n = e.x * s[0] + e.y * s[4] + s[12],
					a = e.x * s[1] + e.y * s[5] + s[13];
				return i.x = n, i.y = a, i
			}
			copyFrom(e) {
				return this.x = e.x, this.y = e.y, this
			}
			multiplyInPlace(e) {
				return this.x *= e.x, this.y *= e.y, this
			}
			static ClampToRef(e, t, i, s) {
				return s.x = yc(e.x, t.x, i.x), s.y = yc(e.y, t.y, i.y), s
			}
			fract() {
				return new e(this.x - Math.floor(this.x), this.y - Math.floor(this.y))
			}
			subtractInPlace(e) {
				return this.x -= e.x, this.y -= e.y, this
			}
			subtractFromFloats(t, i) {
				return new e(this.x - t, this.y - i)
			}
			scaleAndAddToRef(e, t) {
				return t.x += this.x * e, t.y += this.y * e, t
			}
			addToRef(e, t) {
				return t.x = this.x + e.x, t.y = this.y + e.y, t
			}
			fromArray(t, i = 0) {
				return e.FromArrayToRef(t, i, this), this
			}
			static Hermite1stDerivativeToRef(e, t, i, s, n, a) {
				const r = n * n;
				return a.x = 6 * (r - n) * e.x + (3 * r - 4 * n + 1) * t.x + 6 * (-r + n) * i.x + (3 * r - 2 * n) * s.x, a.y = 6 * (r - n) * e.y + (3 * r - 4 * n + 1) * t.y + 6 * (-r + n) * i.y + (3 * r - 2 * n) * s.y, a
			}
			negateToRef(e) {
				return e.x = -this.x, e.y = -this.y, e
			}
			static CenterToRef(e, t, i) {
				return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2)
			}
			subtractFromFloatsToRef(e, t, i) {
				return i.x = this.x - e, i.y = this.y - t, i
			}
			multiplyByFloats(t, i) {
				return new e(this.x * t, this.y * i)
			}
			dot(e) {
				return this.x * e.x + this.y * e.y
			}
			static FromArrayToRef(e, t, i) {
				return i.x = e[t], i.y = e[t + 1], i
			}
		};
	Fc._ZeroReadOnly = Fc.Zero(), Object.defineProperties(Fc.prototype, {
		dimension: {
			value: [2]
		},
		rank: {
			value: 1
		}
	});
	var Lc = class e {
		addInPlaceFromFloats(e, t, i) {
			return this._x += e, this._y += t, this._z += i, this._isDirty = !0, this
		}
		applyRotationQuaternion(t) {
			return this.applyRotationQuaternionToRef(t, new e)
		}
		get hasAZeroComponent() {
			return this._x * this._y * this._z == 0
		}
		static Forward(t = !1) {
			return new e(0, 0, t ? -1 : 1)
		}
		static Right() {
			return new e(1, 0, 0)
		}
		normalizeToRef(e) {
			const t = this.length();
			return 0 === t || 1 === t ? (e._x = this._x, e._y = this._y, e._z = this._z, e._isDirty = !0, e) : this.scaleToRef(1 / t, e)
		}
		minimizeInPlace(e) {
			return this.minimizeInPlaceFromFloats(e._x, e._y, e._z)
		}
		static Down() {
			return new e(0, -1, 0)
		}
		static RotationFromAxis(t, i, s) {
			const n = new e;
			return e.RotationFromAxisToRef(t, i, s, n), n
		}
		set y(e) {
			this._y = e, this._isDirty = !0
		}
		fractToRef(e) {
			return e._x = this.x - Math.floor(this._x), e._y = this.y - Math.floor(this._y), e._z = this.z - Math.floor(this._z), e._isDirty = !0, e
		}
		static Random(t = 0, i = 1) {
			return new e(gc(t, i), gc(t, i), gc(t, i))
		}
		subtractFromFloats(t, i, s) {
			return new e(this._x - t, this._y - i, this._z - s)
		}
		set x(e) {
			this._x = e, this._isDirty = !0
		}
		static PitchYawRollToMoveBetweenPoints(t, i) {
			const s = e.Zero();
			return e.PitchYawRollToMoveBetweenPointsToRef(t, i, s)
		}
		static FromFloatArrayToRef(t, i, s) {
			return e.FromArrayToRef(t, i, s)
		}
		projectOnPlane(t, i) {
			return this.projectOnPlaneToRef(t, i, new e)
		}
		static TransformNormal(t, i) {
			const s = e.Zero();
			return e.TransformNormalToRef(t, i, s), s
		}
		static Cross(t, i) {
			const s = new e;
			return e.CrossToRef(t, i, s), s
		}
		equalsToFloats(e, t, i) {
			return this._x === e && this._y === t && this._z === i
		}
		static ClampToRef(e, t, i, s) {
			let n = e._x;
			n = n > i._x ? i._x : n, n = n < t._x ? t._x : n;
			let a = e._y;
			a = a > i._y ? i._y : a, a = a < t._y ? t._y : a;
			let r = e._z;
			return r = r > i._z ? i._z : r, r = r < t._z ? t._z : r, s.copyFromFloats(n, a, r), s
		}
		getClassName() {
			return "Vector3"
		}
		divideInPlace(e) {
			return this._x = this._x / e._x, this._y = this._y / e._y, this._z = this._z / e._z, this._isDirty = !0, this
		}
		static get RightHandedBackwardReadOnly() {
			return e._RightHandedBackwardReadOnly
		}
		floorToRef(e) {
			return e._x = Math.floor(this._x), e._y = Math.floor(this._y), e._z = Math.floor(this._z), e._isDirty = !0, e
		}
		static Clamp(t, i, s) {
			const n = new e;
			return e.ClampToRef(t, i, s, n), n
		}
		static FromFloatArray(t, i) {
			return e.FromArray(t, i)
		}
		static TransformCoordinatesFromFloatsToRef(e, t, i, s, n) {
			const a = s.m,
				r = e * a[0] + t * a[4] + i * a[8] + a[12],
				o = e * a[1] + t * a[5] + i * a[9] + a[13],
				l = e * a[2] + t * a[6] + i * a[10] + a[14],
				h = 1 / (e * a[3] + t * a[7] + i * a[11] + a[15]);
			return n._x = r * h, n._y = o * h, n._z = l * h, n._isDirty = !0, n
		}
		negateInPlace() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this._isDirty = !0, this
		}
		addInPlace(e) {
			return this._x += e._x, this._y += e._y, this._z += e._z, this._isDirty = !0, this
		}
		equalsWithEpsilon(e, t = .001) {
			return e && _c(this._x, e._x, t) && _c(this._y, e._y, t) && _c(this._z, e._z, t)
		}
		dot(e) {
			return this._x * e._x + this._y * e._y + this._z * e._z
		}
		static SmoothToRef(t, i, s, n, a) {
			return e.SlerpToRef(t, i, 0 === n ? 1 : s / n, a), a
		}
		static get LeftReadOnly() {
			return e._LeftReadOnly
		}
		lengthSquared() {
			return this._x * this._x + this._y * this._y + this._z * this._z
		}
		static CenterToRef(e, t, i) {
			return i.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2)
		}
		static UnprojectFloatsToRef(t, i, s, n, a, r, o, l, h) {
			const c = Uc.Matrix[0];
			r.multiplyToRef(o, c), c.multiplyToRef(l, c), c.invert();
			const u = Uc.Vector3[0];
			return u.x = t / n * 2 - 1, u.y = -(i / a * 2 - 1), Dc.LastCreatedEngine?.isNDCHalfZRange ? u.z = s : u.z = 2 * s - 1, e._UnprojectFromInvertedMatrixToRef(u, c, h), h
		}
		static FromArray(t, i = 0) {
			return new e(t[i], t[i + 1], t[i + 2])
		}
		normalizeFromLength(e) {
			return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
		}
		static Up() {
			return new e(0, 1, 0)
		}
		static Maximize(t, i) {
			const s = new e;
			return s.copyFrom(t), s.maximizeInPlace(i), s
		}
		static Unproject(t, i, s, n, a, r) {
			const o = new e;
			return e.UnprojectToRef(t, i, s, n, a, r, o), o
		}
		static Distance(t, i) {
			return Math.sqrt(e.DistanceSquared(t, i))
		}
		normalize() {
			return this.normalizeFromLength(this.length())
		}
		fract() {
			return new e(this.x - Math.floor(this._x), this.y - Math.floor(this._y), this.z - Math.floor(this._z))
		}
		static RotationFromAxisToRef(e, t, i, s) {
			const n = Uc.uk[0];
			return Gc.RotationQuaternionFromAxisToRef(e, t, i, n), n.toEulerAnglesToRef(s), s
		}
		static ProjectToRef(t, i, s, n, a) {
			const r = n.width,
				o = n.height,
				l = n.x,
				h = n.y,
				c = Uc.Matrix[1],
				u = Dc.LastCreatedEngine?.isNDCHalfZRange,
				m = u ? 1 : .5,
				d = u ? 0 : .5;
			Hc.FromValuesToRef(r / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, m, 0, l + r / 2, o / 2 + h, d, 1, c);
			const f = Uc.Matrix[0];
			return i.multiplyToRef(s, f), f.multiplyToRef(c, f), e.TransformCoordinatesToRef(t, f, a), a
		}
		static Project(t, i, s, n) {
			const a = new e;
			return e.ProjectToRef(t, i, s, n, a), a
		}
		static RandomToRef(e = 0, t = 1, i) {
			return i.copyFromFloats(gc(e, t), gc(e, t), gc(e, t))
		}
		static Reflect(t, i) {
			return this.ReflectToRef(t, i, new e)
		}
		fromArray(t, i = 0) {
			return e.FromArrayToRef(t, i, this), this
		}
		static TransformNormalFromFloatsToRef(e, t, i, s, n) {
			const a = s.m;
			return n._x = e * a[0] + t * a[4] + i * a[8], n._y = e * a[1] + t * a[5] + i * a[9], n._z = e * a[2] + t * a[6] + i * a[10], n._isDirty = !0, n
		}
		addToRef(e, t) {
			return t._x = this._x + e._x, t._y = this._y + e._y, t._z = this._z + e._z, t._isDirty = !0, t
		}
		copyFrom(e) {
			return this.copyFromFloats(e._x, e._y, e._z)
		}
		static get LeftHandedBackwardReadOnly() {
			return e._LeftHandedBackwardReadOnly
		}
		clone() {
			return new e(this._x, this._y, this._z)
		}
		getHashCode() {
			let e = Oc(this._x);
			return e = 397 * e ^ Oc(this._y), e = 397 * e ^ Oc(this._z), e
		}
		static UnprojectFromTransform(e, t, i, s, n) {
			return this.Unproject(e, t, i, s, n, Hc.IdentityReadOnly)
		}
		static Hermite(t, i, s, n, a) {
			const r = a * a,
				o = a * r,
				l = 2 * o - 3 * r + 1,
				h = -2 * o + 3 * r,
				c = o - 2 * r + a,
				u = o - r,
				m = t._x * l + s._x * h + i._x * c + n._x * u,
				d = t._y * l + s._y * h + i._y * c + n._y * u,
				f = t._z * l + s._z * h + i._z * c + n._z * u;
			return new e(m, d, f)
		}
		negate() {
			return new e(-this._x, -this._y, -this._z)
		}
		static Minimize(t, i) {
			const s = new e;
			return s.copyFrom(t), s.minimizeInPlace(i), s
		}
		static Backward(t = !1) {
			return new e(0, 0, t ? 1 : -1)
		}
		static ProjectOnTriangleToRef(t, i, s, n, a) {
			const r = Uc.Vector3[0],
				o = Uc.Vector3[1],
				l = Uc.Vector3[2],
				h = Uc.Vector3[3],
				c = Uc.Vector3[4];
			s.subtractToRef(i, r), n.subtractToRef(i, o), n.subtractToRef(s, l);
			const u = r.length(),
				m = o.length(),
				d = l.length();
			if (u < pc || m < pc || d < pc) return a.copyFrom(i), e.Distance(t, i);
			t.subtractToRef(i, c), e.CrossToRef(r, o, h);
			const f = h.length();
			if (f < pc) return a.copyFrom(i), e.Distance(t, i);
			h.normalizeFromLength(f);
			let p = c.length();
			if (p < pc) return a.copyFrom(i), 0;
			c.normalizeFromLength(p);
			const _ = e.Dot(h, c),
				g = Uc.Vector3[5],
				v = Uc.Vector3[6];
			g.copyFrom(h).scaleInPlace(-p * _), v.copyFrom(t).addInPlace(g);
			const y = Uc.Vector3[4],
				S = Uc.Vector3[5],
				E = Uc.Vector3[7],
				A = Uc.Vector3[8];
			y.copyFrom(r).scaleInPlace(1 / u), A.copyFrom(o).scaleInPlace(1 / m), y.addInPlace(A).scaleInPlace(-1), S.copyFrom(r).scaleInPlace(-1 / u), A.copyFrom(l).scaleInPlace(1 / d), S.addInPlace(A).scaleInPlace(-1), E.copyFrom(l).scaleInPlace(-1 / d), A.copyFrom(o).scaleInPlace(-1 / m), E.addInPlace(A).scaleInPlace(-1);
			const b = Uc.Vector3[9];
			let x;
			b.copyFrom(v).subtractInPlace(i), e.CrossToRef(y, b, A), x = e.Dot(A, h);
			const M = x;
			b.copyFrom(v).subtractInPlace(s), e.CrossToRef(S, b, A), x = e.Dot(A, h);
			const C = x;
			b.copyFrom(v).subtractInPlace(n), e.CrossToRef(E, b, A), x = e.Dot(A, h);
			const T = x,
				w = Uc.Vector3[10];
			let R, N;
			M > 0 && C < 0 ? (w.copyFrom(r), R = i, N = s) : C > 0 && T < 0 ? (w.copyFrom(l), R = s, N = n) : (w.copyFrom(o).scaleInPlace(-1), R = n, N = i);
			const I = Uc.Vector3[9],
				P = Uc.Vector3[4];
			R.subtractToRef(v, A), N.subtractToRef(v, I), e.CrossToRef(A, I, P);
			if (!(e.Dot(P, h) < 0)) return a.copyFrom(v), Math.abs(p * _);
			const k = Uc.Vector3[5];
			e.CrossToRef(w, P, k), k.normalize();
			const D = Uc.Vector3[9];
			D.copyFrom(R).subtractInPlace(v);
			const O = D.length();
			if (O < pc) return a.copyFrom(R), e.Distance(t, R);
			D.normalizeFromLength(O);
			const F = e.Dot(k, D),
				L = Uc.Vector3[7];
			L.copyFrom(v).addInPlace(k.scaleInPlace(O * F)), A.copyFrom(L).subtractInPlace(R), p = w.length(), w.normalizeFromLength(p);
			let B = e.Dot(A, w) / Math.max(p, pc);
			return B = yc(B, 0, 1), L.copyFrom(R).addInPlace(w.scaleInPlace(B * p)), a.copyFrom(L), e.Distance(t, L)
		}
		static SlerpToRef(t, i, s, n) {
			s = yc(s, 0, 1);
			const a = Uc.Vector3[0],
				r = Uc.Vector3[1];
			a.copyFrom(t);
			const o = a.length();
			a.normalizeFromLength(o), r.copyFrom(i);
			const l = r.length();
			r.normalizeFromLength(l);
			const h = e.Dot(a, r);
			let c, u;
			if (h < .999) {
				const e = Math.acos(h),
					t = 1 / Math.sin(e);
				c = Math.sin((1 - s) * e) * t, u = Math.sin(s * e) * t
			} else c = 1 - s, u = s;
			return a.scaleInPlace(c), r.scaleInPlace(u), n.copyFrom(a).addInPlace(r), n.scaleInPlace(vc(o, l, s)), n
		}
		static TransformCoordinates(t, i) {
			const s = e.Zero();
			return e.TransformCoordinatesToRef(t, i, s), s
		}
		set z(e) {
			this._z = e, this._isDirty = !0
		}
		subtractInPlace(e) {
			return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._isDirty = !0, this
		}
		static Center(t, i) {
			return e.CenterToRef(t, i, e.Zero())
		}
		add(t) {
			return new e(this._x + t._x, this._y + t._y, this._z + t._z)
		}
		static FromArrayToRef(e, t, i) {
			return i._x = e[t], i._y = e[t + 1], i._z = e[t + 2], i._isDirty = !0, i
		}
		static CrossToRef(e, t, i) {
			const s = e._y * t._z - e._z * t._y,
				n = e._z * t._x - e._x * t._z,
				a = e._x * t._y - e._y * t._x;
			return i.copyFromFloats(s, n, a), i
		}
		divide(t) {
			return new e(this._x / t._x, this._y / t._y, this._z / t._z)
		}
		get z() {
			return this._z
		}
		static GetAngleBetweenVectorsOnPlane(t, i, s) {
			Uc.Vector3[0].copyFrom(t);
			const n = Uc.Vector3[0];
			Uc.Vector3[1].copyFrom(i);
			const a = Uc.Vector3[1];
			Uc.Vector3[2].copyFrom(s);
			const r = Uc.Vector3[2],
				o = Uc.Vector3[3],
				l = Uc.Vector3[4];
			n.normalize(), a.normalize(), r.normalize(), e.CrossToRef(r, n, o), e.CrossToRef(o, r, l);
			return Sc(Math.atan2(e.Dot(a, o), e.Dot(a, l)))
		}
		static Dot(e, t) {
			return e._x * t._x + e._y * t._y + e._z * t._z
		}
		equals(e) {
			return e && this._x === e._x && this._y === e._y && this._z === e._z
		}
		scaleAndAddToRef(e, t) {
			return t._x += this._x * e, t._y += this._y * e, t._z += this._z * e, t._isDirty = !0, t
		}
		static get DownReadOnly() {
			return e._DownReadOnly
		}
		multiplyByFloats(t, i, s) {
			return new e(this._x * t, this._y * i, this._z * s)
		}
		maximizeInPlace(e) {
			return this.maximizeInPlaceFromFloats(e._x, e._y, e._z)
		}
		static Zero() {
			return new e(0, 0, 0)
		}
		static Lerp(t, i, s) {
			const n = new e(0, 0, 0);
			return e.LerpToRef(t, i, s, n), n
		}
		get isNonUniform() {
			const e = Math.abs(this._x);
			if (e !== Math.abs(this._y)) return !0;
			return e !== Math.abs(this._z)
		}
		floor() {
			return new e(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z))
		}
		static UnprojectToRef(t, i, s, n, a, r, o) {
			return e.UnprojectFloatsToRef(t._x, t._y, t._z, i, s, n, a, r, o), o
		}
		scale(t) {
			return new e(this._x * t, this._y * t, this._z * t)
		}
		static One() {
			return new e(1, 1, 1)
		}
		setAll(e) {
			return this._x = this._y = this._z = e, this._isDirty = !0, this
		}
		static GetClipFactor(t, i, s, n) {
			const a = e.Dot(t, s);
			return (a - n) / (a - e.Dot(i, s))
		}
		static DistanceSquared(e, t) {
			const i = e._x - t._x,
				s = e._y - t._y,
				n = e._z - t._z;
			return i * i + s * s + n * n
		}
		get x() {
			return this._x
		}
		static NormalizeToRef(e, t) {
			return e.normalizeToRef(t), t
		}
		normalizeToNew() {
			return this.normalizeToRef(new e)
		}
		rotateByQuaternionToRef(t, i) {
			return t.toRotationMatrix(Uc.Matrix[0]), e.TransformCoordinatesToRef(this, Uc.Matrix[0], i), i
		}
		toQuaternion() {
			return Gc.Jk(this._y, this._x, this._z)
		}
		asArray() {
			return [this._x, this._y, this._z]
		}
		multiplyInPlace(e) {
			return this._x *= e._x, this._y *= e._y, this._z *= e._z, this._isDirty = !0, this
		}
		static get RightReadOnly() {
			return e._RightReadOnly
		}
		static Hermite1stDerivative(t, i, s, n, a) {
			const r = new e;
			return this.Hermite1stDerivativeToRef(t, i, s, n, a, r), r
		}
		static FromFloatsToRef(e, t, i, s) {
			return s.copyFromFloats(e, t, i), s
		}
		static get OneReadOnly() {
			return e._OneReadOnly
		}
		scaleToRef(e, t) {
			return t._x = this._x * e, t._y = this._y * e, t._z = this._z * e, t._isDirty = !0, t
		}
		static get UpReadOnly() {
			return e._UpReadOnly
		}
		static ReflectToRef(t, i, s) {
			const n = Vc.Vector3[0];
			return n.copyFrom(i).scaleInPlace(2 * e.Dot(t, i)), s.copyFrom(t).subtractInPlace(n)
		}
		reorderInPlace(e) {
			if ("xyz" === (e = e.toLowerCase())) return this;
			const t = Uc.Vector3[0].copyFrom(this);
			return this.x = t[e[0]], this.y = t[e[1]], this.z = t[e[2]], this
		}
		subtractToRef(e, t) {
			return this.subtractFromFloatsToRef(e._x, e._y, e._z, t)
		}
		static GetAngleBetweenVectors(t, i, s) {
			const n = t.normalizeToRef(Uc.Vector3[1]),
				a = i.normalizeToRef(Uc.Vector3[2]);
			let r = e.Dot(n, a);
			r = yc(r, -1, 1);
			const o = Math.acos(r),
				l = Uc.Vector3[3];
			return e.CrossToRef(n, a, l), e.Dot(l, s) > 0 ? isNaN(o) ? 0 : o : isNaN(o) ? -Math.PI : -Math.acos(r)
		}
		subtractFromFloatsToRef(e, t, i, s) {
			return s._x = this._x - e, s._y = this._y - t, s._z = this._z - i, s._isDirty = !0, s
		}
		constructor(e = 0, t = 0, i = 0) {
			this._isDirty = !0, this._x = e, this._y = t, this._z = i
		}
		static PitchYawRollToMoveBetweenPointsToRef(e, t, i) {
			const s = Vc.Vector3[0];
			return t.subtractToRef(e, s), i._y = Math.atan2(s.x, s.z) || 0, i._x = Math.atan2(Math.sqrt(s.x ** 2 + s.z ** 2), s.y) || 0, i._z = 0, i._isDirty = !0, i
		}
		length() {
			return Math.sqrt(this.lengthSquared())
		}
		multiplyToRef(e, t) {
			return t._x = this._x * e._x, t._y = this._y * e._y, t._z = this._z * e._z, t._isDirty = !0, t
		}
		rotateByQuaternionAroundPointToRef(e, t, i) {
			return this.subtractToRef(t, Uc.Vector3[0]), Uc.Vector3[0].rotateByQuaternionToRef(e, Uc.Vector3[0]), t.addToRef(Uc.Vector3[0], i), i
		}
		static CheckExtends(e, t, i) {
			t.minimizeInPlace(e), i.maximizeInPlace(e)
		}
		isNonUniformWithinEpsilon(e) {
			const t = Math.abs(this._x),
				i = Math.abs(this._y);
			if (!_c(t, i, e)) return !0;
			const s = Math.abs(this._z);
			return !_c(t, s, e) || !_c(i, s, e)
		}
		static TransformNormalToRef(e, t, i) {
			return this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, i), i
		}
		static Left() {
			return new e(-1, 0, 0)
		}
		subtract(t) {
			return new e(this._x - t._x, this._y - t._y, this._z - t._z)
		}
		get y() {
			return this._y
		}
		cross(t) {
			return e.CrossToRef(this, t, new e)
		}
		minimizeInPlaceFromFloats(e, t, i) {
			return e < this._x && (this.x = e), t < this._y && (this.y = t), i < this._z && (this.z = i), this
		}
		getNormalToRef(e) {
			const t = this.length();
			let i = Math.acos(this.y / t);
			const s = Math.atan2(this.z, this.x);
			i > Math.PI / 2 ? i -= Math.PI / 2 : i += Math.PI / 2;
			const n = t * Math.sin(i) * Math.cos(s),
				a = t * Math.cos(i),
				r = t * Math.sin(i) * Math.sin(s);
			return e.set(n, a, r), e
		}
		divideToRef(e, t) {
			return t._x = this._x / e._x, t._y = this._y / e._y, t._z = this._z / e._z, t._isDirty = !0, t
		}
		negateToRef(e) {
			return e._x = -1 * this._x, e._y = -1 * this._y, e._z = -1 * this._z, e._isDirty = !0, e
		}
		static CatmullRom(t, i, s, n, a) {
			const r = a * a,
				o = a * r,
				l = .5 * (2 * i._x + (-t._x + s._x) * a + (2 * t._x - 5 * i._x + 4 * s._x - n._x) * r + (-t._x + 3 * i._x - 3 * s._x + n._x) * o),
				h = .5 * (2 * i._y + (-t._y + s._y) * a + (2 * t._y - 5 * i._y + 4 * s._y - n._y) * r + (-t._y + 3 * i._y - 3 * s._y + n._y) * o),
				c = .5 * (2 * i._z + (-t._z + s._z) * a + (2 * t._z - 5 * i._z + 4 * s._z - n._z) * r + (-t._z + 3 * i._z - 3 * s._z + n._z) * o);
			return new e(l, h, c)
		}
		static get ZeroReadOnly() {
			return e._ZeroReadOnly
		}
		applyRotationQuaternionToRef(e, t) {
			const i = this._x,
				s = this._y,
				n = this._z,
				a = e._x,
				r = e._y,
				o = e._z,
				l = e._w,
				h = 2 * (r * n - o * s),
				c = 2 * (o * i - a * n),
				u = 2 * (a * s - r * i);
			return t._x = i + l * h + r * u - o * c, t._y = s + l * c + o * h - a * u, t._z = n + l * u + a * c - r * h, t._isDirty = !0, t
		}
		static get LeftHandedForwardReadOnly() {
			return e._LeftHandedForwardReadOnly
		}
		projectOnPlaneToRef(t, i, s) {
			const n = t.normal,
				a = t.d,
				r = Uc.Vector3[0];
			this.subtractToRef(i, r), r.normalize();
			const o = e.Dot(r, n);
			if (Math.abs(o) < 1e-10) s.setAll(1 / 0);
			else {
				const t = -(e.Dot(i, n) + a) / o,
					l = r.scaleInPlace(t);
				i.addToRef(l, s)
			}
			return s
		}
		maximizeInPlaceFromFloats(e, t, i) {
			return e > this._x && (this.x = e), t > this._y && (this.y = t), i > this._z && (this.z = i), this
		}
		static _UnprojectFromInvertedMatrixToRef(t, i, s) {
			e.TransformCoordinatesToRef(t, i, s);
			const n = i.m,
				a = t._x * n[3] + t._y * n[7] + t._z * n[11] + n[15];
			return _c(a, 1) && s.scaleInPlace(1 / a), s
		}
		static Hermite1stDerivativeToRef(e, t, i, s, n, a) {
			const r = n * n;
			return a._x = 6 * (r - n) * e._x + (3 * r - 4 * n + 1) * t._x + 6 * (-r + n) * i._x + (3 * r - 2 * n) * s._x, a._y = 6 * (r - n) * e._y + (3 * r - 4 * n + 1) * t._y + 6 * (-r + n) * i._y + (3 * r - 2 * n) * s._y, a._z = 6 * (r - n) * e._z + (3 * r - 4 * n + 1) * t._z + 6 * (-r + n) * i._z + (3 * r - 2 * n) * s._z, a._isDirty = !0, a
		}
		static LerpToRef(e, t, i, s) {
			return s._x = e._x + (t._x - e._x) * i, s._y = e._y + (t._y - e._y) * i, s._z = e._z + (t._z - e._z) * i, s._isDirty = !0, s
		}
		scaleInPlace(e) {
			return this._x *= e, this._y *= e, this._z *= e, this._isDirty = !0, this
		}
		toArray(e, t = 0) {
			return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, this
		}
		multiply(e) {
			return this.multiplyByFloats(e._x, e._y, e._z)
		}
		set(e, t, i) {
			return this.copyFromFloats(e, t, i)
		}
		static get RightHandedForwardReadOnly() {
			return e._RightHandedForwardReadOnly
		}
		toString() {
			return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`
		}
		copyFromFloats(e, t, i) {
			return this._x = e, this._y = t, this._z = i, this._isDirty = !0, this
		}
		static TransformCoordinatesToRef(t, i, s) {
			return e.TransformCoordinatesFromFloatsToRef(t._x, t._y, t._z, i, s), s
		}
		applyRotationQuaternionInPlace(e) {
			return this.applyRotationQuaternionToRef(e, this)
		}
		static Normalize(t) {
			const i = e.Zero();
			return e.NormalizeToRef(t, i), i
		}
	};
	Lc._UpReadOnly = Lc.Up(), Lc._DownReadOnly = Lc.Down(), Lc._LeftHandedForwardReadOnly = Lc.Forward(!1), Lc._RightHandedForwardReadOnly = Lc.Forward(!0), Lc._LeftHandedBackwardReadOnly = Lc.Backward(!1), Lc._RightHandedBackwardReadOnly = Lc.Backward(!0), Lc._RightReadOnly = Lc.Right(), Lc._LeftReadOnly = Lc.Left(), Lc._ZeroReadOnly = Lc.Zero(), Lc._OneReadOnly = Lc.One(), Object.defineProperties(Lc.prototype, {
		dimension: {
			value: [3]
		},
		rank: {
			value: 1
		}
	});
	var Bc = class e {
		negateInPlace() {
			return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this
		}
		static Normalize(t) {
			return e.NormalizeToRef(t, new e)
		}
		toString() {
			return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`
		}
		constructor(e = 0, t = 0, i = 0, s = 0) {
			this.x = e, this.y = t, this.z = i, this.w = s
		}
		static FromArray(t, i) {
			return i || (i = 0), new e(t[i], t[i + 1], t[i + 2], t[i + 3])
		}
		toVector3() {
			return new Lc(this.x, this.y, this.z)
		}
		subtractFromFloatsToRef(e, t, i, s, n) {
			return n.x = this.x - e, n.y = this.y - t, n.z = this.z - i, n.w = this.w - s, n
		}
		multiplyByFloats(t, i, s, n) {
			return new e(this.x * t, this.y * i, this.z * s, this.w * n)
		}
		fractToRef(e) {
			return e.x = this.x - Math.floor(this.x), e.y = this.y - Math.floor(this.y), e.z = this.z - Math.floor(this.z), e.w = this.w - Math.floor(this.w), e
		}
		fromArray(t, i = 0) {
			return e.FromArrayToRef(t, i, this), this
		}
		normalizeToNew() {
			return this.normalizeToRef(new e)
		}
		addInPlaceFromFloats(e, t, i, s) {
			return this.x += e, this.y += t, this.z += i, this.w += s, this
		}
		static TransformNormalFromFloatsToRef(e, t, i, s, n, a) {
			const r = n.m;
			return a.x = e * r[0] + t * r[4] + i * r[8], a.y = e * r[1] + t * r[5] + i * r[9], a.z = e * r[2] + t * r[6] + i * r[10], a.w = s, a
		}
		addToRef(e, t) {
			return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, t
		}
		lengthSquared() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
		}
		divide(t) {
			return new e(this.x / t.x, this.y / t.y, this.z / t.z, this.w / t.w)
		}
		clone() {
			return new e(this.x, this.y, this.z, this.w)
		}
		minimizeInPlace(e) {
			return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this
		}
		setAll(e) {
			return this.x = this.y = this.z = this.w = e, this
		}
		static FromVector3(t, i = 0) {
			return new e(t._x, t._y, t._z, i)
		}
		static RandomToRef(e = 0, t = 1, i) {
			return i.x = gc(e, t), i.y = gc(e, t), i.z = gc(e, t), i.w = gc(e, t), i
		}
		maximizeInPlace(e) {
			return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this
		}
		fract() {
			return new e(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w))
		}
		dot(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
		}
		equalsWithEpsilon(e, t = .001) {
			return e && _c(this.x, e.x, t) && _c(this.y, e.y, t) && _c(this.z, e.z, t) && _c(this.w, e.w, t)
		}
		negateToRef(e) {
			return e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = -this.w, e
		}
		static Random(t = 0, i = 1) {
			return new e(gc(t, i), gc(t, i), gc(t, i), gc(t, i))
		}
		static FromArrayToRef(e, t, i) {
			return i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3], i
		}
		static DistanceSquared(e, t) {
			const i = e.x - t.x,
				s = e.y - t.y,
				n = e.z - t.z,
				a = e.w - t.w;
			return i * i + s * s + n * n + a * a
		}
		static CheckExtends(e, t, i) {
			t.minimizeInPlace(e), i.maximizeInPlace(e)
		}
		subtractInPlace(e) {
			return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
		}
		static ClampToRef(e, t, i, s) {
			return s.x = yc(e.x, t.x, i.x), s.y = yc(e.y, t.y, i.y), s.z = yc(e.z, t.z, i.z), s.w = yc(e.w, t.w, i.w), s
		}
		static Zero() {
			return new e(0, 0, 0, 0)
		}
		equals(e) {
			return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
		}
		add(t) {
			return new e(this.x + t.x, this.y + t.y, this.z + t.z, this.w + t.w)
		}
		static Minimize(t, i) {
			const s = new e;
			return s.copyFrom(t), s.minimizeInPlace(i), s
		}
		maximizeInPlaceFromFloats(e, t, i, s) {
			return this.x = Math.max(e, this.x), this.y = Math.max(t, this.y), this.z = Math.max(i, this.z), this.w = Math.max(s, this.w), this
		}
		static Dot(e, t) {
			return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
		}
		multiply(t) {
			return new e(this.x * t.x, this.y * t.y, this.z * t.z, this.w * t.w)
		}
		equalsToFloats(e, t, i, s) {
			return this.x === e && this.y === t && this.z === i && this.w === s
		}
		scaleInPlace(e) {
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		}
		divideToRef(e, t) {
			return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, t
		}
		static TransformNormalToRef(e, t, i) {
			const s = t.m,
				n = e.x * s[0] + e.y * s[4] + e.z * s[8],
				a = e.x * s[1] + e.y * s[5] + e.z * s[9],
				r = e.x * s[2] + e.y * s[6] + e.z * s[10];
			return i.x = n, i.y = a, i.z = r, i.w = e.w, i
		}
		subtractFromFloats(t, i, s, n) {
			return new e(this.x - t, this.y - i, this.z - s, this.w - n)
		}
		multiplyInPlace(e) {
			return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
		}
		static Clamp(t, i, s) {
			return e.ClampToRef(t, i, s, new e)
		}
		scaleAndAddToRef(e, t) {
			return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, t
		}
		floorToRef(e) {
			return e.x = Math.floor(this.x), e.y = Math.floor(this.y), e.z = Math.floor(this.z), e.w = Math.floor(this.w), e
		}
		getClassName() {
			return "Vector4"
		}
		static TransformCoordinatesFromFloatsToRef(e, t, i, s, n) {
			const a = s.m,
				r = e * a[0] + t * a[4] + i * a[8] + a[12],
				o = e * a[1] + t * a[5] + i * a[9] + a[13],
				l = e * a[2] + t * a[6] + i * a[10] + a[14],
				h = e * a[3] + t * a[7] + i * a[11] + a[15];
			return n.x = r, n.y = o, n.z = l, n.w = h, n
		}
		scale(t) {
			return new e(this.x * t, this.y * t, this.z * t, this.w * t)
		}
		static One() {
			return new e(1, 1, 1, 1)
		}
		static CenterToRef(e, t, i) {
			return i.x = (e.x + t.x) / 2, i.y = (e.y + t.y) / 2, i.z = (e.z + t.z) / 2, i.w = (e.w + t.w) / 2, i
		}
		normalize() {
			return this.normalizeFromLength(this.length())
		}
		addInPlace(e) {
			return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
		}
		static TransformCoordinatesToRef(t, i, s) {
			return e.TransformCoordinatesFromFloatsToRef(t._x, t._y, t._z, i, s), s
		}
		static FromFloatArrayToRef(t, i, s) {
			return e.FromArrayToRef(t, i, s), s
		}
		static Maximize(t, i) {
			const s = new e;
			return s.copyFrom(t), s.maximizeInPlace(i), s
		}
		floor() {
			return new e(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w))
		}
		minimizeInPlaceFromFloats(e, t, i, s) {
			return this.x = Math.min(e, this.x), this.y = Math.min(t, this.y), this.z = Math.min(i, this.z), this.w = Math.min(s, this.w), this
		}
		subtract(t) {
			return new e(this.x - t.x, this.y - t.y, this.z - t.z, this.w - t.w)
		}
		static Center(t, i) {
			return e.CenterToRef(t, i, new e)
		}
		negate() {
			return new e(-this.x, -this.y, -this.z, -this.w)
		}
		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		}
		getHashCode() {
			let e = Oc(this.x);
			return e = 397 * e ^ Oc(this.y), e = 397 * e ^ Oc(this.z), e = 397 * e ^ Oc(this.w), e
		}
		static Distance(t, i) {
			return Math.sqrt(e.DistanceSquared(t, i))
		}
		normalizeToRef(e) {
			const t = this.length();
			return 0 === t || 1 === t ? (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w, e) : this.scaleToRef(1 / t, e)
		}
		normalizeFromLength(e) {
			return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
		}
		copyFromFloats(e, t, i, s) {
			return this.x = e, this.y = t, this.z = i, this.w = s, this
		}
		multiplyToRef(e, t) {
			return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, t
		}
		toArray(e, t) {
			return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this
		}
		divideInPlace(e) {
			return this.divideToRef(e, this)
		}
		static FromFloatsToRef(e, t, i, s, n) {
			return n.x = e, n.y = t, n.z = i, n.w = s, n
		}
		static get ZeroReadOnly() {
			return e._ZeroReadOnly
		}
		static TransformNormal(t, i) {
			return e.TransformNormalToRef(t, i, new e)
		}
		static NormalizeToRef(e, t) {
			return e.normalizeToRef(t), t
		}
		subtractToRef(e, t) {
			return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, t
		}
		copyFrom(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this
		}
		static TransformCoordinates(t, i) {
			return e.TransformCoordinatesToRef(t, i, new e)
		}
		asArray() {
			return [this.x, this.y, this.z, this.w]
		}
		scaleToRef(e, t) {
			return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, t
		}
		set(e, t, i, s) {
			return this.copyFromFloats(e, t, i, s)
		}
	};
	Bc._ZeroReadOnly = Bc.Zero(), Object.defineProperties(Bc.prototype, {
		dimension: {
			value: [4]
		},
		rank: {
			value: 1
		}
	});
	var Gc = class e {
		fractToRef(e) {
			throw new ReferenceError("Can not fract a quaternion")
		}
		maximizeInPlaceFromFloats() {
			throw new ReferenceError("Can not maximize a quaternion")
		}
		static Center(t, i) {
			return e.CenterToRef(t, i, e.Zero())
		}
		static Zero() {
			return new e(0, 0, 0, 0)
		}
		static Maximize() {
			throw new ReferenceError("Quaternion.Maximize does not make sense")
		}
		copyFromFloats(e, t, i, s) {
			return this._x = e, this._y = t, this._z = i, this._w = s, this._isDirty = !0, this
		}
		static RotationAxis(t, i) {
			return e.RotationAxisToRef(t, i, new e)
		}
		static FromEulerAnglesToRef(t, i, s, n) {
			return e.RotationYawPitchRollToRef(i, t, s, n), n
		}
		fromRotationMatrix(t) {
			return e.FromRotationMatrixToRef(t, this), this
		}
		toArray(e, t = 0) {
			return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, this
		}
		static FromLookDirectionRHToRef(t, i, s) {
			const n = Uc.Matrix[0];
			return Hc.LookDirectionRHToRef(t, i, n), e.FromRotationMatrixToRef(n, s)
		}
		static Jk(t, i, s) {
			const n = new e;
			return e.RotationYawPitchRollToRef(t, i, s, n), n
		}
		static InverseToRef(e, t) {
			return t.set(-e._x, -e._y, -e._z, e._w), t
		}
		equalsToFloats(e, t, i, s) {
			return this._x === e && this._y === t && this._z === i && this._w === s
		}
		static IsIdentity(e) {
			return e && 0 === e._x && 0 === e._y && 0 === e._z && 1 === e._w
		}
		subtractFromFloatsToRef(e, t, i, s, n) {
			return n._x = this._x - e, n._y = this._y - t, n._z = this._z - i, n._w = this._w - s, n._isDirty = !0, n
		}
		constructor(e = 0, t = 0, i = 0, s = 1) {
			this._isDirty = !0, this._x = e, this._y = t, this._z = i, this._w = s
		}
		normalizeToRef(e) {
			const t = this.length();
			return 0 === t || 1 === t ? e.copyFromFloats(this._x, this._y, this._z, this._w) : this.scaleToRef(1 / t, e)
		}
		get x() {
			return this._x
		}
		static Normalize(t) {
			const i = e.Zero();
			return e.NormalizeToRef(t, i), i
		}
		static FromEulerVectorToRef(t, i) {
			return e.RotationYawPitchRollToRef(t._y, t._x, t._z, i), i
		}
		scaleToRef(e, t) {
			return t._x = this._x * e, t._y = this._y * e, t._z = this._z * e, t._w = this._w * e, t._isDirty = !0, t
		}
		floorToRef(e) {
			throw new ReferenceError("Can not floor a quaternion")
		}
		normalizeToNew() {
			const t = new e(0, 0, 0, 1);
			return this.normalizeToRef(t), t
		}
		divide(e) {
			throw new ReferenceError("Can not divide a quaternion")
		}
		negateInPlace() {
			return this._x = -this._x, this._y = -this._y, this._z = -this._z, this._w = -this._w, this._isDirty = !0, this
		}
		static FromArray(t, i) {
			return i || (i = 0), new e(t[i], t[i + 1], t[i + 2], t[i + 3])
		}
		conjugateToRef(e) {
			return e.copyFromFloats(-this._x, -this._y, -this._z, this._w), e
		}
		static NormalizeToRef(e, t) {
			return e.normalizeToRef(t), t
		}
		static ClampToRef(e, t, i, s) {
			return s.copyFromFloats(yc(e.x, t.x, i.x), yc(e.y, t.y, i.y), yc(e.z, t.z, i.z), yc(e.w, t.w, i.w))
		}
		set(e, t, i, s) {
			return this.copyFromFloats(e, t, i, s)
		}
		scaleAndAddToRef(e, t) {
			return t._x += this._x * e, t._y += this._y * e, t._z += this._z * e, t._w += this._w * e, t._isDirty = !0, t
		}
		set x(e) {
			this._x = e, this._isDirty = !0
		}
		multiply(t) {
			const i = new e(0, 0, 0, 1);
			return this.multiplyToRef(t, i), i
		}
		static FromArrayToRef(e, t, i) {
			return i._x = e[t], i._y = e[t + 1], i._z = e[t + 2], i._w = e[t + 3], i._isDirty = !0, i
		}
		toEulerAngles() {
			const e = Lc.Zero();
			return this.toEulerAnglesToRef(e), e
		}
		set z(e) {
			this._z = e, this._isDirty = !0
		}
		toAlphaBetaGammaToRef(e) {
			const t = this._z,
				i = this._x,
				s = this._y,
				n = this._w,
				a = Math.sqrt(i * i + s * s),
				r = Math.sqrt(t * t + n * n),
				o = 2 * Math.atan2(a, r),
				l = 2 * Math.atan2(t, n),
				h = 2 * Math.atan2(s, i),
				c = (l + h) / 2,
				u = (l - h) / 2;
			return e.set(u, o, c), e
		}
		copyFrom(e) {
			return this._x = e._x, this._y = e._y, this._z = e._z, this._w = e._w, this._isDirty = !0, this
		}
		scale(t) {
			return new e(this._x * t, this._y * t, this._z * t, this._w * t)
		}
		minimizeInPlace() {
			throw new ReferenceError("Can not minimize a quaternion")
		}
		static RotationQuaternionFromAxisToRef(t, i, s, n) {
			const a = Uc.Matrix[0];
			return t = t.normalizeToRef(Uc.Vector3[0]), i = i.normalizeToRef(Uc.Vector3[1]), s = s.normalizeToRef(Uc.Vector3[2]), Hc.FromXYZAxesToRef(t, i, s, a), e.FromRotationMatrixToRef(a, n), n
		}
		static RotationQuaternionFromAxis(t, i, s) {
			const n = new e(0, 0, 0, 0);
			return e.RotationQuaternionFromAxisToRef(t, i, s, n), n
		}
		toRotationMatrix(e) {
			return Hc.FromQuaternionToRef(this, e), e
		}
		invertInPlace() {
			this.conjugateInPlace();
			const e = this.lengthSquared();
			return 0 == e || 1 == e || this.scaleInPlace(1 / e), this
		}
		get w() {
			return this._w
		}
		length() {
			return Math.sqrt(this.lengthSquared())
		}
		asArray() {
			return [this._x, this._y, this._z, this._w]
		}
		static RandomToRef(e = 0, t = 1, i) {
			return i.copyFromFloats(gc(e, t), gc(e, t), gc(e, t), gc(e, t))
		}
		static Random(t = 0, i = 1) {
			return new e(gc(t, i), gc(t, i), gc(t, i), gc(t, i))
		}
		set w(e) {
			this._w = e, this._isDirty = !0
		}
		getHashCode() {
			let e = Oc(this._x);
			return e = 397 * e ^ Oc(this._y), e = 397 * e ^ Oc(this._z), e = 397 * e ^ Oc(this._w), e
		}
		static Hermite1stDerivative(t, i, s, n, a) {
			const r = new e;
			return this.Hermite1stDerivativeToRef(t, i, s, n, a, r), r
		}
		clone() {
			return new e(this._x, this._y, this._z, this._w)
		}
		static SlerpToRef(e, t, i, s) {
			let n, a, r = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w,
				o = !1;
			if (r < 0 && (o = !0, r = -r), r > .999999) a = 1 - i, n = o ? -i : i;
			else {
				const e = Math.acos(r),
					t = 1 / Math.sin(e);
				a = Math.sin((1 - i) * e) * t, n = o ? -Math.sin(i * e) * t : Math.sin(i * e) * t
			}
			return s._x = a * e._x + n * t._x, s._y = a * e._y + n * t._y, s._z = a * e._z + n * t._z, s._w = a * e._w + n * t._w, s._isDirty = !0, s
		}
		subtractInPlace(e) {
			return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._w -= e._w, this._isDirty = !0, this
		}
		multiplyByFloats(e, t, i, s) {
			return this._x *= e, this._y *= t, this._z *= i, this._w *= s, this._isDirty = !0, this
		}
		static AreClose(t, i, s = .1) {
			const n = e.Dot(t, i);
			return 1 - n * n <= s
		}
		static FromLookDirectionRH(t, i) {
			const s = new e;
			return e.FromLookDirectionRHToRef(t, i, s), s
		}
		set y(e) {
			this._y = e, this._isDirty = !0
		}
		static RotationAlphaBetaGammaToRef(e, t, i, s) {
			const n = .5 * (i + e),
				a = .5 * (i - e),
				r = .5 * t;
			return s._x = Math.cos(a) * Math.sin(r), s._y = Math.sin(a) * Math.sin(r), s._z = Math.sin(n) * Math.cos(r), s._w = Math.cos(n) * Math.cos(r), s._isDirty = !0, s
		}
		get y() {
			return this._y
		}
		floor() {
			throw new ReferenceError("Can not floor a quaternion")
		}
		static FromRotationMatrixToRef(e, t) {
			const i = e.m,
				s = i[0],
				n = i[4],
				a = i[8],
				r = i[1],
				o = i[5],
				l = i[9],
				h = i[2],
				c = i[6],
				u = i[10],
				m = s + o + u;
			let d;
			return m > 0 ? (d = .5 / Math.sqrt(m + 1), t._w = .25 / d, t._x = (c - l) * d, t._y = (a - h) * d, t._z = (r - n) * d, t._isDirty = !0) : s > o && s > u ? (d = 2 * Math.sqrt(1 + s - o - u), t._w = (c - l) / d, t._x = .25 * d, t._y = (n + r) / d, t._z = (a + h) / d, t._isDirty = !0) : o > u ? (d = 2 * Math.sqrt(1 + o - s - u), t._w = (a - h) / d, t._x = (n + r) / d, t._y = .25 * d, t._z = (l + c) / d, t._isDirty = !0) : (d = 2 * Math.sqrt(1 + u - s - o), t._w = (r - n) / d, t._x = (a + h) / d, t._y = (l + c) / d, t._z = .25 * d, t._isDirty = !0), t
		}
		scaleInPlace(e) {
			return this._x *= e, this._y *= e, this._z *= e, this._w *= e, this._isDirty = !0, this
		}
		static DistanceSquared(e, t) {
			const i = e.x - t.x,
				s = e.y - t.y,
				n = e.z - t.z,
				a = e.w - t.w;
			return i * i + s * s + n * n + a * a
		}
		conjugate() {
			return new e(-this._x, -this._y, -this._z, this._w)
		}
		negate() {
			return this.negateToRef(new e)
		}
		normalizeFromLength(e) {
			return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
		}
		static FromLookDirectionLHToRef(t, i, s) {
			const n = Uc.Matrix[0];
			return Hc.LookDirectionLHToRef(t, i, n), e.FromRotationMatrixToRef(n, s), s
		}
		static CenterToRef(e, t, i) {
			return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2)
		}
		subtractToRef(e, t) {
			return t._x = this._x - e._x, t._y = this._y - e._y, t._z = this._z - e._z, t._w = this._w - e._w, t._isDirty = !0, t
		}
		maximizeInPlace() {
			throw new ReferenceError("Can not maximize a quaternion")
		}
		multiplyToRef(e, t) {
			const i = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x,
				s = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y,
				n = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z,
				a = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w;
			return t.copyFromFloats(i, s, n, a), t
		}
		add(t) {
			return new e(this._x + t._x, this._y + t._y, this._z + t._z, this._w + t._w)
		}
		static Distance(t, i) {
			return Math.sqrt(e.DistanceSquared(t, i))
		}
		static SmoothToRef(t, i, s, n, a) {
			let r = 0 === n ? 1 : s / n;
			return r = yc(r, 0, 1), e.SlerpToRef(t, i, r, a), a
		}
		static FromEulerAngles(t, i, s) {
			const n = new e;
			return e.RotationYawPitchRollToRef(i, t, s, n), n
		}
		static FromFloatsToRef(e, t, i, s, n) {
			return n.copyFromFloats(e, t, i, s), n
		}
		addInPlaceFromFloats(e, t, i, s) {
			return this._x += e, this._y += t, this._z += i, this._w += s, this._isDirty = !0, this
		}
		equals(e) {
			return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w
		}
		static FromLookDirectionLH(t, i) {
			const s = new e;
			return e.FromLookDirectionLHToRef(t, i, s), s
		}
		static Hermite(t, i, s, n, a) {
			const r = a * a,
				o = a * r,
				l = 2 * o - 3 * r + 1,
				h = -2 * o + 3 * r,
				c = o - 2 * r + a,
				u = o - r,
				m = t._x * l + s._x * h + i._x * c + n._x * u,
				d = t._y * l + s._y * h + i._y * c + n._y * u,
				f = t._z * l + s._z * h + i._z * c + n._z * u,
				p = t._w * l + s._w * h + i._w * c + n._w * u;
			return new e(m, d, f, p)
		}
		static Minimize() {
			throw new ReferenceError("Quaternion.Minimize does not make sense")
		}
		setAll(e) {
			return this.copyFromFloats(e, e, e, e)
		}
		lengthSquared() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		}
		fract() {
			throw new ReferenceError("Can not fract a quaternion")
		}
		static RotationAxisToRef(e, t, i) {
			i._w = Math.cos(t / 2);
			const s = Math.sin(t / 2) / e.length();
			return i._x = e._x * s, i._y = e._y * s, i._z = e._z * s, i._isDirty = !0, i
		}
		static FromEulerVector(t) {
			const i = new e;
			return e.RotationYawPitchRollToRef(t._y, t._x, t._z, i), i
		}
		static Dot(e, t) {
			return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w
		}
		static Hermite1stDerivativeToRef(e, t, i, s, n, a) {
			const r = n * n;
			return a._x = 6 * (r - n) * e._x + (3 * r - 4 * n + 1) * t._x + 6 * (-r + n) * i._x + (3 * r - 2 * n) * s._x, a._y = 6 * (r - n) * e._y + (3 * r - 4 * n + 1) * t._y + 6 * (-r + n) * i._y + (3 * r - 2 * n) * s._y, a._z = 6 * (r - n) * e._z + (3 * r - 4 * n + 1) * t._z + 6 * (-r + n) * i._z + (3 * r - 2 * n) * s._z, a._w = 6 * (r - n) * e._w + (3 * r - 4 * n + 1) * t._w + 6 * (-r + n) * i._w + (3 * r - 2 * n) * s._w, a._isDirty = !0, a
		}
		static Clamp(t, i, s) {
			const n = new e;
			return e.ClampToRef(t, i, s, n), n
		}
		dot(e) {
			return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
		}
		static Identity() {
			return new e(0, 0, 0, 1)
		}
		static RotationAlphaBetaGamma(t, i, s) {
			const n = new e;
			return e.RotationAlphaBetaGammaToRef(t, i, s, n), n
		}
		minimizeInPlaceFromFloats() {
			throw new ReferenceError("Can not minimize a quaternion")
		}
		static RotationYawPitchRollToRef(e, t, i, s) {
			const n = .5 * i,
				a = .5 * t,
				r = .5 * e,
				o = Math.sin(n),
				l = Math.cos(n),
				h = Math.sin(a),
				c = Math.cos(a),
				u = Math.sin(r),
				m = Math.cos(r);
			return s._x = m * h * l + u * c * o, s._y = u * c * l - m * h * o, s._z = m * c * o - u * h * l, s._w = m * c * l + u * h * o, s._isDirty = !0, s
		}
		conjugateInPlace() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this._isDirty = !0, this
		}
		subtractFromFloats(t, i, s, n) {
			return this.subtractFromFloatsToRef(t, i, s, n, new e)
		}
		static Inverse(t) {
			return new e(-t._x, -t._y, -t._z, t._w)
		}
		equalsWithEpsilon(e, t = .001) {
			return e && _c(this._x, e._x, t) && _c(this._y, e._y, t) && _c(this._z, e._z, t) && _c(this._w, e._w, t)
		}
		negateToRef(e) {
			return e._x = -this._x, e._y = -this._y, e._z = -this._z, e._w = -this._w, e._isDirty = !0, e
		}
		subtract(t) {
			return new e(this._x - t._x, this._y - t._y, this._z - t._z, this._w - t._w)
		}
		addToRef(e, t) {
			return t._x = this._x + e._x, t._y = this._y + e._y, t._z = this._z + e._z, t._w = this._w + e._w, t._isDirty = !0, t
		}
		divideInPlace(e) {
			throw new ReferenceError("Can not divide a quaternion")
		}
		addInPlace(e) {
			return this._x += e._x, this._y += e._y, this._z += e._z, this._w += e._w, this._isDirty = !0, this
		}
		toEulerAnglesToRef(e) {
			const t = this._z,
				i = this._x,
				s = this._y,
				n = this._w,
				a = s * t - i * n,
				r = .4999999;
			if (a < -r) e._y = 2 * Math.atan2(s, n), e._x = Math.PI / 2, e._z = 0, e._isDirty = !0;
			else if (a > r) e._y = 2 * Math.atan2(s, n), e._x = -Math.PI / 2, e._z = 0, e._isDirty = !0;
			else {
				const r = n * n,
					o = t * t,
					l = i * i,
					h = s * s;
				e._z = Math.atan2(2 * (i * s + t * n), -o - l + h + r), e._x = Math.asin(-2 * a), e._y = Math.atan2(2 * (t * i + s * n), o - l - h + r), e._isDirty = !0
			}
			return e
		}
		toString() {
			return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`
		}
		static FromRotationMatrix(t) {
			const i = new e;
			return e.FromRotationMatrixToRef(t, i), i
		}
		static FromUnitVectorsToRef(e, t, i, s = .001) {
			const n = Lc.Dot(e, t) + 1;
			return n < s ? Math.abs(e.x) > Math.abs(e.z) ? i.set(-e.y, e.x, 0, 0) : i.set(0, -e.z, e.y, 0) : (Lc.CrossToRef(e, t, Vc.Vector3[0]), i.set(Vc.Vector3[0].x, Vc.Vector3[0].y, Vc.Vector3[0].z, n)), i.normalize()
		}
		get z() {
			return this._z
		}
		normalize() {
			return this.normalizeFromLength(this.length())
		}
		static Slerp(t, i, s) {
			const n = e.Identity();
			return e.SlerpToRef(t, i, s, n), n
		}
		getClassName() {
			return "Quaternion"
		}
		divideToRef(e, t) {
			throw new ReferenceError("Can not divide a quaternion")
		}
		fromArray(t, i = 0) {
			return e.FromArrayToRef(t, i, this)
		}
		invert() {
			const e = this.conjugate(),
				t = this.lengthSquared();
			return 0 == t || 1 == t || e.scaleInPlace(1 / t), e
		}
		multiplyInPlace(e) {
			return this.multiplyToRef(e, this)
		}
	};
	Object.defineProperties(Gc.prototype, {
		dimension: {
			value: [4]
		},
		rank: {
			value: 1
		}
	});
	var Hc = class e {
		static OrthoOffCenterLHToRef(t, i, s, n, a, r, o, l) {
			const h = 2 / (i - t),
				c = 2 / (n - s),
				u = 2 / (r - a),
				m = -(r + a) / (r - a),
				d = (t + i) / (t - i),
				f = (n + s) / (s - n);
			return e.FromValuesToRef(h, 0, 0, 0, 0, c, 0, 0, 0, 0, u, 0, d, f, m, 1, o), l && o.multiplyToRef(Wc, o), o.markAsUpdated(), o
		}
		negateToRef(e) {
			const t = this._m,
				i = e._m;
			for (let e = 0; e < 16; e++) i[e] = -t[e];
			return e.markAsUpdated(), e
		}
		static Identity() {
			const t = e.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return t._updateIdentityStatus(!0), t
		}
		static Transpose(t) {
			const i = new e;
			return e.TransposeToRef(t, i), i
		}
		static RotationYToRef(t, i) {
			const s = Math.sin(t),
				n = Math.cos(t);
			return e.FromValuesToRef(n, 0, -s, 0, 0, 1, 0, 0, s, 0, n, 0, 0, 0, 0, 1, i), i._updateIdentityStatus(1 === n && 0 === s), i
		}
		determinant() {
			if (!0 === this._isIdentity) return 1;
			const e = this._m,
				t = e[0],
				i = e[1],
				s = e[2],
				n = e[3],
				a = e[4],
				r = e[5],
				o = e[6],
				l = e[7],
				h = e[8],
				c = e[9],
				u = e[10],
				m = e[11],
				d = e[12],
				f = e[13],
				p = e[14],
				_ = e[15],
				g = u * _ - p * m,
				v = c * _ - f * m,
				y = c * p - f * u,
				S = h * _ - d * m,
				E = h * p - u * d,
				A = h * f - d * c;
			return t * +(r * g - o * v + l * y) + i * -(a * g - o * S + l * E) + s * +(a * v - r * S + l * A) + n * -(a * y - r * E + o * A)
		}
		decompose(t, i, s, n, a = !0) {
			if (this._isIdentity) return s && s.setAll(0), t && t.setAll(1), i && i.copyFromFloats(0, 0, 0, 1), !0;
			const r = this._m;
			if (s && s.copyFromFloats(r[12], r[13], r[14]), (t = t || Uc.Vector3[0]).x = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]), t.y = Math.sqrt(r[4] * r[4] + r[5] * r[5] + r[6] * r[6]), t.z = Math.sqrt(r[8] * r[8] + r[9] * r[9] + r[10] * r[10]), n) {
				const e = (a ? n.absoluteScaling.x : n.scaling.x) < 0 ? -1 : 1,
					i = (a ? n.absoluteScaling.y : n.scaling.y) < 0 ? -1 : 1,
					s = (a ? n.absoluteScaling.z : n.scaling.z) < 0 ? -1 : 1;
				t.x *= e, t.y *= i, t.z *= s
			} else this.determinant() <= 0 && (t.y *= -1);
			if (0 === t._x || 0 === t._y || 0 === t._z) return i && i.copyFromFloats(0, 0, 0, 1), !1;
			if (i) {
				const s = 1 / t._x,
					n = 1 / t._y,
					a = 1 / t._z;
				e.FromValuesToRef(r[0] * s, r[1] * s, r[2] * s, 0, r[4] * n, r[5] * n, r[6] * n, 0, r[8] * a, r[9] * a, r[10] * a, 0, 0, 0, 0, 1, Uc.Matrix[0]), Gc.FromRotationMatrixToRef(Uc.Matrix[0], i)
			}
			return !0
		}
		scaleToRef(e, t) {
			for (let i = 0; i < 16; i++) t._m[i] = this._m[i] * e;
			return t.markAsUpdated(), t
		}
		subtractFromFloatsToRef(...e) {
			const t = e.pop(),
				i = this._m,
				s = t._m,
				n = e;
			for (let e = 0; e < 16; e++) s[e] = i[e] - n[e];
			return t.markAsUpdated(), t
		}
		get m() {
			return this._m
		}
		getRow(e) {
			if (e < 0 || e > 3) return null;
			const t = 4 * e;
			return new Bc(this._m[t + 0], this._m[t + 1], this._m[t + 2], this._m[t + 3])
		}
		static get IdentityReadOnly() {
			return e._IdentityReadOnly
		}
		static LookAtLHToRef(t, i, s, n) {
			const a = Uc.Vector3[0],
				r = Uc.Vector3[1],
				o = Uc.Vector3[2];
			i.subtractToRef(t, o), o.normalize(), Lc.CrossToRef(s, o, a);
			const l = a.lengthSquared();
			0 === l ? a.x = 1 : a.normalizeFromLength(Math.sqrt(l)), Lc.CrossToRef(o, a, r), r.normalize();
			const h = -Lc.Dot(a, t),
				c = -Lc.Dot(r, t),
				u = -Lc.Dot(o, t);
			return e.FromValuesToRef(a._x, r._x, o._x, 0, a._y, r._y, o._y, 0, a._z, r._z, o._z, 0, h, c, u, 1, n), n
		}
		addToRef(e, t) {
			const i = this._m,
				s = t._m,
				n = e.m;
			for (let e = 0; e < 16; e++) s[e] = i[e] + n[e];
			return t.markAsUpdated(), t
		}
		setRow(e, t) {
			return this.setRowFromFloats(e, t.x, t.y, t.z, t.w)
		}
		static TransposeToRef(e, t) {
			const i = e.m,
				s = i[0],
				n = i[4],
				a = i[8],
				r = i[12],
				o = i[1],
				l = i[5],
				h = i[9],
				c = i[13],
				u = i[2],
				m = i[6],
				d = i[10],
				f = i[14],
				p = i[3],
				_ = i[7],
				g = i[11],
				v = i[15],
				y = t._m;
			return y[0] = s, y[1] = n, y[2] = a, y[3] = r, y[4] = o, y[5] = l, y[6] = h, y[7] = c, y[8] = u, y[9] = m, y[10] = d, y[11] = f, y[12] = p, y[13] = _, y[14] = g, y[15] = v, t.markAsUpdated(), t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty), t
		}
		clone() {
			const t = new e;
			return t.copyFrom(this), t
		}
		static Reflection(t) {
			const i = new e;
			return e.ReflectionToRef(t, i), i
		}
		setAll(e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] = e;
			return this.markAsUpdated(), this
		}
		removeRotationAndScaling() {
			const t = this.m;
			return e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t[12], t[13], t[14], t[15], this), this._updateIdentityStatus(0 === t[12] && 0 === t[13] && 0 === t[14] && 1 === t[15]), this
		}
		isIdentity() {
			if (this._isIdentityDirty) {
				this._isIdentityDirty = !1;
				const e = this._m;
				this._isIdentity = 1 === e[0] && 0 === e[1] && 0 === e[2] && 0 === e[3] && 0 === e[4] && 1 === e[5] && 0 === e[6] && 0 === e[7] && 0 === e[8] && 0 === e[9] && 1 === e[10] && 0 === e[11] && 0 === e[12] && 0 === e[13] && 0 === e[14] && 1 === e[15]
			}
			return this._isIdentity
		}
		scale(t) {
			const i = new e;
			return this.scaleToRef(t, i), i
		}
		add(t) {
			const i = new e;
			return this.addToRef(t, i), i
		}
		static ScalingToRef(t, i, s, n) {
			return e.FromValuesToRef(t, 0, 0, 0, 0, i, 0, 0, 0, 0, s, 0, 0, 0, 0, 1, n), n._updateIdentityStatus(1 === t && 1 === i && 1 === s), n
		}
		static RotationAxisToRef(e, t, i) {
			const s = Math.sin(-t),
				n = Math.cos(-t),
				a = 1 - n;
			e = e.normalizeToRef(Uc.Vector3[0]);
			const r = i._m;
			return r[0] = e._x * e._x * a + n, r[1] = e._x * e._y * a - e._z * s, r[2] = e._x * e._z * a + e._y * s, r[3] = 0, r[4] = e._y * e._x * a + e._z * s, r[5] = e._y * e._y * a + n, r[6] = e._y * e._z * a - e._x * s, r[7] = 0, r[8] = e._z * e._x * a - e._y * s, r[9] = e._z * e._y * a + e._x * s, r[10] = e._z * e._z * a + n, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, i.markAsUpdated(), i
		}
		equals(e) {
			const t = e;
			if (!t) return !1;
			if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty) return this._isIdentity && t._isIdentity;
			const i = this.m,
				s = t.m;
			return i[0] === s[0] && i[1] === s[1] && i[2] === s[2] && i[3] === s[3] && i[4] === s[4] && i[5] === s[5] && i[6] === s[6] && i[7] === s[7] && i[8] === s[8] && i[9] === s[9] && i[10] === s[10] && i[11] === s[11] && i[12] === s[12] && i[13] === s[13] && i[14] === s[14] && i[15] === s[15]
		}
		copyFromFloats(...t) {
			return e.FromArrayToRef(t, 0, this)
		}
		static Invert(t) {
			const i = new e;
			return t.invertToRef(i), i
		}
		static RotationZToRef(t, i) {
			const s = Math.sin(t),
				n = Math.cos(t);
			return e.FromValuesToRef(n, s, 0, 0, -s, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, i), i._updateIdentityStatus(1 === n && 0 === s), i
		}
		static Zero() {
			const t = e.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			return t._updateIdentityStatus(!1), t
		}
		static FromValuesToRef(e, t, i, s, n, a, r, o, l, h, c, u, m, d, f, p, _) {
			const g = _._m;
			g[0] = e, g[1] = t, g[2] = i, g[3] = s, g[4] = n, g[5] = a, g[6] = r, g[7] = o, g[8] = l, g[9] = h, g[10] = c, g[11] = u, g[12] = m, g[13] = d, g[14] = f, g[15] = p, _.markAsUpdated()
		}
		divideInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] /= i[e];
			return this.markAsUpdated(), this
		}
		set(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] = e[i];
			return this.markAsUpdated(), this
		}
		decomposeToTransformNode(e) {
			return e.rotationQuaternion = e.rotationQuaternion || new Gc, this.decompose(e.scaling, e.rotationQuaternion, e.position)
		}
		addAtIndex(e, t) {
			return this._m[e] += t, this.markAsUpdated(), this
		}
		fract() {
			return this.fractToRef(new e)
		}
		static LookDirectionRH(t, i) {
			const s = new e;
			return e.LookDirectionRHToRef(t, i, s), s
		}
		addInPlaceFromFloats(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] += e[i];
			return this.markAsUpdated(), this
		}
		getRotationMatrixToRef(t) {
			const i = Uc.Vector3[0];
			if (!this.decompose(i)) return e.IdentityToRef(t), t;
			const s = this._m,
				n = 1 / i._x,
				a = 1 / i._y,
				r = 1 / i._z;
			return e.FromValuesToRef(s[0] * n, s[1] * n, s[2] * n, 0, s[4] * a, s[5] * a, s[6] * a, 0, s[8] * r, s[9] * r, s[10] * r, 0, 0, 0, 0, 1, t), t
		}
		setTranslationFromFloats(e, t, i) {
			return this._m[12] = e, this._m[13] = t, this._m[14] = i, this.markAsUpdated(), this
		}
		toggleModelMatrixHandInPlace() {
			const e = this._m;
			return e[2] *= -1, e[6] *= -1, e[8] *= -1, e[9] *= -1, e[14] *= -1, this.markAsUpdated(), this
		}
		static RotationXToRef(t, i) {
			const s = Math.sin(t),
				n = Math.cos(t);
			return e.FromValuesToRef(1, 0, 0, 0, 0, n, s, 0, 0, -s, n, 0, 0, 0, 0, 1, i), i._updateIdentityStatus(1 === n && 0 === s), i
		}
		static PerspectiveFovReverseRHToRef(t, i, s, n, a, r = !0, o, l = 0) {
			const h = 1 / Math.tan(.5 * t),
				c = r ? h / i : h,
				u = r ? h : h * i,
				m = Math.tan(l);
			return e.FromValuesToRef(c, 0, 0, 0, 0, u, 0, m, 0, 0, -s, -1, 0, 0, -1, 0, a), o && a.multiplyToRef(Wc, a), a._updateIdentityStatus(!1), a
		}
		subtractFromFloats(...t) {
			return this.subtractFromFloatsToRef(...t, new e)
		}
		multiplyToArray(e, t, i) {
			const s = this._m,
				n = e.m,
				a = s[0],
				r = s[1],
				o = s[2],
				l = s[3],
				h = s[4],
				c = s[5],
				u = s[6],
				m = s[7],
				d = s[8],
				f = s[9],
				p = s[10],
				_ = s[11],
				g = s[12],
				v = s[13],
				y = s[14],
				S = s[15],
				E = n[0],
				A = n[1],
				b = n[2],
				x = n[3],
				M = n[4],
				C = n[5],
				T = n[6],
				w = n[7],
				R = n[8],
				N = n[9],
				I = n[10],
				P = n[11],
				k = n[12],
				D = n[13],
				O = n[14],
				F = n[15];
			return t[i] = a * E + r * M + o * R + l * k, t[i + 1] = a * A + r * C + o * N + l * D, t[i + 2] = a * b + r * T + o * I + l * O, t[i + 3] = a * x + r * w + o * P + l * F, t[i + 4] = h * E + c * M + u * R + m * k, t[i + 5] = h * A + c * C + u * N + m * D, t[i + 6] = h * b + c * T + u * I + m * O, t[i + 7] = h * x + c * w + u * P + m * F, t[i + 8] = d * E + f * M + p * R + _ * k, t[i + 9] = d * A + f * C + p * N + _ * D, t[i + 10] = d * b + f * T + p * I + _ * O, t[i + 11] = d * x + f * w + p * P + _ * F, t[i + 12] = g * E + v * M + y * R + S * k, t[i + 13] = g * A + v * C + y * N + S * D, t[i + 14] = g * b + v * T + y * I + S * O, t[i + 15] = g * x + v * w + y * P + S * F, this
		}
		isIdentityAs3x2() {
			return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1, 1 !== this._m[0] || 1 !== this._m[5] || 1 !== this._m[15] || 0 !== this._m[1] || 0 !== this._m[2] || 0 !== this._m[3] || 0 !== this._m[4] || 0 !== this._m[6] || 0 !== this._m[7] || 0 !== this._m[8] || 0 !== this._m[9] || 0 !== this._m[10] || 0 !== this._m[11] || 0 !== this._m[12] || 0 !== this._m[13] || 0 !== this._m[14] ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0), this._isIdentity3x2
		}
		copyToArray(e, t = 0) {
			const i = this._m;
			return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], this
		}
		static OrthoOffCenterLH(t, i, s, n, a, r, o) {
			const l = new e;
			return e.OrthoOffCenterLHToRef(t, i, s, n, a, r, l, o), l
		}
		static GetFinalMatrix(t, i, s, n, a, r) {
			const o = t.width,
				l = t.height,
				h = t.x,
				c = t.y,
				u = e.FromValues(o / 2, 0, 0, 0, 0, -l / 2, 0, 0, 0, 0, r - a, 0, h + o / 2, l / 2 + c, a, 1),
				m = new e;
			return i.multiplyToRef(s, m), m.multiplyToRef(n, m), m.multiplyToRef(u, m)
		}
		multiply(t) {
			const i = new e;
			return this.multiplyToRef(t, i), i
		}
		asArray() {
			return this._m
		}
		multiplyAtIndex(e, t) {
			return this._m[e] *= t, this.markAsUpdated(), this
		}
		minimizeInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] = Math.min(t[e], i[e]);
			return this.markAsUpdated(), this
		}
		toNormalMatrix(t) {
			const i = Uc.Matrix[0];
			this.invertToRef(i), i.transposeToRef(t);
			const s = t._m;
			return e.FromValuesToRef(s[0], s[1], s[2], 0, s[4], s[5], s[6], 0, s[8], s[9], s[10], 0, 0, 0, 0, 1, t), t
		}
		static OrthoLHToRef(t, i, s, n, a, r) {
			const o = 2 / t,
				l = 2 / i,
				h = 2 / (n - s),
				c = -(n + s) / (n - s);
			return e.FromValuesToRef(o, 0, 0, 0, 0, l, 0, 0, 0, 0, h, 0, 0, 0, c, 1, a), r && a.multiplyToRef(Wc, a), a._updateIdentityStatus(1 === o && 1 === l && 1 === h && 0 === c), a
		}
		static FromQuaternionToRef(e, t) {
			const i = e._x * e._x,
				s = e._y * e._y,
				n = e._z * e._z,
				a = e._x * e._y,
				r = e._z * e._w,
				o = e._z * e._x,
				l = e._y * e._w,
				h = e._y * e._z,
				c = e._x * e._w;
			return t._m[0] = 1 - 2 * (s + n), t._m[1] = 2 * (a + r), t._m[2] = 2 * (o - l), t._m[3] = 0, t._m[4] = 2 * (a - r), t._m[5] = 1 - 2 * (n + i), t._m[6] = 2 * (h + c), t._m[7] = 0, t._m[8] = 2 * (o + l), t._m[9] = 2 * (h - c), t._m[10] = 1 - 2 * (s + i), t._m[11] = 0, t._m[12] = 0, t._m[13] = 0, t._m[14] = 0, t._m[15] = 1, t.markAsUpdated(), t
		}
		getTranslationToRef(e) {
			return e.x = this._m[12], e.y = this._m[13], e.z = this._m[14], e
		}
		toggleProjectionMatrixHandInPlace() {
			const e = this._m;
			return e[8] *= -1, e[9] *= -1, e[10] *= -1, e[11] *= -1, this.markAsUpdated(), this
		}
		divide(t) {
			return this.divideToRef(t, new e)
		}
		transpose() {
			const t = new e;
			return e.TransposeToRef(this, t), t
		}
		static GetAsMatrix2x2(e) {
			const t = e.m,
				i = [t[0], t[1], t[4], t[5]];
			return Nc.MatrixUse64Bits ? i : new Float32Array(i)
		}
		static Scaling(t, i, s) {
			const n = new e;
			return e.ScalingToRef(t, i, s, n), n
		}
		static DecomposeLerp(t, i, s) {
			const n = new e;
			return e.DecomposeLerpToRef(t, i, s, n), n
		}
		getRowToRef(e, t) {
			if (e >= 0 && e <= 3) {
				const i = 4 * e;
				t.x = this._m[i + 0], t.y = this._m[i + 1], t.z = this._m[i + 2], t.w = this._m[i + 3]
			}
			return t
		}
		addToSelf(e) {
			const t = this._m,
				i = e.m;
			return t[0] += i[0], t[1] += i[1], t[2] += i[2], t[3] += i[3], t[4] += i[4], t[5] += i[5], t[6] += i[6], t[7] += i[7], t[8] += i[8], t[9] += i[9], t[10] += i[10], t[11] += i[11], t[12] += i[12], t[13] += i[13], t[14] += i[14], t[15] += i[15], this.markAsUpdated(), this
		}
		multiplyInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] *= i[e];
			return this.markAsUpdated(), this
		}
		setRowFromFloats(e, t, i, s, n) {
			if (e < 0 || e > 3) return this;
			const a = 4 * e;
			return this._m[a + 0] = t, this._m[a + 1] = i, this._m[a + 2] = s, this._m[a + 3] = n, this.markAsUpdated(), this
		}
		static PerspectiveLH(t, i, s, n, a, r = 0) {
			const o = new e,
				l = 2 * s / t,
				h = 2 * s / i,
				c = (n + s) / (n - s),
				u = -2 * n * s / (n - s),
				m = Math.tan(r);
			return e.FromValuesToRef(l, 0, 0, 0, 0, h, 0, m, 0, 0, c, 1, 0, 0, u, 0, o), a && o.multiplyToRef(Wc, o), o._updateIdentityStatus(!1), o
		}
		scaleInPlace(e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] *= e;
			return this.markAsUpdated(), this
		}
		static OrthoOffCenterRH(t, i, s, n, a, r, o) {
			const l = new e;
			return e.OrthoOffCenterRHToRef(t, i, s, n, a, r, l, o), l
		}
		fractToRef(e) {
			const t = this._m,
				i = e._m;
			for (let e = 0; e < 16; e++) i[e] = t[e] - Math.floor(t[e]);
			return e.markAsUpdated(), e
		}
		fromArray(t, i = 0) {
			return e.FromArrayToRef(t, i, this)
		}
		static LookAtRH(t, i, s) {
			const n = new e;
			return e.LookAtRHToRef(t, i, s, n), n
		}
		scaleAndAddToRef(e, t) {
			for (let i = 0; i < 16; i++) t._m[i] += this._m[i] * e;
			return t.markAsUpdated(), t
		}
		_updateIdentityStatus(e, t = !1, i = !1, s = !0) {
			this._isIdentity = e, this._isIdentity3x2 = e || i, this._isIdentityDirty = !this._isIdentity && t, this._isIdentity3x2Dirty = !this._isIdentity3x2 && s
		}
		static LookDirectionLHToRef(t, i, s) {
			const n = Uc.Vector3[0];
			n.copyFrom(t), n.scaleInPlace(-1);
			const a = Uc.Vector3[1];
			return Lc.CrossToRef(i, n, a), e.FromValuesToRef(a._x, a._y, a._z, 0, i._x, i._y, i._z, 0, n._x, n._y, n._z, 0, 0, 0, 0, 1, s), s
		}
		static IdentityToRef(t) {
			return e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(!0), t
		}
		getClassName() {
			return "Matrix"
		}
		static ObliqueOffCenterLHToRef(t, i, s, n, a, r, o, l, h, c, u) {
			const m = -o * Math.cos(l),
				d = -o * Math.sin(l);
			return e.TranslationToRef(0, 0, -h, Uc.Matrix[1]), e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, m, d, 1, 0, 0, 0, 0, 1, Uc.Matrix[0]), Uc.Matrix[1].multiplyToRef(Uc.Matrix[0], Uc.Matrix[0]), e.TranslationToRef(0, 0, h, Uc.Matrix[1]), Uc.Matrix[0].multiplyToRef(Uc.Matrix[1], Uc.Matrix[0]), e.OrthoOffCenterLHToRef(t, i, s, n, a, r, c, u), Uc.Matrix[0].multiplyToRef(c, c), c
		}
		static RotationZ(t) {
			const i = new e;
			return e.RotationZToRef(t, i), i
		}
		subtractInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] -= i[e];
			return this.markAsUpdated(), this
		}
		transposeToRef(t) {
			return e.TransposeToRef(this, t), t
		}
		static RotationAxis(t, i) {
			const s = new e;
			return e.RotationAxisToRef(t, i, s), s
		}
		static TranslationToRef(t, i, s, n) {
			return e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, i, s, 1, n), n._updateIdentityStatus(0 === t && 0 === i && 0 === s), n
		}
		static LerpToRef(e, t, i, s) {
			const n = s._m,
				a = e.m,
				r = t.m;
			for (let e = 0; e < 16; e++) n[e] = a[e] * (1 - i) + r[e] * i;
			return s.markAsUpdated(), s
		}
		static Lerp(t, i, s) {
			const n = new e;
			return e.LerpToRef(t, i, s, n), n
		}
		static FromArrayToRef(e, t, i) {
			for (let s = 0; s < 16; s++) i._m[s] = e[s + t];
			return i.markAsUpdated(), i
		}
		static GetAsMatrix3x3(e) {
			const t = e.m,
				i = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]];
			return Nc.MatrixUse64Bits ? i : new Float32Array(i)
		}
		getHashCode() {
			let e = Oc(this._m[0]);
			for (let t = 1; t < 16; t++) e = 397 * e ^ Oc(this._m[t]);
			return e
		}
		static RotationY(t) {
			const i = new e;
			return e.RotationYToRef(t, i), i
		}
		static Compose(t, i, s) {
			const n = new e;
			return e.ComposeToRef(t, i, s, n), n
		}
		minimizeInPlaceFromFloats(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] = Math.min(t[i], e[i]);
			return this.markAsUpdated(), this
		}
		multiplyToRef(e, t) {
			return this._isIdentity ? (t.copyFrom(e), t) : e._isIdentity ? (t.copyFrom(this), t) : (this.multiplyToArray(e, t._m, 0), t.markAsUpdated(), t)
		}
		negateInPlace() {
			const e = this._m;
			for (let t = 0; t < 16; t++) e[t] = -e[t];
			return this.markAsUpdated(), this
		}
		static PerspectiveFovLHToRef(t, i, s, n, a, r = !0, o, l = 0, h = !1) {
			const c = s,
				u = n,
				m = 1 / Math.tan(.5 * t),
				d = r ? m / i : m,
				f = r ? m : m * i,
				p = h && 0 === c ? -1 : 0 !== u ? (u + c) / (u - c) : 1,
				_ = h && 0 === c ? 2 * u : 0 !== u ? -2 * u * c / (u - c) : -2 * c,
				g = Math.tan(l);
			return e.FromValuesToRef(d, 0, 0, 0, 0, f, 0, g, 0, 0, p, 1, 0, 0, _, 0, a), o && a.multiplyToRef(Wc, a), a._updateIdentityStatus(!1), a
		}
		floorToRef(e) {
			const t = this._m,
				i = e._m;
			for (let e = 0; e < 16; e++) i[e] = Math.floor(t[e]);
			return e.markAsUpdated(), e
		}
		setTranslation(e) {
			return this.setTranslationFromFloats(e._x, e._y, e._z)
		}
		static Jk(t, i, s) {
			const n = new e;
			return e.RotationYawPitchRollToRef(t, i, s, n), n
		}
		addInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] += i[e];
			return this.markAsUpdated(), this
		}
		floor() {
			return this.floorToRef(new e)
		}
		multiplyByFloats(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] *= e[i];
			return this.markAsUpdated(), this
		}
		static DecomposeLerpToRef(t, i, s, n) {
			const a = Uc.Vector3[0],
				r = Uc.uk[0],
				o = Uc.Vector3[1];
			t.decompose(a, r, o);
			const l = Uc.Vector3[2],
				h = Uc.uk[1],
				c = Uc.Vector3[3];
			i.decompose(l, h, c);
			const u = Uc.Vector3[4];
			Lc.LerpToRef(a, l, s, u);
			const m = Uc.uk[2];
			Gc.SlerpToRef(r, h, s, m);
			const d = Uc.Vector3[5];
			return Lc.LerpToRef(o, c, s, d), e.ComposeToRef(u, m, d, n), n
		}
		toString() {
			return `{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`
		}
		constructor() {
			this._isIdentity = !1, this._isIdentityDirty = !0, this._isIdentity3x2 = !0, this._isIdentity3x2Dirty = !0, this.updateFlag = -1, Nc.MatrixTrackPrecisionChange && Nc.MatrixTrackedMatrices.push(this), this._m = new Nc.MatrixCurrentType(16), this.markAsUpdated()
		}
		static get Use64Bits() {
			return Nc.MatrixUse64Bits
		}
		multiplyByFloatsToRef(...e) {
			const t = e.pop(),
				i = this._m,
				s = t._m,
				n = e;
			for (let e = 0; e < 16; e++) s[e] = i[e] * n[e];
			return t.markAsUpdated(), t
		}
		static RotationX(t) {
			const i = new e;
			return e.RotationXToRef(t, i), i
		}
		static LookDirectionLH(t, i) {
			const s = new e;
			return e.LookDirectionLHToRef(t, i, s), s
		}
		static PerspectiveFovLH(t, i, s, n, a, r = 0, o = !1) {
			const l = new e;
			return e.PerspectiveFovLHToRef(t, i, s, n, l, !0, a, r, o), l
		}
		static ReflectionToRef(t, i) {
			t.normalize();
			const s = t.normal.x,
				n = t.normal.y,
				a = t.normal.z,
				r = -2 * s,
				o = -2 * n,
				l = -2 * a;
			return e.FromValuesToRef(r * s + 1, o * s, l * s, 0, r * n, o * n + 1, l * n, 0, r * a, o * a, l * a + 1, 0, r * t.d, o * t.d, l * t.d, 1, i), i
		}
		static FromValues(t, i, s, n, a, r, o, l, h, c, u, m, d, f, p, _) {
			const g = new e,
				v = g._m;
			return v[0] = t, v[1] = i, v[2] = s, v[3] = n, v[4] = a, v[5] = r, v[6] = o, v[7] = l, v[8] = h, v[9] = c, v[10] = u, v[11] = m, v[12] = d, v[13] = f, v[14] = p, v[15] = _, g.markAsUpdated(), g
		}
		subtract(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] -= i[e];
			return this.markAsUpdated(), this
		}
		copyFrom(e) {
			e.copyToArray(this._m);
			const t = e;
			return this.updateFlag = t.updateFlag, this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty), this
		}
		static PerspectiveFovReverseLHToRef(t, i, s, n, a, r = !0, o, l = 0) {
			const h = 1 / Math.tan(.5 * t),
				c = r ? h / i : h,
				u = r ? h : h * i,
				m = Math.tan(l);
			return e.FromValuesToRef(c, 0, 0, 0, 0, u, 0, m, 0, 0, -s, 1, 0, 0, 1, 0, a), o && a.multiplyToRef(Wc, a), a._updateIdentityStatus(!1), a
		}
		static RotationAlignToRef(e, t, i, s = !1) {
			const n = Lc.Dot(t, e),
				a = i._m;
			if (n < -.999) a[0] = -1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = s ? 1 : -1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = s ? -1 : 1, a[11] = 0;
			else {
				const i = Lc.Cross(t, e),
					s = 1 / (1 + n);
				a[0] = i._x * i._x * s + n, a[1] = i._y * i._x * s - i._z, a[2] = i._z * i._x * s + i._y, a[3] = 0, a[4] = i._x * i._y * s + i._z, a[5] = i._y * i._y * s + n, a[6] = i._z * i._y * s - i._x, a[7] = 0, a[8] = i._x * i._z * s - i._y, a[9] = i._y * i._z * s + i._x, a[10] = i._z * i._z * s + n, a[11] = 0
			}
			return a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, i.markAsUpdated(), i
		}
		static ObliqueOffCenterRHToRef(t, i, s, n, a, r, o, l, h, c, u) {
			const m = o * Math.cos(l),
				d = o * Math.sin(l);
			return e.TranslationToRef(0, 0, h, Uc.Matrix[1]), e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, m, d, 1, 0, 0, 0, 0, 1, Uc.Matrix[0]), Uc.Matrix[1].multiplyToRef(Uc.Matrix[0], Uc.Matrix[0]), e.TranslationToRef(0, 0, -h, Uc.Matrix[1]), Uc.Matrix[0].multiplyToRef(Uc.Matrix[1], Uc.Matrix[0]), e.OrthoOffCenterRHToRef(t, i, s, n, a, r, c, u), Uc.Matrix[0].multiplyToRef(c, c), c
		}
		static LookAtLH(t, i, s) {
			const n = new e;
			return e.LookAtLHToRef(t, i, s, n), n
		}
		static PerspectiveFovRH(t, i, s, n, a, r = 0, o = !1) {
			const l = new e;
			return e.PerspectiveFovRHToRef(t, i, s, n, l, !0, a, r, o), l
		}
		negate() {
			return this.negateToRef(new e)
		}
		static PerspectiveFovRHToRef(t, i, s, n, a, r = !0, o, l = 0, h = !1) {
			const c = s,
				u = n,
				m = 1 / Math.tan(.5 * t),
				d = r ? m / i : m,
				f = r ? m : m * i,
				p = h && 0 === c ? 1 : 0 !== u ? -(u + c) / (u - c) : -1,
				_ = h && 0 === c ? 2 * u : 0 !== u ? -2 * u * c / (u - c) : -2 * c,
				g = Math.tan(l);
			return e.FromValuesToRef(d, 0, 0, 0, 0, f, 0, g, 0, 0, p, -1, 0, 0, _, 0, a), o && a.multiplyToRef(Wc, a), a._updateIdentityStatus(!1), a
		}
		static ComposeToRef(e, t, i, s) {
			const n = s._m,
				a = t._x,
				r = t._y,
				o = t._z,
				l = t._w,
				h = a + a,
				c = r + r,
				u = o + o,
				m = a * h,
				d = a * c,
				f = a * u,
				p = r * c,
				_ = r * u,
				g = o * u,
				v = l * h,
				y = l * c,
				S = l * u,
				E = e._x,
				A = e._y,
				b = e._z;
			return n[0] = (1 - (p + g)) * E, n[1] = (d + S) * E, n[2] = (f - y) * E, n[3] = 0, n[4] = (d - S) * A, n[5] = (1 - (m + g)) * A, n[6] = (_ + v) * A, n[7] = 0, n[8] = (f + y) * b, n[9] = (_ - v) * b, n[10] = (1 - (m + p)) * b, n[11] = 0, n[12] = i._x, n[13] = i._y, n[14] = i._z, n[15] = 1, s.markAsUpdated(), s
		}
		static FromXYZAxesToRef(t, i, s, n) {
			return e.FromValuesToRef(t._x, t._y, t._z, 0, i._x, i._y, i._z, 0, s._x, s._y, s._z, 0, 0, 0, 0, 1, n), n
		}
		static LookDirectionRHToRef(t, i, s) {
			const n = Uc.Vector3[2];
			return Lc.CrossToRef(i, t, n), e.FromValuesToRef(n._x, n._y, n._z, 0, i._x, i._y, i._z, 0, t._x, t._y, t._z, 0, 0, 0, 0, 1, s), s
		}
		getRotationMatrix() {
			const t = new e;
			return this.getRotationMatrixToRef(t), t
		}
		static OrthoOffCenterRHToRef(t, i, s, n, a, r, o, l) {
			return e.OrthoOffCenterLHToRef(t, i, s, n, a, r, o, l), o._m[10] *= -1, o
		}
		subtractToRef(e, t) {
			const i = this._m,
				s = e.m,
				n = t._m;
			for (let e = 0; e < 16; e++) n[e] = i[e] - s[e];
			return t.markAsUpdated(), t
		}
		equalsToFloats(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++)
				if (t[i] != e[i]) return !1;
			return !0
		}
		static OrthoLH(t, i, s, n, a) {
			const r = new e;
			return e.OrthoLHToRef(t, i, s, n, r, a), r
		}
		static RotationYawPitchRollToRef(e, t, i, s) {
			return Gc.RotationYawPitchRollToRef(e, t, i, Uc.uk[0]), Uc.uk[0].toRotationMatrix(s), s
		}
		maximizeInPlace(e) {
			const t = this._m,
				i = e.m;
			for (let e = 0; e < 16; e++) t[e] = Math.min(t[e], i[e]);
			return this.markAsUpdated(), this
		}
		static Translation(t, i, s) {
			const n = new e;
			return e.TranslationToRef(t, i, s, n), n
		}
		invertToRef(t) {
			if (!0 === this._isIdentity) return e.IdentityToRef(t), t;
			const i = this._m,
				s = i[0],
				n = i[1],
				a = i[2],
				r = i[3],
				o = i[4],
				l = i[5],
				h = i[6],
				c = i[7],
				u = i[8],
				m = i[9],
				d = i[10],
				f = i[11],
				p = i[12],
				_ = i[13],
				g = i[14],
				v = i[15],
				y = d * v - g * f,
				S = m * v - _ * f,
				E = m * g - _ * d,
				A = u * v - p * f,
				b = u * g - d * p,
				x = u * _ - p * m,
				M = +(l * y - h * S + c * E),
				C = -(o * y - h * A + c * b),
				T = +(o * S - l * A + c * x),
				w = -(o * E - l * b + h * x),
				R = s * M + n * C + a * T + r * w;
			if (0 === R) return t.copyFrom(this), t;
			const N = 1 / R,
				I = h * v - g * c,
				P = l * v - _ * c,
				k = l * g - _ * h,
				D = o * v - p * c,
				O = o * g - p * h,
				F = o * _ - p * l,
				L = h * f - d * c,
				B = l * f - m * c,
				G = l * d - m * h,
				H = o * f - u * c,
				U = o * d - u * h,
				V = o * m - u * l,
				W = -(n * y - a * S + r * E),
				z = +(s * y - a * A + r * b),
				X = -(s * S - n * A + r * x),
				Y = +(s * E - n * b + a * x),
				j = +(n * I - a * P + r * k),
				K = -(s * I - a * D + r * O),
				$ = +(s * P - n * D + r * F),
				J = -(s * k - n * O + a * F),
				q = -(n * L - a * B + r * G),
				Q = +(s * L - a * H + r * U),
				Z = -(s * B - n * H + r * V),
				ee = +(s * G - n * U + a * V);
			return e.FromValuesToRef(M * N, W * N, j * N, q * N, C * N, z * N, K * N, Q * N, T * N, X * N, $ * N, Z * N, w * N, Y * N, J * N, ee * N, t), t
		}
		addTranslationFromFloats(e, t, i) {
			return this._m[12] += e, this._m[13] += t, this._m[14] += i, this.markAsUpdated(), this
		}
		reset() {
			return e.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this), this._updateIdentityStatus(!1), this
		}
		markAsUpdated() {
			this.updateFlag = e._UpdateFlagSeed++, this._isIdentity = !1, this._isIdentity3x2 = !1, this._isIdentityDirty = !0, this._isIdentity3x2Dirty = !0
		}
		equalsWithEpsilon(e, t = 0) {
			const i = this._m,
				s = e.m;
			for (let e = 0; e < 16; e++)
				if (!_c(i[e], s[e], t)) return !1;
			return !0
		}
		static LookAtRHToRef(t, i, s, n) {
			const a = Uc.Vector3[0],
				r = Uc.Vector3[1],
				o = Uc.Vector3[2];
			t.subtractToRef(i, o), o.normalize(), Lc.CrossToRef(s, o, a);
			const l = a.lengthSquared();
			0 === l ? a.x = 1 : a.normalizeFromLength(Math.sqrt(l)), Lc.CrossToRef(o, a, r), r.normalize();
			const h = -Lc.Dot(a, t),
				c = -Lc.Dot(r, t),
				u = -Lc.Dot(o, t);
			return e.FromValuesToRef(a._x, r._x, o._x, 0, a._y, r._y, o._y, 0, a._z, r._z, o._z, 0, h, c, u, 1, n), n
		}
		static FromArray(t, i = 0) {
			const s = new e;
			return e.FromArrayToRef(t, i, s), s
		}
		static FromFloat32ArrayToRefScaled(e, t, i, s) {
			return s._m[0] = e[0 + t] * i, s._m[1] = e[1 + t] * i, s._m[2] = e[2 + t] * i, s._m[3] = e[3 + t] * i, s._m[4] = e[4 + t] * i, s._m[5] = e[5 + t] * i, s._m[6] = e[6 + t] * i, s._m[7] = e[7 + t] * i, s._m[8] = e[8 + t] * i, s._m[9] = e[9 + t] * i, s._m[10] = e[10 + t] * i, s._m[11] = e[11 + t] * i, s._m[12] = e[12 + t] * i, s._m[13] = e[13 + t] * i, s._m[14] = e[14 + t] * i, s._m[15] = e[15 + t] * i, s.markAsUpdated(), s
		}
		toArray(e = null, t = 0) {
			if (!e) return this._m;
			const i = this._m;
			for (let s = 0; s < 16; s++) e[t + s] = i[s];
			return this
		}
		maximizeInPlaceFromFloats(...e) {
			const t = this._m;
			for (let i = 0; i < 16; i++) t[i] = Math.min(t[i], e[i]);
			return this.markAsUpdated(), this
		}
		invert() {
			return this.invertToRef(this), this
		}
		getTranslation() {
			return new Lc(this._m[12], this._m[13], this._m[14])
		}
		divideToRef(e, t) {
			const i = this._m,
				s = e.m,
				n = t._m;
			for (let e = 0; e < 16; e++) n[e] = i[e] / s[e];
			return t.markAsUpdated(), t
		}
	};
	Hc._UpdateFlagSeed = 0, Hc._IdentityReadOnly = Hc.Identity(), Object.defineProperties(Hc.prototype, {
		dimension: {
			value: [4, 4]
		},
		rank: {
			value: 2
		}
	});
	var Uc = class {};
	Uc.Vector3 = rc(11, Lc.Zero), Uc.Matrix = rc(2, Hc.Identity), Uc.uk = rc(3, Gc.Zero);
	var Vc = class {};
	Vc.Vector2 = rc(3, Fc.Zero), Vc.Vector3 = rc(13, Lc.Zero), Vc.Vector4 = rc(3, Bc.Zero), Vc.uk = rc(3, Gc.Zero), Vc.Matrix = rc(8, Hc.Identity), cc("BABYLON.Vector2", Fc), cc("BABYLON.Vector3", Lc), cc("BABYLON.Vector4", Bc), cc("BABYLON.Matrix", Hc);
	var Wc = Hc.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1),
		zc = function(e, t, i, s = {}) {
			const n = e();
			nc && nc.HasTags(t) && nc.AddTagsTo(n, nc.GetTags(t, !0));
			const a = Vh(n),
				r = {};
			for (const e in a) {
				const o = a[e],
					l = t[e],
					h = o.type;
				if (null != l && ("uniqueId" !== e || Xc.AllowLoadingUniqueId)) switch (h) {
					case 0:
					case 6:
					case 11:
						n[e] = l;
						break;
					case 1:
						s.cloneTexturesOnlyOnce && r[l.ik] ? n[e] = r[l.ik] : (n[e] = i || l.isRenderTarget ? l : l.clone(), r[l.ik] = n[e]);
						break;
					case 2:
					case 3:
					case 4:
					case 5:
					case 7:
					case 10:
					case 12:
						n[e] = i ? l : l.clone()
				}
			}
			return n
		},
		Xc = class e {
			static ParseProperties(t, i, s, n) {
				n || (n = "");
				const a = Vh(i);
				for (const r in a) {
					const o = a[r],
						l = t[o.sourceName || r],
						h = o.type;
					if (null != l && ("uniqueId" !== r || e.AllowLoadingUniqueId)) {
						const t = i;
						switch (h) {
							case 0:
								t[r] = l;
								break;
							case 1:
								s && (t[r] = e._TextureParser(l, s, n));
								break;
							case 2:
								t[r] = Tc.FromArray(l);
								break;
							case 3:
								t[r] = e._FresnelParametersParser(l);
								break;
							case 4:
								t[r] = Fc.FromArray(l);
								break;
							case 5:
								t[r] = Lc.FromArray(l);
								break;
							case 6:
								s && (t[r] = s.getLastMeshById(l));
								break;
							case 7:
								t[r] = e._ColorCurvesParser(l);
								break;
							case 8:
								t[r] = wc.FromArray(l);
								break;
							case 9:
								t[r] = e._ImageProcessingConfigurationParser(l);
								break;
							case 10:
								t[r] = Gc.FromArray(l);
								break;
							case 11:
								s && (t[r] = s.getCameraById(l));
								break;
							case 12:
								t[r] = Hc.FromArray(l)
						}
					}
				}
			}
			static AppendSerializedAnimations(e, t) {
				if (e.animations) {
					t.animations = [];
					for (let i = 0; i < e.animations.length; i++) {
						const s = e.animations[i];
						t.animations.push(s.serialize())
					}
				}
			}
			static Clone(e, t, i = {}) {
				return zc(e, t, !1, i)
			}
			static Serialize(t, i) {
				i || (i = {}), nc && (i.tags = nc.GetTags(t));
				const s = Vh(t);
				for (const n in s) {
					const a = s[n],
						r = a.sourceName || n,
						o = a.type,
						l = t[n];
					if (null != l && ("uniqueId" !== n || e.AllowLoadingUniqueId)) switch (o) {
						case 0:
							i[r] = l;
							break;
						case 1:
						case 3:
						case 7:
						case 9:
							i[r] = l.serialize();
							break;
						case 2:
						case 4:
						case 5:
						case 8:
						case 10:
						case 12:
							i[r] = l.asArray();
							break;
						case 6:
						case 11:
							i[r] = l.id
					}
				}
				return i
			}
			static Instanciate(e, t) {
				return zc(e, t, !0)
			}
			static Parse(t, i, s, n = null) {
				const a = t();
				return nc && nc.AddTagsTo(a, i.tags), e.ParseProperties(i, a, s, n), a
			}
		};
	Xc.AllowLoadingUniqueId = !1, Xc._ImageProcessingConfigurationParser = e => {
		throw ic("ImageProcessingConfiguration")
	}, Xc._FresnelParametersParser = e => {
		throw ic("FresnelParameters")
	}, Xc._ColorCurvesParser = e => {
		throw ic("ColorCurves")
	}, Xc._TextureParser = (e, t, i) => {
		throw ic("Texture")
	};
	var Yc = class {
			constructor() {
				this._doNotSerialize = !1, this._isDisposed = !1, this._sceneRootNodesIndex = -1, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._onEnabledStateChangedObservable = new kc, this._onClonedObservable = new kc
			}
		},
		jc = class e {
			get animationPropertiesOverride() {
				return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride
			}
			constructor(e, t = null, i = !0) {
				this._isDirty = !1, this._nodeDataStorage = new Yc, this.state = "", this.metadata = null, this.reservedDataStore = null, this._accessibilityTag = null, this.onAccessibilityTagChangedObservable = new kc, this._parentContainer = null, this.animations = [], this._ranges = {}, this.onReady = null, this._currentRenderId = -1, this._parentUpdateId = -1, this._childUpdateId = -1, this._waitingParentId = null, this._waitingParentInstanceIndex = null, this._waitingParsedUniqueId = null, this._cache = {}, this._parentNode = null, this._children = null, this._worldMatrix = Hc.Identity(), this._worldMatrixDeterminant = 0, this._worldMatrixDeterminantIsDirty = !0, this._animationPropertiesOverride = null, this._isNode = !0, this.onDisposeObservable = new kc, this._onDisposeObserver = null, this._behaviors = new Array, this.name = e, this.id = e, this._scene = t || Dc.LastCreatedScene, this.ik = this._scene.getUniqueId(), this._initCache(), i && this._addToSceneRootNodes()
			}
			get parent() {
				return this._parentNode
			}
			dispose(e, t = !1) {
				if (this._nodeDataStorage._isDisposed = !0, !e) {
					const i = this.getDescendants(!0);
					for (const s of i) s.dispose(e, t)
				}
				this.parent ? this.parent = null : this._removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onEnabledStateChangedObservable.clear(), this.onClonedObservable.clear();
				for (const e of this._behaviors) e.detach();
				this._behaviors.length = 0, this.metadata = null
			}
			getDescendants(e, t) {
				const i = [];
				return this._getDescendants(i, e, t), i
			}
			get onEnabledStateChangedObservable() {
				return this._nodeDataStorage._onEnabledStateChangedObservable
			}
			isDisposed() {
				return this._nodeDataStorage._isDisposed
			}
			get behaviors() {
				return this._behaviors
			}
			_initCache() {
				this._cache = {}
			}
			set doNotSerialize(e) {
				this._nodeDataStorage._doNotSerialize = e
			}
			get accessibilityTag() {
				return this._accessibilityTag
			}
			getHierarchyBoundingVectors(e = !0, t = null) {
				let i, s;
				this.getScene().incrementRenderId(), this.computeWorldMatrix(!0);
				const n = this;
				if (n.getBoundingInfo && n.subMeshes) {
					const e = n.getBoundingInfo();
					i = e.boundingBox.minimumWorld.clone(), s = e.boundingBox.maximumWorld.clone()
				} else i = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
				if (e) {
					const e = this.getDescendants(!1);
					for (const n of e) {
						const e = n;
						if (e.computeWorldMatrix(!0), t && !t(e)) continue;
						if (!e.getBoundingInfo || 0 === e.getTotalVertices()) continue;
						const a = e.getBoundingInfo().boundingBox,
							r = a.minimumWorld,
							o = a.maximumWorld;
						Lc.CheckExtends(r, i, s), Lc.CheckExtends(o, i, s)
					}
				}
				return {
					min: i,
					max: s
				}
			}
			getBehaviorByName(e) {
				for (const t of this._behaviors)
					if (t.name === e) return t;
				return null
			}
			removeBehavior(e) {
				const t = this._behaviors.indexOf(e);
				return -1 === t || (this._behaviors[t].detach(), this._behaviors.splice(t, 1)), this
			}
			isDescendantOf(e) {
				return !!this.parent && (this.parent === e || this.parent.isDescendantOf(e))
			}
			getChildMeshes(e, t) {
				const i = [];
				return this._getDescendants(i, e, (e => (!t || t(e)) && void 0 !== e.cullingStrategy)), i
			}
			getAnimationByName(e) {
				for (let t = 0; t < this.animations.length; t++) {
					const i = this.animations[t];
					if (i.name === e) return i
				}
				return null
			}
			set parent(e) {
				if (this._parentNode === e) return;
				const t = this._parentNode;
				if (this._parentNode && void 0 !== this._parentNode._children && null !== this._parentNode._children) {
					const t = this._parentNode._children.indexOf(this); - 1 !== t && this._parentNode._children.splice(t, 1), e || this._nodeDataStorage._isDisposed || this._addToSceneRootNodes()
				}
				this._parentNode = e, this._isDirty = !0, this._parentNode && (void 0 !== this._parentNode._children && null !== this._parentNode._children || (this._parentNode._children = new Array), this._parentNode._children.push(this), t || this._removeFromSceneRootNodes()), this._syncParentEnabledState()
			}
			_setReady(e) {
				e !== this._nodeDataStorage._isReady && (e ? (this.onReady && this.onReady(this), this._nodeDataStorage._isReady = !0) : this._nodeDataStorage._isReady = !1)
			}
			getAnimationRanges() {
				const e = [];
				let t;
				for (t in this._ranges) e.push(this._ranges[t]);
				return e
			}
			addBehavior(e, t = !1) {
				return -1 !== this._behaviors.indexOf(e) || (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce((() => {
					e.attach(this)
				})) : e.attach(this), this._behaviors.push(e)), this
			}
			serializeAnimationRanges() {
				const e = [];
				for (const t in this._ranges) {
					const i = this._ranges[t];
					if (!i) continue;
					const s = {};
					s.name = t, s.from = i.from, s.to = i.to, e.push(s)
				}
				return e
			}
			getEngine() {
				return this._scene.getEngine()
			}
			deleteAnimationRange(e, t = !0) {
				for (let i = 0, s = this.animations.length; i < s; i++) this.animations[i] && this.animations[i].deleteRange(e, t);
				this._ranges[e] = null
			}
			get worldMatrixFromCache() {
				return this._worldMatrix
			}
			_removeFromSceneRootNodes() {
				if (-1 !== this._nodeDataStorage._sceneRootNodesIndex) {
					const e = this._scene.rootNodes,
						t = e.length - 1;
					e[this._nodeDataStorage._sceneRootNodesIndex] = e[t], e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._nodeDataStorage._sceneRootNodesIndex = -1
				}
			}
			getAnimationRange(e) {
				return this._ranges[e] || null
			}
			get doNotSerialize() {
				return !!this._nodeDataStorage._doNotSerialize || !!this._parentNode && this._parentNode.doNotSerialize
			}
			static ParseAnimationRanges(e, t, i) {
				if (t.ranges)
					for (let i = 0; i < t.ranges.length; i++) {
						const s = t.ranges[i];
						e.createAnimationRange(s.name, s.from, s.to)
					}
			}
			isSynchronized() {
				return !(this._parentNode && !this.isSynchronizedWithParent()) && this._isSynchronized()
			}
			isEnabled(e = !0) {
				return !1 === e ? this._nodeDataStorage._isEnabled : !!this._nodeDataStorage._isEnabled && this._nodeDataStorage._isParentEnabled
			}
			static AddNodeConstructor(e, t) {
				this._NodeConstructors[e] = t
			}
			get onClonedObservable() {
				return this._nodeDataStorage._onClonedObservable
			}
			getClassName() {
				return "Node"
			}
			_serializeAsParent(e) {
				e.parentId = this.ik
			}
			set onDispose(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			}
			_getDescendants(e, t = !1, i) {
				if (this._children)
					for (let s = 0; s < this._children.length; s++) {
						const n = this._children[s];
						i && !i(n) || e.push(n), t || n._getDescendants(e, !1, i)
					}
			}
			_isSynchronized() {
				return !0
			}
			getChildren(e, t = !0) {
				return this.getDescendants(t, e)
			}
			set animationPropertiesOverride(e) {
				this._animationPropertiesOverride = e
			}
			computeWorldMatrix(e) {
				return this._worldMatrix || (this._worldMatrix = Hc.Identity()), this._worldMatrix
			}
			set accessibilityTag(e) {
				this._accessibilityTag = e, this.onAccessibilityTagChangedObservable.notifyObservers(e)
			}
			_getWorldMatrixDeterminant() {
				return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1, this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrixDeterminant
			}
			isSynchronizedWithParent() {
				return !this._parentNode || !this._parentNode._isDirty && this._parentUpdateId === this._parentNode._childUpdateId && this._parentNode.isSynchronized()
			}
			clone(t, i, s) {
				const n = Xc.Clone((() => new e(t, this.getScene())), this);
				if (i && (n.parent = i), !s) {
					const e = this.getDescendants(!0);
					for (let i = 0; i < e.length; i++) {
						const s = e[i];
						s.clone(t + "." + s.name, n)
					}
				}
				return n
			}
			_getActionManagerForTrigger(e, t = !0) {
				return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null
			}
			getScene() {
				return this._scene
			}
			_markSyncedWithParent() {
				this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId)
			}
			static Construct(e, t, i, s) {
				const n = this._NodeConstructors[e];
				return n ? n(t, i, s) : null
			}
			_addToSceneRootNodes() {
				-1 === this._nodeDataStorage._sceneRootNodesIndex && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this))
			}
			getWorldMatrix() {
				return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix
			}
			createAnimationRange(t, i, s) {
				if (!this._ranges[t]) {
					this._ranges[t] = e._AnimationRangeFactory(t, i, s);
					for (let e = 0, n = this.animations.length; e < n; e++) this.animations[e] && this.animations[e].createRange(t, i, s)
				}
			}
			_updateCache(e) {}
			updateCache(e) {
				!e && this.isSynchronized() || this._updateCache()
			}
			isReady(e = !1) {
				return this._nodeDataStorage._isReady
			}
			beginAnimation(e, t, i, s) {
				const n = this.getAnimationRange(e);
				return n ? this._scene.beginAnimation(this, n.from, n.to, t, i, s) : null
			}
			setEnabled(e) {
				this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e, this._syncParentEnabledState(), this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e))
			}
			markAsDirty(e) {
				return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this
			}
			_syncParentEnabledState() {
				this._nodeDataStorage._isParentEnabled = !this._parentNode || this._parentNode.isEnabled(), this._children && this._children.forEach((e => {
					e._syncParentEnabledState()
				}))
			}
		};
	jc._AnimationRangeFactory = (e, t, i) => {
		throw ic("AnimationRange")
	}, jc._NodeConstructors = {}, Gh([Xh()], jc.prototype, "name", void 0), Gh([Xh()], jc.prototype, "id", void 0), Gh([Xh()], jc.prototype, "uniqueId", void 0), Gh([Xh()], jc.prototype, "state", void 0), Gh([Xh()], jc.prototype, "metadata", void 0);
	var Kc, $c = Hc.Compose(Lc.One(), Gc.FromEulerAngles(0, Math.PI, 0), Lc.Zero()),
		Jc = class e extends jc {
			markAsDirty(e) {
				if (this._isDirty) return this;
				if (this._children)
					for (const t of this._children) t.markAsDirty(e);
				return super.markAsDirty(e)
			}
			constructor(t, i = null, s = !0) {
				super(t, i, !1), this._forward = new Lc(0, 0, 1), this._up = new Lc(0, 1, 0), this._right = new Lc(1, 0, 0), this._position = Lc.Zero(), this._rotation = Lc.Zero(), this._rotationQuaternion = null, this._scaling = Lc.One(), this._transformToBoneReferal = null, this._isAbsoluteSynced = !1, this._billboardMode = e.BILLBOARDMODE_NONE, this._preserveParentRotationForBillboard = !1, this.scalingDeterminant = 1, this._infiniteDistance = !1, this.ignoreNonUniformScaling = !1, this.reIntegrateRotationIntoRotationQuaternion = !1, this._poseMatrix = null, this._localMatrix = Hc.Zero(), this._usePivotMatrix = !1, this._absolutePosition = Lc.Zero(), this._absoluteScaling = Lc.Zero(), this._absoluteRotationQuaternion = Gc.Identity(), this._pivotMatrix = Hc.Identity(), this._postMultiplyPivotMatrix = !1, this._isWorldMatrixFrozen = !1, this._indexInSceneTransformNodesArray = -1, this.onAfterWorldMatrixUpdateObservable = new kc, this._nonUniformScaling = !1, s && this.getScene().addTransformNode(this)
			}
			lookAt(t, i = 0, s = 0, n = 0, a = 0) {
				const r = e._LookAtVectorCache,
					o = 0 === a ? this.position : this.getAbsolutePosition();
				if (t.subtractToRef(o, r), this.setDirection(r, i, s, n), 1 === a && this.parent)
					if (this.rotationQuaternion) {
						const e = Vc.Matrix[0];
						this.rotationQuaternion.toRotationMatrix(e);
						const t = Vc.Matrix[1];
						this.parent.getWorldMatrix().getRotationMatrixToRef(t), t.invert(), e.multiplyToRef(t, e), this.rotationQuaternion.fromRotationMatrix(e)
					} else {
						const e = Vc.uk[0];
						Gc.FromEulerVectorToRef(this.rotation, e);
						const t = Vc.Matrix[0];
						e.toRotationMatrix(t);
						const i = Vc.Matrix[1];
						this.parent.getWorldMatrix().getRotationMatrixToRef(i), i.invert(), t.multiplyToRef(i, t), e.fromRotationMatrix(t), e.toEulerAnglesToRef(this.rotation)
					} return this
			}
			getAbsolutePivotPoint() {
				const e = Lc.Zero();
				return this.getAbsolutePivotPointToRef(e), e
			}
			detachFromBone(e = !1) {
				return this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, this.parent = e ? this._currentParentWhenAttachingToBone : null, this) : (e && (this.parent = this._currentParentWhenAttachingToBone), this)
			}
			getDirectionToRef(e, t) {
				return Lc.TransformNormalToRef(e, this.getWorldMatrix(), t), this
			}
			static Parse(t, i, s) {
				const n = Xc.Parse((() => new e(t.name, i)), t, i, s);
				if (t.localMatrix ? n.setPreTransformMatrix(Hc.FromArray(t.localMatrix)) : t.pivotMatrix && n.setPivotMatrix(Hc.FromArray(t.pivotMatrix)), n.setEnabled(t.isEnabled), n._waitingParsedUniqueId = t.ik, void 0 !== t.parentId && (n._waitingParentId = t.parentId), void 0 !== t.parentInstanceIndex && (n._waitingParentInstanceIndex = t.parentInstanceIndex), t.animations) {
					for (let e = 0; e < t.animations.length; e++) {
						const i = t.animations[e],
							s = uc("BABYLON.Animation");
						s && n.animations.push(s.Parse(i))
					}
					jc.ParseAnimationRanges(n, t, i)
				}
				return t.autoAnimate && i.beginAnimation(n, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), n
			}
			get forward() {
				return Lc.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward), this._forward.normalize()
			}
			getPivotMatrix() {
				return this._pivotMatrix
			}
			get billboardMode() {
				return this._billboardMode
			}
			resetLocalMatrix(e = !0) {
				if (this.computeWorldMatrix(), e) {
					const e = this.getChildren();
					for (let t = 0; t < e.length; ++t) {
						const i = e[t];
						if (i) {
							i.computeWorldMatrix();
							const e = Vc.Matrix[0];
							i._localMatrix.multiplyToRef(this._localMatrix, e);
							const t = Vc.uk[0];
							e.decompose(i.scaling, t, i.position), i.rotationQuaternion ? i.rotationQuaternion.copyFrom(t) : t.toEulerAnglesToRef(i.rotation)
						}
					}
				}
				this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = Gc.Identity()), this._worldMatrix = Hc.Identity()
			}
			addRotation(e, t, i) {
				let s;
				this.rotationQuaternion ? s = this.rotationQuaternion : (s = Vc.uk[1], Gc.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, s));
				const n = Vc.uk[0];
				return Gc.RotationYawPitchRollToRef(t, e, i, n), s.multiplyInPlace(n), this.rotationQuaternion || s.toEulerAnglesToRef(this.rotation), this
			}
			unfreezeWorldMatrix() {
				return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this
			}
			setParent(t, i = !1, s = !1) {
				if (!t && !this.parent) return this;
				const n = Vc.uk[0],
					a = Vc.Vector3[0],
					r = Vc.Vector3[1],
					o = Vc.Matrix[1];
				Hc.IdentityToRef(o);
				const l = Vc.Matrix[0];
				this.computeWorldMatrix(!0);
				let h = this.rotationQuaternion;
				return h || (h = e._TmpRotation, Gc.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, h)), Hc.ComposeToRef(this.scaling, h, this.position, l), this.parent && l.multiplyToRef(this.parent.computeWorldMatrix(!0), l), t && (t.computeWorldMatrix(!0).invertToRef(o), l.multiplyToRef(o, l)), l.decompose(r, n, a, i ? this : void 0), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(n) : n.toEulerAnglesToRef(this.rotation), this.scaling.copyFrom(r), this.position.copyFrom(a), this.parent = t, s && this.setPivotMatrix(Hc.Identity()), this
			}
			_getEffectiveParent() {
				return this.parent
			}
			freezeWorldMatrix(e = null, t = !1) {
				return e ? t ? (this._rotation.setAll(0), this._rotationQuaternion = this._rotationQuaternion || Gc.Identity(), e.decompose(this._scaling, this._rotationQuaternion, this._position), this.computeWorldMatrix(!0)) : (this._worldMatrix = e, this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)), this._isDirty = !1, this._isWorldMatrixFrozen = !0, this
			}
			dispose(e, t = !1) {
				if (this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this._parentContainer) {
					const e = this._parentContainer.transformNodes.indexOf(this);
					e > -1 && this._parentContainer.transformNodes.splice(e, 1), this._parentContainer = null
				}
				if (this.onAfterWorldMatrixUpdateObservable.clear(), e) {
					const e = this.getChildTransformNodes(!0);
					for (const t of e) t.parent = null, t.computeWorldMatrix(!0)
				}
				super.dispose(e, t)
			}
			updatePoseMatrix(e) {
				return this._poseMatrix ? (this._poseMatrix.copyFrom(e), this) : (this._poseMatrix = e.clone(), this)
			}
			set infiniteDistance(e) {
				this._infiniteDistance !== e && (this._infiniteDistance = e)
			}
			normalizeToUnitCube(e = !0, t = !1, i) {
				let s = null,
					n = null;
				t && (this.rotationQuaternion ? (n = this.rotationQuaternion.clone(), this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (s = this.rotation.clone(), this.rotation.copyFromFloats(0, 0, 0)));
				const a = this.getHierarchyBoundingVectors(e, i),
					r = a.max.subtract(a.min),
					o = Math.max(r.x, r.y, r.z);
				if (0 === o) return this;
				const l = 1 / o;
				return this.scaling.scaleInPlace(l), t && (this.rotationQuaternion && n ? this.rotationQuaternion.copyFrom(n) : this.rotation && s && this.rotation.copyFrom(s)), this
			}
			getClassName() {
				return "TransformNode"
			}
			addChild(e, t = !1) {
				return e.setParent(this, t), this
			}
			setDirection(e, t = 0, i = 0, s = 0) {
				const n = -Math.atan2(e.z, e.x) + Math.PI / 2,
					a = Math.sqrt(e.x * e.x + e.z * e.z),
					r = -Math.atan2(e.y, a);
				return this.rotationQuaternion ? Gc.RotationYawPitchRollToRef(n + t, r + i, s, this.rotationQuaternion) : (this.rotation.x = r + i, this.rotation.y = n + t, this.rotation.z = s), this
			}
			get up() {
				return Lc.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up), this._up.normalize()
			}
			_computeUseBillboardPath() {
				this._cache.useBillboardPath = this._billboardMode !== e.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard
			}
			setPositionWithLocalVector(e) {
				return this.computeWorldMatrix(), this.position = Lc.TransformNormal(e, this._localMatrix), this
			}
			attachToBone(e, t) {
				return this._currentParentWhenAttachingToBone = this.parent, this._transformToBoneReferal = t, this.parent = e, e.getSkeleton().prepare(!0), e.getFinalMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this
			}
			getAbsolutePivotPointToRef(e) {
				return this.getPivotPointToRef(e), Lc.TransformCoordinatesToRef(e, this.getWorldMatrix(), e), this
			}
			getPivotPointToRef(e) {
				return e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14], this
			}
			getAbsolutePosition() {
				return this.computeWorldMatrix(), this._absolutePosition
			}
			isUsingPivotMatrix() {
				return this._usePivotMatrix
			}
			_afterComputeWorldMatrix() {}
			getPivotPoint() {
				const e = Lc.Zero();
				return this.getPivotPointToRef(e), e
			}
			setPreTransformMatrix(e) {
				return this.setPivotMatrix(e, !1)
			}
			clone(t, i, s) {
				const n = Xc.Clone((() => new e(t, this.getScene())), this);
				if (n.name = t, n.id = t, i && (n.parent = i), !s) {
					const e = this.getDescendants(!0);
					for (let i = 0; i < e.length; i++) {
						const s = e[i];
						s.clone && s.clone(t + "." + s.name, n)
					}
				}
				return n
			}
			serialize(e) {
				const t = Xc.Serialize(this, e);
				return t.type = this.getClassName(), t.ik = this.ik, this.parent && this.parent._serializeAsParent(t), t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(), Xc.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t
			}
			_isSynchronized() {
				const t = this._cache;
				return this._billboardMode === t.billboardMode && this._billboardMode === e.BILLBOARDMODE_NONE && (!t.pivotMatrixUpdated && (!this._infiniteDistance && (!this._position._isDirty && (!this._scaling._isDirty && !(this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty)))))
			}
			get rotationQuaternion() {
				return this._rotationQuaternion
			}
			get position() {
				return this._position
			}
			get absoluteRotationQuaternion() {
				return this._syncAbsoluteScalingAndRotation(), this._absoluteRotationQuaternion
			}
			get absoluteScaling() {
				return this._syncAbsoluteScalingAndRotation(), this._absoluteScaling
			}
			get rotation() {
				return this._rotation
			}
			isUsingPostMultiplyPivotMatrix() {
				return this._postMultiplyPivotMatrix
			}
			setPivotMatrix(e, t = !0) {
				return this._pivotMatrix.copyFrom(e), this._usePivotMatrix = !this._pivotMatrix.isIdentity(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = t, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = Hc.Invert(this._pivotMatrix)), this
			}
			isWorldMatrixCameraDependent() {
				return this._infiniteDistance && !this.parent || this._billboardMode !== e.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard
			}
			rotate(t, i, s) {
				let n;
				if (t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(), this.rotation.setAll(0)), s && 0 !== s) {
					if (this.parent) {
						const e = this.parent.getWorldMatrix(),
							s = Vc.Matrix[0];
						e.invertToRef(s), t = Lc.TransformNormal(t, s), e.determinant() < 0 && (i *= -1)
					}
					n = Gc.RotationAxisToRef(t, i, e._RotationAxisCache), n.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion)
				} else n = Gc.RotationAxisToRef(t, i, e._RotationAxisCache), this.rotationQuaternion.multiplyToRef(n, this.rotationQuaternion);
				return this
			}
			locallyTranslate(e) {
				return this.computeWorldMatrix(!0), this.position = Lc.TransformCoordinates(e, this._localMatrix), this
			}
			getPositionInCameraSpace(e = null) {
				return e || (e = this.getScene().activeCamera), Lc.TransformCoordinates(this.getAbsolutePosition(), e.getViewMatrix())
			}
			set preserveParentRotationForBillboard(e) {
				e !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = e, this._computeUseBillboardPath())
			}
			get preserveParentRotationForBillboard() {
				return this._preserveParentRotationForBillboard
			}
			_syncAbsoluteScalingAndRotation() {
				this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion), this._isAbsoluteSynced = !0)
			}
			setPivotPoint(e, t = 0) {
				0 == this.getScene().getRenderId() && this.computeWorldMatrix(!0);
				const i = this.getWorldMatrix();
				if (1 == t) {
					const t = Vc.Matrix[0];
					i.invertToRef(t), e = Lc.TransformCoordinates(e, t)
				}
				return this.setPivotMatrix(Hc.Translation(-e.x, -e.y, -e.z), !0)
			}
			getChildTransformNodes(t, i) {
				const s = [];
				return this._getDescendants(s, t, (t => (!i || i(t)) && t instanceof e)), s
			}
			instantiateHierarchy(e = null, t, i) {
				const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0);
				s && i && i(this, s);
				for (const e of this.getChildTransformNodes(!0)) e.instantiateHierarchy(s, t, i);
				return s
			}
			get nonUniformScaling() {
				return this._nonUniformScaling
			}
			registerAfterWorldMatrixUpdate(e) {
				return this.onAfterWorldMatrixUpdateObservable.add(e), this
			}
			getPoseMatrix() {
				return this._poseMatrix || (this._poseMatrix = Hc.Identity()), this._poseMatrix
			}
			_initCache() {
				super._initCache();
				const e = this._cache;
				e.localMatrixUpdated = !1, e.billboardMode = -1, e.infiniteDistance = !1, e.useBillboardPosition = !1, e.useBillboardPath = !1
			}
			translate(e, t, i) {
				const s = e.scale(t);
				if (i && 0 !== i) this.setAbsolutePosition(this.getAbsolutePosition().add(s));
				else {
					const e = this.getPositionExpressedInLocalSpace().add(s);
					this.setPositionWithLocalVector(e)
				}
				return this
			}
			get infiniteDistance() {
				return this._infiniteDistance
			}
			getDistanceToCamera(e = null) {
				return e || (e = this.getScene().activeCamera), this.getAbsolutePosition().subtract(e.globalPosition).length()
			}
			removeChild(e, t = !1) {
				return e.setParent(null, t), this
			}
			set rotation(e) {
				this._rotation = e, this._rotationQuaternion = null, this._isDirty = !0
			}
			computeWorldMatrix(t = !1, i = null) {
				if (this._isWorldMatrixFrozen && !this._isDirty) return this._worldMatrix;
				const s = this.getScene().getRenderId();
				if (!this._isDirty && !t && (this._currentRenderId === s || this.isSynchronized())) return this._currentRenderId = s, this._worldMatrix;
				i = i || this.getScene().activeCamera, this._updateCache();
				const n = this._cache;
				n.pivotMatrixUpdated = !1, n.billboardMode = this.billboardMode, n.infiniteDistance = this.infiniteDistance, n.parent = this._parentNode, this._currentRenderId = s, this._childUpdateId += 1, this._isDirty = !1, this._position._isDirty = !1, this._rotation._isDirty = !1, this._scaling._isDirty = !1;
				const a = this._getEffectiveParent(),
					r = e._TmpScaling;
				let o, l = this._position;
				if (this._infiniteDistance && !this.parent && i) {
					const t = i.getWorldMatrix(),
						s = new Lc(t.m[12], t.m[13], t.m[14]);
					l = e._TmpTranslation, l.copyFromFloats(this._position.x + s.x, this._position.y + s.y, this._position.z + s.z)
				}
				if (r.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant), this._rotationQuaternion) {
					if (this._rotationQuaternion._isDirty = !1, o = this._rotationQuaternion, this.reIntegrateRotationIntoRotationQuaternion) {
						this.rotation.lengthSquared() && (this._rotationQuaternion.multiplyInPlace(Gc.Jk(this._rotation.y, this._rotation.x, this._rotation.z)), this._rotation.copyFromFloats(0, 0, 0))
					}
				} else o = e._TmpRotation, Gc.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, o);
				if (this._usePivotMatrix) {
					const e = Vc.Matrix[1];
					Hc.ScalingToRef(r.x, r.y, r.z, e);
					const t = Vc.Matrix[0];
					o.toRotationMatrix(t), this._pivotMatrix.multiplyToRef(e, Vc.Matrix[4]), Vc.Matrix[4].multiplyToRef(t, this._localMatrix), this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix), this._localMatrix.addTranslationFromFloats(l.x, l.y, l.z)
				} else Hc.ComposeToRef(r, o, l, this._localMatrix);
				if (a && a.getWorldMatrix) {
					if (t && a.computeWorldMatrix(t), n.useBillboardPath) {
						if (this._transformToBoneReferal) {
							const e = this.parent;
							e.getSkeleton().prepare(), e.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), Vc.Matrix[7])
						} else Vc.Matrix[7].copyFrom(a.getWorldMatrix());
						const t = Vc.Vector3[5],
							i = Vc.Vector3[6],
							s = Vc.uk[0];
						Vc.Matrix[7].decompose(i, s, t), Hc.ScalingToRef(i.x, i.y, i.z, Vc.Matrix[7]), Vc.Matrix[7].setTranslation(t), e.BillboardUseParentOrientation && (this._position.applyRotationQuaternionToRef(s, t), this._localMatrix.setTranslation(t)), this._localMatrix.multiplyToRef(Vc.Matrix[7], this._worldMatrix)
					} else if (this._transformToBoneReferal) {
						const e = this.parent;
						e.getSkeleton().prepare(), this._localMatrix.multiplyToRef(e.getFinalMatrix(), Vc.Matrix[6]), Vc.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)
					} else this._localMatrix.multiplyToRef(a.getWorldMatrix(), this._worldMatrix);
					this._markSyncedWithParent()
				} else this._worldMatrix.copyFrom(this._localMatrix);
				if (n.useBillboardPath && i && this.billboardMode && !n.useBillboardPosition) {
					const t = Vc.Vector3[0];
					if (this._worldMatrix.getTranslationToRef(t), Vc.Matrix[1].copyFrom(i.getViewMatrix()), this._scene.useRightHandedSystem && Vc.Matrix[1].multiplyToRef($c, Vc.Matrix[1]), Vc.Matrix[1].setTranslationFromFloats(0, 0, 0), Vc.Matrix[1].invertToRef(Vc.Matrix[0]), (this.billboardMode & e.BILLBOARDMODE_ALL) !== e.BILLBOARDMODE_ALL) {
						Vc.Matrix[0].decompose(void 0, Vc.uk[0], void 0);
						const t = Vc.Vector3[1];
						Vc.uk[0].toEulerAnglesToRef(t), (this.billboardMode & e.BILLBOARDMODE_X) !== e.BILLBOARDMODE_X && (t.x = 0), (this.billboardMode & e.BILLBOARDMODE_Y) !== e.BILLBOARDMODE_Y && (t.y = 0), (this.billboardMode & e.BILLBOARDMODE_Z) !== e.BILLBOARDMODE_Z && (t.z = 0), Hc.RotationYawPitchRollToRef(t.y, t.x, t.z, Vc.Matrix[0])
					}
					this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(Vc.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(Vc.Vector3[0])
				} else if (n.useBillboardPath && i && n.useBillboardPosition) {
					const t = Vc.Vector3[0];
					this._worldMatrix.getTranslationToRef(t);
					const s = i.globalPosition;
					this._worldMatrix.invertToRef(Vc.Matrix[1]);
					const n = Vc.Vector3[1];
					Lc.TransformCoordinatesToRef(s, Vc.Matrix[1], n), n.normalize();
					const a = -Math.atan2(n.z, n.x) + Math.PI / 2,
						r = Math.sqrt(n.x * n.x + n.z * n.z),
						o = -Math.atan2(n.y, r);
					if (Gc.RotationYawPitchRollToRef(a, o, 0, Vc.uk[0]), (this.billboardMode & e.BILLBOARDMODE_ALL) !== e.BILLBOARDMODE_ALL) {
						const t = Vc.Vector3[1];
						Vc.uk[0].toEulerAnglesToRef(t), (this.billboardMode & e.BILLBOARDMODE_X) !== e.BILLBOARDMODE_X && (t.x = 0), (this.billboardMode & e.BILLBOARDMODE_Y) !== e.BILLBOARDMODE_Y && (t.y = 0), (this.billboardMode & e.BILLBOARDMODE_Z) !== e.BILLBOARDMODE_Z && (t.z = 0), Hc.RotationYawPitchRollToRef(t.y, t.x, t.z, Vc.Matrix[0])
					} else Hc.FromQuaternionToRef(Vc.uk[0], Vc.Matrix[0]);
					this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(Vc.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(Vc.Vector3[0])
				}
				return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : a && a._nonUniformScaling ? this._updateNonUniformScalingState(a._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._isAbsoluteSynced = !1, this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = Hc.Invert(this._worldMatrix)), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix
			}
			set position(e) {
				this._position = e, this._isDirty = !0
			}
			setAbsolutePosition(e) {
				if (!e) return this;
				let t, i, s;
				if (void 0 === e.x) {
					if (arguments.length < 3) return this;
					t = arguments[0], i = arguments[1], s = arguments[2]
				} else t = e.x, i = e.y, s = e.z;
				if (this.parent) {
					const e = Vc.Matrix[0];
					this.parent.getWorldMatrix().invertToRef(e), Lc.TransformCoordinatesFromFloatsToRef(t, i, s, e, this.position)
				} else this.position.x = t, this.position.y = i, this.position.z = s;
				return this._absolutePosition.copyFrom(e), this
			}
			unregisterAfterWorldMatrixUpdate(e) {
				return this.onAfterWorldMatrixUpdateObservable.removeCallback(e), this
			}
			set rotationQuaternion(e) {
				this._rotationQuaternion = e, e && this._rotation.setAll(0), this._isDirty = !0
			}
			get scaling() {
				return this._scaling
			}
			getPositionExpressedInLocalSpace() {
				this.computeWorldMatrix();
				const e = Vc.Matrix[0];
				return this._localMatrix.invertToRef(e), Lc.TransformNormal(this.position, e)
			}
			get isWorldMatrixFrozen() {
				return this._isWorldMatrixFrozen
			}
			get right() {
				return Lc.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right), this._right.normalize()
			}
			rotateAround(e, t, i) {
				t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = Gc.Jk(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.setAll(0));
				const s = Vc.Vector3[0],
					n = Vc.Vector3[1],
					a = Vc.Vector3[2],
					r = Vc.uk[0],
					o = Vc.Matrix[0],
					l = Vc.Matrix[1],
					h = Vc.Matrix[2],
					c = Vc.Matrix[3];
				return e.subtractToRef(this.position, s), Hc.TranslationToRef(s.x, s.y, s.z, o), Hc.TranslationToRef(-s.x, -s.y, -s.z, l), Hc.RotationAxisToRef(t, i, h), l.multiplyToRef(h, c), c.multiplyToRef(o, c), c.decompose(n, r, a), this.position.addInPlace(a), r.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this
			}
			set scaling(e) {
				this._scaling = e, this._isDirty = !0
			}
			set billboardMode(t) {
				this._billboardMode !== t && (this._billboardMode = t, this._cache.useBillboardPosition = !!(this._billboardMode & e.BILLBOARDMODE_USE_POSITION), this._computeUseBillboardPath())
			}
			get absolutePosition() {
				return this.getAbsolutePosition()
			}
			getDirection(e) {
				const t = Lc.Zero();
				return this.getDirectionToRef(e, t), t
			}
			_updateNonUniformScalingState(e) {
				return this._nonUniformScaling !== e && (this._nonUniformScaling = e, !0)
			}
		};
	Jc.BILLBOARDMODE_NONE = 0, Jc.BILLBOARDMODE_X = 1, Jc.BILLBOARDMODE_Y = 2, Jc.BILLBOARDMODE_Z = 4, Jc.BILLBOARDMODE_ALL = 7, Jc.BILLBOARDMODE_USE_POSITION = 128, Jc.BillboardUseParentOrientation = !1, Jc._TmpRotation = Gc.Zero(), Jc._TmpScaling = Lc.Zero(), Jc._TmpTranslation = Lc.Zero(), Jc._LookAtVectorCache = new Lc(0, 0, 0), Jc._RotationAxisCache = new Gc, Gh([Jh("position")], Jc.prototype, "_position", void 0), Gh([Jh("rotation")], Jc.prototype, "_rotation", void 0), Gh([(Kc = "rotationQuaternion", Wh(10, Kc))], Jc.prototype, "_rotationQuaternion", void 0), Gh([Jh("scaling")], Jc.prototype, "_scaling", void 0), Gh([Xh("billboardMode")], Jc.prototype, "_billboardMode", void 0), Gh([Xh()], Jc.prototype, "scalingDeterminant", void 0), Gh([Xh("infiniteDistance")], Jc.prototype, "_infiniteDistance", void 0), Gh([Xh()], Jc.prototype, "ignoreNonUniformScaling", void 0), Gh([Xh()], Jc.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
	var qc = class e {
		constructor() {
			this.references = 0, this.Yk = 0, this.is32Bits = !1, this.ik = e._Counter++
		}
		get underlyingResource() {
			return null
		}
	};
	qc._Counter = 0;
	var Qc = class e {
		static ClearLogCache() {
			e._LogCache = "", e._LogLimitOutputs = {}, e.errorsCount = 0
		}
		static _AddLogEntry(t) {
			e._LogCache = t + e._LogCache, e.OnNewCacheEntry && e.OnNewCacheEntry(t)
		}
		static set LogLevels(t) {
			e.Log = e._LogDisabled, e.Warn = e._LogDisabled, e.Error = e._LogDisabled, [e.MessageLogLevel, e.WarningLogLevel, e.ErrorLogLevel].forEach((i => {
				if ((t & i) === i) {
					const t = this._Levels[i];
					e[t.name] = e._LogEnabled.bind(e, i)
				}
			}))
		}
		static _FormatMessage(e) {
			const t = e => e < 10 ? "0" + e : "" + e,
				i = new Date;
			return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e
		}
		static _LogEnabled(t = 1, i, s) {
			const n = Array.isArray(i) ? i[0] : i;
			if (void 0 !== s && !e._CheckLimit(n, s)) return;
			const a = e._FormatMessage(n),
				r = this._Levels[t],
				o = Array.isArray(i) ? i.slice(1) : [];
			r.logFunc && r.logFunc("BJS - " + a, ...o);
			const l = `<div style='color:${r.color}'>${a}</div><br>`;
			e._AddLogEntry(l), e._GenerateLimitMessage(n, t)
		}
		static _CheckLimit(t, i) {
			let s = e._LogLimitOutputs[t];
			return s ? s.current++ : (s = {
				limit: i,
				current: 1
			}, e._LogLimitOutputs[t] = s), s.current <= s.limit
		}
		static _GenerateLimitMessage(t, i = 1) {
			const s = e._LogLimitOutputs[t];
			if (!s || !e.MessageLimitReached) return;
			const n = this._Levels[i];
			s.current === s.limit && e[n.name](e.MessageLimitReached.replace(/%LIMIT%/g, "" + s.limit).replace(/%TYPE%/g, n.name ?? ""))
		}
		static get LogCache() {
			return e._LogCache
		}
		static _LogDisabled(e, t) {}
	};
	Qc.NoneLogLevel = 0, Qc.MessageLogLevel = 1, Qc.WarningLogLevel = 2, Qc.ErrorLogLevel = 4, Qc.AllLogLevel = 7, Qc.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.", Qc._LogCache = "", Qc._LogLimitOutputs = {}, Qc._Levels = [{}, {
		color: "white",
		logFunc: console.log,
		name: "Log"
	}, {
		color: "orange",
		logFunc: console.warn,
		name: "Warn"
	}, {}, {
		color: "red",
		logFunc: console.error,
		name: "Error"
	}], Qc.errorsCount = 0, Qc.Log = Qc._LogEnabled.bind(Qc, Qc.MessageLogLevel), Qc.Warn = Qc._LogEnabled.bind(Qc, Qc.WarningLogLevel), Qc.Error = Qc._LogEnabled.bind(Qc, Qc.ErrorLogLevel);
	var Zc = class {
			updateDirectly(e, t, i, s = !1) {
				this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, s ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0), this._data = 0 === t && void 0 === i ? e : null)
			}
			getBuffer() {
				return this._buffer
			}
			get isDisposed() {
				return this._isDisposed
			}
			isUpdatable() {
				return this._updatable
			}
			constructor(e, t, i, s = 0, n = !1, a = !1, r = !1, o, l) {
				this._isAlreadyOwned = !1, this._isDisposed = !1, e && e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = i, this._instanced = a, this._divisor = o || 1, this._label = l, t instanceof qc ? (this._data = null, this._buffer = t) : (this._data = t, this._buffer = null), this.byteStride = r ? s : s * Float32Array.BYTES_PER_ELEMENT, n || this.create()
			}
			dispose() {
				this._buffer && this._engine._releaseBuffer(this._buffer) && (this._isDisposed = !0, this._data = null, this._buffer = null)
			}
			createVertexBuffer(e, t, i, s, n, a = !1, r) {
				const o = a ? t : t * Float32Array.BYTES_PER_ELEMENT,
					l = s ? a ? s : s * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
				return new eu(this._engine, this, e, this._updatable, !0, l, void 0 === n ? this._instanced : n, o, i, void 0, void 0, !0, this._divisor || r)
			}
			getStrideSize() {
				return this.byteStride / Float32Array.BYTES_PER_ELEMENT
			}
			update(e) {
				this.create(e)
			}
			_increaseReferences() {
				this._buffer && (this._isAlreadyOwned ? this._buffer.references++ : this._isAlreadyOwned = !0)
			}
			getData() {
				return this._data
			}
			_rebuild() {
				if (this._data) this._buffer = null, this.create(this._data);
				else {
					if (!this._buffer) return;
					if (this._buffer.Yk > 0) return void(this._updatable ? this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.Yk, this._label) : this._buffer = this._engine.createVertexBuffer(this._buffer.Yk, void 0, this._label));
					Qc.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.ik+")":""}. Buffer reconstruction failed.`), this._buffer = null
				}
			}
			create(e = null) {
				!e && this._buffer || (e = e || this._data) && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e, this._label), this._data = e) : this._buffer = this._engine.createVertexBuffer(e, void 0, this._label))
			}
		},
		eu = class e {
			getFloatData(t, i) {
				const s = this.getData();
				return s ? e.GetFloatData(s, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, t, i) : null
			}
			updateDirectly(e, t, i = !1) {
				this._buffer.updateDirectly(e, t, void 0, i), this._alignBuffer()
			}
			getSize(t = !1) {
				return t ? this._size * e.GetTypeByteLength(this.type) : this._size
			}
			create(e) {
				this._buffer.create(e), this._alignBuffer()
			}
			isUpdatable() {
				return this._buffer.isUpdatable()
			}
			set instanceDivisor(e) {
				const t = 0 != e;
				this._instanceDivisor = e, t !== this._instanced && (this._instanced = t, this._computeHashCode())
			}
			get _maxVerticesCount() {
				const e = this.getData();
				return e ? Array.isArray(e) ? e.length / (this.byteStride / 4) - this.byteOffset / 4 : (e.byteLength - this.byteOffset) / this.byteStride : 0
			}
			getWrapperBuffer() {
				return this._buffer
			}
			getBuffer() {
				return this._buffer.getBuffer()
			}
			getKind() {
				return this._kind
			}
			get isDisposed() {
				return this._isDisposed
			}
			forEach(t, i) {
				e.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, t, this.normalized, i)
			}
			getIsInstanced() {
				return this._instanced
			}
			static ForEach(t, i, s, n, a, r, o, l) {
				if (t instanceof Array) {
					let e = i / 4;
					const a = s / 4;
					for (let i = 0; i < r; i += n) {
						for (let s = 0; s < n; s++) l(t[e + s], i + s);
						e += a
					}
				} else {
					const h = t instanceof ArrayBuffer ? new DataView(t) : new DataView(t.buffer, t.byteOffset, t.byteLength),
						c = e.GetTypeByteLength(a);
					for (let t = 0; t < r; t += n) {
						let r = i;
						for (let i = 0; i < n; i++) {
							l(e._GetFloatValue(h, a, r, o), t + i), r += c
						}
						i += s
					}
				}
			}
			getData() {
				return this._buffer.getData()
			}
			get instanceDivisor() {
				return this._instanceDivisor
			}
			update(e) {
				this._buffer.update(e), this._alignBuffer()
			}
			static DeduceStride(t) {
				switch (t) {
					case e.UVKind:
					case e.UV2Kind:
					case e.UV3Kind:
					case e.UV4Kind:
					case e.UV5Kind:
					case e.UV6Kind:
						return 2;
					case e.NormalKind:
					case e.PositionKind:
						return 3;
					case e.ColorKind:
					case e.ColorInstanceKind:
					case e.MatricesIndicesKind:
					case e.MatricesIndicesExtraKind:
					case e.MatricesWeightsKind:
					case e.MatricesWeightsExtraKind:
					case e.TangentKind:
						return 4;
					default:
						throw new Error("Invalid kind '" + t + "'")
				}
			}
			getStrideSize() {
				return this.byteStride / e.GetTypeByteLength(this.type)
			}
			constructor(t, i, s, n, a, r, o, l, h, c, u = !1, m = !1, d = 1, f = !1) {
				this._isDisposed = !1;
				let p = !1;
				if (this.engine = t, "object" == typeof n && null !== n ? (p = n.updatable ?? !1, a = n.postponeInternalCreation, r = n.stride, o = n.instanced, l = n.offset, h = n.size, c = n.type, u = n.normalized ?? !1, m = n.useBytes ?? !1, d = n.divisor ?? 1, f = n.takeBufferOwnership ?? !1, this._label = n.label) : p = !!n, i instanceof Zc ? (this._buffer = i, this._ownsBuffer = f) : (this._buffer = new Zc(t, i, p, r, a, o, m, d, this._label), this._ownsBuffer = !0), this.ik = e._Counter++, this._kind = s, void 0 === c) {
					const t = this.getData();
					this.type = t ? e.GetDataType(t) : e.FLOAT
				} else this.type = c;
				const _ = e.GetTypeByteLength(this.type);
				m ? (this._size = h || (r ? r / _ : e.DeduceStride(s)), this.byteStride = r || this._buffer.byteStride || this._size * _, this.byteOffset = l || 0) : (this._size = h || r || e.DeduceStride(s), this.byteStride = r ? r * _ : this._buffer.byteStride || this._size * _, this.byteOffset = (l || 0) * _), this.normalized = u, this._instanced = void 0 !== o && o, this._instanceDivisor = o ? d : 0, this._alignBuffer(), this._computeHashCode()
			}
			static GetDataType(t) {
				return t instanceof Int8Array ? e.BYTE : t instanceof Uint8Array ? e.UNSIGNED_BYTE : t instanceof Int16Array ? e.SHORT : t instanceof Uint16Array ? e.UNSIGNED_SHORT : t instanceof Int32Array ? e.INT : t instanceof Uint32Array ? e.UNSIGNED_INT : e.FLOAT
			}
			_alignBuffer() {}
			getInstanceDivisor() {
				return this._instanceDivisor
			}
			getOffset() {
				return this.byteOffset / e.GetTypeByteLength(this.type)
			}
			static GetFloatData(t, i, s, n, a, r, o, l) {
				const h = i * e.GetTypeByteLength(s),
					c = o * i;
				if (s !== e.FLOAT || a !== h) {
					const o = new Float32Array(c);
					return e.ForEach(t, n, a, i, s, c, r, ((e, t) => o[t] = e)), o
				}
				if (!(t instanceof Array || t instanceof Float32Array) || 0 !== n || t.length !== c) {
					if (t instanceof Array) {
						const e = n / 4;
						return t.slice(e, e + c)
					}
					if (t instanceof ArrayBuffer) return new Float32Array(t, n, c);
					{
						const e = t.byteOffset + n;
						if (3 & e && (Qc.Warn("Float array must be aligned to 4-bytes border"), l = !0), l) {
							const i = new Uint8Array(c * Float32Array.BYTES_PER_ELEMENT),
								s = new Uint8Array(t.buffer, e, i.length);
							return i.set(s), new Float32Array(i.buffer)
						}
						return new Float32Array(t.buffer, e, c)
					}
				}
				return l ? t.slice() : t
			}
			static GetTypeByteLength(t) {
				switch (t) {
					case e.BYTE:
					case e.UNSIGNED_BYTE:
						return 1;
					case e.SHORT:
					case e.UNSIGNED_SHORT:
						return 2;
					case e.INT:
					case e.UNSIGNED_INT:
					case e.FLOAT:
						return 4;
					default:
						throw new Error(`Invalid type '${t}'`)
				}
			}
			_rebuild() {
				this._buffer?._rebuild()
			}
			dispose() {
				this._ownsBuffer && this._buffer.dispose(), this._isDisposed = !0
			}
			static _GetFloatValue(t, i, s, n) {
				switch (i) {
					case e.BYTE: {
						let e = t.getInt8(s);
						return n && (e = Math.max(e / 127, -1)), e
					}
					case e.UNSIGNED_BYTE: {
						let e = t.getUint8(s);
						return n && (e /= 255), e
					}
					case e.SHORT: {
						let e = t.getInt16(s, !0);
						return n && (e = Math.max(e / 32767, -1)), e
					}
					case e.UNSIGNED_SHORT: {
						let e = t.getUint16(s, !0);
						return n && (e /= 65535), e
					}
					case e.INT:
						return t.getInt32(s, !0);
					case e.UNSIGNED_INT:
						return t.getUint32(s, !0);
					case e.FLOAT:
						return t.getFloat32(s, !0);
					default:
						throw new Error(`Invalid component type ${i}`)
				}
			}
			_computeHashCode() {
				this.hashCode = (this.type - 5120 | 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12)
			}
		};

	function tu(e, t, i) {
		try {
			const s = e.next();
			s.done ? t(s) : s.value ? s.value.then((() => {
				s.value = void 0, t(s)
			}), i) : t(s)
		} catch (e) {
			i(e)
		}
	}

	function iu(e, t, i, s, n) {
		const a = () => {
			let r;
			const o = e => {
				e.done ? i(e.value) : void 0 === r ? r = !0 : a()
			};
			do {
				r = void 0, n && n.aborted ? s(new Error("Aborted")) : t(e, o, s), void 0 === r && (r = !1)
			} while (r)
		};
		a()
	}

	function su(e, t) {
		let i;
		return iu(e, tu, (e => i = e), (e => {
			throw e
		}), t), i
	}
	eu._Counter = 0, eu.BYTE = 5120, eu.UNSIGNED_BYTE = 5121, eu.SHORT = 5122, eu.UNSIGNED_SHORT = 5123, eu.INT = 5124, eu.UNSIGNED_INT = 5125, eu.FLOAT = 5126, eu.PositionKind = "position", eu.NormalKind = "normal", eu.TangentKind = "tangent", eu.UVKind = "uv", eu.UV2Kind = "uv2", eu.UV3Kind = "uv3", eu.UV4Kind = "uv4", eu.UV5Kind = "uv5", eu.UV6Kind = "uv6", eu.ColorKind = "color", eu.ColorInstanceKind = "instanceColor", eu.MatricesIndicesKind = "matricesIndices", eu.MatricesWeightsKind = "matricesWeights", eu.MatricesIndicesExtraKind = "matricesIndicesExtra", eu.MatricesWeightsExtraKind = "matricesWeightsExtra";
	var nu = class extends Error {};
	nu._setPrototypeOf = Object.setPrototypeOf || ((e, t) => (e.__proto__ = t, e));
	var au = 0,
		ru = 2e3,
		ou = 3e3,
		lu = 4e3,
		hu = 4001,
		cu = 4002,
		uu = class e extends nu {
			constructor(t, i, s) {
				super(t), this.errorCode = i, this.innerError = s, this.name = "RuntimeError", nu._setPrototypeOf(this, e.prototype)
			}
		},
		mu = class {
			constructor(e, t, i) {
				this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0
			}
		},
		du = class e {
			intersectsPoint(e) {
				const t = this.minimumWorld,
					i = this.maximumWorld,
					s = t.x,
					n = t.y,
					a = t.z,
					r = i.x,
					o = i.y,
					l = i.z,
					h = e.x,
					c = e.y,
					u = e.z,
					m = -.001;
				return !(r - h < m || m > h - s) && (!(o - c < m || m > c - n) && !(l - u < m || m > u - a))
			}
			dispose() {
				this._drawWrapperFront?.dispose(), this._drawWrapperBack?.dispose()
			}
			constructor(e, t, i) {
				this.vectors = ac(8, Lc.Zero), this.center = Lc.Zero(), this.centerWorld = Lc.Zero(), this.extendSize = Lc.Zero(), this.extendSizeWorld = Lc.Zero(), this.directions = ac(3, Lc.Zero), this.vectorsWorld = ac(8, Lc.Zero), this.minimumWorld = Lc.Zero(), this.maximumWorld = Lc.Zero(), this.minimum = Lc.Zero(), this.maximum = Lc.Zero(), this._drawWrapperFront = null, this._drawWrapperBack = null, this.reConstruct(e, t, i)
			}
			static Intersects(e, t) {
				return e.intersectsMinMax(t.minimumWorld, t.maximumWorld)
			}
			static IsInFrustum(e, t) {
				for (let i = 0; i < 6; ++i) {
					let s = !0;
					const n = t[i];
					for (let t = 0; t < 8; ++t)
						if (n.dotCoordinate(e[t]) >= 0) {
							s = !1;
							break
						} if (s) return !1
				}
				return !0
			}
			isCompletelyInFrustum(t) {
				return e.IsCompletelyInFrustum(this.vectorsWorld, t)
			}
			scale(t) {
				const i = e._TmpVector3,
					s = this.maximum.subtractToRef(this.minimum, i[0]),
					n = s.length();
				s.normalizeFromLength(n);
				const a = n * t,
					r = s.scaleInPlace(.5 * a),
					o = this.center.subtractToRef(r, i[1]),
					l = this.center.addToRef(r, i[2]);
				return this.reConstruct(o, l, this._worldMatrix), this
			}
			intersectsSphere(t) {
				return e.IntersectsSphere(this.minimumWorld, this.maximumWorld, t.centerWorld, t.radiusWorld)
			}
			intersectsMinMax(e, t) {
				const i = this.minimumWorld,
					s = this.maximumWorld,
					n = i.x,
					a = i.y,
					r = i.z,
					o = s.x,
					l = s.y,
					h = s.z,
					c = e.x,
					u = e.y,
					m = e.z,
					d = t.x,
					f = t.y,
					p = t.z;
				return !(o < c || n > d) && (!(l < u || a > f) && !(h < m || r > p))
			}
			static IntersectsSphere(t, i, s, n) {
				const a = e._TmpVector3[0];
				Lc.ClampToRef(s, t, i, a);
				return Lc.DistanceSquared(s, a) <= n * n
			}
			isInFrustum(t) {
				return e.IsInFrustum(this.vectorsWorld, t)
			}
			reConstruct(e, t, i) {
				const s = e.x,
					n = e.y,
					a = e.z,
					r = t.x,
					o = t.y,
					l = t.z,
					h = this.vectors;
				this.minimum.copyFromFloats(s, n, a), this.maximum.copyFromFloats(r, o, l), h[0].copyFromFloats(s, n, a), h[1].copyFromFloats(r, o, l), h[2].copyFromFloats(r, n, a), h[3].copyFromFloats(s, o, a), h[4].copyFromFloats(s, n, l), h[5].copyFromFloats(r, o, a), h[6].copyFromFloats(s, o, l), h[7].copyFromFloats(r, n, l), t.addToRef(e, this.center).scaleInPlace(.5), t.subtractToRef(e, this.extendSize).scaleInPlace(.5), this._worldMatrix = i || Hc.IdentityReadOnly, this._update(this._worldMatrix)
			}
			getWorldMatrix() {
				return this._worldMatrix
			}
			static IsCompletelyInFrustum(e, t) {
				for (let i = 0; i < 6; ++i) {
					const s = t[i];
					for (let t = 0; t < 8; ++t)
						if (s.dotCoordinate(e[t]) < 0) return !1
				}
				return !0
			}
			_update(e) {
				const t = this.minimumWorld,
					i = this.maximumWorld,
					s = this.directions,
					n = this.vectorsWorld,
					a = this.vectors;
				if (e.isIdentity()) {
					t.copyFrom(this.minimum), i.copyFrom(this.maximum);
					for (let e = 0; e < 8; ++e) n[e].copyFrom(a[e]);
					this.extendSizeWorld.copyFrom(this.extendSize), this.centerWorld.copyFrom(this.center)
				} else {
					t.setAll(Number.MAX_VALUE), i.setAll(-Number.MAX_VALUE);
					for (let s = 0; s < 8; ++s) {
						const r = n[s];
						Lc.TransformCoordinatesToRef(a[s], e, r), t.minimizeInPlace(r), i.maximizeInPlace(r)
					}
					i.subtractToRef(t, this.extendSizeWorld).scaleInPlace(.5), i.addToRef(t, this.centerWorld).scaleInPlace(.5)
				}
				Lc.FromArrayToRef(e.m, 0, s[0]), Lc.FromArrayToRef(e.m, 4, s[1]), Lc.FromArrayToRef(e.m, 8, s[2]), this._worldMatrix = e
			}
		};
	du._TmpVector3 = ac(3, Lc.Zero);
	var fu = class e {
		getWorldMatrix() {
			return this._worldMatrix
		}
		scale(t) {
			const i = this.radius * t,
				s = e._TmpVector3,
				n = s[0].setAll(i),
				a = this.center.subtractToRef(n, s[1]),
				r = this.center.addToRef(n, s[2]);
			return this.reConstruct(a, r, this._worldMatrix), this
		}
		_update(t) {
			if (t.isIdentity()) this.centerWorld.copyFrom(this.center), this.radiusWorld = this.radius;
			else {
				Lc.TransformCoordinatesToRef(this.center, t, this.centerWorld);
				const i = e._TmpVector3[0];
				Lc.TransformNormalFromFloatsToRef(1, 1, 1, t, i), this.radiusWorld = Math.max(Math.abs(i.x), Math.abs(i.y), Math.abs(i.z)) * this.radius
			}
		}
		static Intersects(e, t) {
			const i = Lc.DistanceSquared(e.centerWorld, t.centerWorld),
				s = e.radiusWorld + t.radiusWorld;
			return !(s * s < i)
		}
		constructor(e, t, i) {
			this.center = Lc.Zero(), this.centerWorld = Lc.Zero(), this.minimum = Lc.Zero(), this.maximum = Lc.Zero(), this.reConstruct(e, t, i)
		}
		reConstruct(e, t, i) {
			this.minimum.copyFrom(e), this.maximum.copyFrom(t);
			const s = Lc.Distance(e, t);
			t.addToRef(e, this.center).scaleInPlace(.5), this.radius = .5 * s, this._update(i || Hc.IdentityReadOnly)
		}
		isInFrustum(e) {
			const t = this.centerWorld,
				i = this.radiusWorld;
			for (let s = 0; s < 6; s++)
				if (e[s].dotCoordinate(t) <= -i) return !1;
			return !0
		}
		intersectsPoint(e) {
			const t = Lc.DistanceSquared(this.centerWorld, e);
			return !(this.radiusWorld * this.radiusWorld < t)
		}
		isCenterInFrustum(e) {
			const t = this.centerWorld;
			for (let i = 0; i < 6; i++)
				if (e[i].dotCoordinate(t) < 0) return !1;
			return !0
		}
		static CreateFromCenterAndRadius(t, i, s) {
			this._TmpVector3[0].copyFrom(t), this._TmpVector3[1].copyFromFloats(0, 0, i), this._TmpVector3[2].copyFrom(t), this._TmpVector3[0].addInPlace(this._TmpVector3[1]), this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
			const n = new e(this._TmpVector3[0], this._TmpVector3[2]);
			return n._worldMatrix = s || Hc.Identity(), n
		}
	};
	fu._TmpVector3 = ac(3, Lc.Zero);
	var pu = {
			min: 0,
			max: 0
		},
		_u = {
			min: 0,
			max: 0
		},
		gu = (e, t, i) => {
			const s = Lc.Dot(t.centerWorld, e),
				n = Math.abs(Lc.Dot(t.directions[0], e)) * t.extendSize.x + Math.abs(Lc.Dot(t.directions[1], e)) * t.extendSize.y + Math.abs(Lc.Dot(t.directions[2], e)) * t.extendSize.z;
			i.min = s - n, i.max = s + n
		},
		vu = (e, t, i) => (gu(e, t, pu), gu(e, i, _u), !(pu.min > _u.max || _u.min > pu.max)),
		yu = class e {
			set isLocked(e) {
				this._isLocked = e
			}
			isCompletelyInFrustum(e) {
				return this.boundingBox.isCompletelyInFrustum(e)
			}
			get minimum() {
				return this.boundingBox.minimum
			}
			centerOn(t, i) {
				const s = e._TmpVector3[0].copyFrom(t).subtractInPlace(i),
					n = e._TmpVector3[1].copyFrom(t).addInPlace(i);
				return this.boundingBox.reConstruct(s, n, this.boundingBox.getWorldMatrix()), this.boundingSphere.reConstruct(s, n, this.boundingBox.getWorldMatrix()), this
			}
			get maximum() {
				return this.boundingBox.maximum
			}
			reConstruct(e, t, i) {
				this.boundingBox.reConstruct(e, t, i), this.boundingSphere.reConstruct(e, t, i)
			}
			constructor(e, t, i) {
				this._isLocked = !1, this.boundingBox = new du(e, t, i), this.boundingSphere = new fu(e, t, i)
			}
			get isLocked() {
				return this._isLocked
			}
			scale(e) {
				return this.boundingBox.scale(e), this.boundingSphere.scale(e), this
			}
			intersects(e, t) {
				if (!fu.Intersects(this.boundingSphere, e.boundingSphere)) return !1;
				if (!du.Intersects(this.boundingBox, e.boundingBox)) return !1;
				if (!t) return !0;
				const i = this.boundingBox,
					s = e.boundingBox;
				return !!vu(i.directions[0], i, s) && (!!vu(i.directions[1], i, s) && (!!vu(i.directions[2], i, s) && (!!vu(s.directions[0], i, s) && (!!vu(s.directions[1], i, s) && (!!vu(s.directions[2], i, s) && (!!vu(Lc.Cross(i.directions[0], s.directions[0]), i, s) && (!!vu(Lc.Cross(i.directions[0], s.directions[1]), i, s) && (!!vu(Lc.Cross(i.directions[0], s.directions[2]), i, s) && (!!vu(Lc.Cross(i.directions[1], s.directions[0]), i, s) && (!!vu(Lc.Cross(i.directions[1], s.directions[1]), i, s) && (!!vu(Lc.Cross(i.directions[1], s.directions[2]), i, s) && (!!vu(Lc.Cross(i.directions[2], s.directions[0]), i, s) && (!!vu(Lc.Cross(i.directions[2], s.directions[1]), i, s) && !!vu(Lc.Cross(i.directions[2], s.directions[2]), i, s))))))))))))))
			}
			intersectsPoint(e) {
				return !!this.boundingSphere.centerWorld && (!!this.boundingSphere.intersectsPoint(e) && !!this.boundingBox.intersectsPoint(e))
			}
			encapsulate(e) {
				const t = Lc.Minimize(this.minimum, e),
					i = Lc.Maximize(this.maximum, e);
				return this.reConstruct(t, i, this.boundingBox.getWorldMatrix()), this
			}
			isInFrustum(e, t = 0) {
				if ((2 === t || 3 === t) && this.boundingSphere.isCenterInFrustum(e)) return !0;
				if (!this.boundingSphere.isInFrustum(e)) return !1;
				return !(1 !== t && 3 !== t) || this.boundingBox.isInFrustum(e)
			}
			update(e) {
				this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e))
			}
			get diagonalLength() {
				const t = this.boundingBox;
				return t.maximumWorld.subtractToRef(t.minimumWorld, e._TmpVector3[0]).length()
			}
			encapsulateBoundingInfo(e) {
				const t = Vc.Matrix[0];
				this.boundingBox.getWorldMatrix().invertToRef(t);
				const i = Vc.Vector3[0];
				return Lc.TransformCoordinatesToRef(e.boundingBox.minimumWorld, t, i), this.encapsulate(i), Lc.TransformCoordinatesToRef(e.boundingBox.maximumWorld, t, i), this.encapsulate(i), this
			}
			_checkCollision(e) {
				return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld)
			}
		};
	yu._TmpVector3 = ac(2, Lc.Zero);
	var Su = class {
		static extractMinAndMaxIndexed(e, t, i, s, n, a) {
			for (let r = i; r < i + s; r++) {
				const i = 3 * t[r],
					s = e[i],
					o = e[i + 1],
					l = e[i + 2];
				n.minimizeInPlaceFromFloats(s, o, l), a.maximizeInPlaceFromFloats(s, o, l)
			}
		}
		static extractMinAndMax(e, t, i, s, n, a) {
			for (let r = t, o = t * s; r < t + i; r++, o += s) {
				const t = e[o],
					i = e[o + 1],
					s = e[o + 2];
				n.minimizeInPlaceFromFloats(t, i, s), a.maximizeInPlaceFromFloats(t, i, s)
			}
		}
	};

	function Eu(e, t, i, s = null, n) {
		const a = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
			r = new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
		return n || (n = 3), Su.extractMinAndMax(e, t, i, n, a, r), s && (a.x -= a.x * s.x + s.y, a.y -= a.y * s.x + s.y, a.z -= a.z * s.x + s.y, r.x += r.x * s.x + s.y, r.y += r.y * s.x + s.y, r.z += r.z * s.x + s.y), {
			minimum: a,
			maximum: r
		}
	}
	Gh([ec.filter(((...[e, t]) => !Array.isArray(e) && !Array.isArray(t)))], Su, "extractMinAndMaxIndexed", null), Gh([ec.filter(((...[e]) => !Array.isArray(e)))], Su, "extractMinAndMax", null);
	var Au = class {
			static GetEffect(e) {
				return void 0 === e.getPipelineContext ? e.effect : e
			}
			dispose() {
				this.drawContext?.dispose()
			}
			constructor(e, t = !0) {
				this._wasPreviouslyReady = !1, this._forceRebindOnNextCall = !0, this._wasPreviouslyUsingInstances = null, this.effect = null, this.defines = null, this.drawContext = e.createDrawContext(), t && (this.materialContext = e.createMaterialContext())
			}
			setEffect(e, t, i = !0) {
				this.effect = e, void 0 !== t && (this.defines = t), i && this.drawContext?.reset()
			}
		},
		bu = class e {
			_removeDrawWrapper(e, t = !0) {
				t && this._drawWrappers[e]?.dispose(), this._drawWrappers[e] = void 0
			}
			isInFrustum(e) {
				const t = this.getBoundingInfo();
				return !!t && t.isInFrustum(e, this._mesh.cullingStrategy)
			}
			_setMainDrawWrapperOverride(e) {
				this._mainDrawWrapperOverride = e
			}
			_checkCollision(e) {
				return this.getBoundingInfo()._checkCollision(e)
			}
			_intersectUnIndexedLines(e, t, i, s, n) {
				let a = null;
				for (let i = this.verticesStart; i < this.verticesStart + this.verticesCount; i += 2) {
					const r = t[i],
						o = t[i + 1],
						l = e.intersectionSegment(r, o, s);
					if (!(l < 0) && ((n || !a || l < a.distance) && (a = new mu(null, null, l), a.faceId = i / 2, n))) break
				}
				return a
			}
			render(e) {
				return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0), this
			}
			getMesh() {
				return this._mesh
			}
			_intersectTriangles(e, t, i, s, n, a, r) {
				let o = null,
					l = -1;
				for (let h = this.indexStart; h < this.indexStart + this.indexCount - (3 - s); h += s) {
					l++;
					const s = i[h],
						c = i[h + 1],
						u = i[h + 2];
					if (n && 4294967295 === u) {
						h += 2;
						continue
					}
					const m = t[s],
						d = t[c],
						f = t[u];
					if (!m || !d || !f) continue;
					if (r && !r(m, d, f, e, s, c, u)) continue;
					const p = e.intersectsTriangle(m, d, f);
					if (p) {
						if (p.distance < 0) continue;
						if ((a || !o || p.distance < o.distance) && (o = p, o.faceId = l, a)) break
					}
				}
				return o
			}
			get materialDefines() {
				return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : this._getDrawWrapper()?.defines
			}
			constructor(e, t, i, s, n, a, r, o = !0, l = !0) {
				this.materialIndex = e, this.verticesStart = t, this.verticesCount = i, this.indexStart = s, this.indexCount = n, this._mainDrawWrapperOverride = null, this._linesIndexCount = 0, this._linesIndexBuffer = null, this._lastColliderWorldVertices = null, this._lastColliderTransformMatrix = null, this._wasDispatched = !1, this._renderId = 0, this._alphaIndex = 0, this._distanceToCamera = 0, this._currentMaterial = null, this._mesh = a, this._renderingMesh = r || a, l && a.subMeshes.push(this), this._engine = this._mesh.getScene().getEngine(), this.resetDrawCache(), this._trianglePlanes = [], this._id = a.subMeshes.length - 1, o && (this.refreshBoundingInfo(), a.computeWorldMatrix(!0))
			}
			dispose() {
				this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);
				const e = this._mesh.subMeshes.indexOf(this);
				this._mesh.subMeshes.splice(e, 1), this.resetDrawCache()
			}
			resetDrawCache(e) {
				if (this._drawWrappers) {
					if (void 0 !== e) return void this._removeDrawWrapper(e);
					for (const e of this._drawWrappers) e?.dispose()
				}
				this._drawWrappers = []
			}
			intersects(e, t, i, s, n) {
				const a = this.getMaterial();
				if (!a) return null;
				let r = 3,
					o = !1;
				switch (a.fillMode) {
					case 3:
					case 5:
					case 6:
					case 8:
						return null;
					case 7:
						r = 1, o = !0
				}
				return 4 === a.fillMode ? i.length ? this._intersectLines(e, t, i, this._mesh.intersectionThreshold, s) : this._intersectUnIndexedLines(e, t, i, this._mesh.intersectionThreshold, s) : !i.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, i, s, n) : this._intersectTriangles(e, t, i, r, o, s, n)
			}
			canIntersects(e) {
				const t = this.getBoundingInfo();
				return !!t && e.intersectsBox(t.boundingBox)
			}
			setEffect(e, t = null, i, s = !0) {
				const n = this._drawWrapper;
				n.setEffect(e, t, s), void 0 !== i && (n.materialContext = i), e || (n.defines = null, n.materialContext = void 0)
			}
			getReplacementMesh() {
				return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null
			}
			get IsGlobal() {
				return 0 === this.verticesStart && this.verticesCount === this._mesh.getTotalVertices() && 0 === this.indexStart && this.indexCount === this._mesh.getTotalIndices()
			}
			setBoundingInfo(e) {
				return this._boundingInfo = e, this
			}
			getRenderingMesh() {
				return this._renderingMesh
			}
			_intersectUnIndexedTriangles(e, t, i, s, n) {
				let a = null;
				for (let i = this.verticesStart; i < this.verticesStart + this.verticesCount; i += 3) {
					const r = t[i],
						o = t[i + 1],
						l = t[i + 2];
					if (n && !n(r, o, l, e, -1, -1, -1)) continue;
					const h = e.intersectsTriangle(r, o, l);
					if (h) {
						if (h.distance < 0) continue;
						if ((s || !a || h.distance < a.distance) && (a = h, a.faceId = i / 3, s)) break
					}
				}
				return a
			}
			_intersectLines(e, t, i, s, n) {
				let a = null;
				for (let r = this.indexStart; r < this.indexStart + this.indexCount; r += 2) {
					const o = t[i[r]],
						l = t[i[r + 1]],
						h = e.intersectionSegment(o, l, s);
					if (!(h < 0) && ((n || !a || h < a.distance) && (a = new mu(null, null, h), a.faceId = r / 2, n))) break
				}
				return a
			}
			getMaterial(e = !0) {
				const t = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;
				if (!t) return e ? this._mesh.getScene().defaultMaterial : null;
				if (this._isMultiMaterial(t)) {
					const e = t.getSubMaterial(this.materialIndex);
					return this._currentMaterial !== e && (this._currentMaterial = e, this.resetDrawCache()), e
				}
				return t
			}
			getBoundingInfo() {
				return this.IsGlobal || this._mesh.hasThinInstances ? this._mesh.getBoundingInfo() : this._boundingInfo
			}
			clone(t, i) {
				const s = new e(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, t, i, !1);
				if (!this.IsGlobal) {
					const e = this.getBoundingInfo();
					if (!e) return s;
					s._boundingInfo = new yu(e.minimum, e.maximum)
				}
				return s
			}
			getEffectiveMesh() {
				const e = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
				return e || this._renderingMesh
			}
			_isMultiMaterial(e) {
				return void 0 !== e.getSubMaterial
			}
			refreshBoundingInfo(e = null) {
				if (this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) return this;
				if (e || (e = this._renderingMesh.getVerticesData(eu.PositionKind)), !e) return this._boundingInfo = this._mesh.getBoundingInfo(), this;
				const t = this._renderingMesh.getIndices();
				let i;
				if (0 === this.indexStart && this.indexCount === t.length) {
					const e = this._renderingMesh.getBoundingInfo();
					i = {
						minimum: e.minimum.clone(),
						maximum: e.maximum.clone()
					}
				} else i = function(e, t, i, s, n = null) {
					const a = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
						r = new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
					return Su.extractMinAndMaxIndexed(e, t, i, s, a, r), n && (a.x -= a.x * n.x + n.y, a.y -= a.y * n.x + n.y, a.z -= a.z * n.x + n.y, r.x += r.x * n.x + n.y, r.y += r.y * n.x + n.y, r.z += r.z * n.x + n.y), {
						minimum: a,
						maximum: r
					}
				}(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
				return this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new yu(i.minimum, i.maximum), this
			}
			static AddToMesh(t, i, s, n, a, r, o, l = !0) {
				return new e(t, i, s, n, a, r, o, l)
			}
			static CreateFromIndices(t, i, s, n, a, r = !0) {
				let o = Number.MAX_VALUE,
					l = -Number.MAX_VALUE;
				const h = (a || n).getIndices();
				for (let e = i; e < i + s; e++) {
					const t = h[e];
					t < o && (o = t), t > l && (l = t)
				}
				return new e(t, o, l - o + 1, i, s, n, a, r)
			}
			get effect() {
				return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null
			}
			get _drawWrapperOverride() {
				return this._mainDrawWrapperOverride
			}
			_getDrawWrapper(e, t = !1) {
				e = e ?? this._engine.currentRenderPassId;
				let i = this._drawWrappers[e];
				return !i && t && (this._drawWrappers[e] = i = new Au(this._mesh.getScene().getEngine())), i
			}
			_getLinesIndexBuffer(e, t) {
				if (!this._linesIndexBuffer) {
					const i = [];
					for (let t = this.indexStart; t < this.indexStart + this.indexCount; t += 3) i.push(e[t], e[t + 1], e[t + 1], e[t + 2], e[t + 2], e[t]);
					this._linesIndexBuffer = t.createIndexBuffer(i), this._linesIndexCount = i.length
				}
				return this._linesIndexBuffer
			}
			set materialDefines(e) {
				(this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, !0)).defines = e
			}
			isCompletelyInFrustum(e) {
				const t = this.getBoundingInfo();
				return !!t && t.isCompletelyInFrustum(e)
			}
			updateBoundingInfo(e) {
				let t = this.getBoundingInfo();
				return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t && t.update(e), this
			}
			getClassName() {
				return "SubMesh"
			}
			_rebuild() {
				this._linesIndexBuffer && (this._linesIndexBuffer = null)
			}
			get _drawWrapper() {
				return this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, !0)
			}
		},
		xu = class {},
		Mu = class e {
			updateMesh(e) {
				return this._update(e), this
			}
			static Nk(e) {
				throw ic("ribbonBuilder")
			}
			static Parse(t) {
				const i = new e,
					s = t.positions;
				s && i.set(s, eu.PositionKind);
				const n = t.normals;
				n && i.set(n, eu.NormalKind);
				const a = t.tangents;
				a && i.set(a, eu.TangentKind);
				const r = t.uvs;
				r && i.set(r, eu.UVKind);
				const o = t.uvs2;
				o && i.set(o, eu.UV2Kind);
				const l = t.uvs3;
				l && i.set(l, eu.UV3Kind);
				const h = t.uvs4;
				h && i.set(h, eu.UV4Kind);
				const c = t.uvs5;
				c && i.set(c, eu.UV5Kind);
				const u = t.uvs6;
				u && i.set(u, eu.UV6Kind);
				const m = t.colors;
				m && (i.set(wc.CheckColors4(m, s.length / 3), eu.ColorKind), void 0 !== t.hasVertexAlpha && (i.hasVertexAlpha = t.hasVertexAlpha));
				const d = t.matricesIndices;
				d && i.set(d, eu.MatricesIndicesKind);
				const f = t.matricesWeights;
				f && i.set(f, eu.MatricesWeightsKind);
				const p = t.indices;
				p && (i.indices = p);
				const _ = t.materialInfos;
				if (_) {
					i.materialInfos = [];
					for (const e of _) {
						const t = new xu;
						t.indexCount = e.indexCount, t.indexStart = e.indexStart, t.verticesCount = e.verticesCount, t.verticesStart = e.verticesStart, t.materialIndex = e.materialIndex, i.materialInfos.push(t)
					}
				}
				return i
			}
			static Pk(e) {
				throw ic("planeBuilder")
			}
			static gk(e) {
				throw ic("discBuilder")
			}
			static ExtractFromMesh(t, i, s) {
				return e._ExtractFrom(t, i, s)
			}
			static CreateCapsule(e = {
				orientation: Lc.Up(),
				subdivisions: 2,
				tessellation: 16,
				height: 1,
				radius: .25,
				capSubdivisions: 6
			}) {
				throw ic("capsuleBuilder")
			}* _applyToCoroutine(e, t = !1, i) {
				if (this.positions && (e.setVerticesData(eu.PositionKind, this.positions, t), i && (yield)), this.normals && (e.setVerticesData(eu.NormalKind, this.normals, t), i && (yield)), this.tangents && (e.setVerticesData(eu.TangentKind, this.tangents, t), i && (yield)), this.uvs && (e.setVerticesData(eu.UVKind, this.uvs, t), i && (yield)), this.uvs2 && (e.setVerticesData(eu.UV2Kind, this.uvs2, t), i && (yield)), this.uvs3 && (e.setVerticesData(eu.UV3Kind, this.uvs3, t), i && (yield)), this.uvs4 && (e.setVerticesData(eu.UV4Kind, this.uvs4, t), i && (yield)), this.uvs5 && (e.setVerticesData(eu.UV5Kind, this.uvs5, t), i && (yield)), this.uvs6 && (e.setVerticesData(eu.UV6Kind, this.uvs6, t), i && (yield)), this.colors && (e.setVerticesData(eu.ColorKind, this.colors, t), this.hasVertexAlpha && void 0 !== e.hasVertexAlpha && (e.hasVertexAlpha = !0), i && (yield)), this.matricesIndices && (e.setVerticesData(eu.MatricesIndicesKind, this.matricesIndices, t), i && (yield)), this.matricesWeights && (e.setVerticesData(eu.MatricesWeightsKind, this.matricesWeights, t), i && (yield)), this.matricesIndicesExtra && (e.setVerticesData(eu.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), i && (yield)), this.matricesWeightsExtra && (e.setVerticesData(eu.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), i && (yield)), this.indices ? (e.setIndices(this.indices, null, t), i && (yield)) : e.setIndices([], null), e.subMeshes && this.materialInfos && this.materialInfos.length > 1) {
					const t = e;
					t.subMeshes = [];
					for (const e of this.materialInfos) new bu(e.materialIndex, e.verticesStart, e.verticesCount, e.indexStart, e.indexCount, t)
				}
				return this
			}
			static _ComputeSides(t, i, s, n, a, r, o) {
				const l = s.length,
					h = n.length;
				let c, u;
				switch (t = t || e.DEFAULTSIDE) {
					case e.FRONTSIDE:
						break;
					case e.BACKSIDE:
						for (c = 0; c < l; c += 3) {
							const e = s[c];
							s[c] = s[c + 2], s[c + 2] = e
						}
						for (u = 0; u < h; u++) n[u] = -n[u];
						break;
					case e.DOUBLESIDE: {
						const e = i.length,
							t = e / 3;
						for (let t = 0; t < e; t++) i[e + t] = i[t];
						for (c = 0; c < l; c += 3) s[c + l] = s[c + 2] + t, s[c + 1 + l] = s[c + 1] + t, s[c + 2 + l] = s[c] + t;
						for (u = 0; u < h; u++) n[h + u] = -n[u];
						const m = a.length;
						let d = 0;
						for (d = 0; d < m; d++) a[d + m] = a[d];
						for (r = r || new Bc(0, 0, 1, 1), o = o || new Bc(0, 0, 1, 1), d = 0, c = 0; c < m / 2; c++) a[d] = r.x + (r.z - r.x) * a[d], a[d + 1] = r.y + (r.w - r.y) * a[d + 1], a[d + m] = o.x + (o.z - o.x) * a[d + m], a[d + m + 1] = o.y + (o.w - o.y) * a[d + m + 1], d += 2;
						break
					}
				}
			}
			static CreateIcoSphere(e) {
				throw ic("icoSphereBuilder")
			}
			static _MergeElement(t, i, s, n) {
				const a = n.filter((e => null !== e[0] && void 0 !== e[0]));
				if (!i && 0 == a.length) return i;
				if (!i) return this._MergeElement(t, a[0][0], a[0][1], a.slice(1));
				const r = a.reduce(((e, t) => e + t[0].length), i.length),
					o = t === eu.PositionKind ? e._TransformVector3Coordinates : t === eu.NormalKind ? e._TransformVector3Normals : t === eu.TangentKind ? e._TransformVector4Normals : () => {};
				if (i instanceof Float32Array) {
					const e = new Float32Array(r);
					e.set(i), s && o(e, s, 0, i.length);
					let t = i.length;
					for (const [i, s] of a) e.set(i, t), s && o(e, s, t, i.length), t += i.length;
					return e
				} {
					const e = new Array(r);
					for (let t = 0; t < i.length; t++) e[t] = i[t];
					s && o(e, s, 0, i.length);
					let t = i.length;
					for (const [i, s] of a) {
						for (let s = 0; s < i.length; s++) e[t + s] = i[s];
						s && o(e, s, t, i.length), t += i.length
					}
					return e
				}
			}
			applyToMesh(e, t) {
				return this._applyTo(e, t, !1), this
			}
			static CreateLineSystem(e) {
				throw ic("linesBuilder")
			}
			static _TransformVector3Coordinates(e, t, i = 0, s = e.length) {
				const n = Vc.Vector3[0],
					a = Vc.Vector3[1];
				for (let r = i; r < i + s; r += 3) Lc.FromArrayToRef(e, r, n), Lc.TransformCoordinatesToRef(n, t, a), e[r] = a.x, e[r + 1] = a.y, e[r + 2] = a.z
			}
			static CreateTiledGround(e) {
				throw ic("groundBuilder")
			}
			static _FlipFaces(e, t = 0, i = e.length) {
				for (let s = t; s < t + i; s += 3) {
					const t = e[s + 1];
					e[s + 1] = e[s + 2], e[s + 2] = t
				}
			}
			splitBasedOnMaterialID() {
				if (!this.materialInfos || this.materialInfos.length < 2) return [this];
				const t = [];
				for (const i of this.materialInfos) {
					const s = new e;
					if (this.positions && (s.positions = this.positions.slice(3 * i.verticesStart, 3 * (i.verticesCount + i.verticesStart))), this.normals && (s.normals = this.normals.slice(3 * i.verticesStart, 3 * (i.verticesCount + i.verticesStart))), this.tangents && (s.tangents = this.tangents.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.colors && (s.colors = this.colors.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.uvs && (s.uvs = this.uvs.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.uvs2 && (s.uvs2 = this.uvs2.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.uvs3 && (s.uvs3 = this.uvs3.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.uvs4 && (s.uvs4 = this.uvs4.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.uvs5 && (s.uvs5 = this.uvs5.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.uvs6 && (s.uvs6 = this.uvs6.slice(2 * i.verticesStart, 2 * (i.verticesCount + i.verticesStart))), this.matricesIndices && (s.matricesIndices = this.matricesIndices.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.matricesIndicesExtra && (s.matricesIndicesExtra = this.matricesIndicesExtra.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.matricesWeights && (s.matricesWeights = this.matricesWeights.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.matricesWeightsExtra && (s.matricesWeightsExtra = this.matricesWeightsExtra.slice(4 * i.verticesStart, 4 * (i.verticesCount + i.verticesStart))), this.indices) {
						s.indices = [];
						for (let e = i.indexStart; e < i.indexStart + i.indexCount; e++) s.indices.push(this.indices[e] - i.verticesStart)
					}
					const n = new xu;
					n.indexStart = 0, n.indexCount = s.indices ? s.indices.length : 0, n.materialIndex = i.materialIndex, n.verticesStart = 0, n.verticesCount = (s.positions ? s.positions.length : 0) / 3, s.materialInfos = [n], t.push(s)
				}
				return t
			}
			static Ak(e) {
				throw ic("cylinderBuilder")
			}
			merge(e, t = !1, i = !1, s = !1, n = !1) {
				const a = Array.isArray(e) ? e.map((e => ({
					vertexData: e
				}))) : [{
					vertexData: e
				}];
				return su(this._mergeCoroutine(void 0, a, t, !1, i, s, n))
			}
			serialize() {
				const e = {};
				if (this.positions && (e.positions = Array.from(this.positions)), this.normals && (e.normals = Array.from(this.normals)), this.tangents && (e.tangents = Array.from(this.tangents)), this.uvs && (e.uvs = Array.from(this.uvs)), this.uvs2 && (e.uvs2 = Array.from(this.uvs2)), this.uvs3 && (e.uvs3 = Array.from(this.uvs3)), this.uvs4 && (e.uvs4 = Array.from(this.uvs4)), this.uvs5 && (e.uvs5 = Array.from(this.uvs5)), this.uvs6 && (e.uvs6 = Array.from(this.uvs6)), this.colors && (e.colors = Array.from(this.colors), e.hasVertexAlpha = this.hasVertexAlpha), this.matricesIndices && (e.matricesIndices = Array.from(this.matricesIndices), e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = Array.from(this.matricesWeights)), this.matricesIndicesExtra && (e.matricesIndicesExtra = Array.from(this.matricesIndicesExtra), e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = Array.from(this.matricesWeightsExtra)), e.indices = Array.from(this.indices), this.materialInfos) {
					e.materialInfos = [];
					for (const t of this.materialInfos) {
						const i = {
							indexStart: t.indexStart,
							indexCount: t.indexCount,
							materialIndex: t.materialIndex,
							verticesStart: t.verticesStart,
							verticesCount: t.verticesCount
						};
						e.materialInfos.push(i)
					}
				}
				return e
			}* _mergeCoroutine(t, i, s = !1, n, a, r = !1, o = !1) {
				this._validate();
				let l = i.map((e => e.vertexData)),
					h = this;
				if (o)
					for (const e of l) e && (e._validate(), !this.normals && e.normals && (this.normals = new Float32Array(this.positions.length)), !this.tangents && e.tangents && (this.tangents = new Float32Array(this.positions.length / 3 * 4)), !this.uvs && e.uvs && (this.uvs = new Float32Array(this.positions.length / 3 * 2)), !this.uvs2 && e.uvs2 && (this.uvs2 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs3 && e.uvs3 && (this.uvs3 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs4 && e.uvs4 && (this.uvs4 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs5 && e.uvs5 && (this.uvs5 = new Float32Array(this.positions.length / 3 * 2)), !this.uvs6 && e.uvs6 && (this.uvs6 = new Float32Array(this.positions.length / 3 * 2)), !this.colors && e.colors && (this.colors = new Float32Array(this.positions.length / 3 * 4), this.colors.fill(1)), !this.matricesIndices && e.matricesIndices && (this.matricesIndices = new Float32Array(this.positions.length / 3 * 4)), !this.matricesWeights && e.matricesWeights && (this.matricesWeights = new Float32Array(this.positions.length / 3 * 4)), !this.matricesIndicesExtra && e.matricesIndicesExtra && (this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4)), !this.matricesWeightsExtra && e.matricesWeightsExtra && (this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4)));
				for (const e of l)
					if (e)
						if (o) this.normals && !e.normals && (e.normals = new Float32Array(e.positions.length)), this.tangents && !e.tangents && (e.tangents = new Float32Array(e.positions.length / 3 * 4)), this.uvs && !e.uvs && (e.uvs = new Float32Array(e.positions.length / 3 * 2)), this.uvs2 && !e.uvs2 && (e.uvs2 = new Float32Array(e.positions.length / 3 * 2)), this.uvs3 && !e.uvs3 && (e.uvs3 = new Float32Array(e.positions.length / 3 * 2)), this.uvs4 && !e.uvs4 && (e.uvs4 = new Float32Array(e.positions.length / 3 * 2)), this.uvs5 && !e.uvs5 && (e.uvs5 = new Float32Array(e.positions.length / 3 * 2)), this.uvs6 && !e.uvs6 && (e.uvs6 = new Float32Array(e.positions.length / 3 * 2)), this.colors && !e.colors && (e.colors = new Float32Array(e.positions.length / 3 * 4), e.colors.fill(1)), this.matricesIndices && !e.matricesIndices && (e.matricesIndices = new Float32Array(e.positions.length / 3 * 4)), this.matricesWeights && !e.matricesWeights && (e.matricesWeights = new Float32Array(e.positions.length / 3 * 4)), this.matricesIndicesExtra && !e.matricesIndicesExtra && (e.matricesIndicesExtra = new Float32Array(e.positions.length / 3 * 4)), this.matricesWeightsExtra && !e.matricesWeightsExtra && (e.matricesWeightsExtra = new Float32Array(e.positions.length / 3 * 4));
						else if (e._validate(), !this.normals != !e.normals || !this.tangents != !e.tangents || !this.uvs != !e.uvs || !this.uvs2 != !e.uvs2 || !this.uvs3 != !e.uvs3 || !this.uvs4 != !e.uvs4 || !this.uvs5 != !e.uvs5 || !this.uvs6 != !e.uvs6 || !this.colors != !e.colors || !this.matricesIndices != !e.matricesIndices || !this.matricesWeights != !e.matricesWeights || !this.matricesIndicesExtra != !e.matricesIndicesExtra || !this.matricesWeightsExtra != !e.matricesWeightsExtra) throw new Error("Cannot merge vertex data that do not have the same set of attributes");
				if (r) {
					let e = 0,
						s = 0,
						n = 0;
					const a = [];
					let r = null;
					const o = [];
					for (const e of this.splitBasedOnMaterialID()) o.push({
						vertexData: e,
						transform: t
					});
					for (const e of i)
						if (e.vertexData)
							for (const t of e.vertexData.splitBasedOnMaterialID()) o.push({
								vertexData: t,
								transform: e.transform
							});
					o.sort(((e, t) => {
						const i = e.vertexData.materialInfos ? e.vertexData.materialInfos[0].materialIndex : 0,
							s = t.vertexData.materialInfos ? t.vertexData.materialInfos[0].materialIndex : 0;
						return i > s ? 1 : i === s ? 0 : -1
					}));
					for (const t of o) {
						const i = t.vertexData;
						if (e = i.materialInfos ? i.materialInfos[0].materialIndex : 0, r && r.materialIndex === e) r.indexCount += i.indices.length, r.verticesCount += i.positions.length / 3;
						else {
							const t = new xu;
							t.materialIndex = e, t.indexStart = s, t.indexCount = i.indices.length, t.verticesStart = n, t.verticesCount = i.positions.length / 3, a.push(t), r = t
						}
						s += i.indices.length, n += i.positions.length / 3
					}
					const c = o.splice(0, 1)[0];
					h = c.vertexData, t = c.transform, l = o.map((e => e.vertexData)), i = o, this.materialInfos = a
				}
				const c = l.reduce(((e, t) => e + (t.indices?.length ?? 0)), h.indices?.length ?? 0);
				let u = a || l.some((e => e.indices === h.indices)) ? h.indices?.slice() : h.indices;
				if (c > 0) {
					let a = u?.length ?? 0;
					if (u || (u = new Array(c)), u.length !== c) {
						if (Array.isArray(u)) u.length = c;
						else {
							const e = s || u instanceof Uint32Array ? new Uint32Array(c) : new Uint16Array(c);
							e.set(u), u = e
						}
						t && t.determinant() < 0 && e._FlipFaces(u, 0, a)
					}
					let r = h.positions ? h.positions.length / 3 : 0;
					for (const {
							vertexData: t,
							transform: s
						}
						of i)
						if (t.indices) {
							for (let e = 0; e < t.indices.length; e++) u[a + e] = t.indices[e] + r;
							s && s.determinant() < 0 && e._FlipFaces(u, a, t.indices.length), r += t.positions.length / 3, a += t.indices.length, n && (yield)
						}
				}
				return this.indices = u, this.positions = e._MergeElement(eu.PositionKind, h.positions, t, i.map((e => [e.vertexData.positions, e.transform]))), n && (yield), h.normals && (this.normals = e._MergeElement(eu.NormalKind, h.normals, t, i.map((e => [e.vertexData.normals, e.transform]))), n && (yield)), h.tangents && (this.tangents = e._MergeElement(eu.TangentKind, h.tangents, t, i.map((e => [e.vertexData.tangents, e.transform]))), n && (yield)), h.uvs && (this.uvs = e._MergeElement(eu.UVKind, h.uvs, t, i.map((e => [e.vertexData.uvs, e.transform]))), n && (yield)), h.uvs2 && (this.uvs2 = e._MergeElement(eu.UV2Kind, h.uvs2, t, i.map((e => [e.vertexData.uvs2, e.transform]))), n && (yield)), h.uvs3 && (this.uvs3 = e._MergeElement(eu.UV3Kind, h.uvs3, t, i.map((e => [e.vertexData.uvs3, e.transform]))), n && (yield)), h.uvs4 && (this.uvs4 = e._MergeElement(eu.UV4Kind, h.uvs4, t, i.map((e => [e.vertexData.uvs4, e.transform]))), n && (yield)), h.uvs5 && (this.uvs5 = e._MergeElement(eu.UV5Kind, h.uvs5, t, i.map((e => [e.vertexData.uvs5, e.transform]))), n && (yield)), h.uvs6 && (this.uvs6 = e._MergeElement(eu.UV6Kind, h.uvs6, t, i.map((e => [e.vertexData.uvs6, e.transform]))), n && (yield)), h.colors && (this.colors = e._MergeElement(eu.ColorKind, h.colors, t, i.map((e => [e.vertexData.colors, e.transform]))), (void 0 !== h.hasVertexAlpha || i.some((e => void 0 !== e.vertexData.hasVertexAlpha))) && (this.hasVertexAlpha = h.hasVertexAlpha || i.some((e => e.vertexData.hasVertexAlpha))), n && (yield)), h.matricesIndices && (this.matricesIndices = e._MergeElement(eu.MatricesIndicesKind, h.matricesIndices, t, i.map((e => [e.vertexData.matricesIndices, e.transform]))), n && (yield)), h.matricesWeights && (this.matricesWeights = e._MergeElement(eu.MatricesWeightsKind, h.matricesWeights, t, i.map((e => [e.vertexData.matricesWeights, e.transform]))), n && (yield)), h.matricesIndicesExtra && (this.matricesIndicesExtra = e._MergeElement(eu.MatricesIndicesExtraKind, h.matricesIndicesExtra, t, i.map((e => [e.vertexData.matricesIndicesExtra, e.transform]))), n && (yield)), h.matricesWeightsExtra && (this.matricesWeightsExtra = e._MergeElement(eu.MatricesWeightsExtraKind, h.matricesWeightsExtra, t, i.map((e => [e.vertexData.matricesWeightsExtra, e.transform])))), this
			}
			set(e, t) {
				switch (e.length || Qc.Warn(`Setting vertex data kind '${t}' with an empty array`), t) {
					case eu.PositionKind:
						this.positions = e;
						break;
					case eu.NormalKind:
						this.normals = e;
						break;
					case eu.TangentKind:
						this.tangents = e;
						break;
					case eu.UVKind:
						this.uvs = e;
						break;
					case eu.UV2Kind:
						this.uvs2 = e;
						break;
					case eu.UV3Kind:
						this.uvs3 = e;
						break;
					case eu.UV4Kind:
						this.uvs4 = e;
						break;
					case eu.UV5Kind:
						this.uvs5 = e;
						break;
					case eu.UV6Kind:
						this.uvs6 = e;
						break;
					case eu.ColorKind:
						this.colors = e;
						break;
					case eu.MatricesIndicesKind:
						this.matricesIndices = e;
						break;
					case eu.MatricesWeightsKind:
						this.matricesWeights = e;
						break;
					case eu.MatricesIndicesExtraKind:
						this.matricesIndicesExtra = e;
						break;
					case eu.MatricesWeightsExtraKind:
						this.matricesWeightsExtra = e
				}
			}
			applyToGeometry(e, t) {
				return this._applyTo(e, t, !1), this
			}
			static Rk(e) {
				throw ic("sphereBuilder")
			}
			static dk(e) {
				throw ic("boxBuilder")
			}
			static _ExtractFrom(t, i, s) {
				const n = new e;
				if (t.isVerticesDataPresent(eu.PositionKind) && (n.positions = t.getVerticesData(eu.PositionKind, i, s)), t.isVerticesDataPresent(eu.NormalKind) && (n.normals = t.getVerticesData(eu.NormalKind, i, s)), t.isVerticesDataPresent(eu.TangentKind) && (n.tangents = t.getVerticesData(eu.TangentKind, i, s)), t.isVerticesDataPresent(eu.UVKind) && (n.uvs = t.getVerticesData(eu.UVKind, i, s)), t.isVerticesDataPresent(eu.UV2Kind) && (n.uvs2 = t.getVerticesData(eu.UV2Kind, i, s)), t.isVerticesDataPresent(eu.UV3Kind) && (n.uvs3 = t.getVerticesData(eu.UV3Kind, i, s)), t.isVerticesDataPresent(eu.UV4Kind) && (n.uvs4 = t.getVerticesData(eu.UV4Kind, i, s)), t.isVerticesDataPresent(eu.UV5Kind) && (n.uvs5 = t.getVerticesData(eu.UV5Kind, i, s)), t.isVerticesDataPresent(eu.UV6Kind) && (n.uvs6 = t.getVerticesData(eu.UV6Kind, i, s)), t.isVerticesDataPresent(eu.ColorKind)) {
					const e = t.geometry || t,
						a = e.getVertexBuffer(eu.ColorKind),
						r = e.getVerticesData(eu.ColorKind, i, s);
					if (3 === a.getSize()) {
						const e = new Float32Array(4 * r.length / 3);
						for (let t = 0, i = 0; t < r.length; t += 3, i += 4) e[i] = r[t], e[i + 1] = r[t + 1], e[i + 2] = r[t + 2], e[i + 3] = 1;
						n.colors = e
					} else {
						if (4 !== a.getSize()) throw new Error(`Unexpected number of color components: ${a.getSize()}`);
						n.colors = r
					}
				}
				return t.isVerticesDataPresent(eu.MatricesIndicesKind) && (n.matricesIndices = t.getVerticesData(eu.MatricesIndicesKind, i, s)), t.isVerticesDataPresent(eu.MatricesWeightsKind) && (n.matricesWeights = t.getVerticesData(eu.MatricesWeightsKind, i, s)), t.isVerticesDataPresent(eu.MatricesIndicesExtraKind) && (n.matricesIndicesExtra = t.getVerticesData(eu.MatricesIndicesExtraKind, i, s)), t.isVerticesDataPresent(eu.MatricesWeightsExtraKind) && (n.matricesWeightsExtra = t.getVerticesData(eu.MatricesWeightsExtraKind, i, s)), n.indices = t.getIndices(i, s), n
			}
			transform(t) {
				const i = t.determinant() < 0;
				return this.positions && e._TransformVector3Coordinates(this.positions, t), this.normals && e._TransformVector3Normals(this.normals, t), this.tangents && e._TransformVector4Normals(this.tangents, t), i && this.indices && e._FlipFaces(this.indices), this
			}
			static CreatePolygon(e, t, i, s, n, a, r) {
				throw ic("polygonBuilder")
			}
			static CreateTiledBox(e) {
				throw ic("tiledBoxBuilder")
			}
			static CreateTorusKnot(e) {
				throw ic("torusKnotBuilder")
			}
			static CreateGround(e) {
				throw ic("groundBuilder")
			}
			updateGeometry(e) {
				return this._update(e), this
			}
			static CreateGroundFromHeightMap(e) {
				throw ic("groundBuilder")
			}
			static ImportVertexData(t, i) {
				const s = e.Parse(t);
				i.setAllVerticesData(s, t.updatable)
			}
			constructor() {
				var t, i;
				this.ik = 0, this.metadata = {}, this._applyTo = (t = this._applyToCoroutine.bind(this), (...e) => su(t(...e), i)), this.ik = e._UniqueIDGenerator, e._UniqueIDGenerator++
			}
			static CreateDashedLines(e) {
				throw ic("linesBuilder")
			}
			_update(e, t, i) {
				return this.positions && e.updateVerticesData(eu.PositionKind, this.positions, t, i), this.normals && e.updateVerticesData(eu.NormalKind, this.normals, t, i), this.tangents && e.updateVerticesData(eu.TangentKind, this.tangents, t, i), this.uvs && e.updateVerticesData(eu.UVKind, this.uvs, t, i), this.uvs2 && e.updateVerticesData(eu.UV2Kind, this.uvs2, t, i), this.uvs3 && e.updateVerticesData(eu.UV3Kind, this.uvs3, t, i), this.uvs4 && e.updateVerticesData(eu.UV4Kind, this.uvs4, t, i), this.uvs5 && e.updateVerticesData(eu.UV5Kind, this.uvs5, t, i), this.uvs6 && e.updateVerticesData(eu.UV6Kind, this.uvs6, t, i), this.colors && e.updateVerticesData(eu.ColorKind, this.colors, t, i), this.matricesIndices && e.updateVerticesData(eu.MatricesIndicesKind, this.matricesIndices, t, i), this.matricesWeights && e.updateVerticesData(eu.MatricesWeightsKind, this.matricesWeights, t, i), this.matricesIndicesExtra && e.updateVerticesData(eu.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i), this.matricesWeightsExtra && e.updateVerticesData(eu.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i), this.indices && e.setIndices(this.indices, null), this
			}
			_validate() {
				if (!this.positions) throw new uu("Positions are required", au);
				const e = (e, t) => {
						const i = eu.DeduceStride(e);
						if (t.length % i != 0) throw new Error("The " + e + "s array count must be a multiple of " + i);
						return t.length / i
					},
					t = e(eu.PositionKind, this.positions),
					i = (i, s) => {
						const n = e(i, s);
						if (n !== t) throw new Error("The " + i + "s element count (" + n + ") does not match the positions count (" + t + ")")
					};
				this.normals && i(eu.NormalKind, this.normals), this.tangents && i(eu.TangentKind, this.tangents), this.uvs && i(eu.UVKind, this.uvs), this.uvs2 && i(eu.UV2Kind, this.uvs2), this.uvs3 && i(eu.UV3Kind, this.uvs3), this.uvs4 && i(eu.UV4Kind, this.uvs4), this.uvs5 && i(eu.UV5Kind, this.uvs5), this.uvs6 && i(eu.UV6Kind, this.uvs6), this.colors && i(eu.ColorKind, this.colors), this.matricesIndices && i(eu.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && i(eu.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && i(eu.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && i(eu.MatricesWeightsExtraKind, this.matricesWeightsExtra)
			}
			static CreateTorus(e) {
				throw ic("torusBuilder")
			}
			static ComputeNormals(e, t, i, s) {
				let n = 0,
					a = 0,
					r = 0,
					o = 0,
					l = 0,
					h = 0,
					c = 0,
					u = 0,
					m = 0,
					d = 0,
					f = 0,
					p = 0,
					_ = 0,
					g = 0,
					v = 0,
					y = 0,
					S = 0,
					E = 0,
					A = 0,
					b = 0,
					x = !1,
					M = !1,
					C = !1,
					T = !1,
					w = 1,
					R = 0,
					N = null;
				s && (x = !!s.facetNormals, M = !!s.facetPositions, C = !!s.facetPartitioning, w = !0 === s.useRightHandedSystem ? -1 : 1, R = s.ratio || 0, T = !!s.depthSort, N = s.distanceTo, T && void 0 === N && (N = Lc.Zero()));
				let I = 0,
					P = 0,
					k = 0,
					D = 0;
				for (C && s && s.bbSize && (I = s.subDiv.X * R / s.bbSize.x, P = s.subDiv.Y * R / s.bbSize.y, k = s.subDiv.Z * R / s.bbSize.z, D = s.subDiv.max * s.subDiv.max, s.facetPartitioning.length = 0), n = 0; n < e.length; n++) i[n] = 0;
				const O = t.length / 3 | 0;
				for (n = 0; n < O; n++) {
					if (p = 3 * t[3 * n], _ = p + 1, g = p + 2, v = 3 * t[3 * n + 1], y = v + 1, S = v + 2, E = 3 * t[3 * n + 2], A = E + 1, b = E + 2, a = e[p] - e[v], r = e[_] - e[y], o = e[g] - e[S], l = e[E] - e[v], h = e[A] - e[y], c = e[b] - e[S], u = w * (r * c - o * h), m = w * (o * l - a * c), d = w * (a * h - r * l), f = Math.sqrt(u * u + m * m + d * d), f = 0 === f ? 1 : f, u /= f, m /= f, d /= f, x && s && (s.facetNormals[n].x = u, s.facetNormals[n].y = m, s.facetNormals[n].z = d), M && s && (s.facetPositions[n].x = (e[p] + e[v] + e[E]) / 3, s.facetPositions[n].y = (e[_] + e[y] + e[A]) / 3, s.facetPositions[n].z = (e[g] + e[S] + e[b]) / 3), C && s) {
						const t = Math.floor((s.facetPositions[n].x - s.bInfo.minimum.x * R) * I),
							i = Math.floor((s.facetPositions[n].y - s.bInfo.minimum.y * R) * P),
							a = Math.floor((s.facetPositions[n].z - s.bInfo.minimum.z * R) * k),
							r = Math.floor((e[p] - s.bInfo.minimum.x * R) * I),
							o = Math.floor((e[_] - s.bInfo.minimum.y * R) * P),
							l = Math.floor((e[g] - s.bInfo.minimum.z * R) * k),
							h = Math.floor((e[v] - s.bInfo.minimum.x * R) * I),
							c = Math.floor((e[y] - s.bInfo.minimum.y * R) * P),
							u = Math.floor((e[S] - s.bInfo.minimum.z * R) * k),
							m = Math.floor((e[E] - s.bInfo.minimum.x * R) * I),
							d = Math.floor((e[A] - s.bInfo.minimum.y * R) * P),
							f = Math.floor((e[b] - s.bInfo.minimum.z * R) * k),
							x = r + s.subDiv.max * o + D * l,
							M = h + s.subDiv.max * c + D * u,
							C = m + s.subDiv.max * d + D * f,
							T = t + s.subDiv.max * i + D * a;
						s.facetPartitioning[T] = s.facetPartitioning[T] ? s.facetPartitioning[T] : new Array, s.facetPartitioning[x] = s.facetPartitioning[x] ? s.facetPartitioning[x] : new Array, s.facetPartitioning[M] = s.facetPartitioning[M] ? s.facetPartitioning[M] : new Array, s.facetPartitioning[C] = s.facetPartitioning[C] ? s.facetPartitioning[C] : new Array, s.facetPartitioning[x].push(n), M != x && s.facetPartitioning[M].push(n), C != M && C != x && s.facetPartitioning[C].push(n), T != x && T != M && T != C && s.facetPartitioning[T].push(n)
					}
					if (T && s && s.facetPositions) {
						const e = s.depthSortedFacets[n];
						e.ind = 3 * n, e.sqDistance = Lc.DistanceSquared(s.facetPositions[n], N)
					}
					i[p] += u, i[_] += m, i[g] += d, i[v] += u, i[y] += m, i[S] += d, i[E] += u, i[A] += m, i[b] += d
				}
				for (n = 0; n < i.length / 3; n++) u = i[3 * n], m = i[3 * n + 1], d = i[3 * n + 2], f = Math.sqrt(u * u + m * m + d * d), f = 0 === f ? 1 : f, u /= f, m /= f, d /= f, i[3 * n] = u, i[3 * n + 1] = m, i[3 * n + 2] = d
			}
			static _TransformVector4Normals(e, t, i = 0, s = e.length) {
				const n = Vc.Vector4[0],
					a = Vc.Vector4[1];
				for (let r = i; r < i + s; r += 4) Bc.FromArrayToRef(e, r, n), Bc.TransformNormalToRef(n, t, a), e[r] = a.x, e[r + 1] = a.y, e[r + 2] = a.z, e[r + 3] = a.w
			}
			static CreatePolyhedron(e) {
				throw ic("polyhedronBuilder")
			}
			static _TransformVector3Normals(e, t, i = 0, s = e.length) {
				const n = Vc.Vector3[0],
					a = Vc.Vector3[1];
				for (let r = i; r < i + s; r += 3) Lc.FromArrayToRef(e, r, n), Lc.TransformNormalToRef(n, t, a), e[r] = a.x, e[r + 1] = a.y, e[r + 2] = a.z
			}
			clone() {
				const t = this.serialize();
				return e.Parse(t)
			}
			static ExtractFromGeometry(t, i, s) {
				return e._ExtractFrom(t, i, s)
			}
			static CreateTiledPlane(e) {
				throw ic("tiledPlaneBuilder")
			}
		};

	function Cu() {
		return "undefined" != typeof window
	}

	function Tu() {
		return "undefined" != typeof navigator
	}

	function wu() {
		return "undefined" != typeof document
	}

	function Ru(e) {
		let t = "",
			i = e.firstChild;
		for (; i;) 3 === i.nodeType && (t += i.textContent), i = i.nextSibling;
		return t
	}
	Mu.FRONTSIDE = 0, Mu.BACKSIDE = 1, Mu.DOUBLESIDE = 2, Mu.DEFAULTSIDE = 0, Mu._UniqueIDGenerator = 0, Gh([ec.filter(((...[e]) => !Array.isArray(e)))], Mu, "_TransformVector3Coordinates", null), Gh([ec.filter(((...[e]) => !Array.isArray(e)))], Mu, "_TransformVector3Normals", null), Gh([ec.filter(((...[e]) => !Array.isArray(e)))], Mu, "_TransformVector4Normals", null), Gh([ec.filter(((...[e]) => !Array.isArray(e)))], Mu, "_FlipFaces", null);
	var Nu = (e, t, i) => e ? e.getClassName && "Mesh" === e.getClassName() ? null : !e.getClassName || "SubMesh" !== e.getClassName() && "PhysicsBody" !== e.getClassName() ? e.clone ? e.clone() : Array.isArray(e) ? e.slice() : i && "object" == typeof e ? {
		...e
	} : null : e.clone(t) : null;
	var Iu = class {
			static DeepCopy(e, t, i, s, n = !1) {
				const a = function(e) {
					const t = [];
					do {
						Object.getOwnPropertyNames(e).forEach((function(e) {
							-1 === t.indexOf(e) && t.push(e)
						}))
					} while (e = Object.getPrototypeOf(e));
					return t
				}(e);
				for (const r of a) {
					if ("_" === r[0] && (!s || -1 === s.indexOf(r))) continue;
					if (r.endsWith("Observable")) continue;
					if (i && -1 !== i.indexOf(r)) continue;
					const a = e[r],
						o = typeof a;
					if ("function" !== o) try {
						if ("object" === o)
							if (a instanceof Uint8Array) t[r] = Uint8Array.from(a);
							else if (a instanceof Array) {
							if (t[r] = [], a.length > 0)
								if ("object" == typeof a[0])
									for (let e = 0; e < a.length; e++) {
										const i = Nu(a[e], t, n); - 1 === t[r].indexOf(i) && t[r].push(i)
									} else t[r] = a.slice(0)
						} else t[r] = Nu(a, t, n);
						else t[r] = a
					} catch (e) {
						Qc.Warn(e.message)
					}
				}
			}
		},
		Pu = class {
			static get Now() {
				return Cu() && window.performance && window.performance.now ? window.performance.now() : Date.now()
			}
		};
	var ku = class e {
		static get IsCustomRequestAvailable() {
			return Object.keys(e.CustomRequestHeaders).length > 0 || e.CustomRequestModifiers.length > 0
		}
		set timeout(e) {
			this._xhr.timeout = e
		}
		send(t) {
			e.CustomRequestHeaders && this._injectCustomRequestHeaders(), this._xhr.send(t)
		}
		set responseType(e) {
			this._xhr.responseType = e
		}
		get readyState() {
			return this._xhr.readyState
		}
		get response() {
			return this._xhr.response
		}
		get responseURL() {
			return this._xhr.responseURL
		}
		addEventListener(e, t, i) {
			this._xhr.addEventListener(e, t, i)
		}
		_injectCustomRequestHeaders() {
			if (!this._shouldSkipRequestModifications(this._requestURL))
				for (const t in e.CustomRequestHeaders) {
					const i = e.CustomRequestHeaders[t];
					i && this._xhr.setRequestHeader(t, i)
				}
		}
		open(t, i) {
			for (const t of e.CustomRequestModifiers) {
				if (this._shouldSkipRequestModifications(i)) return;
				t(this._xhr, i)
			}
			i = (i = i.replace("file:http:", "http:")).replace("file:https:", "https:"), this._requestURL = i, this._xhr.open(t, i, !0)
		}
		get responseText() {
			return this._xhr.responseText
		}
		get responseType() {
			return this._xhr.responseType
		}
		get statusText() {
			return this._xhr.statusText
		}
		setRequestHeader(e, t) {
			this._xhr.setRequestHeader(e, t)
		}
		getResponseHeader(e) {
			return this._xhr.getResponseHeader(e)
		}
		get timeout() {
			return this._xhr.timeout
		}
		_shouldSkipRequestModifications(t) {
			return e.SkipRequestModificationForBabylonCDN && (t.includes("preview.babylonjs.com") || t.includes("cdn.babylonjs.com"))
		}
		get status() {
			return this._xhr.status
		}
		abort() {
			this._xhr.abort()
		}
		get onprogress() {
			return this._xhr.onprogress
		}
		removeEventListener(e, t, i) {
			this._xhr.removeEventListener(e, t, i)
		}
		constructor() {
			this._xhr = "undefined" != typeof _native && _native.XMLHttpRequest ? new _native.XMLHttpRequest : new XMLHttpRequest, this._requestURL = ""
		}
		set onprogress(e) {
			this._xhr.onprogress = e
		}
	};
	ku.CustomRequestHeaders = {}, ku.CustomRequestModifiers = new Array, ku.SkipRequestModificationForBabylonCDN = !0;
	var Du = class {};
	Du.FilesToLoad = {};
	var Ou = e => {
			const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
			let i, s, n, a, r, o, l, h = "",
				c = 0;
			const u = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
			for (; c < u.length;) i = u[c++], s = c < u.length ? u[c++] : Number.NaN, n = c < u.length ? u[c++] : Number.NaN, a = i >> 2, r = (3 & i) << 4 | s >> 4, o = (15 & s) << 2 | n >> 6, l = 63 & n, isNaN(s) ? o = l = 64 : isNaN(n) && (l = 64), h += t.charAt(a) + t.charAt(r) + t.charAt(o) + t.charAt(l);
			return h
		},
		Fu = e => atob(e),
		Lu = class {
			constructor() {
				this.children = []
			}
			isValid(e) {
				return !0
			}
			process(e, t) {
				let i = "";
				if (this.line) {
					let s = this.line;
					const n = t.processor;
					if (n) {
						n.lineProcessor && (s = n.lineProcessor(s, t.isFragment, t.processingContext));
						const i = t.processor?.attributeKeywordName ?? "attribute",
							a = t.isFragment && t.processor?.varyingFragmentKeywordName ? t.processor?.varyingFragmentKeywordName : !t.isFragment && t.processor?.varyingVertexKeywordName ? t.processor?.varyingVertexKeywordName : "varying";
						if (!t.isFragment && n.attributeProcessor && this.line.startsWith(i)) s = n.attributeProcessor(this.line, e, t.processingContext);
						else if (n.varyingProcessor && (n.varyingCheck?.(this.line, t.isFragment) || !n.varyingCheck && this.line.startsWith(a))) s = n.varyingProcessor(this.line, t.isFragment, e, t.processingContext);
						else if (n.uniformProcessor && n.uniformRegexp && n.uniformRegexp.test(this.line)) t.lookForClosingBracketForUniformBuffer || (s = n.uniformProcessor(this.line, t.isFragment, e, t.processingContext));
						else if (n.uniformBufferProcessor && n.uniformBufferRegexp && n.uniformBufferRegexp.test(this.line)) t.lookForClosingBracketForUniformBuffer || (s = n.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0);
						else if (n.textureProcessor && n.textureRegexp && n.textureRegexp.test(this.line)) s = n.textureProcessor(this.line, t.isFragment, e, t.processingContext);
						else if ((n.uniformProcessor || n.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer) {
							/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line) ? n.uniformProcessor && (s = n.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : n.uniformBufferProcessor && (s = n.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0)
						}
						t.lookForClosingBracketForUniformBuffer && -1 !== this.line.indexOf("}") && (t.lookForClosingBracketForUniformBuffer = !1, n.endOfUniformBufferProcessor && (s = n.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext)))
					}
					i += s + "\n"
				}
				return this.children.forEach((s => {
					i += s.process(e, t)
				})), this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"), i
			}
		},
		Bu = class {
			set lines(e) {
				this._lines.length = 0;
				for (const t of e) {
					if (!t || "\r" === t) continue;
					if ("#" === t[0]) {
						this._lines.push(t);
						continue
					}
					const e = t.trim();
					if (!e) continue;
					if (e.startsWith("//")) {
						this._lines.push(t);
						continue
					}
					const i = e.indexOf(";");
					if (-1 === i) this._lines.push(e);
					else if (i === e.length - 1) e.length > 1 && this._lines.push(e);
					else {
						const e = t.split(";");
						for (let t = 0; t < e.length; t++) {
							let i = e[t];
							i && (i = i.trim(), i && this._lines.push(i + (t !== e.length - 1 ? ";" : "")))
						}
					}
				}
			}
			get canRead() {
				return this.lineIndex < this._lines.length - 1
			}
			get currentLine() {
				return this._lines[this.lineIndex]
			}
			constructor() {
				this._lines = []
			}
		},
		Gu = class extends Lu {
			process(e, t) {
				for (let i = 0; i < this.children.length; i++) {
					const s = this.children[i];
					if (s.isValid(e)) return s.process(e, t)
				}
				return ""
			}
		},
		Hu = class extends Lu {
			isValid(e) {
				return this.testExpression.isTrue(e)
			}
		},
		Uu = class e {
			static ClearCache() {
				const t = Array.from(e._InfixToPostfixCache.entries()).sort(((e, t) => e[1].accessTime - t[1].accessTime));
				for (let i = 0; i < e.InfixToPostfixCacheCleanupSize; i++) e._InfixToPostfixCache.delete(t[i][0])
			}
			isTrue(e) {
				return !0
			}
			static infixToPostfix(t) {
				const i = e._InfixToPostfixCache.get(t);
				if (i) return i.accessTime = Date.now(), i.result;
				if (!(t.includes("&&") || t.includes("||") || t.includes(")") || t.includes("("))) return [t];
				const s = [];
				let n = -1;
				const a = () => {
						c = c.trim(), "" !== c && (s.push(c), c = "")
					},
					r = t => {
						n < e._Stack.length - 1 && (e._Stack[++n] = t)
					},
					o = () => e._Stack[n],
					l = () => -1 === n ? "!!INVALID EXPRESSION!!" : e._Stack[n--];
				let h = 0,
					c = "";
				for (; h < t.length;) {
					const i = t.charAt(h),
						u = h < t.length - 1 ? t.substr(h, 2) : "";
					if ("(" === i) c = "", r(i);
					else if (")" === i) {
						for (a(); - 1 !== n && "(" !== o();) s.push(l());
						l()
					} else if (e._OperatorPriority[u] > 1) {
						for (a(); - 1 !== n && e._OperatorPriority[o()] >= e._OperatorPriority[u];) s.push(l());
						r(u), h++
					} else c += i;
					h++
				}
				for (a(); - 1 !== n;) "(" === o() ? l() : s.push(l());
				return e._InfixToPostfixCache.size >= e.InfixToPostfixCacheLimitSize && e.ClearCache(), e._InfixToPostfixCache.set(t, {
					result: s,
					accessTime: Date.now()
				}), s
			}
			static postfixToInfix(t) {
				const i = [];
				for (const s of t)
					if (void 0 === e._OperatorPriority[s]) i.push(s);
					else {
						const e = i[i.length - 1],
							t = i[i.length - 2];
						i.length -= 2, i.push(`(${t}${s}${e})`)
					} return i[i.length - 1]
			}
		};
	Uu.InfixToPostfixCacheLimitSize = 5e4, Uu.InfixToPostfixCacheCleanupSize = 25e3, Uu._InfixToPostfixCache = new Map, Uu._OperatorPriority = {
		")": 0,
		"(": 1,
		"||": 2,
		"&&": 3
	}, Uu._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
	var Vu = class extends Uu {
			isTrue(e) {
				let t = void 0 !== e[this.define];
				return this.not && (t = !t), t
			}
			constructor(e, t = !1) {
				super(), this.define = e, this.not = t
			}
		},
		Wu = class extends Uu {
			isTrue(e) {
				return this.leftOperand.isTrue(e) || this.rightOperand.isTrue(e)
			}
		},
		zu = class extends Uu {
			isTrue(e) {
				return this.leftOperand.isTrue(e) && this.rightOperand.isTrue(e)
			}
		},
		Xu = class extends Uu {
			constructor(e, t, i) {
				super(), this.define = e, this.operand = t, this.testValue = i
			}
			isTrue(e) {
				let t = e[this.define];
				void 0 === t && (t = this.define);
				let i = !1;
				const s = parseInt(t),
					n = parseInt(this.testValue);
				switch (this.operand) {
					case ">":
						i = s > n;
						break;
					case "<":
						i = s < n;
						break;
					case "<=":
						i = s <= n;
						break;
					case ">=":
						i = s >= n;
						break;
					case "==":
						i = s === n;
						break;
					case "!=":
						i = s !== n
				}
				return i
			}
		},
		Yu = {};

	function ju(e, t, i = "") {
		return i + (t ? t + "\n" : "") + e
	}

	function Ku(e, t, i, s, n, a, r) {
		const o = r || Yu.loadFile;
		if (o) {
			return o(e, t, i, s, n, a)
		}
		throw ic("FileTools")
	}

	function $u(e, t, i, s) {
		if (e) return t ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, i ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER, void(s ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS);
		{
			let e = "";
			return t && (e += "#define IS_NDC_HALF_ZRANGE"), i && (e && (e += "\n"), e += "#define USE_REVERSE_DEPTHBUFFER"), s && (e && (e += "\n"), e += "#define USE_EXACT_SRGB_CONVERSIONS"), e
		}
	}
	var Ju = /defined\s*?\((.+?)\)/g,
		qu = /defined\s*?\[(.+?)\]/g,
		Qu = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,
		Zu = /__decl__/,
		em = /light\{X\}.(\w*)/g,
		tm = /\{X\}/g,
		im = [],
		sm = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;

	function nm(e, t, i, s) {
		t.processor?.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), hm(e, t, (e => {
			t.processCodeAfterIncludes && (e = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", e, t.defines));
			const n = function(e, t, i) {
				let s = function(e, t) {
					if (t.processor?.noPrecision) return e;
					const i = t.shouldUseHighPrecisionShader; - 1 === e.indexOf("precision highp float") ? e = i ? "precision highp float;\n" + e : "precision mediump float;\n" + e : i || (e = e.replace("precision highp float", "precision mediump float"));
					return e
				}(e, t);
				if (!t.processor) return s;
				if (0 === t.processor.shaderLanguage && -1 !== s.indexOf("#version 3") && (s = s.replace("#version 300 es", ""), !t.processor.parseGLES3)) return s;
				const n = t.defines,
					a = function(e, t) {
						const i = e.defines,
							s = {};
						for (const e of i) {
							const t = e.replace("#define", "").replace(";", "").trim().split(" ");
							s[t[0]] = t.length > 1 ? t[1] : ""
						}
						0 === e.processor?.shaderLanguage && (s.GL_ES = "true");
						return s.__VERSION__ = e.version, s[e.platformName] = "true", $u(s, t?.isNDCHalfZRange, t?.useReverseDepthBuffer, t?.useExactSrgbConversions), s
					}(t, i);
				t.processor.preProcessor && (s = t.processor.preProcessor(s, n, a, t.isFragment, t.processingContext));
				s = function(e, t, i) {
					const s = new Lu,
						n = new Bu;
					return n.lineIndex = -1, n.lines = e.split("\n"), lm(n, s), s.process(t, i)
				}(s, a, t), t.processor.postProcessor && (s = t.processor.postProcessor(s, n, t.isFragment, t.processingContext, i ? {
					drawBuffersExtensionDisabled: !i.getCaps().drawBuffersExtension
				} : {}));
				i?._features.needShaderCodeInlining && (s = i.inlineShaderCode(s));
				return s
			}(e, t, s);
			i(n, e)
		}))
	}

	function am(e) {
		const t = /defined\((.+)\)/.exec(e);
		if (t && t.length) return new Vu(t[1].trim(), "!" === e[0]);
		const i = ["==", "!=", ">=", "<=", "<", ">"];
		let s = "",
			n = 0;
		for (s of i)
			if (n = e.indexOf(s), n > -1) break;
		if (-1 === n) return new Vu(e);
		const a = e.substring(0, n).trim(),
			r = e.substring(n + s.length).trim();
		return new Xu(a, s, r)
	}

	function rm(e, t) {
		const i = new Hu,
			s = e.substring(0, t);
		let n = e.substring(t);
		return n = n.substring(0, (n.indexOf("//") + 1 || n.length + 1) - 1).trim(), i.testExpression = "#ifdef" === s ? new Vu(n) : "#ifndef" === s ? new Vu(n, !0) : function(e) {
			e = e.replace(Ju, "defined[$1]");
			const t = Uu.infixToPostfix(e),
				i = [];
			for (const e of t)
				if ("||" !== e && "&&" !== e) i.push(e);
				else if (i.length >= 2) {
				let t = i[i.length - 1],
					s = i[i.length - 2];
				i.length -= 2;
				const n = "&&" == e ? new zu : new Wu;
				"string" == typeof t && (t = t.replace(qu, "defined($1)")), "string" == typeof s && (s = s.replace(qu, "defined($1)")), n.leftOperand = "string" == typeof s ? am(s) : s, n.rightOperand = "string" == typeof t ? am(t) : t, i.push(n)
			}
			let s = i[i.length - 1];
			return "string" == typeof s && (s = s.replace(qu, "defined($1)")), "string" == typeof s ? am(s) : s
		}(n), i
	}

	function om(e, t, i) {
		let s = e.currentLine;
		for (; lm(e, i);) {
			s = e.currentLine;
			const n = s.substring(0, 5).toLowerCase();
			if ("#else" === n) {
				const i = new Lu;
				return t.children.push(i), void lm(e, i)
			}
			if ("#elif" === n) {
				const e = rm(s, 5);
				t.children.push(e), i = e
			}
		}
	}

	function lm(e, t) {
		for (; e.canRead;) {
			e.lineIndex++;
			const i = e.currentLine;
			if (i.indexOf("#") >= 0) {
				const s = sm.exec(i);
				if (s && s.length) {
					switch (s[0]) {
						case "#ifdef": {
							const s = new Gu;
							t.children.push(s);
							const n = rm(i, 6);
							s.children.push(n), om(e, s, n);
							break
						}
						case "#else":
						case "#elif":
							return !0;
						case "#endif":
							return !1;
						case "#ifndef": {
							const s = new Gu;
							t.children.push(s);
							const n = rm(i, 7);
							s.children.push(n), om(e, s, n);
							break
						}
						case "#if": {
							const s = new Gu,
								n = rm(i, 3);
							t.children.push(s), s.children.push(n), om(e, s, n);
							break
						}
					}
					continue
				}
			}
			const s = new Lu;
			if (s.line = i, t.children.push(s), "#" === i[0] && "d" === i[1]) {
				const e = i.replace(";", "").split(" ");
				s.additionalDefineKey = e[1], 3 === e.length && (s.additionalDefineValue = e[2])
			}
		}
		return !1
	}

	function hm(e, t, i) {
		let s;
		for (im.length = 0; null !== (s = Qu.exec(e));) im.push(s);
		let n = String(e),
			a = [e],
			r = !1;
		for (const e of im) {
			let s = e[1];
			if (-1 !== s.indexOf("__decl__") && (s = s.replace(Zu, ""), t.supportsUniformBuffers && (s = s.replace("Vertex", "Ubo").replace("Fragment", "Ubo")), s += "Declaration"), !t.includesShadersStore[s]) {
				const e = t.shadersRepository + "ShadersInclude/" + s + ".fx";
				return void cm.loadFile(e, (e => {
					t.includesShadersStore[s] = e, hm(a.join(""), t, i)
				}))
			} {
				let i = t.includesShadersStore[s];
				if (e[2]) {
					const t = e[3].split(",");
					for (let e = 0; e < t.length; e += 2) {
						const s = new RegExp(t[e], "g"),
							n = t[e + 1];
						i = i.replace(s, n)
					}
				}
				if (e[4]) {
					const s = e[5];
					if (-1 !== s.indexOf("..")) {
						const e = s.split(".."),
							n = parseInt(e[0]);
						let a = parseInt(e[1]),
							r = i.slice(0);
						i = "", isNaN(a) && (a = t.indexParameters[e[1]]);
						for (let e = n; e < a; e++) t.supportsUniformBuffers || (r = r.replace(em, ((e, t) => t + "{X}"))), i += r.replace(tm, e.toString()) + "\n"
					} else t.supportsUniformBuffers || (i = i.replace(em, ((e, t) => t + "{X}"))), i = i.replace(tm, s)
				}
				const n = [];
				for (const t of a) {
					const s = t.split(e[0]);
					for (let e = 0; e < s.length - 1; e++) n.push(s[e]), n.push(i);
					n.push(s[s.length - 1])
				}
				a = n, r = r || i.indexOf("#include<") >= 0 || i.indexOf("#include <") >= 0
			}
		}
		im.length = 0, n = a.join(""), r ? hm(n.toString(), t, i) : i(n)
	}
	var cm = {
			loadFile: (e, t, i, s, n, a) => {
				throw ic("FileTools")
			}
		},
		um = class {
			static SetImmediate(e) {
				Cu() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1)
			}
		};
	h();
	var mm = class {
			_cacheFloat2(e, t, i) {
				let s = this._valueCache[e];
				if (!s || 2 !== s.length) return s = [t, i], this._valueCache[e] = s, !0;
				let n = !1;
				return s[0] !== t && (s[0] = t, n = !0), s[1] !== i && (s[1] = i, n = !0), n
			}
			setInt(e, t) {
				const i = this._valueCache[e];
				void 0 !== i && i === t || this.engine.setInt(this._uniforms[e], t) && (this._valueCache[e] = t)
			}
			_cacheFloat4(e, t, i, s, n) {
				let a = this._valueCache[e];
				if (!a || 4 !== a.length) return a = [t, i, s, n], this._valueCache[e] = a, !0;
				let r = !1;
				return a[0] !== t && (a[0] = t, r = !0), a[1] !== i && (a[1] = i, r = !0), a[2] !== s && (a[2] = s, r = !0), a[3] !== n && (a[3] = n, r = !0), r
			}
			setArray(e, t) {
				this._valueCache[e] = null, this.engine.setArray(this._uniforms[e], t)
			}
			_cacheMatrix(e, t) {
				const i = this._valueCache[e],
					s = t.updateFlag;
				return (void 0 === i || i !== s) && (this._valueCache[e] = s, !0)
			}
			setArray4(e, t) {
				this._valueCache[e] = null, this.engine.setArray4(this._uniforms[e], t)
			}
			setMatrix3x3(e, t) {
				this._valueCache[e] = null, this.engine.setMatrix3x3(this._uniforms[e], t)
			}
			setInt2(e, t, i) {
				this._cacheFloat2(e, t, i) && (this.engine.setInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
			}
			setUIntArray4(e, t) {
				this._valueCache[e] = null, this.engine.setUIntArray4(this._uniforms[e], t)
			}
			setArray3(e, t) {
				this._valueCache[e] = null, this.engine.setArray3(this._uniforms[e], t)
			}
			setQuaternion(e, t) {
				this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null))
			}
			setIntArray3(e, t) {
				this._valueCache[e] = null, this.engine.setIntArray3(this._uniforms[e], t)
			}
			setColor4(e, t, i) {
				this._cacheFloat4(e, t.r, t.g, t.b, i) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, i) || (this._valueCache[e] = null))
			}
			_handlesSpectorRebuildCallback(e) {
				e && this.program && e(this.program)
			}
			setUIntArray(e, t) {
				this._valueCache[e] = null, this.engine.setUIntArray(this._uniforms[e], t)
			}
			setMatrix2x2(e, t) {
				this._valueCache[e] = null, this.engine.setMatrix2x2(this._uniforms[e], t)
			}
			setMatrix(e, t) {
				this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.asArray()) || (this._valueCache[e] = null))
			}
			setFloat3(e, t, i, s) {
				this._cacheFloat3(e, t, i, s) && (this.engine.setFloat3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
			}
			setFloat(e, t) {
				const i = this._valueCache[e];
				void 0 !== i && i === t || this.engine.setFloat(this._uniforms[e], t) && (this._valueCache[e] = t)
			}
			setFloat4(e, t, i, s, n) {
				this._cacheFloat4(e, t, i, s, n) && (this.engine.setFloat4(this._uniforms[e], t, i, s, n) || (this._valueCache[e] = null))
			}
			_fillEffectInformation(e, t, i, s, n, a, r, o) {
				const l = this.engine;
				if (l.supportsUniformBuffers)
					for (const i in t) e.bindUniformBlock(i, t[i]);
				let h;
				for (this.engine.getUniforms(this, i).forEach(((e, t) => {
						s[i[t]] = e
					})), this._uniforms = s, h = 0; h < n.length; h++) {
					null == e.getUniform(n[h]) && (n.splice(h, 1), h--)
				}
				n.forEach(((e, t) => {
					a[e] = t
				}));
				for (const e of l.getAttributes(this, r)) o.push(e)
			}
			_getVertexShaderCode() {
				return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null
			}
			setVector2(e, t) {
				this._cacheFloat2(e, t.x, t.y) && (this.engine.setFloat2(this._uniforms[e], t.x, t.y) || (this._valueCache[e] = null))
			}
			setMatrices(e, t) {
				t && (this._valueCache[e] = null, this.engine.setMatrices(this._uniforms[e], t))
			}
			setIntArray(e, t) {
				this._valueCache[e] = null, this.engine.setIntArray(this._uniforms[e], t)
			}
			setUInt(e, t) {
				const i = this._valueCache[e];
				void 0 !== i && i === t || this.engine.setUInt(this._uniforms[e], t) && (this._valueCache[e] = t)
			}
			get isReady() {
				return !!this.program && (!this.isParallelCompiled || this.engine._isRenderingStateCompiled(this))
			}
			_getFragmentShaderCode() {
				return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null
			}
			constructor() {
				this._valueCache = {}, this.vertexCompilationError = null, this.fragmentCompilationError = null, this.programLinkError = null, this.programValidationError = null, this._isDisposed = !1
			}
			setUIntArray3(e, t) {
				this._valueCache[e] = null, this.engine.setUIntArray3(this._uniforms[e], t)
			}
			setVector4(e, t) {
				this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null))
			}
			setFloat2(e, t, i) {
				this._cacheFloat2(e, t, i) && (this.engine.setFloat2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
			}
			setIntArray4(e, t) {
				this._valueCache[e] = null, this.engine.setIntArray4(this._uniforms[e], t)
			}
			get isAsync() {
				return this.isParallelCompiled
			}
			setArray2(e, t) {
				this._valueCache[e] = null, this.engine.setArray2(this._uniforms[e], t)
			}
			dispose() {
				this._uniforms = {}, this._isDisposed = !0
			}
			setEngine(e) {
				this.engine = e
			}
			setUInt4(e, t, i, s, n) {
				this._cacheFloat4(e, t, i, s, n) && (this.engine.setUInt4(this._uniforms[e], t, i, s, n) || (this._valueCache[e] = null))
			}
			setVector3(e, t) {
				this._cacheFloat3(e, t.x, t.y, t.z) && (this.engine.setFloat3(this._uniforms[e], t.x, t.y, t.z) || (this._valueCache[e] = null))
			}
			setIntArray2(e, t) {
				this._valueCache[e] = null, this.engine.setIntArray2(this._uniforms[e], t)
			}
			setDirectColor4(e, t) {
				this._cacheFloat4(e, t.r, t.g, t.b, t.a) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, t.a) || (this._valueCache[e] = null))
			}
			setColor3(e, t) {
				this._cacheFloat3(e, t.r, t.g, t.b) && (this.engine.setFloat3(this._uniforms[e], t.r, t.g, t.b) || (this._valueCache[e] = null))
			}
			setUIntArray2(e, t) {
				this._valueCache[e] = null, this.engine.setUIntArray2(this._uniforms[e], t)
			}
			_cacheFloat3(e, t, i, s) {
				let n = this._valueCache[e];
				if (!n || 3 !== n.length) return n = [t, i, s], this._valueCache[e] = n, !0;
				let a = !1;
				return n[0] !== t && (n[0] = t, a = !0), n[1] !== i && (n[1] = i, a = !0), n[2] !== s && (n[2] = s, a = !0), a
			}
			setInt4(e, t, i, s, n) {
				this._cacheFloat4(e, t, i, s, n) && (this.engine.setInt4(this._uniforms[e], t, i, s, n) || (this._valueCache[e] = null))
			}
			setUInt2(e, t, i) {
				this._cacheFloat2(e, t, i) && (this.engine.setUInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
			}
			setInt3(e, t, i, s) {
				this._cacheFloat3(e, t, i, s) && (this.engine.setInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
			}
			setUInt3(e, t, i, s) {
				this._cacheFloat3(e, t, i, s) && (this.engine.setUInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
			}
		},
		dm = new WeakMap,
		fm = {
			_webGLVersion: 2,
			cachedPipelines: {}
		};

	function pm(e) {
		let t = dm.get(e);
		if (!t) {
			if (!e) return fm;
			t = {
				_webGLVersion: e.TEXTURE_BINDING_3D ? 2 : 1,
				_context: e,
				cachedPipelines: {}
			}, dm.set(e, t)
		}
		return t
	}

	function _m(e, t, i, s, n, a) {
		const r = pm(s);
		a || (a = r._createShaderProgramInjection ?? vm);
		return a(e, Em(t, "vertex", s, r._contextWasLost), Em(i, "fragment", s, r._contextWasLost), s, n, r.validateShaderPrograms)
	}

	function gm(e, t, i, s, n, a = null, r) {
		const o = pm(n);
		r || (r = o._createShaderProgramInjection ?? vm);
		const l = o._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
		return r(e, Sm(t, "vertex", s, l, n, o._contextWasLost), Sm(i, "fragment", s, l, n, o._contextWasLost), n, a, o.validateShaderPrograms)
	}

	function vm(e, t, i, s, n = null, a) {
		const r = s.createProgram();
		if (e.program = r, !r) throw new Error("Unable to create program");
		return s.attachShader(r, t), s.attachShader(r, i), s.linkProgram(r), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || ym(e, s, a), r
	}

	function ym(e, t, i) {
		const s = e.context,
			n = e.vertexShader,
			a = e.fragmentShader,
			r = e.program;
		if (!s.getProgramParameter(r, s.LINK_STATUS)) {
			if (!t.getShaderParameter(n, t.COMPILE_STATUS)) {
				const i = t.getShaderInfoLog(n);
				if (i) throw e.vertexCompilationError = i, new Error("VERTEX SHADER " + i)
			}
			if (!t.getShaderParameter(a, t.COMPILE_STATUS)) {
				const i = t.getShaderInfoLog(a);
				if (i) throw e.fragmentCompilationError = i, new Error("FRAGMENT SHADER " + i)
			}
			const i = s.getProgramInfoLog(r);
			if (i) throw e.programLinkError = i, new Error(i)
		}
		if (i) {
			s.validateProgram(r);
			if (!s.getProgramParameter(r, s.VALIDATE_STATUS)) {
				const t = s.getProgramInfoLog(r);
				if (t) throw e.programValidationError = t, new Error(t)
			}
		}
		s.deleteShader(n), s.deleteShader(a), e.vertexShader = void 0, e.fragmentShader = void 0, e.onCompiled && (e.onCompiled(), e.onCompiled = void 0)
	}

	function Sm(e, t, i, s, n, a) {
		return Em(ju(e, i, s), t, n, a)
	}

	function Em(e, t, i, s) {
		const n = i.createShader("vertex" === t ? i.VERTEX_SHADER : i.FRAGMENT_SHADER);
		if (!n) {
			let e = i.NO_ERROR,
				n = i.NO_ERROR;
			for (;
				(n = i.getError()) !== i.NO_ERROR;) e = n;
			throw new Error(`Something went wrong while creating a gl ${t} shader object. gl error=${e}, gl isContextLost=${i.isContextLost()}, _contextWasLost=${s}`)
		}
		return i.shaderSource(n, e), i.compileShader(n), n
	}

	function Am(e) {
		const t = e._name,
			i = e.context;
		if (t && i) {
			const e = pm(i),
				s = e.cachedPipelines[t];
			s?.dispose(), delete e.cachedPipelines[t]
		}
	}

	function bm(t, i, s, n, a, r) {
		if ("undefined" != typeof HTMLElement && t instanceof HTMLElement) {
			return void n(Ru(t))
		}
		if ("source:" === t.substr(0, 7)) return void n(t.substr(7));
		if ("base64:" === t.substr(0, 7)) {
			return void n(window.atob(t.substr(7)))
		}
		const o = e.GetShadersStore(a);
		if (o[t + i + "Shader"]) return void n(o[t + i + "Shader"]);
		if (s && o[t + s + "Shader"]) return void n(o[t + s + "Shader"]);
		let l;
		if (l = "." === t[0] || "/" === t[0] || t.indexOf("http") > -1 ? t : e.GetShadersRepository(a) + t, !(r = r || Ku)) throw new Error("loadFileInjection is not defined");
		r(l + "." + i.toLowerCase() + ".fx", n)
	}
	h();
	var xm = class t {
		allFallbacksProcessed() {
			return this._allFallbacksProcessed
		}
		get rawFragmentSourceCode() {
			return this._rawFragmentSourceCode
		}
		setArray3(e, t) {
			return this._pipelineContext.setArray3(e, t), this
		}
		static RegisterShader(t, i, s, n = 0) {
			i && (e.GetShadersStore(n)[`${t}PixelShader`] = i), s && (e.GetShadersStore(n)[`${t}VertexShader`] = s)
		}
		getSamplers() {
			return this._samplerList
		}
		setVector3(e, t) {
			return this._pipelineContext.setVector3(e, t), this
		}
		setFloat3(e, t, i, s) {
			return this._pipelineContext.setFloat3(e, t, i, s), this
		}
		setUInt(e, t) {
			return this._pipelineContext.setUInt(e, t), this
		}
		setQuaternion(e, t) {
			return this._pipelineContext.setQuaternion(e, t), this
		}
		static ResetCache() {
			t._BaseCache = {}
		}
		executeWhenCompiled(e) {
			this.isReady() ? e(this) : (this.onCompileObservable.add((t => {
				e(t)
			})), this._pipelineContext && !this._pipelineContext.isAsync || setTimeout((() => {
				this._checkIsReady(null)
			}), 16))
		}
		setTexture(e, t) {
			this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e)
		}
		setVector4(e, t) {
			return this._pipelineContext.setVector4(e, t), this
		}
		getPipelineGenerationOptions() {
			return {
				platformName: this._engine.shaderPlatformName,
				shaderLanguage: this._shaderLanguage,
				shaderNameOrContent: this.name,
				key: this._key,
				defines: this.defines.split("\n"),
				addGlobalDefines: !1,
				extendedProcessingOptions: {
					indexParameters: this._indexParameters,
					isNDCHalfZRange: this._engine.isNDCHalfZRange,
					useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
					supportsUniformBuffers: this._engine.supportsUniformBuffers
				},
				extendedCreatePipelineOptions: {
					transformFeedbackVaryings: this._transformFeedbackVaryings,
					createAsRaw: !(!this._vertexSourceCodeOverride || !this._fragmentSourceCodeOverride)
				}
			}
		}
		_processCompilationErrors(e, i = null) {
			this._compilationError = e.message;
			const s = this._attributesNames,
				n = this._fallbacks;
			if (Qc.Error("Unable to compile effect:"), Qc.Error("Uniforms: " + this._uniformsNames.map((function(e) {
					return " " + e
				}))), Qc.Error("Attributes: " + s.map((function(e) {
					return " " + e
				}))), Qc.Error("Defines:\n" + this.defines), t.LogShaderCodeOnCompilationError) {
				let e = null,
					t = null,
					i = null;
				this._pipelineContext?._getVertexShaderCode() && ([i, e] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1), i && (Qc.Error("Vertex code:"), Qc.Error(i))), this._pipelineContext?._getFragmentShaderCode() && ([i, t] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, !0), i && (Qc.Error("Fragment code:"), Qc.Error(i))), e && Qc.Error(e), t && Qc.Error(t)
			}
			Qc.Error("Error: " + this._compilationError);
			const a = () => {
				this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this)
			};
			i && (this._pipelineContext = i, this._isReady = !0, a()), n ? (this._pipelineContext = null, n.hasMoreFallbacks ? (this._allFallbacksProcessed = !1, Qc.Error("Trying next fallback."), this.defines = n.reduce(this.defines, this), this._prepareEffect()) : (this._allFallbacksProcessed = !0, a(), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh())) : (this._allFallbacksProcessed = !0, i || a())
		}
		setMatrix(e, t) {
			return this._pipelineContext.setMatrix(e, t), this
		}
		get key() {
			return this._key
		}
		getUniformBuffersNames() {
			return this._uniformBuffersNamesList
		}
		setFloatArray3(e, t) {
			return this._pipelineContext.setArray3(e, t), this
		}
		getAttributesNames() {
			return this._attributesNames
		}
		setUIntArray3(e, t) {
			return this._pipelineContext.setUIntArray3(e, t), this
		}
		setArray4(e, t) {
			return this._pipelineContext.setArray4(e, t), this
		}
		getAttributeLocationByName(e) {
			return this._attributeLocationByName[e]
		}
		getUniformNames() {
			return this._uniformsNames
		}
		setIntArray2(e, t) {
			return this._pipelineContext.setIntArray2(e, t), this
		}
		setFloatArray(e, t) {
			return this._pipelineContext.setArray(e, t), this
		}
		setFloat(e, t) {
			return this._pipelineContext.setFloat(e, t), this
		}
		setUInt4(e, t, i, s, n) {
			return this._pipelineContext.setUInt4(e, t, i, s, n), this
		}
		get fragmentSourceCode() {
			return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode
		}
		getCompilationError() {
			return this._compilationError
		}
		setInt(e, t) {
			return this._pipelineContext.setInt(e, t), this
		}
		setIntArray4(e, t) {
			return this._pipelineContext.setIntArray4(e, t), this
		}
		bindUniformBuffer(e, i) {
			const s = this._uniformBuffersNames[i];
			void 0 === s || t._BaseCache[s] === e && this._engine._features.useUBOBindingCache || (t._BaseCache[s] = e, this._engine.bindUniformBufferBase(e, s, i))
		}
		getUniform(e) {
			return this._uniforms[e]
		}
		getEngine() {
			return this._engine
		}
		setIntArray(e, t) {
			return this._pipelineContext.setIntArray(e, t), this
		}
		setMatrix2x2(e, t) {
			return this._pipelineContext.setMatrix2x2(e, t), this
		}
		setUIntArray4(e, t) {
			return this._pipelineContext.setUIntArray4(e, t), this
		}
		get vertexSourceCode() {
			return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode
		}
		setTextureArray(e, t) {
			const i = e + "Ex";
			if (-1 === this._samplerList.indexOf(i + "0")) {
				const s = this._samplerList.indexOf(e);
				for (let e = 1; e < t.length; e++) {
					const t = i + (e - 1).toString();
					this._samplerList.splice(s + e, 0, t)
				}
				let n = 0;
				for (const e of this._samplerList) this._samplers[e] = n, n += 1
			}
			this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e)
		}
		setFloatArray2(e, t) {
			return this._pipelineContext.setArray2(e, t), this
		}
		setColor4(e, t, i) {
			return this._pipelineContext.setColor4(e, t, i), this
		}
		_isReadyInternal() {
			return !!this._isReady || !!this._pipelineContext && this._pipelineContext.isReady
		}
		setUInt2(e, t, i) {
			return this._pipelineContext.setUInt2(e, t, i), this
		}
		getUniformIndex(e) {
			return this._uniformsNames.indexOf(e)
		}
		setInt4(e, t, i, s, n) {
			return this._pipelineContext.setInt4(e, t, i, s, n), this
		}
		setUIntArray(e, t) {
			return this._pipelineContext.setUIntArray(e, t), this
		}
		static set ShadersRepository(t) {
			e.ShadersRepository = t
		}
		get fragmentSourceCodeBeforeMigration() {
			return this._fragmentSourceCodeBeforeMigration
		}
		_getShaderCodeAndErrorLine(e, t, i) {
			const s = i ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
			let n = null;
			if (t && e) {
				const a = t.match(s);
				if (a && 2 === a.length) {
					const t = parseInt(a[1]),
						s = e.split("\n", -1);
					s.length >= t && (n = `Offending line [${t}] in ${i?"fragment":"vertex"} code: ${s[t-1]}`)
				}
			}
			return [e, n]
		}
		_onRenderingStateCompiled(e) {
			if (this._pipelineContext = e, this._pipelineContext.setEngine(this._engine), this._attributes = [], this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, this._attributesNames, this._attributes), this._attributesNames)
				for (let e = 0; e < this._attributesNames.length; e++) {
					const t = this._attributesNames[e];
					this._attributeLocationByName[t] = this._attributes[e]
				}
			this._engine.bindSamplers(this), this._compilationError = "", this._isReady = !0, this.onCompiled && this.onCompiled(this), this.onCompileObservable.notifyObservers(this), this.onCompileObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh()
		}
		_processShaderCode(t = null, i = !1, s = null) {
			this._processingContext = s || this._engine._getShaderProcessingContext(this._shaderLanguage, !1);
			! function(e, t, i, s, n, a, r) {
				let o, l;
				const h = Cu() ? a?.getHostDocument() : null;
				o = "string" == typeof t ? t : t.vertexSource ? "source:" + t.vertexSource : t.vertexElement ? h?.getElementById(t.vertexElement) || t.vertexElement : t.vertex || t, l = "string" == typeof t ? t : t.fragmentSource ? "source:" + t.fragmentSource : t.fragmentElement ? h?.getElementById(t.fragmentElement) || t.fragmentElement : t.fragment || t;
				const c = [void 0, void 0],
					u = () => {
						if (c[0] && c[1]) {
							e.isFragment = !0;
							const [o, l] = c;
							nm(l, e, ((a, l) => {
								r && (r._fragmentSourceCodeBeforeMigration = l), i && (a = i("fragment", a));
								const h = function(e, t, i) {
									return i.processor && i.processor.finalizeShaders ? i.processor.finalizeShaders(e, t, i.processingContext) : {
										vertexCode: e,
										fragmentCode: t
									}
								}(o, a, e);
								e = null;
								const c = function(e, t, i, s) {
									return i ? {
										vertexSourceCode: (1 === s ? "//" : "") + "#define SHADER_NAME vertex:" + (i.vertexElement || i.vertex || i.spectorName || i) + "\n" + e,
										fragmentSourceCode: (1 === s ? "//" : "") + "#define SHADER_NAME fragment:" + (i.fragmentElement || i.fragment || i.spectorName || i) + "\n" + t
									} : {
										vertexSourceCode: e,
										fragmentSourceCode: t
									}
								}(h.vertexCode, h.fragmentCode, t, n);
								s?.(c.vertexSourceCode, c.fragmentSourceCode)
							}), a)
						}
					};
				bm(o, "Vertex", "", (t => {
					var s;
					(s = e).processor && s.processor.initializeShaders && s.processor.initializeShaders(s.processingContext), nm(t, e, ((e, s) => {
						r && (r._rawVertexSourceCode = t, r._vertexSourceCodeBeforeMigration = s), i && (e = i("vertex", e)), c[0] = e, u()
					}), a)
				}), n), bm(l, "Fragment", "Pixel", (e => {
					r && (r._rawFragmentSourceCode = e), c[1] = e, u()
				}), n)
			}({
				defines: this.defines.split("\n"),
				indexParameters: this._indexParameters,
				isFragment: !1,
				shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
				processor: t ?? this._engine._getShaderProcessor(this._shaderLanguage),
				supportsUniformBuffers: this._engine.supportsUniformBuffers,
				shadersRepository: e.GetShadersRepository(this._shaderLanguage),
				includesShadersStore: e.GetIncludesShadersStore(this._shaderLanguage),
				version: (100 * this._engine.version).toString(),
				platformName: this._engine.shaderPlatformName,
				processingContext: this._processingContext,
				isNDCHalfZRange: this._engine.isNDCHalfZRange,
				useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
				processCodeAfterIncludes: this._processCodeAfterIncludes
			}, this.name, this._processFinalCode, ((e, t) => {
				this._vertexSourceCode = e, this._fragmentSourceCode = t, this._prepareEffect(i)
			}), this._shaderLanguage, this._engine, this)
		}
		setMatrices(e, t) {
			return this._pipelineContext.setMatrices(e, t), this
		}
		isReady() {
			try {
				return this._isReadyInternal()
			} catch {
				return !1
			}
		}
		setIntArray3(e, t) {
			return this._pipelineContext.setIntArray3(e, t), this
		}
		setUInt3(e, t, i, s) {
			return this._pipelineContext.setUInt3(e, t, i, s), this
		}
		get isSupported() {
			return "" === this._compilationError
		}
		get shaderLanguage() {
			return this._shaderLanguage
		}
		get rawVertexSourceCode() {
			return this._rawVertexSourceCode
		}
		_prepareEffect(e = !1) {
			const t = this._pipelineContext;
			this._isReady = !1;
			try {
				const i = !(!this._vertexSourceCodeOverride || !this._fragmentSourceCodeOverride),
					s = i ? null : this.defines,
					n = i ? this._vertexSourceCodeOverride : this._vertexSourceCode,
					a = i ? this._fragmentSourceCodeOverride : this._fragmentSourceCode,
					r = this._engine;
				this._pipelineContext = ((e, t, i, s) => {
					try {
						const n = e.existingPipelineContext || t(e.shaderProcessingContext);
						return n._name = e.name, e.name && e.context && (pm(e.context).cachedPipelines[e.name] = n), i(n, e.vertex, e.fragment, !!e.createAsRaw, "", "", e.rebuildRebind, e.defines, e.transformFeedbackVaryings, "", (() => {
							s(n, (() => {
								e.onRenderingStateCompiled?.(n)
							}))
						})), n
					} catch (e) {
						throw Qc.Error("Error compiling effect"), e
					}
				})({
					existingPipelineContext: e ? t : null,
					vertex: n,
					fragment: a,
					context: "WEBGL2" === r.shaderPlatformName ? r._gl : void 0,
					rebuildRebind: (e, t, i, s) => this._rebuildProgram(e, t, i, s),
					defines: s,
					transformFeedbackVaryings: this._transformFeedbackVaryings,
					name: this._key.replace(/\r/g, "").replace(/\n/g, "|"),
					createAsRaw: i,
					parallelShaderCompile: r._caps.parallelShaderCompile,
					shaderProcessingContext: this._processingContext,
					onRenderingStateCompiled: i => {
						t && !e && this._engine._deletePipelineContext(t), i && this._onRenderingStateCompiled(i)
					}
				}, this._engine.createPipelineContext.bind(this._engine), this._engine._preparePipelineContext.bind(this._engine), this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)), this._pipelineContext.isAsync && this._checkIsReady(t)
			} catch (e) {
				this._processCompilationErrors(e, t)
			}
		}
		setFloat2(e, t, i) {
			return this._pipelineContext.setFloat2(e, t, i), this
		}
		setBool(e, t) {
			return this._pipelineContext.setInt(e, t ? 1 : 0), this
		}
		setInt3(e, t, i, s) {
			return this._pipelineContext.setInt3(e, t, i, s), this
		}
		setUIntArray2(e, t) {
			return this._pipelineContext.setUIntArray2(e, t), this
		}
		setArray(e, t) {
			return this._pipelineContext.setArray(e, t), this
		}
		setInt2(e, t, i) {
			return this._pipelineContext.setInt2(e, t, i), this
		}
		setMatrix3x3(e, t) {
			return this._pipelineContext.setMatrix3x3(e, t), this
		}
		setFloat4(e, t, i, s, n) {
			return this._pipelineContext.setFloat4(e, t, i, s, n), this
		}
		_rebuildProgram(e, t, i, s) {
			this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = (e, t) => {
				s && s(t)
			}, this.onCompiled = () => {
				const e = this.getEngine().scenes;
				if (e)
					for (let t = 0; t < e.length; t++) e[t].markAllMaterialsAsDirty(63);
				this._pipelineContext._handlesSpectorRebuildCallback?.(i)
			}, this._fallbacks = null, this._prepareEffect()
		}
		getAttributesCount() {
			return this._attributes.length
		}
		getIndexParameters() {
			return this._indexParameters
		}
		setDirectColor4(e, t) {
			return this._pipelineContext.setDirectColor4(e, t), this
		}
		_bindTexture(e, t) {
			this._engine._bindTexture(this._samplers[e], t, e)
		}
		getPipelineContext() {
			return this._pipelineContext
		}
		setVector2(e, t) {
			return this._pipelineContext.setVector2(e, t), this
		}
		setArray2(e, t) {
			return this._pipelineContext.setArray2(e, t), this
		}
		dispose() {
			this._refCount--, this._refCount > 0 || (this._pipelineContext && Am(this._pipelineContext), this._engine._releaseEffect(this), this._isDisposed = !0)
		}
		_checkIsReady(e) {
			try {
				if (this._isReadyInternal()) return
			} catch (t) {
				return void this._processCompilationErrors(t, e)
			}
			this._isDisposed || setTimeout((() => {
				this._checkIsReady(e)
			}), 16)
		}
		bindUniformBlock(e, t) {
			this._engine.bindUniformBlock(this._pipelineContext, e, t)
		}
		getAttributeLocation(e) {
			return this._attributes[e]
		}
		constructor(e, i, s, n = null, a, r = null, o = null, l = null, h = null, c, u = "", m = 0) {
			this.defines = "", this.onCompiled = null, this.onError = null, this.onBind = null, this.ik = 0, this.onCompileObservable = new kc, this.onErrorObservable = new kc, this._onBindObservable = null, this._isDisposed = !1, this._refCount = 1, this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._multiTarget = !1, this._samplers = {}, this._isReady = !1, this._compilationError = "", this._allFallbacksProcessed = !1, this._uniforms = {}, this._key = "", this._fallbacks = null, this._vertexSourceCodeOverride = "", this._fragmentSourceCodeOverride = "", this._transformFeedbackVaryings = null, this._pipelineContext = null, this._vertexSourceCode = "", this._fragmentSourceCode = "", this._vertexSourceCodeBeforeMigration = "", this._fragmentSourceCodeBeforeMigration = "", this._rawVertexSourceCode = "", this._rawFragmentSourceCode = "", this._processCodeAfterIncludes = void 0, this._processFinalCode = null, this.name = e, this._key = u;
			const d = this._key.replace(/\r/g, "").replace(/\n/g, "|");
			let f;
			if (i.attributes) {
				const e = i;
				if (this._engine = s, this._attributesNames = e.attributes, this._uniformsNames = e.uniformsNames.concat(e.samplers), this._samplerList = e.samplers.slice(), this.defines = e.defines, this.onError = e.onError, this.onCompiled = e.onCompiled, this._fallbacks = e.fallbacks, this._indexParameters = e.indexParameters, this._transformFeedbackVaryings = e.transformFeedbackVaryings || null, this._multiTarget = !!e.multiTarget, this._shaderLanguage = e.shaderLanguage ?? 0, e.uniformBuffersNames) {
					this._uniformBuffersNamesList = e.uniformBuffersNames.slice();
					for (let t = 0; t < e.uniformBuffersNames.length; t++) this._uniformBuffersNames[e.uniformBuffersNames[t]] = t
				}
				this._processFinalCode = e.processFinalCode ?? null, this._processCodeAfterIncludes = e.processCodeAfterIncludes ?? void 0, f = e.existingPipelineContext
			} else this._engine = a, this.defines = null == r ? "" : r, this._uniformsNames = s.concat(n), this._samplerList = n ? n.slice() : [], this._attributesNames = i, this._uniformBuffersNamesList = [], this._shaderLanguage = m, this.onError = h, this.onCompiled = l, this._indexParameters = c, this._fallbacks = o;
			var p;
			"WEBGL2" === this._engine.shaderPlatformName && (p = d, f = pm(this._engine._gl).cachedPipelines[p] ?? f), this._attributeLocationByName = {}, this.ik = t._UniqueIdSeed++, f ? (this._pipelineContext = f, this._pipelineContext.setEngine(this._engine), this._onRenderingStateCompiled(this._pipelineContext), this._pipelineContext.program && (this._pipelineContext.program.__SPECTOR_rebuildProgram = this._rebuildProgram.bind(this))) : this._processShaderCode()
		}
		get onBindObservable() {
			return this._onBindObservable || (this._onBindObservable = new kc), this._onBindObservable
		}
		static get ShadersRepository() {
			return e.ShadersRepository
		}
		setColor3(e, t) {
			return this._pipelineContext.setColor3(e, t), this
		}
		setFloatArray4(e, t) {
			return this._pipelineContext.setArray4(e, t), this
		}
		get vertexSourceCodeBeforeMigration() {
			return this._vertexSourceCodeBeforeMigration
		}
	};
	xm.LogShaderCodeOnCompilationError = !0, xm._UniqueIdSeed = 0, xm._BaseCache = {}, xm.ShadersStore = e.ShadersStore, xm.IncludesShadersStore = e.IncludesShadersStore;
	var Mm = class {
			get frontFace() {
				return this._frontFace
			}
			apply(e) {
				this.isDirty && (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1))
			}
			set zOffsetUnits(e) {
				this._zOffsetUnits !== e && (this._zOffsetUnits = e, this._isZOffsetDirty = !0)
			}
			set cullFace(e) {
				this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0)
			}
			get depthFunc() {
				return this._depthFunc
			}
			get depthTest() {
				return this._depthTest
			}
			set depthFunc(e) {
				this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0)
			}
			get cull() {
				return this._cull
			}
			constructor(e = !0) {
				this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, e && this.reset()
			}
			get zOffsetUnits() {
				return this._zOffsetUnits
			}
			get cullFace() {
				return this._cullFace
			}
			reset() {
				this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._zOffsetUnits = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !0, this._isFrontFaceDirty = !1
			}
			get zOffset() {
				return this._zOffset
			}
			set zOffset(e) {
				this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0)
			}
			set depthMask(e) {
				this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0)
			}
			set cull(e) {
				this._cull !== e && (this._cull = e, this._isCullDirty = !0)
			}
			set frontFace(e) {
				this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0)
			}
			get depthMask() {
				return this._depthMask
			}
			get isDirty() {
				return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty
			}
			set depthTest(e) {
				this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0)
			}
		},
		Cm = class {
			get func() {
				return this._func
			}
			get funcRef() {
				return this._funcRef
			}
			get opDepthFail() {
				return this._opDepthFail
			}
			get funcMask() {
				return this._funcMask
			}
			set opStencilFail(e) {
				this._opStencilFail !== e && (this._opStencilFail = e, this._isStencilOpDirty = !0)
			}
			reset() {
				this.stencilMaterial = void 0, this.stencilGlobal?.reset(), this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0
			}
			get enabled() {
				return this._enabled
			}
			get opStencilFail() {
				return this._opStencilFail
			}
			set func(e) {
				this._func !== e && (this._func = e, this._isStencilFuncDirty = !0)
			}
			get isDirty() {
				return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty
			}
			set mask(e) {
				this._mask !== e && (this._mask = e, this._isStencilMaskDirty = !0)
			}
			get opStencilDepthPass() {
				return this._opStencilDepthPass
			}
			set opDepthFail(e) {
				this._opDepthFail !== e && (this._opDepthFail = e, this._isStencilOpDirty = !0)
			}
			apply(e) {
				if (!e) return;
				const t = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;
				this.enabled = t ? this.stencilMaterial.enabled : this.stencilGlobal.enabled, this.func = t ? this.stencilMaterial.func : this.stencilGlobal.func, this.funcRef = t ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef, this.funcMask = t ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask, this.opStencilFail = t ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail, this.opDepthFail = t ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail, this.opStencilDepthPass = t ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass, this.mask = t ? this.stencilMaterial.mask : this.stencilGlobal.mask, this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.mask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass), this._isStencilOpDirty = !1))
			}
			get mask() {
				return this._mask
			}
			set opStencilDepthPass(e) {
				this._opStencilDepthPass !== e && (this._opStencilDepthPass = e, this._isStencilOpDirty = !0)
			}
			set funcRef(e) {
				this._funcRef !== e && (this._funcRef = e, this._isStencilFuncDirty = !0)
			}
			constructor(e = !0) {
				this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.useStencilGlobalOnly = !1, e && this.reset()
			}
			set enabled(e) {
				this._enabled !== e && (this._enabled = e, this._isStencilTestDirty = !0)
			}
			set funcMask(e) {
				this._funcMask !== e && (this._funcMask = e, this._isStencilFuncDirty = !0)
			}
		},
		Tm = class e {
			get stencilOpDepthFail() {
				return this.opDepthFail
			}
			get stencilFuncMask() {
				return this.funcMask
			}
			set stencilFuncMask(e) {
				this.funcMask = e
			}
			get stencilMask() {
				return this.mask
			}
			constructor() {
				this.reset()
			}
			set stencilOpDepthFail(e) {
				this.opDepthFail = e
			}
			reset() {
				this.enabled = !1, this.mask = 255, this.func = e.ALWAYS, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = e.KEEP, this.opDepthFail = e.KEEP, this.opStencilDepthPass = e.REPLACE
			}
			set stencilTest(e) {
				this.enabled = e
			}
			set stencilMask(e) {
				this.mask = e
			}
			set stencilOpStencilDepthPass(e) {
				this.opStencilDepthPass = e
			}
			get stencilOpStencilFail() {
				return this.opStencilFail
			}
			get stencilTest() {
				return this.enabled
			}
			set stencilOpStencilFail(e) {
				this.opStencilFail = e
			}
			get stencilFuncRef() {
				return this.funcRef
			}
			set stencilFunc(e) {
				this.func = e
			}
			set stencilFuncRef(e) {
				this.funcRef = e
			}
			get stencilOpStencilDepthPass() {
				return this.opStencilDepthPass
			}
			get stencilFunc() {
				return this.func
			}
		};
	Tm.ALWAYS = 519, Tm.KEEP = 7680, Tm.REPLACE = 7681;
	var wm, Rm, Nm = class {
			apply(e) {
				this.isDirty && (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1))
			}
			setAlphaBlendFunctionParameters(e, t, i, s) {
				this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === s || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = s, this._isBlendFunctionParametersDirty = !0)
			}
			reset() {
				this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1
			}
			set alphaBlend(e) {
				this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0)
			}
			constructor() {
				this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this.reset()
			}
			get alphaBlend() {
				return this._alphaBlend
			}
			setAlphaEquationParameters(e, t) {
				this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0)
			}
			setAlphaBlendConstants(e, t, i, s) {
				this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === s || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = i, this._blendConstants[3] = s, this._isBlendConstantsDirty = !0)
			}
			get isDirty() {
				return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty
			}
		},
		Im = class {
			constructor() {
				this.samplingMode = -1, this._useMipMaps = !0, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this._comparisonFunction = 0
			}
			get comparisonFunction() {
				return this._comparisonFunction
			}
			get anisotropicFilteringLevel() {
				return this._cachedAnisotropicFilteringLevel
			}
			compareSampler(e) {
				return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps
			}
			get useMipMaps() {
				return this._useMipMaps
			}
			set wrapU(e) {
				this._cachedWrapU = e
			}
			get wrapR() {
				return this._cachedWrapR
			}
			get wrapU() {
				return this._cachedWrapU
			}
			setParameters(e = 1, t = 1, i = 1, s = 1, n = 2, a = 0) {
				return this._cachedWrapU = e, this._cachedWrapV = t, this._cachedWrapR = i, this._cachedAnisotropicFilteringLevel = s, this.samplingMode = n, this._comparisonFunction = a, this
			}
			set anisotropicFilteringLevel(e) {
				this._cachedAnisotropicFilteringLevel = e
			}
			set useMipMaps(e) {
				this._useMipMaps = e
			}
			set comparisonFunction(e) {
				this._comparisonFunction = e
			}
			set wrapR(e) {
				this._cachedWrapR = e
			}
			get wrapV() {
				return this._cachedWrapV
			}
			set wrapV(e) {
				this._cachedWrapV = e
			}
		};
	(Rm = wm || (wm = {}))[Rm.Unknown = 0] = "Unknown", Rm[Rm.Url = 1] = "Url", Rm[Rm.Temp = 2] = "Temp", Rm[Rm.Raw = 3] = "Raw", Rm[Rm.Dynamic = 4] = "Dynamic", Rm[Rm.RenderTarget = 5] = "RenderTarget", Rm[Rm.MultiRenderTarget = 6] = "MultiRenderTarget", Rm[Rm.Cube = 7] = "Cube", Rm[Rm.CubeRaw = 8] = "CubeRaw", Rm[Rm.CubePrefiltered = 9] = "CubePrefiltered", Rm[Rm.Raw3D = 10] = "Raw3D", Rm[Rm.Raw2DArray = 11] = "Raw2DArray", Rm[Rm.DepthStencil = 12] = "DepthStencil", Rm[Rm.CubeRawRGBD = 13] = "CubeRawRGBD", Rm[Rm.Depth = 14] = "Depth";
	var Pm = class e extends Im {
		_swapAndDie(e, t = !0) {
			this._hardwareTexture?.setUsage(e._source, this.generateMipMaps, this.is2DArray, this.isCube, this.is3D, this.width, this.height, this.depth), e._hardwareTexture = this._hardwareTexture, t && (e._isRGBD = this._isRGBD), this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(), e._lodTextureLow = this._lodTextureLow), this._irradianceTexture && (e._irradianceTexture && e._irradianceTexture.dispose(), e._irradianceTexture = this._irradianceTexture);
			const i = this._engine.getLoadedTexturesCache();
			let s = i.indexOf(this); - 1 !== s && i.splice(s, 1), s = i.indexOf(e), -1 === s && i.push(e)
		}
		incrementReferences() {
			this._references++
		}
		get source() {
			return this._source
		}
		get ik() {
			return this._uniqueId
		}
		updateSize(e, t, i = 1) {
			this._engine.updateTextureDimensions(this, e, t, i), this.width = e, this.height = t, this.depth = i, this.baseWidth = e, this.baseHeight = t, this.baseDepth = i, this._size = e * t * i
		}
		getEngine() {
			return this._engine
		}
		_rebuild() {
			if (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this.onRebuildCallback) {
				const e = this.onRebuildCallback(this),
					t = t => {
						t._swapAndDie(this, !1), this.isReady = e.isReady
					};
				return void(e.isAsync ? e.proxy.then(t) : t(e.proxy))
			}
			let e;
			switch (this.source) {
				case 2:
				case 12:
				case 14:
					break;
				case 1:
					return void(e = this._engine.createTexture(this._originalUrl ?? this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, (e => {
						e._swapAndDie(this, !1), this.isReady = !0
					}), null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer));
				case 3:
					e = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, this._creationFlags, this._useSRGBBuffer), e._swapAndDie(this, !1), this.isReady = !0;
					break;
				case 10:
					e = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), e._swapAndDie(this, !1), this.isReady = !0;
					break;
				case 11:
					e = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), e._swapAndDie(this, !1), this.isReady = !0;
					break;
				case 4:
					e = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode), e._swapAndDie(this, !1), this._dynamicTextureSource && this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, !0);
					break;
				case 7:
					return void(e = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, (() => {
						e._swapAndDie(this, !1), this.isReady = !0
					}), null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer, ArrayBuffer.isView(this._buffer) ? this._buffer : null));
				case 8:
					e = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this._originalFormat ?? this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), e._swapAndDie(this, !1), this.isReady = !0;
					break;
				case 13:
					return;
				case 9:
					return e = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (e => {
						e && e._swapAndDie(this, !1), this.isReady = !0
					}), null, this.format, this._extension), void(e._sphericalPolynomial = this._sphericalPolynomial)
			}
		}
		constructor(t, i, s = !1) {
			super(), this.isReady = !1, this.isCube = !1, this.is3D = !1, this.is2DArray = !1, this.isMultiview = !1, this.url = "", this.generateMipMaps = !1, this.samples = 0, this.type = -1, this.format = -1, this.onLoadedObservable = new kc, this.onErrorObservable = new kc, this.onRebuildCallback = null, this.width = 0, this.height = 0, this.depth = 0, this.baseWidth = 0, this.baseHeight = 0, this.baseDepth = 0, this.invertY = !1, this._invertVScale = !1, this._associatedChannel = -1, this._source = 0, this._buffer = null, this._bufferView = null, this._bufferViewArray = null, this._bufferViewArrayArray = null, this._size = 0, this._extension = "", this._files = null, this._workingCanvas = null, this._workingContext = null, this._cachedCoordinatesMode = null, this._isDisabled = !1, this._compression = null, this._sphericalPolynomial = null, this._sphericalPolynomialPromise = null, this._sphericalPolynomialComputed = !1, this._lodGenerationScale = 0, this._lodGenerationOffset = 0, this._useSRGBBuffer = !1, this._creationFlags = 0, this._lodTextureHigh = null, this._lodTextureMid = null, this._lodTextureLow = null, this._isRGBD = !1, this._linearSpecularLOD = !1, this._irradianceTexture = null, this._hardwareTexture = null, this._maxLodLevel = null, this._references = 1, this._gammaSpace = null, this._premulAlpha = !1, this._dynamicTextureSource = null, this._engine = t, this._source = i, this._uniqueId = e._Counter++, s || (this._hardwareTexture = t._createHardwareTexture())
		}
		set useMipMaps(e) {
			this.generateMipMaps = e
		}
		_setUniqueId(e) {
			this._uniqueId = e
		}
		get useMipMaps() {
			return this.generateMipMaps
		}
		dispose() {
			this._references--, this.onLoadedObservable.clear(), this.onErrorObservable.clear(), 0 === this._references && (this._engine._releaseTexture(this), this._hardwareTexture = null, this._dynamicTextureSource = null)
		}
	};

	function km(e, t) {
		if (Cu()) {
			const {
				requestAnimationFrame: i
			} = t || window;
			if ("function" == typeof i) return i(e)
		} else if ("function" == typeof requestAnimationFrame) return requestAnimationFrame(e);
		return setTimeout(e, 16)
	}
	Pm._Counter = 0;
	var Dm = class e {
		getClassName() {
			return "AbstractEngine"
		}
		_flagContextRestored() {
			Qc.Warn(this.name + " context successfully restored."), this.onContextRestoredObservable.notifyObservers(this), this._contextWasLost = !1
		}
		setViewport(e, t, i) {
			const s = t || this.getRenderWidth(),
				n = i || this.getRenderHeight(),
				a = e.x || 0,
				r = e.y || 0;
			this._cachedViewport = e, this._viewport(a * s, r * n, s * e.width, n * e.height)
		}
		get activeRenderLoops() {
			return this._activeRenderLoops
		}
		get description() {
			let e = this.name + this.version;
			return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"), e
		}
		get snapshotRendering() {
			return !1
		}
		createRawTexture(e, t, i, s, n, a, r, o, l, h, c) {
			throw ic("engine.rawTexture")
		}
		getFontOffset(e) {
			throw new Error("getFontOffset is not implemented")
		}
		_getGlobalDefines(e) {
			if (e) return this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER, void(this.useExactSrgbConversions ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS);
			{
				let e = "";
				return this.isNDCHalfZRange && (e += "#define IS_NDC_HALF_ZRANGE"), this.useReverseDepthBuffer && (e && (e += "\n"), e += "#define USE_REVERSE_DEPTHBUFFER"), this.useExactSrgbConversions && (e && (e += "\n"), e += "#define USE_EXACT_SRGB_CONVERSIONS"), e
			}
		}
		_rebuildRenderTargetWrappers() {
			const e = this._renderTargetWrapperCache.slice();
			for (const t of e) t._rebuild()
		}
		getHostDocument() {
			return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : wu() ? document : null
		}
		getHardwareScalingLevel() {
			return this._hardwareScalingLevel
		}
		get depthCullingState() {
			return this._depthCullingState
		}
		_cancelFrame() {
			if (0 !== this._frameHandler) {
				const e = this._frameHandler;
				if (this._frameHandler = 0, Cu()) {
					const {
						cancelAnimationFrame: t
					} = this.getHostWindow() || window;
					if ("function" == typeof t) return t(e)
				} else if ("function" == typeof cancelAnimationFrame) return cancelAnimationFrame(e);
				return clearTimeout(e)
			}
		}
		createCanvasImage() {
			return document.createElement("img")
		}
		_renderFrame() {
			for (let e = 0; e < this._activeRenderLoops.length; e++) {
				(0, this._activeRenderLoops[e])()
			}
		}
		static DefaultLoadingScreenFactory(e) {
			throw ic("LoadingScreen")
		}
		getColorWrite() {
			return this._colorWrite
		}
		_clearEmptyResources() {
			this._emptyTexture = null, this._emptyCubeTexture = null, this._emptyTexture3D = null, this._emptyTexture2DArray = null
		}
		_createTextureBase(t, i, s, n, a = 3, r = null, o = null, l, h, c = null, u = null, m = null, d = null, f, p, _) {
			const g = "data:" === (t = t || "").substr(0, 5),
				v = "blob:" === t.substr(0, 5),
				y = g && -1 !== t.indexOf(";base64,"),
				S = u || new Pm(this, 1);
			S !== u && (S.label = t.substring(0, 60));
			const E = t;
			!this._transformTextureUrl || y || u || c || (t = this._transformTextureUrl(t)), E !== t && (S._originalUrl = E);
			const A = t.lastIndexOf(".");
			let b = d || (A > -1 ? t.substring(A).toLowerCase() : ""),
				x = null;
			b.indexOf("?") > -1 && (b = b.split("?")[0]);
			for (const t of e._TextureLoaders)
				if (t.canLoad(b, f)) {
					x = t;
					break
				} n && n.addPendingData(S), S.url = t, S.generateMipMaps = !i, S.samplingMode = a, S.invertY = s, S._useSRGBBuffer = this._getUseSRGBBuffer(!!_, i), this._doNotHandleContextLost || (S._buffer = c);
			let M = null;
			r && !u && (M = S.onLoadedObservable.add(r)), u || this._internalTexturesCache.push(S);
			const C = (e, s) => {
				n && n.removePendingData(S), t === E ? (M && S.onLoadedObservable.remove(M), Dc.UseFallbackTexture && t !== Dc.FallbackTexture && this._createTextureBase(Dc.FallbackTexture, i, S.invertY, n, a, null, o, l, h, c, S), e = (e || "Unknown error") + (Dc.UseFallbackTexture ? " - Fallback texture was used" : ""), S.onErrorObservable.notifyObservers({
					message: e,
					exception: s
				}), o && o(e, s)) : (Qc.Warn(`Failed to load ${t}, falling back to ${E}`), this._createTextureBase(E, i, S.invertY, n, a, r, o, l, h, c, S, m, d, f, p, _))
			};
			if (x) {
				const e = e => {
					x.loadData(e, S, ((e, t, i, s, r, o) => {
						o ? C("TextureLoader failed to load data") : l(S, b, n, {
							width: e,
							height: t
						}, S.invertY, !i, s, (() => (r(), !1)), a)
					}), p)
				};
				c ? c instanceof ArrayBuffer ? e(new Uint8Array(c)) : ArrayBuffer.isView(c) ? e(c) : o && o("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(t, (t => e(new Uint8Array(t))), void 0, n ? n.offlineProvider : void 0, !0, ((e, t) => {
					C("Unable to load " + (e && e.responseURL, t))
				}))
			} else {
				const s = e => {
					v && !this._doNotHandleContextLost && (S._buffer = e), l(S, b, n, e, S.invertY, i, !1, h, a)
				};
				!g || y ? c && ("string" == typeof c.decoding || c.close) ? s(c) : e._FileToolsLoadImage(t || "", s, C, n ? n.offlineProvider : null, f, S.invertY && this._features.needsInvertingBitmap ? {
					imageOrientation: "flipY"
				} : void 0) : "string" == typeof c || c instanceof ArrayBuffer || ArrayBuffer.isView(c) || c instanceof Blob ? e._FileToolsLoadImage(c, s, C, n ? n.offlineProvider : null, f, S.invertY && this._features.needsInvertingBitmap ? {
					imageOrientation: "flipY"
				} : void 0) : c && s(c)
			}
			return S
		}
		set name(e) {
			this._name = e
		}
		_restoreEngineAfterContextLost(e) {
			setTimeout((async () => {
				this._clearEmptyResources();
				const t = this._depthCullingState.depthTest,
					i = this._depthCullingState.depthFunc,
					s = this._depthCullingState.depthMask,
					n = this._stencilState.stencilTest;
				await e(), this._rebuildGraphicsResources(), this._depthCullingState.depthTest = t, this._depthCullingState.depthFunc = i, this._depthCullingState.depthMask = s, this._stencilState.stencilTest = n, this._flagContextRestored()
			}), 0)
		}
		createImageBitmap(e, t) {
			return createImageBitmap(e, t)
		}
		getLoadedTexturesCache() {
			return this._internalTexturesCache
		}
		get compatibilityMode() {
			return this._compatibilityMode
		}
		getHostWindow() {
			return Cu() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null
		}
		_renderViews() {
			return !1
		}
		getAudioDestination() {
			return this._audioDestination
		}
		get alphaState() {
			return this._alphaState
		}
		get isDisposed() {
			return this._isDisposed
		}
		_setupMobileChecks() {
			navigator && navigator.userAgent && (this._checkForMobile = () => {
				const e = navigator.userAgent;
				this.hostInformation.isMobile = -1 !== e.indexOf("Mobile") || -1 !== e.indexOf("Mac") && wu() && "ontouchend" in document
			}, this._checkForMobile(), Cu() && window.addEventListener("resize", this._checkForMobile))
		}
		get isStencilEnable() {
			return this._isStencilEnable
		}
		createRawCubeTexture(e, t, i, s, n, a, r, o) {
			throw ic("engine.rawTexture")
		}
		setSize(e, t, i = !1) {
			if (!this._renderingCanvas) return !1;
			if (e |= 0, t |= 0, !i && this._renderingCanvas.width === e && this._renderingCanvas.height === t) return !1;
			if (this._renderingCanvas.width = e, this._renderingCanvas.height = t, this.scenes) {
				for (let e = 0; e < this.scenes.length; e++) {
					const t = this.scenes[e];
					for (let e = 0; e < t.cameras.length; e++) {
						t.cameras[e]._currentRenderId = 0
					}
				}
				this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this)
			}
			return !0
		}
		get emptyCubeTexture() {
			if (!this._emptyCubeTexture) {
				const e = new Uint8Array(4),
					t = [e, e, e, e, e, e];
				this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1)
			}
			return this._emptyCubeTexture
		}
		set snapshotRenderingMode(e) {}
		getRenderingCanvas() {
			return this._renderingCanvas
		}
		getDepthBuffer() {
			return this._depthCullingState.depthTest
		}
		get useReverseDepthBuffer() {
			return this._useReverseDepthBuffer
		}
		createRawTexture2DArray(e, t, i, s, n, a, r, o, l, h, c) {
			throw ic("engine.rawTexture")
		}
		_reportDrawCall(e = 1) {
			this._drawCalls?.addCount(e, !1)
		}
		setHardwareScalingLevel(e) {
			this._hardwareScalingLevel = e, this.resize()
		}
		_getShaderProcessor(e) {
			return this._shaderProcessor
		}
		dispose() {
			for (this.releaseEffects(), this._isDisposed = !0, this.stopRenderLoop(), this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._renderingCanvas = null, this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(); this.postProcesses.length;) this.postProcesses[0].dispose();
			for (; this.scenes.length;) this.scenes[0].dispose();
			for (; this._virtualScenes.length;) this._virtualScenes[0].dispose();
			this.releaseComputeEffects?.(), xm.ResetCache();
			for (const e of this._activeRequests) e.abort();
			this._boundRenderFunction = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onNewSceneAddedObservable.clear(), Cu() && window.removeEventListener("resize", this._checkForMobile);
			const e = Dc.Instances.indexOf(this);
			e >= 0 && Dc.Instances.splice(e, 1), Dc.Instances.length || (Dc.OnEnginesDisposedObservable.notifyObservers(this), Dc.OnEnginesDisposedObservable.clear()), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear()
		}
		getFps() {
			return this._fps
		}
		stopRenderLoop(e) {
			if (!e) return this._activeRenderLoops.length = 0, void this._cancelFrame();
			const t = this._activeRenderLoops.indexOf(e);
			t >= 0 && (this._activeRenderLoops.splice(t, 1), 0 == this._activeRenderLoops.length && this._cancelFrame())
		}
		createRawTexture3D(e, t, i, s, n, a, r, o, l, h, c) {
			throw ic("engine.rawTexture")
		}
		_createImageBitmapFromSource(e, t) {
			throw new Error("createImageBitmapFromSource is not implemented")
		}
		getTimeStep() {
			return 1e3 * this._timeStep
		}
		endFrame() {
			this._frameId++, this.onEndFrameObservable.notifyObservers(this)
		}
		get name() {
			return this._name
		}
		get emptyTexture2DArray() {
			return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture2DArray
		}
		get frameId() {
			return this._frameId
		}
		createVideoElement(e) {
			return document.createElement("video")
		}
		_sharedInit(e) {
			this._renderingCanvas = e
		}
		get currentViewport() {
			return this._cachedViewport
		}
		get isWebGPU() {
			return this._isWebGPU
		}
		getLockstepMaxSteps() {
			return this._lockstepMaxSteps
		}
		setZOffset(e) {
			this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e
		}
		get stencilState() {
			return this._stencilState
		}
		_renderLoop() {
			if (this._frameHandler = 0, !this._contextWasLost) {
				let e = !0;
				(this._isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1), e && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame())
			}
			this._activeRenderLoops.length > 0 && 0 === this._frameHandler && (this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()))
		}
		resetTextureCache() {
			for (const e in this._boundTexturesCache) Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) && (this._boundTexturesCache[e] = null);
			this._currentTextureChannel = -1
		}
		_loadFile(e, t, i, s, n, a) {
			const r = Ku(e, t, i, s, n, a);
			return this._activeRequests.push(r), r.onCompleteObservable.add((() => {
				const e = this._activeRequests.indexOf(r); - 1 !== e && this._activeRequests.splice(e, 1)
			})), r
		}
		setZOffsetUnits(e) {
			this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e
		}
		getZOffset() {
			const e = this._depthCullingState.zOffset;
			return this.useReverseDepthBuffer ? -e : e
		}
		get snapshotRenderingMode() {
			return 0
		}
		_releaseRenderTargetWrapper(e) {
			const t = this._renderTargetWrapperCache.indexOf(e); - 1 !== t && this._renderTargetWrapperCache.splice(t, 1)
		}
		getCreationOptions() {
			return this._creationOptions
		}
		set compatibilityMode(e) {
			this._compatibilityMode = !0
		}
		_rebuildTextures() {
			for (const e of this.scenes) e._rebuildTextures();
			for (const e of this._virtualScenes) e._rebuildTextures()
		}
		get emptyTexture() {
			return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)), this._emptyTexture
		}
		getAudioContext() {
			return this._audioContext
		}
		isDeterministicLockStep() {
			return this._deterministicLockstep
		}
		beginFrame() {
			this.onBeginFrameObservable.notifyObservers(this)
		}
		get _shouldUseHighPrecisionShader() {
			return !(!this._caps.highPrecisionShaderSupported || !this._highPrecisionShadersAllowed)
		}
		static get Version() {
			return "7.21.1"
		}
		_rebuildGraphicsResources() {
			this.wipeCaches(!0), this._rebuildEffects(), this._rebuildComputeEffects?.(), this._rebuildBuffers(), this._rebuildInternalTextures(), this._rebuildTextures(), this._rebuildRenderTargetWrappers(), this.wipeCaches(!0)
		}
		resizeImageBitmap(e, t, i) {
			throw new Error("resizeImageBitmap is not implemented")
		}
		Zk(e) {
			-1 === this._activeRenderLoops.indexOf(e) && (this._activeRenderLoops.push(e), 1 === this._activeRenderLoops.length && 0 === this._frameHandler && (this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow())))
		}
		setDepthBuffer(e) {
			this._depthCullingState.depthTest = e
		}
		resize(e = !1) {
			let t, i;
			if (this.adaptToDeviceRatio) {
				const e = Cu() && window.devicePixelRatio || 1,
					t = this._lastDevicePixelRatio / e;
				this._lastDevicePixelRatio = e, this._hardwareScalingLevel *= t
			}
			if (Cu() && wu())
				if (this._renderingCanvas) {
					const e = this._renderingCanvas.getBoundingClientRect ? this._renderingCanvas.getBoundingClientRect() : {
						width: this._renderingCanvas.width * this._hardwareScalingLevel,
						height: this._renderingCanvas.height * this._hardwareScalingLevel
					};
					t = this._renderingCanvas.clientWidth || e.width || this._renderingCanvas.width || 100, i = this._renderingCanvas.clientHeight || e.height || this._renderingCanvas.height || 100
				} else t = window.innerWidth, i = window.innerHeight;
			else t = this._renderingCanvas ? this._renderingCanvas.width : 100, i = this._renderingCanvas ? this._renderingCanvas.height : 100;
			this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel, e)
		}
		static _FileToolsLoadImage(e, t, i, s, n, a) {
			throw ic("FileTools")
		}
		getZOffsetUnits() {
			const e = this._depthCullingState.zOffsetUnits;
			return this.useReverseDepthBuffer ? -e : e
		}
		set snapshotRendering(e) {}
		get emptyTexture3D() {
			return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture3D
		}
		get doNotHandleContextLost() {
			return this._doNotHandleContextLost
		}
		getCaps() {
			return this._caps
		}
		static get NpmPackage() {
			return "babylonjs@7.21.1"
		}
		getDeltaTime() {
			return this._deltaTime
		}
		get stencilStateComposer() {
			return this._stencilStateComposer
		}
		static _FileToolsLoadFile(e, t, i, s, n, a) {
			if (Yu.loadFile) return Yu.loadFile(e, t, i, s, n, a);
			throw ic("FileTools")
		}
		set doNotHandleContextLost(e) {
			this._doNotHandleContextLost = e
		}
		_rebuildEffects() {
			for (const e in this._compiledEffects) {
				const t = this._compiledEffects[e];
				t._pipelineContext = null, t._prepareEffect()
			}
			xm.ResetCache()
		}
		_rebuildBuffers() {
			for (const e of this._uniformBuffers) e._rebuildAfterContextLost()
		}
		constructor(e, t, i) {
			this._colorWrite = !0, this._colorWriteChanged = !0, this._depthCullingState = new Mm, this._stencilStateComposer = new Cm, this._stencilState = new Tm, this._alphaState = new Nm, this._alphaMode = 1, this._alphaEquation = 0, this._activeRequests = [], this._badOS = !1, this._badDesktopOS = !1, this._compatibilityMode = !0, this._internalTexturesCache = new Array, this._currentRenderTarget = null, this._boundTexturesCache = {}, this._activeChannel = 0, this._currentTextureChannel = -1, this._viewportCached = {
				x: 0,
				y: 0,
				z: 0,
				w: 0
			}, this._isWebGPU = !1, this.onCanvasBlurObservable = new kc, this.onCanvasFocusObservable = new kc, this.onNewSceneAddedObservable = new kc, this.onResizeObservable = new kc, this.onCanvasPointerOutObservable = new kc, this.disablePerformanceMonitorInBackground = !1, this.disableVertexArrayObjects = !1, this._frameId = 0, this.hostInformation = {
				isMobile: !1
			}, this.isFullscreen = !1, this.enableOfflineSupport = !1, this.disableManifestCheck = !1, this.disableContextMenu = !0, this.currentRenderPassId = 0, this.isPointerLock = !1, this.postProcesses = [], this.canvasTabIndex = 1, this._contextWasLost = !1, this._useReverseDepthBuffer = !1, this.isNDCHalfZRange = !1, this.hasOriginBottomLeft = !0, this._renderTargetWrapperCache = new Array, this._compiledEffects = {}, this._isDisposed = !1, this.scenes = [], this._virtualScenes = new Array, this.onBeforeTextureInitObservable = new kc, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this._frameHandler = 0, this._activeRenderLoops = new Array, this._windowIsBackground = !1, this._boundRenderFunction = () => this._renderLoop(), this.onBeforeShaderCompilationObservable = new kc, this.onAfterShaderCompilationObservable = new kc, this.onBeginFrameObservable = new kc, this.onEndFrameObservable = new kc, this._transformTextureUrl = null, this._uniformBuffers = new Array, this._storageBuffers = new Array, this._highPrecisionShadersAllowed = !0, this.onContextLostObservable = new kc, this.onContextRestoredObservable = new kc, this._name = "", this.premultipliedAlpha = !0, this.adaptToDeviceRatio = !1, this._lastDevicePixelRatio = 1, this._doNotHandleContextLost = !1, this.cullBackFaces = null, this._renderPassNames = ["main"], this._fps = 60, this._deltaTime = 0, this._deterministicLockstep = !1, this._lockstepMaxSteps = 4, this._timeStep = 1 / 60, this.onDisposeObservable = new kc, Dc.Instances.push(this), this.startTime = Pu.Now, this._stencilStateComposer.stencilGlobal = this._stencilState, Nc.SetMatrixPrecision(!!t.useHighPrecisionMatrix), Tu() && navigator.userAgent && (this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), this.adaptToDeviceRatio = i ?? !1, t.antialias = e ?? t.antialias, t.deterministicLockstep = t.deterministicLockstep ?? !1, t.lockstepMaxSteps = t.lockstepMaxSteps ?? 4, t.timeStep = t.timeStep ?? 1 / 60, t.audioEngine = t.audioEngine ?? !0, t.stencil = t.stencil ?? !0, this._audioContext = t.audioEngineOptions?.audioContext ?? null, this._audioDestination = t.audioEngineOptions?.audioDestination ?? null, this.premultipliedAlpha = t.premultipliedAlpha ?? !0, this._doNotHandleContextLost = !!t.doNotHandleContextLost, this._isStencilEnable = !!t.stencil, this.useExactSrgbConversions = t.useExactSrgbConversions ?? !1;
			const s = Cu() && window.devicePixelRatio || 1,
				n = t.limitDeviceRatio || s;
			i = i || t.adaptToDeviceRatio || !1, this._hardwareScalingLevel = i ? 1 / Math.min(n, s) : 1, this._lastDevicePixelRatio = s, this._creationOptions = t
		}
		clearInternalTexturesCache() {
			this._internalTexturesCache.length = 0
		}
		get shaderPlatformName() {
			return this._shaderPlatformName
		}
		static _CreateCanvas(e, t) {
			if ("undefined" == typeof document) return new OffscreenCanvas(e, t);
			const i = document.createElement("canvas");
			return i.width = e, i.height = t, i
		}
		_rebuildInternalTextures() {
			const e = this._internalTexturesCache.slice();
			for (const t of e) t._rebuild()
		}
		setColorWrite(e) {
			e !== this._colorWrite && (this._colorWriteChanged = !0, this._colorWrite = e)
		}
		_queueNewFrame(e, t) {
			return km(e, t)
		}
		set useReverseDepthBuffer(e) {
			e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e, this._depthCullingState.depthFunc = e ? 518 : 515)
		}
		createCanvas(t, i) {
			return e._CreateCanvas(t, i)
		}
	};
	Dm._TextureLoaders = [], Dm._RenderPassIdCounter = 0, Dm._RescalePostProcessFactory = null;
	var Om = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i),
		Fm = class e extends uu {
			constructor(t, i) {
				super(t, lu), this.name = "LoadFileError", nu._setPrototypeOf(this, e.prototype), i instanceof ku ? this.request = i : this.file = i
			}
		},
		Lm = class e extends uu {
			constructor(t, i) {
				super(t, hu), this.request = i, this.name = "RequestFileError", nu._setPrototypeOf(this, e.prototype)
			}
		},
		Bm = class e extends uu {
			constructor(t, i) {
				super(t, cu), this.file = i, this.name = "ReadFileError", nu._setPrototypeOf(this, e.prototype)
			}
		},
		Gm = {
			DefaultRetryStrategy: class {
				static ExponentialBackoff(e = 3, t = 500) {
					return (i, s, n) => 0 !== s.status || n >= e || -1 !== i.indexOf("file:") ? -1 : Math.pow(2, n) * t
				}
			}.ExponentialBackoff(),
			BaseUrl: "",
			CorsBehavior: "anonymous",
			PreprocessUrl: e => e,
			ScriptBaseUrl: "",
			ScriptPreprocessUrl: e => e,
			CleanUrl: e => e = e.replace(/#/gm, "%23")
		},
		Hm = (e, t) => {
			if ((!e || 0 !== e.indexOf("data:")) && Gm.CorsBehavior)
				if ("string" == typeof Gm.CorsBehavior || Gm.CorsBehavior instanceof String) t.crossOrigin = Gm.CorsBehavior;
				else {
					const i = Gm.CorsBehavior(e);
					i && (t.crossOrigin = i)
				}
		},
		Um = (e, t, i, s, n = "", a) => {
			const r = Dc.LastCreatedEngine;
			if ("undefined" == typeof HTMLImageElement && !r?._features.forceBitmapOverHTMLImageElement) return i("LoadImage is only supported in web or BabylonNative environments."), null;
			let o, l = !1;
			e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? "undefined" != typeof Blob && "undefined" != typeof URL ? (o = URL.createObjectURL(new Blob([e], {
				type: n
			})), l = !0) : o = `data:${n};base64,` + Ou(e) : e instanceof Blob ? (o = URL.createObjectURL(e), l = !0) : (o = Gm.CleanUrl(e), o = Gm.PreprocessUrl(o));
			const h = t => {
				if (i) {
					const s = o || e.toString();
					i(`Error while trying to load image: ${0===s.indexOf("http")||s.length<=128?s:s.slice(0,128)+"..."}`, t)
				}
			};
			if (r?._features.forceBitmapOverHTMLImageElement) return Wm(o, (s => {
				r.createImageBitmap(new Blob([s], {
					type: n
				}), {
					premultiplyAlpha: "none",
					...a
				}).then((e => {
					t(e), l && URL.revokeObjectURL(o)
				})).catch((t => {
					i && i("Error while trying to load image: " + e, t)
				}))
			}), void 0, s || void 0, !0, ((e, t) => {
				h(t)
			})), null;
			const c = new Image;
			Hm(o, c);
			const u = [],
				m = () => {
					u.forEach((e => {
						e.target.removeEventListener(e.name, e.handler)
					})), u.length = 0
				};
			u.push({
				target: c,
				name: "load",
				handler: () => {
					m(), t(c), l && c.src && URL.revokeObjectURL(c.src)
				}
			}), u.push({
				target: c,
				name: "error",
				handler: e => {
					m(), h(e), l && c.src && URL.revokeObjectURL(c.src)
				}
			}), u.push({
				target: document,
				name: "securitypolicyviolation",
				handler: e => {
					if (e.blockedURI !== c.src) return;
					m();
					const t = new Error(`CSP violation of policy ${e.effectiveDirective} ${e.blockedURI}. Current policy is ${e.originalPolicy}`);
					Dc.UseFallbackTexture = !1, h(t), l && c.src && URL.revokeObjectURL(c.src), c.src = ""
				}
			}), u.forEach((e => {
				e.target.addEventListener(e.name, e.handler)
			}));
			const d = "blob:" === o.substring(0, 5),
				f = "data:" === o.substring(0, 5),
				p = () => {
					d || f || !ku.IsCustomRequestAvailable ? c.src = o : Wm(o, ((e, t, i) => {
						const s = new Blob([e], {
								type: !n && i ? i : n
							}),
							a = URL.createObjectURL(s);
						l = !0, c.src = a
					}), void 0, s || void 0, !0, ((e, t) => {
						h(t)
					}))
				},
				_ = () => {
					s && s.loadImage(o, c)
				};
			if (!d && !f && s && s.enableTexturesOffline) s.open(_, p);
			else {
				if (-1 !== o.indexOf("file:")) {
					const e = decodeURIComponent(o.substring(5).toLowerCase());
					if (Du.FilesToLoad[e] && "undefined" != typeof URL) {
						try {
							let t;
							try {
								t = URL.createObjectURL(Du.FilesToLoad[e])
							} catch (i) {
								t = URL.createObjectURL(Du.FilesToLoad[e])
							}
							c.src = t, l = !0
						} catch (e) {
							c.src = ""
						}
						return c
					}
				}
				p()
			}
			return c
		},
		Vm = (e, t, i, s, n) => {
			const a = new FileReader,
				r = {
					onCompleteObservable: new kc,
					abort: () => a.abort()
				};
			return a.onloadend = () => r.onCompleteObservable.notifyObservers(r), n && (a.onerror = () => {
				n(new Bm(`Unable to read ${e.name}`, e))
			}), a.onload = e => {
				t(e.target.result)
			}, i && (a.onprogress = i), s ? a.readAsArrayBuffer(e) : a.readAsText(e), r
		},
		Wm = (e, t, i, s, n, a, r) => {
			if (e.name) return Vm(e, t, i, n, a ? e => {
				a(void 0, e)
			} : void 0);
			const o = e;
			if (-1 !== o.indexOf("file:")) {
				let e = decodeURIComponent(o.substring(5).toLowerCase());
				0 === e.indexOf("./") && (e = e.substring(2));
				const s = Du.FilesToLoad[e];
				if (s) return Vm(s, t, i, n, a ? e => a(void 0, new Fm(e.message, e.file)) : void 0)
			}
			const {
				match: l,
				type: h
			} = jm(o);
			if (l) {
				const e = {
					onCompleteObservable: new kc,
					abort: () => () => {}
				};
				try {
					const e = n ? Km(o) : Jm(o);
					t(e, void 0, h)
				} catch (e) {
					a ? a(void 0, e) : Qc.Error(e.message || "Failed to parse the Data URL")
				}
				return um.SetImmediate((() => {
					e.onCompleteObservable.notifyObservers(e)
				})), e
			}
			return zm(o, ((e, i) => {
				t(e, i?.responseURL, i?.getResponseHeader("content-type"))
			}), i, s, n, a ? e => {
				a(e.request, new Fm(e.message, e.request))
			} : void 0, r)
		},
		zm = (e, t, i, s, n, a, r) => {
			e = Gm.CleanUrl(e), e = Gm.PreprocessUrl(e);
			const o = Gm.BaseUrl + e;
			let l = !1;
			const h = {
					onCompleteObservable: new kc,
					abort: () => l = !0
				},
				c = () => {
					let e, s = new ku,
						c = null;
					const u = () => {
						s && (i && s.removeEventListener("progress", i), e && s.removeEventListener("readystatechange", e), s.removeEventListener("loadend", m))
					};
					let m = () => {
						u(), h.onCompleteObservable.notifyObservers(h), h.onCompleteObservable.clear(), i = void 0, e = null, m = null, a = void 0, r = void 0, t = void 0
					};
					h.abort = () => {
						l = !0, m && m(), s && s.readyState !== (XMLHttpRequest.DONE || 4) && s.abort(), null !== c && (clearTimeout(c), c = null), s = null
					};
					const d = e => {
							const t = e.message || "Unknown error";
							a && s ? a(new Lm(t, s)) : Qc.Error(t)
						},
						f = h => {
							if (s) {
								if (s.open("GET", o), r) try {
									r(s)
								} catch (e) {
									return void d(e)
								}
								n && (s.responseType = "arraybuffer"), i && s.addEventListener("progress", i), m && s.addEventListener("loadend", m), e = () => {
									if (!l && s && s.readyState === (XMLHttpRequest.DONE || 4)) {
										if (e && s.removeEventListener("readystatechange", e), s.status >= 200 && s.status < 300 || 0 === s.status && (!Cu() || Xm())) {
											try {
												t && t(n ? s.response : s.responseText, s)
											} catch (e) {
												d(e)
											}
											return
										}
										const i = Gm.DefaultRetryStrategy;
										if (i) {
											const e = i(o, s, h);
											if (-1 !== e) return u(), s = new ku, void(c = setTimeout((() => f(h + 1)), e))
										}
										const r = new Lm("Error status: " + s.status + " " + s.statusText + " - Unable to load " + o, s);
										a && a(r)
									}
								}, s.addEventListener("readystatechange", e), s.send()
							}
						};
					f(0)
				};
			if (s && s.enableSceneOffline) {
				const r = e => {
						e && e.status > 400 ? a && a(e) : c()
					},
					o = () => {
						s && s.loadFile(Gm.BaseUrl + e, (e => {
							!l && t && t(e), h.onCompleteObservable.notifyObservers(h)
						}), i ? e => {
							!l && i && i(e)
						} : void 0, r, n)
					};
				s.open(o, r)
			} else c();
			return h
		},
		Xm = () => "undefined" != typeof location && "file:" === location.protocol,
		Ym = e => Om.test(e),
		jm = e => {
			const t = Om.exec(e);
			if (null === t || 0 === t.length) return {
				match: !1,
				type: ""
			};
			return {
				match: !0,
				type: t[0].replace("data:", "").replace("base64,", "")
			}
		};

	function Km(e) {
		return (e => {
			const t = Fu(e),
				i = t.length,
				s = new Uint8Array(new ArrayBuffer(i));
			for (let e = 0; e < i; e++) s[e] = t.charCodeAt(e);
			return s.buffer
		})(e.split(",")[1])
	}
	var $m, Jm = e => Fu(e.split(",")[1]);
	Dm._FileToolsLoadImage = Um, Yu.loadFile = Wm, cm.loadFile = Wm;
	var qm, Qm, Zm, ed, td, id, sd, nd;
	Qm = Ym, Zm = Xm, ed = Wm, td = Um, id = Vm, sd = zm, nd = Hm, $m = {
		DecodeBase64UrlToBinary: Km,
		DecodeBase64UrlToString: Jm,
		DefaultRetryStrategy: (qm = Gm).DefaultRetryStrategy,
		BaseUrl: qm.BaseUrl,
		CorsBehavior: qm.CorsBehavior,
		PreprocessUrl: qm.PreprocessUrl,
		IsBase64DataUrl: Qm,
		IsFileURL: Zm,
		LoadFile: ed,
		LoadImage: td,
		ReadFile: id,
		RequestFile: sd,
		SetCorsBehavior: nd
	}, Object.defineProperty($m, "DefaultRetryStrategy", {
		get: function() {
			return qm.DefaultRetryStrategy
		},
		set: function(e) {
			qm.DefaultRetryStrategy = e
		}
	}), Object.defineProperty($m, "BaseUrl", {
		get: function() {
			return qm.BaseUrl
		},
		set: function(e) {
			qm.BaseUrl = e
		}
	}), Object.defineProperty($m, "PreprocessUrl", {
		get: function() {
			return qm.PreprocessUrl
		},
		set: function(e) {
			qm.PreprocessUrl = e
		}
	}), Object.defineProperty($m, "CorsBehavior", {
		get: function() {
			return qm.CorsBehavior
		},
		set: function(e) {
			qm.CorsBehavior = e
		}
	});
	var ad = class {
		static Instantiate(e) {
			if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e]) return this.RegisteredExternalClasses[e];
			const t = uc(e);
			if (t) return t;
			Qc.Warn(e + " not found, you may have missed an import.");
			const i = e.split(".");
			let s = window || this;
			for (let e = 0, t = i.length; e < t; e++) s = s[i[e]];
			return "function" != typeof s ? null : s
		}
	};

	function rd() {
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e => {
			const t = 16 * Math.random() | 0;
			return ("x" === e ? t : 3 & t | 8).toString(16)
		}))
	}

	function od(e) {
		let t = 1;
		do {
			t *= 2
		} while (t < e);
		return t === e
	}

	function ld(e, t, i) {
		return e * (1 - i) + t * i
	}

	function hd(e) {
		const t = cd(e),
			i = ud(e);
		return t - e > e - i ? i : t
	}

	function cd(e) {
		return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e
	}

	function ud(e) {
		return e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, (e |= e >> 16) - (e >> 1)
	}

	function md(e, t, i = 2) {
		let s;
		switch (i) {
			case 1:
				s = ud(e);
				break;
			case 2:
				s = hd(e);
				break;
			default:
				s = cd(e)
		}
		return Math.min(s, t)
	}
	ad.RegisteredExternalClasses = {};
	var dd = class e {
		static GetBabylonScriptURL(t, i) {
			if (!t) return "";
			if (e.ScriptBaseUrl && t.startsWith(e._DefaultCdnUrl)) {
				const i = "/" === e.ScriptBaseUrl[e.ScriptBaseUrl.length - 1] ? e.ScriptBaseUrl.substring(0, e.ScriptBaseUrl.length - 1) : e.ScriptBaseUrl;
				t = t.replace(e._DefaultCdnUrl, i)
			}
			return t = e.ScriptPreprocessUrl(t), i && (t = e.GetAbsoluteUrl(t)), t
		}
		static IsSafari() {
			return !!Tu() && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
		}
		static LoadFileAsync(e, t = !0) {
			return new Promise(((i, s) => {
				Wm(e, (e => {
					i(e)
				}), void 0, void 0, t, ((e, t) => {
					s(t)
				}))
			}))
		}
		static IsEmpty(e) {
			for (const t in e)
				if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
			return !0
		}
		static get CorsBehavior() {
			return Gm.CorsBehavior
		}
		static ToBlob(t, i, s = "image/png", n) {
			e._IsOffScreenCanvas(t) || t.toBlob || (t.toBlob = function(e, t, i) {
				setTimeout((() => {
					const s = atob(this.toDataURL(t, i).split(",")[1]),
						n = s.length,
						a = new Uint8Array(n);
					for (let e = 0; e < n; e++) a[e] = s.charCodeAt(e);
					e(new Blob([a]))
				}))
			}), e._IsOffScreenCanvas(t) ? t.convertToBlob({
				type: s,
				quality: n
			}).then((e => i(e))) : t.toBlob((function(e) {
				i(e)
			}), s, n)
		}
		static get Now() {
			return Pu.Now
		}
		static DelayAsync(e) {
			return new Promise((t => {
				setTimeout((() => {
					t()
				}), e)
			}))
		}
		static get BaseUrl() {
			return Gm.BaseUrl
		}
		static ReadFileAsDataURL(e, t, i) {
			const s = new FileReader,
				n = {
					onCompleteObservable: new kc,
					abort: () => s.abort()
				};
			return s.onloadend = () => {
				n.onCompleteObservable.notifyObservers(n)
			}, s.onload = e => {
				t(e.target.result)
			}, s.onprogress = i, s.readAsDataURL(e), n
		}
		static GetFolderPath(e, t = !1) {
			const i = e.lastIndexOf("/");
			return i < 0 ? t ? e : "" : e.substring(0, i + 1)
		}
		static EncodeScreenshotCanvasData(t, i, s = "image/png", n, a) {
			if ("string" != typeof n && i) {
				if (i) {
					if (e._IsOffScreenCanvas(t)) return void t.convertToBlob({
						type: s,
						quality: a
					}).then((e => {
						const t = new FileReader;
						t.readAsDataURL(e), t.onloadend = () => {
							const e = t.result;
							i(e)
						}
					}));
					const n = t.toDataURL(s, a);
					i(n)
				}
			} else this.ToBlob(t, (function(t) {
				t && e.DownloadBlob(t, n), i && i("")
			}), s, a)
		}
		static set CorsBehavior(e) {
			Gm.CorsBehavior = e
		}
		static SetImmediate(e) {
			um.SetImmediate(e)
		}
		static get ScriptPreprocessUrl() {
			return Gm.ScriptPreprocessUrl
		}
		static BackCompatCameraNoPreventDefault(e) {
			return "boolean" == typeof e[0] ? e[0] : "boolean" == typeof e[1] && e[1]
		}
		static get DefaultRetryStrategy() {
			return Gm.DefaultRetryStrategy
		}
		static async DumpFramebuffer(e, t, i, s, n = "image/png", a, r) {
			throw ic("DumpTools")
		}
		static get RegisteredExternalClasses() {
			return ad.RegisteredExternalClasses
		}
		static SetCorsBehavior(e, t) {
			Hm(e, t)
		}
		static ReadFile(e, t, i, s, n) {
			return Vm(e, t, i, s, n)
		}
		static CreateScreenshot(e, t, i, s, n = "image/png", a = !1, r) {
			throw ic("ScreenshotTools")
		}
		static GetPointerPrefix(e) {
			let t = "pointer";
			return Cu() && !window.PointerEvent && (t = "mouse"), !e._badDesktopOS || e._badOS || document && "ontouchend" in document || (t = "mouse"), t
		}
		static SmoothAngleChange(e, t, i = .9) {
			const s = this.ToRadians(e),
				n = this.ToRadians(t);
			return this.ToDegrees(Math.atan2((1 - i) * Math.sin(n) + i * Math.sin(s), (1 - i) * Math.cos(n) + i * Math.cos(s)))
		}
		static LoadBabylonScript(t, i, s, n) {
			t = e.GetBabylonScriptURL(t), e.LoadScript(t, i, s)
		}
		static LoadBabylonScriptAsync(t) {
			return t = e.GetBabylonScriptURL(t), e.LoadScriptAsync(t)
		}
		static GetClassName(e, t = !1) {
			let i = null;
			if (!t && e.getClassName) i = e.getClassName();
			else {
				if (e instanceof Object) {
					i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__
				}
				i || (i = typeof e)
			}
			return i
		}
		static Error(e) {
			Qc.Error(e)
		}
		static set UseFallbackTexture(e) {
			Dc.UseFallbackTexture = e
		}
		static get fallbackTexture() {
			return Dc.FallbackTexture
		}
		static set DefaultRetryStrategy(e) {
			Gm.DefaultRetryStrategy = e
		}
		static DownloadBlob(t, i) {
			if ("download" in document.createElement("a")) {
				if (!i) {
					const e = new Date;
					i = "screenshot_" + ((e.getFullYear() + "-" + (e.getMonth() + 1)).slice(2) + "-" + e.getDate() + "_" + e.getHours() + "-" + ("0" + e.getMinutes()).slice(-2)) + ".png"
				}
				e.Download(t, i)
			} else if (t && "undefined" != typeof URL) {
				const e = URL.createObjectURL(t),
					i = window.open("");
				if (!i) return;
				const s = i.document.createElement("img");
				s.onload = function() {
					URL.revokeObjectURL(e)
				}, s.src = e, i.document.body.appendChild(s)
			}
		}
		static get ScriptBaseUrl() {
			return Gm.ScriptBaseUrl
		}
		static _IsOffScreenCanvas(e) {
			return void 0 !== e.convertToBlob
		}
		static DeepCopy(e, t, i, s) {
			Iu.DeepCopy(e, t, i, s)
		}
		static get LogCache() {
			return Qc.LogCache
		}
		static LoadScript(e, t, i, s) {
			if ("function" == typeof importScripts) {
				try {
					importScripts(e), t()
				} catch (t) {
					i?.(`Unable to load script '${e}' in worker`, t)
				}
				return
			}
			if (!Cu()) return void i?.(`Cannot load script '${e}' outside of a window or a worker`);
			const n = document.getElementsByTagName("head")[0],
				a = document.createElement("script");
			a.setAttribute("type", "text/javascript"), a.setAttribute("src", e), s && (a.id = s), a.onload = () => {
				t && t()
			}, a.onerror = t => {
				i && i(`Unable to load script '${e}'`, t)
			}, n.appendChild(a)
		}
		static Download(e, t) {
			if ("undefined" == typeof URL) return;
			const i = window.URL.createObjectURL(e),
				s = document.createElement("a");
			document.body.appendChild(s), s.style.display = "none", s.href = i, s.download = t, s.addEventListener("click", (() => {
				s.parentElement && s.parentElement.removeChild(s)
			})), s.click(), window.URL.revokeObjectURL(i)
		}
		static GetFilename(e) {
			const t = e.lastIndexOf("/");
			return t < 0 ? e : e.substring(t + 1)
		}
		static LoadImage(e, t, i, s, n, a) {
			return Um(e, t, i, s, n, a)
		}
		static set BaseUrl(e) {
			Gm.BaseUrl = e
		}
		static FileAsURL(e) {
			const t = new Blob([e]);
			return window.URL.createObjectURL(t)
		}
		static _EndPerformanceConsole(t, i = !0) {
			i && (e._EndUserMark(t, i), console.timeEnd(t))
		}
		static set PreprocessUrl(e) {
			Gm.PreprocessUrl = e
		}
		static set ScriptPreprocessUrl(e) {
			Gm.ScriptPreprocessUrl = e
		}
		static DumpData(e, t, i, s, n = "image/png", a, r = !1, o = !1, l) {
			throw ic("DumpTools")
		}
		static Instantiate(e) {
			return ad.Instantiate(e)
		}
		static ToDegrees(e) {
			return 180 * e / Math.PI
		}
		static DumpDataAsync(e, t, i, s = "image/png", n, a = !1, r = !1, o) {
			throw ic("DumpTools")
		}
		static set CleanUrl(e) {
			Gm.CleanUrl = e
		}
		static ToRadians(e) {
			return e * Math.PI / 180
		}
		static First(e, t) {
			for (const i of e)
				if (t(i)) return i;
			return null
		}
		static set PerformanceLogLevel(t) {
			return (t & e.PerformanceUserMarkLogLevel) === e.PerformanceUserMarkLogLevel ? (e.StartPerformanceCounter = e._StartUserMark, void(e.EndPerformanceCounter = e._EndUserMark)) : (t & e.PerformanceConsoleLogLevel) === e.PerformanceConsoleLogLevel ? (e.StartPerformanceCounter = e._StartPerformanceConsole, void(e.EndPerformanceCounter = e._EndPerformanceConsole)) : (e.StartPerformanceCounter = e._StartPerformanceCounterDisabled, void(e.EndPerformanceCounter = e._EndPerformanceCounterDisabled))
		}
		static RegisterTopRootEvents(e, t) {
			for (let i = 0; i < t.length; i++) {
				const s = t[i];
				e.addEventListener(s.name, s.handler, !1);
				try {
					window.parent && window.parent.addEventListener(s.name, s.handler, !1)
				} catch (e) {}
			}
		}
		static get UseFallbackTexture() {
			return Dc.UseFallbackTexture
		}
		static DecodeBase64(e) {
			return Km(e)
		}
		static get PreprocessUrl() {
			return Gm.PreprocessUrl
		}
		static Format(e, t = 2) {
			return e.toFixed(t)
		}
		static CreateScreenshotAsync(e, t, i, s = "image/png", n) {
			throw ic("ScreenshotTools")
		}
		static FloatRound(e) {
			return Math.fround(e)
		}
		static UnregisterTopRootEvents(e, t) {
			for (let i = 0; i < t.length; i++) {
				const s = t[i];
				e.removeEventListener(s.name, s.handler);
				try {
					e.parent && e.parent.removeEventListener(s.name, s.handler)
				} catch (e) {}
			}
		}
		static FetchToRef(e, t, i, s, n, a) {
			const r = 4 * ((Math.abs(e) * i % i | 0) + (Math.abs(t) * s % s | 0) * i);
			a.r = n[r] / 255, a.g = n[r + 1] / 255, a.b = n[r + 2] / 255, a.a = n[r + 3] / 255
		}
		static get CleanUrl() {
			return Gm.CleanUrl
		}
		static Warn(e) {
			Qc.Warn(e)
		}
		static _StartPerformanceConsole(t, i = !0) {
			i && (e._StartUserMark(t, i), console.time && console.time(t))
		}
		static IsAbsoluteUrl(e) {
			return 0 === e.indexOf("//") || -1 !== e.indexOf("://") && (-1 !== e.indexOf(".") && (-1 !== e.indexOf("/") && (!(e.indexOf(":") > e.indexOf("/")) && (e.indexOf("://") < e.indexOf(".") || (0 === e.indexOf("data:") || 0 === e.indexOf("blob:"))))))
		}
		static Log(e) {
			Qc.Log(e)
		}
		static CreateScreenshotUsingRenderTargetAsync(e, t, i, s = "image/png", n = 1, a = !1, r, o = !1, l = !1, h = !0, c) {
			throw ic("ScreenshotTools")
		}
		static LoadFile(e, t, i, s, n, a) {
			return Wm(e, t, i, s, n, a)
		}
		static set RegisteredExternalClasses(e) {
			ad.RegisteredExternalClasses = e
		}
		static get errorsCount() {
			return Qc.errorsCount
		}
		static _StartUserMark(t, i = !0) {
			if (!e._Performance) {
				if (!Cu()) return;
				e._Performance = window.performance
			}
			i && e._Performance.mark && e._Performance.mark(t + "-Begin")
		}
		static _EndUserMark(t, i = !0) {
			i && e._Performance.mark && (e._Performance.mark(t + "-End"), e._Performance.measure(t, t + "-Begin", t + "-End"))
		}
		static set ScriptBaseUrl(e) {
			Gm.ScriptBaseUrl = e
		}
		static SetReferrerPolicyBehavior(e, t) {
			t.referrerPolicy = e
		}
		static _StartPerformanceCounterDisabled(e, t) {}
		static set fallbackTexture(e) {
			Dc.FallbackTexture = e
		}
		static IsExponentOfTwo(e) {
			return !0
		}
		static RandomId() {
			return rd()
		}
		static _EndPerformanceCounterDisabled(e, t) {}
		static IsBase64(e) {
			return Ym(e)
		}
		static Mix(e, t, i) {
			return 0
		}
		static getFullClassName(e, t = !1) {
			let i = null,
				s = null;
			if (!t && e.getClassName) i = e.getClassName();
			else {
				if (e instanceof Object) {
					const n = t ? e : Object.getPrototypeOf(e);
					i = n.constructor.__bjsclassName__, s = n.constructor.__bjsmoduleName__
				}
				i || (i = typeof e)
			}
			return i ? (null != s ? s + "." : "") + i : null
		}
		static set LogLevels(e) {
			Qc.LogLevels = e
		}
		static MakeArray(e, t) {
			return !0 === t || void 0 !== e && null != e ? Array.isArray(e) ? e : [e] : null
		}
		static LoadScriptAsync(e, t) {
			return new Promise(((i, s) => {
				this.LoadScript(e, (() => {
					i()
				}), ((e, t) => {
					s(t || new Error(e))
				}), t)
			}))
		}
		static ClearLogCache() {
			Qc.ClearLogCache()
		}
		static CreateScreenshotUsingRenderTarget(e, t, i, s, n = "image/png", a = 1, r = !1, o, l = !1, h = !1, c = !0, u) {
			throw ic("ScreenshotTools")
		}
	};
	dd.UseCustomRequestHeaders = !1, dd.CustomRequestHeaders = ku.CustomRequestHeaders, dd.GetDOMTextContent = Ru, dd._DefaultCdnUrl = "https://cdn.babylonjs.com", dd.GetAbsoluteUrl = "object" == typeof document ? e => {
		const t = document.createElement("a");
		return t.href = e, t.href
	} : "function" == typeof URL && "object" == typeof location ? e => new URL(e, location.origin).href : () => {
		throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")
	}, dd.NoneLogLevel = Qc.NoneLogLevel, dd.MessageLogLevel = Qc.MessageLogLevel, dd.WarningLogLevel = Qc.WarningLogLevel, dd.ErrorLogLevel = Qc.ErrorLogLevel, dd.AllLogLevel = Qc.AllLogLevel, dd.IsWindowObjectExist = Cu, dd.PerformanceNoneLogLevel = 0, dd.PerformanceUserMarkLogLevel = 1, dd.PerformanceConsoleLogLevel = 2, dd.StartPerformanceCounter = dd._StartPerformanceCounterDisabled, dd.EndPerformanceCounter = dd._EndPerformanceCounterDisabled;
	var fd = class e {
		executeNext() {
			this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop())
		}
		constructor(e, t, i, s = 0) {
			this.iterations = e, this.index = s - 1, this._done = !1, this._fn = t, this._successCallback = i
		}
		static SyncAsyncForLoop(t, i, s, n, a, r = 0) {
			return e.Run(Math.ceil(t / i), (e => {
				a && a() ? e.breakLoop() : setTimeout((() => {
					for (let n = 0; n < i; ++n) {
						const r = e.index * i + n;
						if (r >= t) break;
						if (s(r), a && a()) {
							e.breakLoop();
							break
						}
					}
					e.executeNext()
				}), r)
			}), n)
		}
		breakLoop() {
			this._done = !0, this._successCallback()
		}
		static Run(t, i, s, n = 0) {
			const a = new e(t, i, s, n);
			return a.executeNext(), a
		}
	};
	dd.Mix = ld, dd.IsExponentOfTwo = od, Dc.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
	var pd = class e {
		push(e) {
			this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2)
		}
		sort(e) {
			this.data.sort(e)
		}
		constructor(t) {
			this.length = 0, this.data = new Array(t), this._id = e._GlobalId++
		}
		contains(e) {
			return -1 !== this.indexOf(e)
		}
		dispose() {
			this.reset(), this.data && (this.data.length = 0)
		}
		indexOf(e) {
			const t = this.data.indexOf(e);
			return t >= this.length ? -1 : t
		}
		concat(e) {
			if (0 !== e.length) {
				this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
				for (let t = 0; t < e.length; t++) this.data[this.length++] = (e.data || e)[t]
			}
		}
		forEach(e) {
			for (let t = 0; t < this.length; t++) e(this.data[t])
		}
		reset() {
			this.length = 0
		}
	};
	pd._GlobalId = 0;
	var _d = class extends pd {
			push(e) {
				super.push(e), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId
			}
			reset() {
				super.reset(), this._duplicateId++
			}
			constructor() {
				super(...arguments), this._duplicateId = 0
			}
			pushNoDuplicate(e) {
				return (!e.__smartArrayFlags || e.__smartArrayFlags[this._id] !== this._duplicateId) && (this.push(e), !0)
			}
			concatWithNoDuplicate(e) {
				if (0 !== e.length) {
					this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
					for (let t = 0; t < e.length; t++) {
						const i = (e.data || e)[t];
						this.pushNoDuplicate(i)
					}
				}
			}
		},
		gd = class e {
			toGlobal(t, i) {
				return new e(this.x * t, this.y * i, this.width * t, this.height * i)
			}
			clone() {
				return new e(this.x, this.y, this.width, this.height)
			}
			constructor(e, t, i, s) {
				this.x = e, this.y = t, this.width = i, this.height = s
			}
			toGlobalToRef(e, t, i) {
				return i.x = this.x * e, i.y = this.y * t, i.width = this.width * e, i.height = this.height * t, this
			}
		},
		vd = class e {
			clone() {
				return new e(this.normal.x, this.normal.y, this.normal.z, this.d)
			}
			getClassName() {
				return "Plane"
			}
			static FromPositionAndNormalToRef(e, t, i) {
				return i.normal.copyFrom(t), i.normal.normalize(), i.d = -e.dot(i.normal), i
			}
			signedDistanceTo(e) {
				return Lc.Dot(e, this.normal) + this.d
			}
			static FromArray(t) {
				return new e(t[0], t[1], t[2], t[3])
			}
			static FromPositionAndNormal(t, i) {
				const s = new e(0, 0, 0, 0);
				return this.FromPositionAndNormalToRef(t, i, s)
			}
			constructor(e, t, i, s) {
				this.normal = new Lc(e, t, i), this.d = s
			}
			static FromPoints(t, i, s) {
				const n = new e(0, 0, 0, 0);
				return n.copyFromPoints(t, i, s), n
			}
			isFrontFacingTo(e, t) {
				return Lc.Dot(this.normal, e) <= t
			}
			static SignedDistanceToPlaneFromPositionAndNormal(e, t, i) {
				const s = -(t.x * e.x + t.y * e.y + t.z * e.z);
				return Lc.Dot(i, t) + s
			}
			asArray() {
				return [this.normal.x, this.normal.y, this.normal.z, this.d]
			}
			dotCoordinate(e) {
				return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d
			}
			transform(t) {
				const i = e._TmpMatrix;
				t.invertToRef(i);
				const s = i.m,
					n = this.normal.x,
					a = this.normal.y,
					r = this.normal.z,
					o = this.d,
					l = n * s[0] + a * s[1] + r * s[2] + o * s[3],
					h = n * s[4] + a * s[5] + r * s[6] + o * s[7],
					c = n * s[8] + a * s[9] + r * s[10] + o * s[11],
					u = n * s[12] + a * s[13] + r * s[14] + o * s[15];
				return new e(l, h, c, u)
			}
			getHashCode() {
				let e = this.normal.getHashCode();
				return e = 397 * e ^ this.d, e
			}
			copyFromPoints(e, t, i) {
				const s = t.x - e.x,
					n = t.y - e.y,
					a = t.z - e.z,
					r = i.x - e.x,
					o = i.y - e.y,
					l = i.z - e.z,
					h = n * l - a * o,
					c = a * r - s * l,
					u = s * o - n * r,
					m = Math.sqrt(h * h + c * c + u * u);
				let d;
				return d = 0 !== m ? 1 / m : 0, this.normal.x = h * d, this.normal.y = c * d, this.normal.z = u * d, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this
			}
			normalize() {
				const e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
				let t = 0;
				return 0 !== e && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this
			}
		};
	vd._TmpMatrix = Hc.Identity();
	var yd = class e {
			static GetRightPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] - i[0], t.normal.y = i[7] - i[4], t.normal.z = i[11] - i[8], t.d = i[15] - i[12], t.normalize()
			}
			static GetLeftPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] + i[0], t.normal.y = i[7] + i[4], t.normal.z = i[11] + i[8], t.d = i[15] + i[12], t.normalize()
			}
			static GetBottomPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] + i[1], t.normal.y = i[7] + i[5], t.normal.z = i[11] + i[9], t.d = i[15] + i[13], t.normalize()
			}
			static IsPointInFrustum(e, t) {
				for (let i = 0; i < 6; i++)
					if (t[i].dotCoordinate(e) < 0) return !1;
				return !0
			}
			static GetNearPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] + i[2], t.normal.y = i[7] + i[6], t.normal.z = i[11] + i[10], t.d = i[15] + i[14], t.normalize()
			}
			static GetPlanesToRef(t, i) {
				e.GetNearPlaneToRef(t, i[0]), e.GetFarPlaneToRef(t, i[1]), e.GetLeftPlaneToRef(t, i[2]), e.GetRightPlaneToRef(t, i[3]), e.GetTopPlaneToRef(t, i[4]), e.GetBottomPlaneToRef(t, i[5])
			}
			static GetFarPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] - i[2], t.normal.y = i[7] - i[6], t.normal.z = i[11] - i[10], t.d = i[15] - i[14], t.normalize()
			}
			static GetPlanes(t) {
				const i = [];
				for (let e = 0; e < 6; e++) i.push(new vd(0, 0, 0, 0));
				return e.GetPlanesToRef(t, i), i
			}
			static GetTopPlaneToRef(e, t) {
				const i = e.m;
				t.normal.x = i[3] - i[1], t.normal.y = i[7] - i[5], t.normal.z = i[11] - i[9], t.d = i[15] - i[13], t.normalize()
			}
		},
		Sd = class e extends jc {
			get absoluteRotation() {
				return this.getWorldMatrix().decompose(void 0, this._absoluteRotation), this._absoluteRotation
			}
			restoreState() {
				return !!this._restoreStateValues() && (this.onRestoreStateObservable.notifyObservers(this), !0)
			}
			clone(t, i = null) {
				const s = Xc.Clone(e.GetConstructorFromName(this.getClassName(), t, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
				return s.name = t, s.parent = i, this.onClonedObservable.notifyObservers(s), s
			}
			get globalPosition() {
				return this._globalPosition
			}
			_restoreStateValues() {
				return !!this._stateStored && (this.mk = this._storedFov, !0)
			}
			toString(e) {
				let t = "Name: " + this.name;
				if (t += ", type: " + this.getClassName(), this.animations)
					for (let i = 0; i < this.animations.length; i++) t += ", animation[0]: " + this.animations[i].toString(e);
				return t
			}
			_updateCache(e) {
				e || super._updateCache(), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector)
			}
			getActiveMeshes() {
				return this._activeMeshes
			}
			get isRightCamera() {
				return this._isRightCamera
			}
			storeState() {
				return this._stateStored = !0, this._storedFov = this.mk, this
			}
			get leftCamera() {
				return this._rigCameras.length < 1 ? null : this._rigCameras[0]
			}
			_getViewMatrix() {
				return Hc.Identity()
			}
			getViewMatrix(e) {
				return !e && this._isSynchronizedViewMatrix() || (this._hasMoved = !0, this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childUpdateId++, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix)), this._computedViewMatrix
			}
			static Parse(t, i) {
				const s = t.type,
					n = e.GetConstructorFromName(s, t.name, i, t.interaxial_distance, t.isStereoscopicSideBySide),
					a = Xc.Parse(n, t, i);
				if (void 0 !== t.parentId && (a._waitingParentId = t.parentId), void 0 !== t.parentInstanceIndex && (a._waitingParentInstanceIndex = t.parentInstanceIndex), a.inputs && (a.inputs.parse(t), a._setupInputs()), t.upVector && (a.upVector = Lc.FromArray(t.upVector)), a.setPosition && (a.position.copyFromFloats(0, 0, 0), a.setPosition(Lc.FromArray(t.position))), t.target && a.setTarget && a.setTarget(Lc.FromArray(t.target)), t.cameraRigMode) {
					const e = t.interaxial_distance ? {
						interaxialDistance: t.interaxial_distance
					} : {};
					a.setCameraRigMode(t.cameraRigMode, e)
				}
				if (t.animations) {
					for (let e = 0; e < t.animations.length; e++) {
						const i = t.animations[e],
							s = uc("BABYLON.Animation");
						s && a.animations.push(s.Parse(i))
					}
					jc.ParseAnimationRanges(a, t, i)
				}
				return t.autoAnimate && i.beginAnimation(a, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), void 0 !== t.isEnabled && a.setEnabled(t.isEnabled), a
			}
			_computeObliqueDistance(e) {
				return (this.radius || (this.target ? Lc.Distance(this.position, this.target) : this.position.length())) + e
			}
			_cascadePostProcessesToRigCams() {
				const e = this._getFirstPostProcess();
				e && e.markTextureDirty();
				for (let e = 0, t = this._rigCameras.length; e < t; e++) {
					const t = this._rigCameras[e],
						i = t._rigPostProcess;
					if (i) {
						"pass" === i.getEffectName() && (t.isIntermediate = 0 === this._postProcesses.length), t._postProcesses = this._postProcesses.slice(0).concat(i), i.markTextureDirty()
					} else t._postProcesses = this._postProcesses.slice(0)
				}
			}
			_initCache() {
				super._initCache(), this._cache.position = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.mk = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.obliqueAngle = void 0, this._cache.obliqueLength = void 0, this._cache.obliqueOffset = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0
			}
			_checkInputs() {
				this.onAfterCheckInputsObservable.notifyObservers(this)
			}
			_getVRProjectionMatrix() {
				return Hc.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix
			}
			isActiveMesh(e) {
				return -1 !== this._activeMeshes.indexOf(e)
			}
			getProjectionMatrix(t) {
				if (this._doNotComputeProjectionMatrix || !t && this._isSynchronizedProjectionMatrix()) return this._projectionMatrix;
				this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0;
				const i = this.getEngine(),
					s = this.getScene(),
					n = i.useReverseDepthBuffer;
				if (this.mode === e.PERSPECTIVE_CAMERA) {
					let t;
					this._cache.mk = this.mk, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = i.getAspectRatio(this), this._cache.projectionPlaneTilt = this.projectionPlaneTilt, this.minZ <= 0 && (this.minZ = .1), t = s.useRightHandedSystem ? Hc.PerspectiveFovRHToRef : Hc.PerspectiveFovLHToRef, t(this.mk, i.getAspectRatio(this), n ? this.maxZ : this.minZ, n ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === e.FOVMODE_VERTICAL_FIXED, i.isNDCHalfZRange, this.projectionPlaneTilt, n)
				} else {
					const e = i.getRenderWidth() / 2,
						t = i.getRenderHeight() / 2;
					s.useRightHandedSystem ? this.oblique ? Hc.ObliqueOffCenterRHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -t, this.orthoTop ?? t, n ? this.maxZ : this.minZ, n ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, i.isNDCHalfZRange) : Hc.OrthoOffCenterRHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -t, this.orthoTop ?? t, n ? this.maxZ : this.minZ, n ? this.minZ : this.maxZ, this._projectionMatrix, i.isNDCHalfZRange) : this.oblique ? Hc.ObliqueOffCenterLHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -t, this.orthoTop ?? t, n ? this.maxZ : this.minZ, n ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, i.isNDCHalfZRange) : Hc.OrthoOffCenterLHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -t, this.orthoTop ?? t, n ? this.maxZ : this.minZ, n ? this.minZ : this.maxZ, this._projectionMatrix, i.isNDCHalfZRange), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.obliqueAngle = this.oblique?.angle, this._cache.obliqueLength = this.oblique?.length, this._cache.obliqueOffset = this.oblique?.offset, this._cache.renderWidth = i.getRenderWidth(), this._cache.renderHeight = i.getRenderHeight()
				}
				return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix
			}
			attachPostProcess(e, t = null) {
				return !e.isReusable() && this._postProcesses.indexOf(e) > -1 ? (Qc.Error("You're trying to reuse a post process not defined as reusable."), 0) : (null == t || t < 0 ? this._postProcesses.push(e) : null === this._postProcesses[t] ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e), this._cascadePostProcessesToRigCams(), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._postProcesses.indexOf(e))
			}
			get orthoRight() {
				return this._orthoRight
			}
			isReady(e = !1) {
				if (e)
					for (const e of this._postProcesses)
						if (e && !e.isReady()) return !1;
				return super.isReady(e)
			}
			set orthoRight(e) {
				this._orthoRight = e;
				for (const t of this._rigCameras) t.orthoRight = e
			}
			get upVector() {
				return this._upVector
			}
			_updateRigCameras() {
				for (let e = 0; e < this._rigCameras.length; e++) this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].mk = this.mk, this._rigCameras[e].upVector.copyFrom(this.upVector);
				this.cameraRigMode === e.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport)
			}
			set orthoBottom(e) {
				this._orthoBottom = e;
				for (const t of this._rigCameras) t.orthoBottom = e
			}
			getClassName() {
				return "Camera"
			}
			get rigPostProcess() {
				return this._rigPostProcess
			}
			_isSynchronizedViewMatrix() {
				return !!super._isSynchronized() && (this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent())
			}
			get orthoTop() {
				return this._orthoTop
			}
			getTransformationMatrix() {
				return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix
			}
			set orthoTop(e) {
				this._orthoTop = e;
				for (const t of this._rigCameras) t.orthoTop = e
			}
			set position(e) {
				this._position = e
			}
			get rightCamera() {
				return this._rigCameras.length < 2 ? null : this._rigCameras[1]
			}
			get screenArea() {
				let t = 0,
					i = 0;
				if (this.mode === e.PERSPECTIVE_CAMERA) this.fovMode === e.FOVMODE_VERTICAL_FIXED ? (i = 2 * this.minZ * Math.tan(this.mk / 2), t = this.getEngine().getAspectRatio(this) * i) : (t = 2 * this.minZ * Math.tan(this.mk / 2), i = t / this.getEngine().getAspectRatio(this));
				else {
					const e = this.getEngine().getRenderWidth() / 2,
						s = this.getEngine().getRenderHeight() / 2;
					t = (this.orthoRight ?? e) - (this.orthoLeft ?? -e), i = (this.orthoTop ?? s) - (this.orthoBottom ?? -s)
				}
				return t * i
			}
			update() {
				this._hasMoved = !1, this._checkInputs(), this.cameraRigMode !== e.RIG_MODE_NONE && this._updateRigCameras(), this.getViewMatrix(), this.getProjectionMatrix()
			}
			_calculateHandednessMultiplier() {
				let e = this.getScene().useRightHandedSystem ? -1 : 1;
				return this.parent && this.parent._getWorldMatrixDeterminant() < 0 && (e *= -1), e
			}
			getDirectionToRef(e, t) {
				Lc.TransformNormalToRef(e, this.getWorldMatrix(), t)
			}
			get isLeftCamera() {
				return this._isLeftCamera
			}
			setCameraRigMode(t, i) {
				if (this.cameraRigMode !== t) {
					for (; this._rigCameras.length > 0;) {
						const e = this._rigCameras.pop();
						e && e.dispose()
					}
					if (this.cameraRigMode = t, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = i.interaxialDistance || .0637, this._cameraRigParams.stereoHalfAngle = dd.ToRadians(this._cameraRigParams.interaxialDistance / .0637), this.cameraRigMode !== e.RIG_MODE_NONE) {
						const e = this.createRigCamera(this.name + "_L", 0);
						e && (e._isLeftCamera = !0);
						const t = this.createRigCamera(this.name + "_R", 1);
						t && (t._isRightCamera = !0), e && t && (this._rigCameras.push(e), this._rigCameras.push(t))
					}
					this._setRigMode(i), this._cascadePostProcessesToRigCams(), this.update()
				}
			}
			setCameraRigParameter(e, t) {
				this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[e] = t, "interaxialDistance" === e && (this._cameraRigParams.stereoHalfAngle = dd.ToRadians(t / .0637))
			}
			_updateFrustumPlanes() {
				this._refreshFrustumPlanes && (this.getTransformationMatrix(), this._frustumPlanes ? yd.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = yd.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1)
			}
			set upVector(e) {
				this._upVector = e
			}
			_isSynchronized() {
				return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix()
			}
			applyVerticalCorrection() {
				const e = this.absoluteRotation.toEulerAngles();
				this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -e.x : e.x
			}
			getRightTarget() {
				return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget()
			}
			get orthoLeft() {
				return this._orthoLeft
			}
			dispose(t, i = !1) {
				for (this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0;) {
					const e = this._rigCameras.pop();
					e && e.dispose()
				}
				if (this._parentContainer) {
					const e = this._parentContainer.cameras.indexOf(this);
					e > -1 && this._parentContainer.cameras.splice(e, 1), this._parentContainer = null
				}
				if (this._rigPostProcess) this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses.length = 0;
				else if (this.cameraRigMode !== e.RIG_MODE_NONE) this._rigPostProcess = null, this._postProcesses.length = 0;
				else {
					let e = this._postProcesses.length;
					for (; --e >= 0;) {
						const t = this._postProcesses[e];
						t && t.dispose(this)
					}
				}
				let s = this.customRenderTargets.length;
				for (; --s >= 0;) this.customRenderTargets[s].dispose();
				this.customRenderTargets.length = 0, this._activeMeshes.dispose(), this.getScene().getEngine().releaseRenderPassId(this.renderPassId), super.dispose(t, i)
			}
			getForwardRay(e = 100, t, i) {
				throw ic("Ray")
			}
			_isSynchronizedProjectionMatrix() {
				let t = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
				if (!t) return !1;
				const i = this.getEngine();
				return this.mode === e.PERSPECTIVE_CAMERA ? t = this._cache.mk === this.mk && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === i.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : (t = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === i.getRenderWidth() && this._cache.renderHeight === i.getRenderHeight(), this.oblique && (t = t && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset)), t
			}
			_setupInputs() {}
			isCompletelyInFrustum(e) {
				return this._updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes)
			}
			freezeProjectionMatrix(e) {
				this._doNotComputeProjectionMatrix = !0, void 0 !== e && (this._projectionMatrix = e)
			}
			get rigCameras() {
				return this._rigCameras
			}
			createRigCamera(e, t) {
				return null
			}
			getForwardRayToRef(e, t = 100, i, s) {
				throw ic("Ray")
			}
			serialize() {
				const e = Xc.Serialize(this);
				return e.ik = this.ik, e.type = this.getClassName(), this.parent && this.parent._serializeAsParent(e), this.inputs && this.inputs.serialize(e), Xc.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e
			}
			attachControl(e, t) {}
			get mode() {
				return this._mode
			}
			hasStateStored() {
				return !!this._stateStored
			}
			_getFirstPostProcess() {
				for (let e = 0; e < this._postProcesses.length; e++)
					if (null !== this._postProcesses[e]) return this._postProcesses[e];
				return null
			}
			getDirection(e) {
				const t = Lc.Zero();
				return this.getDirectionToRef(e, t), t
			}
			constructor(t, i, s, n = !0) {
				super(t, s, !1), this._position = Lc.Zero(), this._upVector = Lc.Up(), this.oblique = null, this._orthoLeft = null, this._orthoRight = null, this._orthoBottom = null, this._orthoTop = null, this.mk = .8, this.projectionPlaneTilt = 0, this.minZ = 1, this.maxZ = 1e4, this.inertia = .9, this._mode = e.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new gd(0, 0, 1, 1), this.layerMask = 268435455, this.fovMode = e.FOVMODE_VERTICAL_FIXED, this.cameraRigMode = e.RIG_MODE_NONE, this.customRenderTargets = [], this.outputRenderTarget = null, this.onViewMatrixChangedObservable = new kc, this.onProjectionMatrixChangedObservable = new kc, this.onAfterCheckInputsObservable = new kc, this.onRestoreStateObservable = new kc, this.isRigCamera = !1, this._hasMoved = !1, this._rigCameras = new Array, this._skipRendering = !1, this._projectionMatrix = new Hc, this._postProcesses = new Array, this._activeMeshes = new pd(256), this._globalPosition = Lc.Zero(), this._computedViewMatrix = Hc.Identity(), this._doNotComputeProjectionMatrix = !1, this._transformMatrix = Hc.Zero(), this._refreshFrustumPlanes = !0, this._absoluteRotation = Gc.Identity(), this._isCamera = !0, this._isLeftCamera = !1, this._isRightCamera = !1, this.getScene().addCamera(this), n && !this.getScene().activeCamera && (this.getScene().activeCamera = this), this.position = i, this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${t}`)
			}
			set mode(e) {
				this._mode = e;
				for (const t of this._rigCameras) t.mode = e
			}
			computeWorldMatrix() {
				return this.getWorldMatrix()
			}
			isInFrustum(e, t = !1) {
				if (this._updateFrustumPlanes(), t && this.rigCameras.length > 0) {
					let t = !1;
					return this.rigCameras.forEach((i => {
						i._updateFrustumPlanes(), t = t || e.isInFrustum(i._frustumPlanes)
					})), t
				}
				return e.isInFrustum(this._frustumPlanes)
			}
			get position() {
				return this._position
			}
			get hasMoved() {
				return this._hasMoved
			}
			static GetConstructorFromName(t, i, s, n = 0, a = !0) {
				const r = jc.Construct(t, i, s, {
					interaxial_distance: n,
					isStereoscopicSideBySide: a
				});
				return r || (() => e._CreateDefaultParsedCamera(i, s))
			}
			set orthoLeft(e) {
				this._orthoLeft = e;
				for (const t of this._rigCameras) t.orthoLeft = e
			}
			unfreezeProjectionMatrix() {
				this._doNotComputeProjectionMatrix = !1
			}
			getLeftTarget() {
				return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget()
			}
			detachControl(e) {}
			getWorldMatrix() {
				return this._isSynchronizedViewMatrix() || this.getViewMatrix(), this._worldMatrix
			}
			_setRigMode(e) {}
			detachPostProcess(e) {
				const t = this._postProcesses.indexOf(e); - 1 !== t && (this._postProcesses[t] = null), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._cascadePostProcessesToRigCams()
			}
			get orthoBottom() {
				return this._orthoBottom
			}
		};
	Sd._CreateDefaultParsedCamera = (e, t) => {
		throw ic("UniversalCamera")
	}, Sd.PERSPECTIVE_CAMERA = 0, Sd.ORTHOGRAPHIC_CAMERA = 1, Sd.FOVMODE_VERTICAL_FIXED = 0, Sd.FOVMODE_HORIZONTAL_FIXED = 1, Sd.RIG_MODE_NONE = 0, Sd.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, Sd.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, Sd.RIG_MODE_STEREOSCOPIC_INTERLACED = 14, Sd.RIG_MODE_VR = 20, Sd.RIG_MODE_CUSTOM = 22, Sd.ForceAttachControlToAlwaysPreventDefault = !1, Gh([Jh("position")], Sd.prototype, "_position", void 0), Gh([Jh("upVector")], Sd.prototype, "_upVector", void 0), Gh([Xh()], Sd.prototype, "orthoLeft", null), Gh([Xh()], Sd.prototype, "orthoRight", null), Gh([Xh()], Sd.prototype, "orthoBottom", null), Gh([Xh()], Sd.prototype, "orthoTop", null), Gh([Xh()], Sd.prototype, "fov", void 0), Gh([Xh()], Sd.prototype, "projectionPlaneTilt", void 0), Gh([Xh()], Sd.prototype, "minZ", void 0), Gh([Xh()], Sd.prototype, "maxZ", void 0), Gh([Xh()], Sd.prototype, "inertia", void 0), Gh([Xh()], Sd.prototype, "mode", null), Gh([Xh()], Sd.prototype, "layerMask", void 0), Gh([Xh()], Sd.prototype, "fovMode", void 0), Gh([Xh()], Sd.prototype, "cameraRigMode", void 0), Gh([Xh()], Sd.prototype, "interaxialDistance", void 0), Gh([Xh()], Sd.prototype, "isStereoscopicSideBySide", void 0);
	var Ed = class e {
		static get ForceFullSceneLoadingForIncremental() {
			return e._ForceFullSceneLoadingForIncremental
		}
		static set loggingLevel(t) {
			e._LoggingLevel = t
		}
		static set ForceFullSceneLoadingForIncremental(t) {
			e._ForceFullSceneLoadingForIncremental = t
		}
		static set CleanBoneMatrixWeights(t) {
			e._CleanBoneMatrixWeights = t
		}
		static get ShowLoadingScreen() {
			return e._ShowLoadingScreen
		}
		static get CleanBoneMatrixWeights() {
			return e._CleanBoneMatrixWeights
		}
		static set ShowLoadingScreen(t) {
			e._ShowLoadingScreen = t
		}
		static get loggingLevel() {
			return e._LoggingLevel
		}
	};
	Ed._ForceFullSceneLoadingForIncremental = !1, Ed._ShowLoadingScreen = !0, Ed._CleanBoneMatrixWeights = !1, Ed._LoggingLevel = 0;
	var Ad = !1;
	var bd = class e {
		clearCachedData() {
			this._indices = [], this._resetPointsArrayCache();
			for (const e in this._vertexBuffers) Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) && (this._vertexBuffers[e]._buffer._data = null)
		}
		static CreateGeometryForMesh(t) {
			const i = new e(e.RandomId(), t.getScene());
			return i.applyToMesh(t), i
		}
		toLeftHanded() {
			const e = this.getIndices(!1);
			if (null != e && e.length > 0) {
				for (let t = 0; t < e.length; t += 3) {
					const i = e[t + 0];
					e[t + 0] = e[t + 2], e[t + 2] = i
				}
				this.setIndices(e)
			}
			const t = this.getVerticesData(eu.PositionKind, !1);
			if (null != t && t.length > 0) {
				for (let e = 0; e < t.length; e += 3) t[e + 2] = -t[e + 2];
				this.setVerticesData(eu.PositionKind, t, !1)
			}
			const i = this.getVerticesData(eu.NormalKind, !1);
			if (null != i && i.length > 0) {
				for (let e = 0; e < i.length; e += 3) i[e + 2] = -i[e + 2];
				this.setVerticesData(eu.NormalKind, i, !1)
			}
		}
		serialize() {
			const e = {};
			return e.id = this.id, e.ik = this.ik, e.updatable = this._updatable, nc && nc.HasTags(this) && (e.tags = nc.GetTags(this)), e
		}
		get extend() {
			return this._extend
		}
		dispose() {
			const e = this._meshes,
				t = e.length;
			let i;
			for (i = 0; i < t; i++) this.releaseForMesh(e[i]);
			this._meshes.length = 0, this._disposeVertexArrayObjects();
			for (const e in this._vertexBuffers) this._vertexBuffers[e].dispose();
			if (this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = 0, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._parentContainer) {
				const e = this._parentContainer.geometries.indexOf(this);
				e > -1 && this._parentContainer.geometries.splice(e, 1), this._parentContainer = null
			}
			this._isDisposed = !0
		}
		_disposeVertexArrayObjects() {
			if (this._vertexArrayObjects) {
				for (const e in this._vertexArrayObjects) this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e]);
				this._vertexArrayObjects = {};
				const e = this._meshes,
					t = e.length;
				for (let i = 0; i < t; i++) e[i]._invalidateInstanceVertexArrayObject()
			}
		}
		get doNotSerialize() {
			for (let e = 0; e < this._meshes.length; e++)
				if (!this._meshes[e].doNotSerialize) return !1;
			return !0
		}
		updateIndices(e, t, i = !1) {
			if (this._indexBuffer)
				if (this._indexBufferIsUpdatable) {
					const s = e.length !== this._indices.length;
					if (i || (this._indices = e.slice()), this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t), s)
						for (const e of this._meshes) e._createGlobalSubMesh(!0)
				} else this.setIndices(e, null, !0)
		}
		setIndices(e, t = null, i = !1) {
			this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, this._indexBufferIsUpdatable = i, 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i, "Geometry_" + this.id + "_IndexBuffer")), null != t && (this._totalVertices = t);
			for (const e of this._meshes) e._createGlobalSubMesh(!0), e.synchronizeInstances();
			this._notifyUpdate()
		}
		_updateBoundingInfo(e, t) {
			if (e && this._updateExtend(t), this._resetPointsArrayCache(), e) {
				const e = this._meshes;
				for (const t of e) {
					t.hasBoundingInfo ? t.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : t.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
					const e = t.subMeshes;
					for (const t of e) t.refreshBoundingInfo()
				}
			}
		}
		_rebuild() {
			this._vertexArrayObjects && (this._vertexArrayObjects = {}), 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer"));
			const e = new Set;
			for (const t in this._vertexBuffers) e.add(this._vertexBuffers[t].getWrapperBuffer());
			e.forEach((e => {
				e._rebuild()
			}))
		}
		getVerticesData(e, t, i) {
			const s = this.getVertexBuffer(e);
			return s ? s.getFloatData(this._totalVertices, i || t && 1 !== this._meshes.length) : null
		}
		_notifyUpdate(e) {
			this.onGeometryUpdated && this.onGeometryUpdated(this, e), this._vertexArrayObjects && this._disposeVertexArrayObjects();
			for (const e of this._meshes) e._markSubMeshesAsAttributesDirty()
		}
		isReady() {
			return 1 === this.delayLoadState || 0 === this.delayLoadState
		}
		getVerticesDataKinds() {
			const e = [];
			let t;
			if (!this._vertexBuffers && this._delayInfo)
				for (t in this._delayInfo) e.push(t);
			else
				for (t in this._vertexBuffers) e.push(t);
			return e
		}
		constructor(e, t, i, s = !1, n = null) {
			this.delayLoadState = 0, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this._positionsCache = [], this._parentContainer = null, this.useBoundingInfoFromGeometry = !1, this._scene = t || Dc.LastCreatedScene, this._scene && (this.id = e, this.ik = this._scene.getUniqueId(), this._engine = this._scene.getEngine(), this._meshes = [], this._vertexBuffers = {}, this._indices = [], this._updatable = s, i ? this.setAllVerticesData(i, s) : this._totalVertices = 0, this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), n && (this.applyToMesh(n), n.computeWorldMatrix(!0)))
		}
		getTotalIndices() {
			return this.isReady() ? void 0 !== this._totalIndices ? this._totalIndices : this._indices.length : 0
		}
		getVertexBuffer(e) {
			return this.isReady() ? this._vertexBuffers[e] : null
		}
		static _ImportGeometry(t, i) {
			const s = i.getScene(),
				n = t.geometryUniqueId,
				a = t.geometryId;
			if (n || a) {
				const e = n ? this._GetGeometryByLoadedUniqueId(n, s) : s.getGeometryById(a);
				e && e.applyToMesh(i)
			} else if (t instanceof ArrayBuffer) {
				const e = i._binaryInfo;
				if (e.positionsAttrDesc && e.positionsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.positionsAttrDesc.offset, e.positionsAttrDesc.count);
					i.setVerticesData(eu.PositionKind, s, !1)
				}
				if (e.normalsAttrDesc && e.normalsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.normalsAttrDesc.offset, e.normalsAttrDesc.count);
					i.setVerticesData(eu.NormalKind, s, !1)
				}
				if (e.tangetsAttrDesc && e.tangetsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.tangetsAttrDesc.offset, e.tangetsAttrDesc.count);
					i.setVerticesData(eu.TangentKind, s, !1)
				}
				if (e.uvsAttrDesc && e.uvsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvsAttrDesc.offset, e.uvsAttrDesc.count);
					Ad, i.setVerticesData(eu.UVKind, s, !1)
				}
				if (e.uvs2AttrDesc && e.uvs2AttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvs2AttrDesc.offset, e.uvs2AttrDesc.count);
					Ad, i.setVerticesData(eu.UV2Kind, s, !1)
				}
				if (e.uvs3AttrDesc && e.uvs3AttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvs3AttrDesc.offset, e.uvs3AttrDesc.count);
					Ad, i.setVerticesData(eu.UV3Kind, s, !1)
				}
				if (e.uvs4AttrDesc && e.uvs4AttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvs4AttrDesc.offset, e.uvs4AttrDesc.count);
					Ad, i.setVerticesData(eu.UV4Kind, s, !1)
				}
				if (e.uvs5AttrDesc && e.uvs5AttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvs5AttrDesc.offset, e.uvs5AttrDesc.count);
					Ad, i.setVerticesData(eu.UV5Kind, s, !1)
				}
				if (e.uvs6AttrDesc && e.uvs6AttrDesc.count > 0) {
					const s = new Float32Array(t, e.uvs6AttrDesc.offset, e.uvs6AttrDesc.count);
					Ad, i.setVerticesData(eu.UV6Kind, s, !1)
				}
				if (e.colorsAttrDesc && e.colorsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.colorsAttrDesc.offset, e.colorsAttrDesc.count);
					i.setVerticesData(eu.ColorKind, s, !1, e.colorsAttrDesc.stride)
				}
				if (e.matricesIndicesAttrDesc && e.matricesIndicesAttrDesc.count > 0) {
					const s = new Int32Array(t, e.matricesIndicesAttrDesc.offset, e.matricesIndicesAttrDesc.count),
						n = [];
					for (let e = 0; e < s.length; e++) {
						const t = s[e];
						n.push(255 & t), n.push((65280 & t) >> 8), n.push((16711680 & t) >> 16), n.push(t >> 24 & 255)
					}
					i.setVerticesData(eu.MatricesIndicesKind, n, !1)
				}
				if (e.matricesIndicesExtraAttrDesc && e.matricesIndicesExtraAttrDesc.count > 0) {
					const s = new Int32Array(t, e.matricesIndicesExtraAttrDesc.offset, e.matricesIndicesExtraAttrDesc.count),
						n = [];
					for (let e = 0; e < s.length; e++) {
						const t = s[e];
						n.push(255 & t), n.push((65280 & t) >> 8), n.push((16711680 & t) >> 16), n.push(t >> 24 & 255)
					}
					i.setVerticesData(eu.MatricesIndicesExtraKind, n, !1)
				}
				if (e.matricesWeightsAttrDesc && e.matricesWeightsAttrDesc.count > 0) {
					const s = new Float32Array(t, e.matricesWeightsAttrDesc.offset, e.matricesWeightsAttrDesc.count);
					i.setVerticesData(eu.MatricesWeightsKind, s, !1)
				}
				if (e.indicesAttrDesc && e.indicesAttrDesc.count > 0) {
					const s = new Int32Array(t, e.indicesAttrDesc.offset, e.indicesAttrDesc.count);
					i.setIndices(s, null)
				}
				if (e.subMeshesAttrDesc && e.subMeshesAttrDesc.count > 0) {
					const s = new Int32Array(t, e.subMeshesAttrDesc.offset, 5 * e.subMeshesAttrDesc.count);
					i.subMeshes = [];
					for (let t = 0; t < e.subMeshesAttrDesc.count; t++) {
						const e = s[5 * t + 0],
							n = s[5 * t + 1],
							a = s[5 * t + 2],
							r = s[5 * t + 3],
							o = s[5 * t + 4];
						bu.AddToMesh(e, n, a, r, o, i)
					}
				}
			} else if (t.positions && t.normals && t.indices) {
				if (i.setVerticesData(eu.PositionKind, t.positions, t.positions._updatable), i.setVerticesData(eu.NormalKind, t.normals, t.normals._updatable), t.tangents && i.setVerticesData(eu.TangentKind, t.tangents, t.tangents._updatable), t.uvs && i.setVerticesData(eu.UVKind, t.uvs, t.uvs._updatable), t.uvs2 && i.setVerticesData(eu.UV2Kind, t.uvs2, t.uvs2._updatable), t.uvs3 && i.setVerticesData(eu.UV3Kind, t.uvs3, t.uvs3._updatable), t.uvs4 && i.setVerticesData(eu.UV4Kind, t.uvs4, t.uvs4._updatable), t.uvs5 && i.setVerticesData(eu.UV5Kind, t.uvs5, t.uvs5._updatable), t.uvs6 && i.setVerticesData(eu.UV6Kind, t.uvs6, t.uvs6._updatable), t.colors && i.setVerticesData(eu.ColorKind, wc.CheckColors4(t.colors, t.positions.length / 3), t.colors._updatable), t.matricesIndices)
					if (t.matricesIndices._isExpanded) delete t.matricesIndices._isExpanded, i.setVerticesData(eu.MatricesIndicesKind, t.matricesIndices, t.matricesIndices._updatable);
					else {
						const e = [];
						for (let i = 0; i < t.matricesIndices.length; i++) {
							const s = t.matricesIndices[i];
							e.push(255 & s), e.push((65280 & s) >> 8), e.push((16711680 & s) >> 16), e.push(s >> 24 & 255)
						}
						i.setVerticesData(eu.MatricesIndicesKind, e, t.matricesIndices._updatable)
					} if (t.matricesIndicesExtra)
					if (t.matricesIndicesExtra._isExpanded) delete t.matricesIndices._isExpanded, i.setVerticesData(eu.MatricesIndicesExtraKind, t.matricesIndicesExtra, t.matricesIndicesExtra._updatable);
					else {
						const e = [];
						for (let i = 0; i < t.matricesIndicesExtra.length; i++) {
							const s = t.matricesIndicesExtra[i];
							e.push(255 & s), e.push((65280 & s) >> 8), e.push((16711680 & s) >> 16), e.push(s >> 24 & 255)
						}
						i.setVerticesData(eu.MatricesIndicesExtraKind, e, t.matricesIndicesExtra._updatable)
					} t.matricesWeights && (e._CleanMatricesWeights(t, i), i.setVerticesData(eu.MatricesWeightsKind, t.matricesWeights, t.matricesWeights._updatable)), t.matricesWeightsExtra && i.setVerticesData(eu.MatricesWeightsExtraKind, t.matricesWeightsExtra, t.matricesWeights._updatable), i.setIndices(t.indices, null)
			}
			if (t.subMeshes) {
				i.subMeshes = [];
				for (let e = 0; e < t.subMeshes.length; e++) {
					const s = t.subMeshes[e];
					bu.AddToMesh(s.materialIndex, s.verticesStart, s.verticesCount, s.indexStart, s.indexCount, i)
				}
			}
			i._shouldGenerateFlatShading && (i.convertToFlatShadedMesh(), i._shouldGenerateFlatShading = !1), i.computeWorldMatrix(!0), s.onMeshImportedObservable.notifyObservers(i)
		}
		serializeVerticeData() {
			const e = this.serialize();
			return this.isVerticesDataPresent(eu.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(eu.PositionKind)), this.isVertexBufferUpdatable(eu.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(eu.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(eu.NormalKind)), this.isVertexBufferUpdatable(eu.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(eu.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(eu.TangentKind)), this.isVertexBufferUpdatable(eu.TangentKind) && (e.tangents._updatable = !0)), this.isVerticesDataPresent(eu.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(eu.UVKind)), this.isVertexBufferUpdatable(eu.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(eu.UV2Kind) && (e.uvs2 = this._toNumberArray(this.getVerticesData(eu.UV2Kind)), this.isVertexBufferUpdatable(eu.UV2Kind) && (e.uvs2._updatable = !0)), this.isVerticesDataPresent(eu.UV3Kind) && (e.uvs3 = this._toNumberArray(this.getVerticesData(eu.UV3Kind)), this.isVertexBufferUpdatable(eu.UV3Kind) && (e.uvs3._updatable = !0)), this.isVerticesDataPresent(eu.UV4Kind) && (e.uvs4 = this._toNumberArray(this.getVerticesData(eu.UV4Kind)), this.isVertexBufferUpdatable(eu.UV4Kind) && (e.uvs4._updatable = !0)), this.isVerticesDataPresent(eu.UV5Kind) && (e.uvs5 = this._toNumberArray(this.getVerticesData(eu.UV5Kind)), this.isVertexBufferUpdatable(eu.UV5Kind) && (e.uvs5._updatable = !0)), this.isVerticesDataPresent(eu.UV6Kind) && (e.uvs6 = this._toNumberArray(this.getVerticesData(eu.UV6Kind)), this.isVertexBufferUpdatable(eu.UV6Kind) && (e.uvs6._updatable = !0)), this.isVerticesDataPresent(eu.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(eu.ColorKind)), this.isVertexBufferUpdatable(eu.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(eu.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(eu.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(eu.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(eu.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(eu.MatricesWeightsKind)), this.isVertexBufferUpdatable(eu.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this._toNumberArray(this.getIndices()), e
		}
		static _CleanMatricesWeights(e, t) {
			const i = .001;
			if (!Ed.CleanBoneMatrixWeights) return;
			let s = 0;
			if (!(e.skeletonId > -1)) return;
			{
				const i = t.getScene().getLastSkeletonById(e.skeletonId);
				if (!i) return;
				s = i.bones.length
			}
			const n = t.getVerticesData(eu.MatricesIndicesKind),
				a = t.getVerticesData(eu.MatricesIndicesExtraKind),
				r = e.matricesWeights,
				o = e.matricesWeightsExtra,
				l = e.numBoneInfluencer,
				h = r.length;
			for (let e = 0; e < h; e += 4) {
				let t = 0,
					h = -1;
				for (let s = 0; s < 4; s++) {
					const n = r[e + s];
					t += n, n < i && h < 0 && (h = s)
				}
				if (o)
					for (let s = 0; s < 4; s++) {
						const n = o[e + s];
						t += n, n < i && h < 0 && (h = s + 4)
					}
				if ((h < 0 || h > l - 1) && (h = l - 1), t > i) {
					const i = 1 / t;
					for (let t = 0; t < 4; t++) r[e + t] *= i;
					if (o)
						for (let t = 0; t < 4; t++) o[e + t] *= i
				} else h >= 4 ? (o[e + h - 4] = 1 - t, a[e + h - 4] = s) : (r[e + h] = 1 - t, n[e + h] = s)
			}
			t.setVerticesData(eu.MatricesIndicesKind, n), e.matricesWeightsExtra && t.setVerticesData(eu.MatricesIndicesExtraKind, a)
		}
		static _GetGeometryByLoadedUniqueId(e, t) {
			for (let i = 0; i < t.geometries.length; i++)
				if (t.geometries[i]._loadedUniqueId === e) return t.geometries[i];
			return null
		}
		copyVerticesData(e, t) {
			const i = this.getVertexBuffer(e);
			if (!i) return;
			t[e] || (t[e] = new Float32Array(this._totalVertices * i.getSize()));
			const s = i.getData();
			s && function(e, t, i, s, n, a, r, o) {
				const l = t * eu.GetTypeByteLength(i),
					h = r * t;
				if (o.length !== h) throw new Error("Output length is not valid");
				if (i === eu.FLOAT && n === l)
					if (e instanceof Array) {
						const t = s / 4;
						o.set(e, t)
					} else if (e instanceof ArrayBuffer) {
					const t = new Float32Array(e, s, h);
					o.set(t)
				} else {
					const t = e.byteOffset + s;
					if (t % 4) return Qc.Warn("CopyFloatData: copied misaligned data."), void o.set(new Float32Array(e.buffer.slice(t, t + 4 * h)));
					const i = new Float32Array(e.buffer, t, h);
					o.set(i)
				} else eu.ForEach(e, s, n, t, i, h, a, ((e, t) => o[t] = e))
			}(s, i.getSize(), i.type, i.byteOffset, i.byteStride, i.normalized, this._totalVertices, t[e])
		}
		getIndexBuffer() {
			return this.isReady() ? this._indexBuffer : null
		}
		getIndices(e, t) {
			if (!this.isReady()) return null;
			const i = this._indices;
			return t || e && 1 !== this._meshes.length ? i.slice() : i
		}
		isVerticesDataPresent(e) {
			return this._vertexBuffers ? void 0 !== this._vertexBuffers[e] : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e)
		}
		_generatePointsArray() {
			if (this._positions) return !0;
			const e = this.getVerticesData(eu.PositionKind);
			if (!e || 0 === e.length) return !1;
			for (let t = 3 * this._positionsCache.length, i = this._positionsCache.length; t < e.length; t += 3, ++i) this._positionsCache[i] = Lc.FromArray(e, t);
			for (let t = 0, i = 0; t < e.length; t += 3, ++i) this._positionsCache[i].set(e[0 + t], e[1 + t], e[2 + t]);
			return this._positionsCache.length = e.length / 3, this._positions = this._positionsCache, !0
		}
		isDisposed() {
			return this._isDisposed
		}
		get boundingBias() {
			return this._boundingBias
		}
		_queueLoad(e, t) {
			this.delayLoadingFile && (e.addPendingData(this), e._loadFile(this.delayLoadingFile, (i => {
				if (!this._delayLoadingFunction) return;
				this._delayLoadingFunction(JSON.parse(i), this), this.delayLoadState = 1, this._delayInfo = [], e.removePendingData(this);
				const s = this._meshes,
					n = s.length;
				for (let e = 0; e < n; e++) this._applyToMesh(s[e]);
				t && t()
			}), void 0, !0))
		}
		updateVerticesDataDirectly(e, t, i, s = !1) {
			const n = this.getVertexBuffer(e);
			n && (n.updateDirectly(t, i, s), this._notifyUpdate(e))
		}
		removeVerticesData(e) {
			this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]), this._vertexArrayObjects && this._disposeVertexArrayObjects()
		}
		copy(t) {
			const i = new Mu;
			i.indices = [];
			const s = this.getIndices();
			if (s)
				for (let e = 0; e < s.length; e++) i.indices.push(s[e]);
			let n, a = !1,
				r = !1;
			for (n in this._vertexBuffers) {
				const e = this.getVerticesData(n);
				if (e && (e instanceof Float32Array ? i.set(new Float32Array(e), n) : i.set(e.slice(0), n), !r)) {
					const e = this.getVertexBuffer(n);
					e && (a = e.isUpdatable(), r = !a)
				}
			}
			const o = new e(t, this._scene, i, a);
			for (n in o.delayLoadState = this.delayLoadState, o.delayLoadingFile = this.delayLoadingFile, o._delayLoadingFunction = this._delayLoadingFunction, this._delayInfo) o._delayInfo = o._delayInfo || [], o._delayInfo.push(n);
			return o._boundingInfo = new yu(this._extend.minimum, this._extend.maximum), o
		}
		applyToMesh(e) {
			if (e._geometry === this) return;
			const t = e._geometry;
			t && t.releaseForMesh(e), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject();
			const i = this._meshes;
			e._geometry = this, e._internalAbstractMeshDataInfo._positions = null, this._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo)
		}
		isVertexBufferUpdatable(e) {
			const t = this._vertexBuffers[e];
			return !!t && t.isUpdatable()
		}
		releaseForMesh(e, t) {
			const i = this._meshes,
				s = i.indexOf(e); - 1 !== s && (i.splice(s, 1), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(), e._geometry = null, 0 === i.length && t && this.dispose())
		}
		_toNumberArray(e) {
			return Array.isArray(e) ? e : Array.prototype.slice.call(e)
		}
		setIndexBuffer(e, t, i) {
			this._indices = [], this._indexBufferIsUpdatable = !1, this._indexBuffer = e, this._totalVertices = t, this._totalIndices = i, e.is32Bits || (e.is32Bits = this._totalIndices > 65535);
			for (const e of this._meshes) e._createGlobalSubMesh(!0), e.synchronizeInstances();
			this._notifyUpdate()
		}
		getScene() {
			return this._scene
		}
		_updateExtend(e = null) {
			if (this.useBoundingInfoFromGeometry && this._boundingInfo) this._extend = {
				minimum: this._boundingInfo.minimum.clone(),
				maximum: this._boundingInfo.maximum.clone()
			};
			else {
				if (!e && !(e = this.getVerticesData(eu.PositionKind))) return;
				this._extend = Eu(e, 0, this._totalVertices, this.boundingBias, 3)
			}
		}
		getTotalVertices() {
			return this.isReady() ? this._totalVertices : 0
		}
		static ExtractFromMesh(e, t) {
			const i = e._geometry;
			return i ? i.copy(t) : null
		}
		getVertexBuffers() {
			return this.isReady() ? this._vertexBuffers : null
		}
		_bind(e, t, i, s) {
			if (!e) return;
			void 0 === t && (t = this._indexBuffer);
			const n = this.getVertexBuffers();
			if (!n) return;
			if (t != this._indexBuffer || !this._vertexArrayObjects && !s) return void this._engine.bindBuffers(n, t, e, i);
			const a = s || this._vertexArrayObjects,
				r = this._engine;
			a[e.key] || (a[e.key] = r.recordVertexArrayObject(n, t, e, i)), r.bindVertexArrayObject(a[e.key], t)
		}
		setVerticesData(e, t, i = !1, s) {
			i && Array.isArray(t) && (t = new Float32Array(t));
			const n = new eu(this._engine, t, e, {
				updatable: i,
				postponeInternalCreation: 0 === this._meshes.length,
				stride: s,
				label: "Geometry_" + this.id + "_" + e
			});
			this.setVerticesBuffer(n)
		}
		setAllVerticesData(e, t) {
			e.applyToGeometry(this, t), this._notifyUpdate()
		}
		setVerticesBuffer(e, t = null, i = !0) {
			const s = e.getKind();
			this._vertexBuffers[s] && i && this._vertexBuffers[s].dispose(), e._buffer && e._buffer._increaseReferences(), this._vertexBuffers[s] = e;
			const n = this._meshes,
				a = n.length;
			if (s === eu.PositionKind) {
				this._totalVertices = t ?? e._maxVerticesCount, this._updateExtend(e.getFloatData(this._totalVertices)), this._resetPointsArrayCache();
				const i = this._extend && this._extend.minimum || new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
					s = this._extend && this._extend.maximum || new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				for (let e = 0; e < a; e++) {
					const t = n[e];
					t.buildBoundingInfo(i, s), t._createGlobalSubMesh(t.isUnIndexed), t.computeWorldMatrix(!0), t.synchronizeInstances()
				}
			}
			this._notifyUpdate(s)
		}
		updateVerticesData(e, t, i = !1) {
			const s = this.getVertexBuffer(e);
			s && (s.update(t), e === eu.PositionKind && this._updateBoundingInfo(i, t), this._notifyUpdate(e))
		}
		static Parse(t, i, s) {
			const n = new e(t.id, i, void 0, t.updatable);
			return n._loadedUniqueId = t.ik, nc && nc.AddTagsTo(n, t.tags), t.delayLoadingFile ? (n.delayLoadState = 4, n.delayLoadingFile = s + t.delayLoadingFile, n._boundingInfo = new yu(Lc.FromArray(t.boundingBoxMinimum), Lc.FromArray(t.boundingBoxMaximum)), n._delayInfo = [], t.hasUVs && n._delayInfo.push(eu.UVKind), t.hasUVs2 && n._delayInfo.push(eu.UV2Kind), t.hasUVs3 && n._delayInfo.push(eu.UV3Kind), t.hasUVs4 && n._delayInfo.push(eu.UV4Kind), t.hasUVs5 && n._delayInfo.push(eu.UV5Kind), t.hasUVs6 && n._delayInfo.push(eu.UV6Kind), t.hasColors && n._delayInfo.push(eu.ColorKind), t.hasMatricesIndices && n._delayInfo.push(eu.MatricesIndicesKind), t.hasMatricesWeights && n._delayInfo.push(eu.MatricesWeightsKind), n._delayLoadingFunction = Mu.ImportVertexData) : Mu.ImportVertexData(t, n), i.pushGeometry(n, !0), n
		}
		load(e, t) {
			2 !== this.delayLoadState && (this.isReady() ? t && t() : (this.delayLoadState = 2, this._queueLoad(e, t)))
		}
		getEngine() {
			return this._engine
		}
		static RandomId() {
			return dd.RandomId()
		}
		_releaseVertexArrayObject(e = null) {
			e && this._vertexArrayObjects && this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key])
		}
		get meshes() {
			return this._meshes
		}
		_resetPointsArrayCache() {
			this._positions = null
		}
		set boundingBias(e) {
			this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(), this._updateBoundingInfo(!0, null)
		}
		_applyToMesh(e) {
			const t = this._meshes.length;
			for (const i in this._vertexBuffers) 1 === t && this._vertexBuffers[i].create(), i === eu.PositionKind && (this._extend || this._updateExtend(), e.buildBoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(e.isUnIndexed), e._updateBoundingInfo());
			1 === t && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer")), e._syncGeometryWithMorphTargetManager(), e.synchronizeInstances()
		}
	};
	var xd = class {
			constructor() {
				this.shaderLanguage = 0
			}
			postProcessor(e, t, i, s, n) {
				if (n.drawBuffersExtensionDisabled) {
					const t = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
					e = e.replace(t, "")
				}
				return e
			}
		},
		Md = /(flat\s)?\s*varying\s*.*/,
		Cd = class {
			varyingProcessor(e, t) {
				return e.replace("varying", t ? "in" : "out")
			}
			constructor() {
				this.shaderLanguage = 0
			}
			varyingCheck(e, t) {
				return Md.test(e)
			}
			postProcessor(e, t, i) {
				const s = -1 !== e.search(/#extension.+GL_EXT_draw_buffers.+require/);
				if (e = (e = e.replace(/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g, "")).replace(/texture2D\s*\(/g, "texture("), i) {
					const t = -1 !== e.search(/layout *\(location *= *0\) *out/g);
					e = (e = (e = (e = (e = (e = (e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod(")).replace(/textureCubeLodEXT\s*\(/g, "textureLod(")).replace(/textureCube\s*\(/g, "texture(")).replace(/gl_FragDepthEXT/g, "gl_FragDepth")).replace(/gl_FragColor/g, "glFragColor")).replace(/gl_FragData/g, "glFragData")).replace(/void\s+?main\s*\(/g, (s || t ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(")
				} else {
					if (-1 !== t.indexOf("#define MULTIVIEW")) return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + e
				}
				return e
			}
			attributeProcessor(e) {
				return e.replace("attribute", "in")
			}
		},
		Td = class extends qc {
			get underlyingResource() {
				return this._buffer
			}
			constructor(e) {
				super(), this._buffer = e
			}
		},
		wd = class {
			releaseMSAARenderBuffers() {
				if (this._MSAARenderBuffers) {
					for (const e of this._MSAARenderBuffers) this._context.deleteRenderbuffer(e);
					this._MSAARenderBuffers = null
				}
			}
			addMSAARenderBuffer(e) {
				this._MSAARenderBuffers || (this._MSAARenderBuffers = []), this._MSAARenderBuffers.push(e)
			}
			constructor(e = null, t) {
				if (this._MSAARenderBuffers = null, this._context = t, !e && !(e = t.createTexture())) throw new Error("Unable to create webGL texture");
				this.set(e)
			}
			reset() {
				this._webGLTexture = null, this._MSAARenderBuffers = null
			}
			get underlyingResource() {
				return this._webGLTexture
			}
			set(e) {
				this._webGLTexture = e
			}
			setUsage() {}
			getMSAARenderBuffer(e = 0) {
				return this._MSAARenderBuffers?.[e] ?? null
			}
			release() {
				this.releaseMSAARenderBuffers(), this._webGLTexture && this._context.deleteTexture(this._webGLTexture), this.reset()
			}
		},
		Rd = class {},
		Nd = class e extends Dm {
			setInt(e, t) {
				return !!e && (this._gl.uniform1i(e, t), !0)
			}
			_prepareWebGLTextureContinuation(e, t, i, s, n) {
				const a = this._gl;
				if (!a) return;
				const r = this._getSamplingParameters(n, !i);
				a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, r.mag), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, r.min), i || s || a.generateMipmap(a.TEXTURE_2D), this._bindTextureDirectly(a.TEXTURE_2D, null), t && t.removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear()
			}
			_getGlobalDefines(e) {
				return $u(e, this.isNDCHalfZRange, this.useReverseDepthBuffer, this.useExactSrgbConversions)
			}
			_setAnisotropicLevel(e, t, i) {
				const s = this._caps.textureAnisotropicFilterExtension;
				11 !== t.samplingMode && 3 !== t.samplingMode && 2 !== t.samplingMode && (i = 1), s && t._cachedAnisotropicFilteringLevel !== i && (this._setTextureParameterFloat(e, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i, this._caps.maxAnisotropy), t), t._cachedAnisotropicFilteringLevel = i)
			}
			_unbindVertexArrayObject() {
				this._cachedVertexArrayObject && (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null))
			}
			_getShaderSource(e) {
				return this._gl.getShaderSource(e)
			}
			updateTextureWrappingMode(e, t, i = null, s = null) {
				const n = this._getTextureTarget(e);
				null !== t && (this._setTextureParameterInteger(n, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e), e._cachedWrapU = t), null !== i && (this._setTextureParameterInteger(n, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(i), e), e._cachedWrapV = i), (e.is2DArray || e.is3D) && null !== s && (this._setTextureParameterInteger(n, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(s), e), e._cachedWrapR = s), this._bindTextureDirectly(n, null)
			}
			setArray(e, t) {
				return !!e && (!(t.length < 1) && (this._gl.uniform1fv(e, t), !0))
			}
			applyStates() {
				if (this._depthCullingState.apply(this._gl), this._stencilStateComposer.apply(this._gl), this._alphaState.apply(this._gl), this._colorWriteChanged) {
					this._colorWriteChanged = !1;
					const e = this._colorWrite;
					this._gl.colorMask(e, e, e, e)
				}
			}
			static get IsSupported() {
				return this.isSupported()
			}
			_setTextureParameterInteger(e, t, i, s) {
				s && this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameteri(e, t, i)
			}
			snapshotRenderingReset() {
				this.snapshotRendering = !1
			}
			_setProgram(e) {
				this._currentProgram !== e && (! function(e, t) {
					t.useProgram(e)
				}(e, this._gl), this._currentProgram = e)
			}
			_createVertexBuffer(e, t) {
				const i = this._gl.createBuffer();
				if (!i) throw new Error("Unable to create vertex buffer");
				const s = new Td(i);
				return this.bindArrayBuffer(s), "number" != typeof e ? e instanceof Array ? (this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t), s.Yk = 4 * e.length) : (this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t), s.Yk = e.byteLength) : (this._gl.bufferData(this._gl.ARRAY_BUFFER, new Uint8Array(e), t), s.Yk = e), this._resetVertexBufferBinding(), s.references = 1, s
			}
			_deleteBuffer(e) {
				this._gl.deleteBuffer(e.underlyingResource)
			}
			_initFeatures() {
				this._features = {
					forceBitmapOverHTMLImageElement: "undefined" == typeof HTMLImageElement,
					supportRenderAndCopyToLodForFloatTextures: 1 !== this._webGLVersion,
					supportDepthStencilTexture: 1 !== this._webGLVersion,
					supportShadowSamplers: 1 !== this._webGLVersion,
					uniformBufferHardCheckMatrix: !1,
					allowTexturePrefiltering: 1 !== this._webGLVersion,
					trackUbosInFrame: !1,
					checkUbosContentBeforeUpload: !1,
					supportCSM: 1 !== this._webGLVersion,
					basisNeedsPOT: 1 === this._webGLVersion,
					support3DTextures: 1 !== this._webGLVersion,
					needTypeSuffixInShaderConstants: 1 !== this._webGLVersion,
					supportMSAA: 1 !== this._webGLVersion,
					supportSSAO2: 1 !== this._webGLVersion,
					supportExtendedTextureFormats: 1 !== this._webGLVersion,
					supportSwitchCaseInShader: 1 !== this._webGLVersion,
					supportSyncTextureRead: !0,
					needsInvertingBitmap: !0,
					useUBOBindingCache: !0,
					needShaderCodeInlining: !1,
					needToAlwaysBindUniformBuffers: !1,
					supportRenderPasses: !1,
					supportSpriteInstancing: !0,
					forceVertexBufferStrideAndOffsetMultiple4Bytes: !1,
					_checkNonFloatVertexBuffersDontRecreatePipelineContext: !1,
					_collectUbosUpdatedInFrame: !1
				}
			}
			drawElementsType(e, t, i, s) {
				this.applyStates(), this._reportDrawCall();
				const n = this._drawMode(e),
					a = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT,
					r = this._uintIndicesCurrentlySet ? 4 : 2;
				s ? this._gl.drawElementsInstanced(n, i, a, t * r, s) : this._gl.drawElements(n, i, a, t * r)
			}
			_resetVertexBufferBinding() {
				this.bindArrayBuffer(null), this._cachedVertexBuffers = null
			}
			_deleteTexture(e) {
				e?.release()
			}
			inlineShaderCode(e) {
				return e
			}
			_uploadCompressedDataToTextureDirectly(e, t, i, s, n, a = 0, r = 0) {
				const o = this._gl;
				let l = o.TEXTURE_2D;
				if (e.isCube && (l = o.TEXTURE_CUBE_MAP_POSITIVE_X + a), e._useSRGBBuffer) switch (t) {
					case 37492:
					case 36196:
						this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1;
						break;
					case 37496:
						this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1;
						break;
					case 36492:
						t = o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
						break;
					case 37808:
						t = o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
						break;
					case 33776:
						this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
						break;
					case 33777:
						this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
						break;
					case 33779:
						this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1;
						break;
					default:
						e._useSRGBBuffer = !1
				}
				this._gl.compressedTexImage2D(l, r, t, i, s, 0, n)
			}
			static get HasMajorPerformanceCaveat() {
				if (null === this._HasMajorPerformanceCaveat) try {
					const e = Dm._CreateCanvas(1, 1),
						t = e.getContext("webgl", {
							failIfMajorPerformanceCaveat: !0
						}) || e.getContext("experimental-webgl", {
							failIfMajorPerformanceCaveat: !0
						});
					this._HasMajorPerformanceCaveat = !t
				} catch (e) {
					this._HasMajorPerformanceCaveat = !1
				}
				return this._HasMajorPerformanceCaveat
			}
			_uploadDataToTextureDirectly(e, t, i = 0, s = 0, n, a = !1) {
				const r = this._gl,
					o = this._getWebGLTextureType(e.type),
					l = this._getInternalFormat(e.format),
					h = void 0 === n ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(n, e._useSRGBBuffer);
				this._unpackFlipY(e.invertY);
				let c = r.TEXTURE_2D;
				e.isCube && (c = r.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				const u = Math.round(Math.log(e.width) * Math.LOG2E),
					m = Math.round(Math.log(e.height) * Math.LOG2E),
					d = a ? e.width : Math.pow(2, Math.max(u - s, 0)),
					f = a ? e.height : Math.pow(2, Math.max(m - s, 0));
				r.texImage2D(c, s, h, d, f, 0, l, o, t)
			}
			attachContextRestoredEvent(e) {
				this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1)
			}
			_getTexImageParametersForCreateTexture(e, t) {
				let i, s;
				return 1 === this.webGLVersion ? (i = this._getInternalFormat(e, t), s = i) : (i = this._getInternalFormat(e, !1), s = this._getRGBABufferInternalSizedFormat(0, e, t)), {
					internalFormat: s,
					format: i,
					type: this._gl.UNSIGNED_BYTE
				}
			}
			wipeCaches(e) {
				this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, this._unbindVertexArrayObject(), e && (this._currentProgram = null, this.resetTextureCache(), this._stencilStateComposer.reset(), this._depthCullingState.reset(), this._depthCullingState.depthFunc = this._gl.LEQUAL, this._alphaState.reset(), this._alphaMode = 1, this._alphaEquation = 0, this._colorWrite = !0, this._colorWriteChanged = !0, this._unpackFlipYCached = null, this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this._mustWipeVertexAttributes = !0, this.unbindAllAttributes()), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this.bindIndexBuffer(null))
			}
			setUIntArray(e, t) {
				return !!e && (this._gl.uniform1uiv(e, t), !0)
			}
			get name() {
				return this._name
			}
			extractDriverInfo() {
				const e = this.getGlInfo();
				return e && e.renderer ? e.renderer : ""
			}
			_resetIndexBufferBinding() {
				this.bindIndexBuffer(null), this._cachedIndexBuffer = null
			}
			_preparePipelineContext(e, t, i, s, n, a, r, o, l, h, c) {
				const u = pm(this._gl);
				return u._contextWasLost = this._contextWasLost, u.validateShaderPrograms = this.validateShaderPrograms, u._createShaderProgramInjection = this._createShaderProgram.bind(this), u.createRawShaderProgramInjection = this.createRawShaderProgram.bind(this), u.createShaderProgramInjection = this.createShaderProgram.bind(this), u.loadFileInjection = this._loadFile.bind(this),
					function(e, t, i, s, n, a, r, o, l, h = "", c, u, m) {
						const d = pm(e.context);
						u || (u = d.createRawShaderProgramInjection ?? _m), m || (m = d.createShaderProgramInjection ?? gm);
						const f = e;
						f.program = s ? u(f, t, i, f.context, l) : m(f, t, i, o, f.context, l), f.program.__SPECTOR_rebuildProgram = r, c()
					}(e, t, i, s, 0, 0, r, o, l, h, c)
			}
			bindBuffersDirectly(e, t, i, s, n) {
				if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== n) {
					this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = n;
					const t = n.getAttributesCount();
					this._unbindVertexArrayObject(), this.unbindAllAttributes();
					let a = 0;
					for (let r = 0; r < t; r++)
						if (r < i.length) {
							const t = n.getAttributeLocation(r);
							t >= 0 && (this._gl.enableVertexAttribArray(t), this._vertexAttribArraysEnabled[t] = !0, this._vertexAttribPointer(e, t, i[r], this._gl.FLOAT, !1, s, a)), a += 4 * i[r]
						}
				}
				this._bindIndexBufferWithCache(t)
			}
			_vertexAttribPointer(e, t, i, s, n, a, r) {
				const o = this._currentBufferPointers[t];
				if (!o) return;
				let l = !1;
				o.active ? (o.buffer !== e && (o.buffer = e, l = !0), o.size !== i && (o.size = i, l = !0), o.type !== s && (o.type = s, l = !0), o.normalized !== n && (o.normalized = n, l = !0), o.stride !== a && (o.stride = a, l = !0), o.offset !== r && (o.offset = r, l = !0)) : (l = !0, o.active = !0, o.index = t, o.size = i, o.type = s, o.normalized = n, o.stride = a, o.offset = r, o.buffer = e), (l || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), s === this._gl.UNSIGNED_INT || s === this._gl.INT ? this._gl.vertexAttribIPointer(t, i, s, a, r) : this._gl.vertexAttribPointer(t, i, s, n, a, r))
			}
			bindBuffers(e, t, i, s) {
				this._cachedVertexBuffers === e && this._cachedEffectForVertexBuffers === i || (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i, this._bindVertexBuffersAttributes(e, i, s)), this._bindIndexBufferWithCache(t)
			}
			getInfo() {
				return this.getGlInfo()
			}
			setUInt4(e, t, i, s, n) {
				return !!e && (this._gl.uniform4ui(e, t, i, s, n), !0)
			}
			setFloat4(e, t, i, s, n) {
				return !!e && (this._gl.uniform4f(e, t, i, s, n), !0)
			}
			createTexture(e, t, i, s, n = 3, a = null, r = null, o = null, l = null, h = null, c = null, u, m, d, f) {
				return this._createTextureBase(e, t, i, s, n, a, r, ((...e) => this._prepareWebGLTexture(...e, h)), ((e, t, i, n, a, r) => {
					const o = this._gl,
						l = i.width === e && i.height === t;
					a._creationFlags = d ?? 0;
					const h = this._getTexImageParametersForCreateTexture(a.format, a._useSRGBBuffer);
					if (l) return o.texImage2D(o.TEXTURE_2D, 0, h.internalFormat, h.format, h.type, i), !1;
					const c = this._caps.maxTextureSize;
					if (i.width > c || i.height > c || !this._supportsHardwareTextureRescaling) return this._prepareWorkingCanvas(), !(!this._workingCanvas || !this._workingContext) && (this._workingCanvas.width = e, this._workingCanvas.height = t, this._workingContext.drawImage(i, 0, 0, i.width, i.height, 0, 0, e, t), o.texImage2D(o.TEXTURE_2D, 0, h.internalFormat, h.format, h.type, this._workingCanvas), a.width = e, a.height = t, !1);
					{
						const e = new Pm(this, 2);
						this._bindTextureDirectly(o.TEXTURE_2D, e, !0), o.texImage2D(o.TEXTURE_2D, 0, h.internalFormat, h.format, h.type, i), this._rescaleTexture(e, a, s, h.format, (() => {
							this._releaseTexture(e), this._bindTextureDirectly(o.TEXTURE_2D, a, !0), r()
						}))
					}
					return !0
				}), o, l, h, c, u, m, f)
			}
			_setTextureParameterFloat(e, t, i, s) {
				this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameterf(e, t, i)
			}
			_createTexture() {
				const e = this._gl.createTexture();
				if (!e) throw new Error("Unable to create texture");
				return e
			}
			releaseVertexArrayObject(e) {
				this._gl.deleteVertexArray(e)
			}
			_drawMode(e) {
				switch (e) {
					case 0:
					default:
						return this._gl.TRIANGLES;
					case 2:
					case 3:
						return this._gl.POINTS;
					case 1:
					case 4:
						return this._gl.LINES;
					case 5:
						return this._gl.LINE_LOOP;
					case 6:
						return this._gl.LINE_STRIP;
					case 7:
						return this._gl.TRIANGLE_STRIP;
					case 8:
						return this._gl.TRIANGLE_FAN
				}
			}
			draw(e, t, i, s) {
				this.drawElementsType(e ? 0 : 1, t, i, s)
			}
			setFloat(e, t) {
				return !!e && (this._gl.uniform1f(e, t), !0)
			}
			setFloat3(e, t, i, s) {
				return !!e && (this._gl.uniform3f(e, t, i, s), !0)
			}
			flushFramebuffer() {
				this._gl.flush()
			}
			_bindVertexBuffersAttributes(e, t, i) {
				const s = t.getAttributesNames();
				this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes();
				for (let n = 0; n < s.length; n++) {
					const a = t.getAttributeLocation(n);
					if (a >= 0) {
						const t = s[n];
						let r = null;
						if (i && (r = i[t]), r || (r = e[t]), !r) continue;
						this._gl.enableVertexAttribArray(a), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[a] = !0);
						const o = r.getBuffer();
						o && (this._vertexAttribPointer(o, a, r.getSize(), r.type, r.normalized, r.byteStride, r.byteOffset), r.getIsInstanced() && (this._gl.vertexAttribDivisor(a, r.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(a), this._currentInstanceBuffers.push(o))))
					}
				}
			}
			enableEffect(e) {
				(e = null !== e && function(e) {
					return void 0 === e.getPipelineContext
				}(e) ? e.effect : e) && e !== this._currentEffect && (this._stencilStateComposer.stencilMaterial = void 0, this.bindSamplers(e), this._currentEffect = e, e.onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e))
			}
			setArray3(e, t) {
				return !(!e || t.length % 3 != 0) && (this._gl.uniform3fv(e, t), !0)
			}
			_createShaderProgram(e, t, i, s, n = null) {
				return vm(e, t, i, s, n)
			}
			createVertexBuffer(e, t, i) {
				return this._createVertexBuffer(e, this._gl.STATIC_DRAW)
			}
			disableInstanceAttributeByName(e) {
				if (!this._currentEffect) return;
				const t = this._currentEffect.getAttributeLocationByName(e);
				this.disableInstanceAttribute(t)
			}
			setMatrix3x3(e, t) {
				return !!e && (this._gl.uniformMatrix3fv(e, !1, t), !0)
			}
			setInt4(e, t, i, s, n) {
				return !!e && (this._gl.uniform4i(e, t, i, s, n), !0)
			}
			setTextureArray(e, t, i, s) {
				if (void 0 !== e && t) {
					this._textureUnits && this._textureUnits.length === i.length || (this._textureUnits = new Int32Array(i.length));
					for (let t = 0; t < i.length; t++) {
						const s = i[t].getInternalTexture();
						s ? (this._textureUnits[t] = e + t, s._associatedChannel = e + t) : this._textureUnits[t] = -1
					}
					this._gl.uniform1iv(t, this._textureUnits);
					for (let e = 0; e < i.length; e++) this._setTexture(this._textureUnits[e], i[e], !0)
				}
			}
			updateTextureSamplingMode(e, t, i = !1) {
				const s = this._getTextureTarget(t),
					n = this._getSamplingParameters(e, t.useMipMaps || i);
				this._setTextureParameterInteger(s, this._gl.TEXTURE_MAG_FILTER, n.mag, t), this._setTextureParameterInteger(s, this._gl.TEXTURE_MIN_FILTER, n.min), i && (t.generateMipMaps = !0, this._gl.generateMipmap(s)), this._bindTextureDirectly(s, null), t.samplingMode = e
			}
			_setupFramebufferDepthAttachments(e, t, i, s, n = 1) {
				const a = this._gl;
				if (e && t) return this._createRenderBuffer(i, s, n, a.DEPTH_STENCIL, a.DEPTH24_STENCIL8, a.DEPTH_STENCIL_ATTACHMENT);
				if (t) {
					let e = a.DEPTH_COMPONENT16;
					return this._webGLVersion > 1 && (e = a.DEPTH_COMPONENT32F), this._createRenderBuffer(i, s, n, e, e, a.DEPTH_ATTACHMENT)
				}
				return e ? this._createRenderBuffer(i, s, n, a.STENCIL_INDEX8, a.STENCIL_INDEX8, a.STENCIL_ATTACHMENT) : null
			}
			drawPointClouds(e, t, i) {
				this.drawArraysType(2, e, t, i)
			}
			get supportsUniformBuffers() {
				return this.webGLVersion > 1 && !this.disableUniformBuffers
			}
			get version() {
				return this._webGLVersion
			}
			_bindBuffer(e, t) {
				(this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null), this._currentBoundBuffer[t] = e)
			}
			_bindSamplerUniformToChannel(e, t) {
				const i = this._boundUniforms[e];
				i && i._currentState !== t && (this._gl.uniform1i(i, t), i._currentState = t)
			}
			_viewport(e, t, i, s) {
				e === this._viewportCached.x && t === this._viewportCached.y && i === this._viewportCached.z && s === this._viewportCached.w || (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = i, this._viewportCached.w = s, this._gl.viewport(e, t, i, s))
			}
			setUIntArray2(e, t) {
				return !(!e || t.length % 2 != 0) && (this._gl.uniform2uiv(e, t), !0)
			}
			createPipelineContext(e) {
				if (this._gl) {
					pm(this._gl).parallelShaderCompile = this._caps.parallelShaderCompile
				}
				const t = function(e) {
					const t = new mm,
						i = pm(e);
					return i.parallelShaderCompile && (t.isParallelCompiled = !0), t.context = i._context, t
				}(this._gl);
				return t.engine = this, t
			}
			constructor(t, i, s, n) {
				if (s = s || {}, super(i ?? s.antialias, s, n), this._name = "WebGL", this.forcePOTTextures = !1, this.validateShaderPrograms = !1, this.disableUniformBuffers = !1, this._webGLVersion = 1, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array, this._currentFramebuffer = null, this._dummyFramebuffer = null, this._currentBufferPointers = new Array, this._currentInstanceLocations = new Array, this._currentInstanceBuffers = new Array, this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array, this._maxSimultaneousTextures = 0, this._maxMSAASamplesOverride = null, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {}, !t) return;
				let a = null;
				if (t.getContext) {
					if (a = t, this._renderingCanvas = a, void 0 === s.preserveDrawingBuffer && (s.preserveDrawingBuffer = !1), void 0 === s.xrCompatible && (s.xrCompatible = !1), navigator && navigator.userAgent) {
						this._setupMobileChecks();
						const t = navigator.userAgent;
						for (const i of e.ExceptionList) {
							const e = i.key,
								n = i.targets;
							if (new RegExp(e).test(t)) {
								if (i.capture && i.captureConstraint) {
									const e = i.capture,
										s = i.captureConstraint,
										n = new RegExp(e).exec(t);
									if (n && n.length > 0) {
										if (parseInt(n[n.length - 1]) >= s) continue
									}
								}
								for (const e of n) switch (e) {
									case "uniformBuffer":
										this.disableUniformBuffers = !0;
										break;
									case "vao":
										this.disableVertexArrayObjects = !0;
										break;
									case "antialias":
										s.antialias = !1;
										break;
									case "maxMSAASamples":
										this._maxMSAASamplesOverride = 1
								}
							}
						}
					}
					if (this._doNotHandleContextLost || (this._onContextLost = e => {
							e.preventDefault(), this._contextWasLost = !0, Qc.Warn("WebGL context lost."), this.onContextLostObservable.notifyObservers(this)
						}, this._onContextRestored = () => {
							this._restoreEngineAfterContextLost((() => this._initGLContext()))
						}, a.addEventListener("webglcontextlost", this._onContextLost, !1), a.addEventListener("webglcontextrestored", this._onContextRestored, !1), s.powerPreference = s.powerPreference || "high-performance"), this._badDesktopOS && (s.xrCompatible = !1), !s.disableWebGL2Support) try {
						this._gl = a.getContext("webgl2", s) || a.getContext("experimental-webgl2", s), this._gl && (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2", this._gl.deleteQuery || (this._webGLVersion = 1, this._shaderPlatformName = "WEBGL1"))
					} catch (e) {}
					if (!this._gl) {
						if (!a) throw new Error("The provided canvas is null or undefined.");
						try {
							this._gl = a.getContext("webgl", s) || a.getContext("experimental-webgl", s)
						} catch (e) {
							throw new Error("WebGL not supported")
						}
					}
					if (!this._gl) throw new Error("WebGL not supported")
				} else {
					this._gl = t, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1";
					const e = this._gl.getContextAttributes();
					e && (s.stencil = e.stencil)
				}
				this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), void 0 !== s.useHighPrecisionFloats && (this._highPrecisionShadersAllowed = s.useHighPrecisionFloats), this.resize(), this._initGLContext(), this._initFeatures();
				for (let e = 0; e < this._caps.maxVertexAttribs; e++) this._currentBufferPointers[e] = new Rd;
				this._shaderProcessor = this.webGLVersion > 1 ? new Cd : new xd;
				const r = `Babylon.js v${e.Version}`;
				Qc.Log(r + ` - ${this.description}`), this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", r);
				const o = pm(this._gl);
				o.validateShaderPrograms = this.validateShaderPrograms, o.parallelShaderCompile = this._caps.parallelShaderCompile
			}
			get webGLVersion() {
				return this._webGLVersion
			}
			set framebufferDimensionsObject(e) {
				this._framebufferDimensionsObject = e
			}
			clear(t, i, s, n = !1) {
				const a = this.stencilStateComposer.useStencilGlobalOnly;
				this.stencilStateComposer.useStencilGlobalOnly = !0, this.applyStates(), this.stencilStateComposer.useStencilGlobalOnly = a;
				let r = 0;
				if (i && t) {
					let i = !0;
					if (this._currentRenderTarget) {
						const s = this._currentRenderTarget.texture?.format;
						if (8 === s || 9 === s || 10 === s || 11 === s) {
							const s = this._currentRenderTarget.texture?.type;
							7 === s || 5 === s ? (e._TempClearColorUint32[0] = 255 * t.r, e._TempClearColorUint32[1] = 255 * t.g, e._TempClearColorUint32[2] = 255 * t.b, e._TempClearColorUint32[3] = 255 * t.a, this._gl.clearBufferuiv(this._gl.COLOR, 0, e._TempClearColorUint32), i = !1) : (e._TempClearColorInt32[0] = 255 * t.r, e._TempClearColorInt32[1] = 255 * t.g, e._TempClearColorInt32[2] = 255 * t.b, e._TempClearColorInt32[3] = 255 * t.a, this._gl.clearBufferiv(this._gl.COLOR, 0, e._TempClearColorInt32), i = !1)
						}
					}
					i && (this._gl.clearColor(t.r, t.g, t.b, void 0 !== t.a ? t.a : 1), r |= this._gl.COLOR_BUFFER_BIT)
				}
				s && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL, this._gl.clearDepth(0)) : this._gl.clearDepth(1), r |= this._gl.DEPTH_BUFFER_BIT), n && (this._gl.clearStencil(0), r |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(r)
			}
			_prepareWorkingCanvas() {
				if (this._workingCanvas) return;
				this._workingCanvas = this.createCanvas(1, 1);
				const e = this._workingCanvas.getContext("2d");
				e && (this._workingContext = e)
			}
			getRenderHeight(e = !1) {
				return !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight
			}
			getError() {
				return this._gl.getError()
			}
			disableInstanceAttribute(e) {
				let t, i = !1;
				for (; - 1 !== (t = this._currentInstanceLocations.indexOf(e));) this._currentInstanceLocations.splice(t, 1), this._currentInstanceBuffers.splice(t, 1), i = !0, t = this._currentInstanceLocations.indexOf(e);
				i && (this._gl.vertexAttribDivisor(e, 0), this.disableAttributeByIndex(e))
			}
			_createRenderBuffer(e, t, i, s, n, a, r = !0) {
				const o = this._gl.createRenderbuffer();
				return this._updateRenderBuffer(o, e, t, i, s, n, a, r)
			}
			bindIndexBuffer(e) {
				this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER)
			}
			_canRenderToFloatFramebuffer() {
				return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1)
			}
			_currentFrameBufferIsDefaultFrameBuffer() {
				return null === this._currentFramebuffer
			}
			getClassName() {
				return "ThinEngine"
			}
			createMaterialContext() {}
			_canRenderToFramebuffer(e) {
				const t = this._gl;
				for (; t.getError() !== t.NO_ERROR;);
				let i = !0;
				const s = t.createTexture();
				t.bindTexture(t.TEXTURE_2D, s), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
				const n = t.createFramebuffer();
				t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0);
				const a = t.checkFramebufferStatus(t.FRAMEBUFFER);
				if (i = i && a === t.FRAMEBUFFER_COMPLETE, i = i && t.getError() === t.NO_ERROR, i && (t.clear(t.COLOR_BUFFER_BIT), i = i && t.getError() === t.NO_ERROR), i) {
					t.bindFramebuffer(t.FRAMEBUFFER, null);
					const e = t.RGBA,
						s = t.UNSIGNED_BYTE,
						n = new Uint8Array(4);
					t.readPixels(0, 0, 1, 1, e, s, n), i = i && t.getError() === t.NO_ERROR
				}
				for (t.deleteTexture(s), t.deleteFramebuffer(n), t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR;);
				return i
			}
			setInt2(e, t, i) {
				return !!e && (this._gl.uniform2i(e, t, i), !0)
			}
			_rescaleTexture(e, t, i, s, n) {}
			_normalizeIndexData(e) {
				if (2 === e.BYTES_PER_ELEMENT) return e;
				if (this._caps.uintIndices) {
					if (e instanceof Uint32Array) return e;
					for (let t = 0; t < e.length; t++)
						if (e[t] >= 65535) return new Uint32Array(e);
					return new Uint16Array(e)
				}
				return new Uint16Array(e)
			}
			setIntArray(e, t) {
				return !!e && (this._gl.uniform1iv(e, t), !0)
			}
			get performanceMonitor() {
				throw new Error("Not Supported by ThinEngine")
			}
			_releaseBuffer(e) {
				return e.references--, 0 === e.references && (this._deleteBuffer(e), !0)
			}
			unBindFramebuffer(e, t = !1, i) {
				const s = e;
				this._currentRenderTarget = null;
				const n = this._gl;
				if (s._MSAAFramebuffer) {
					if (e.isMulti) return void this.unBindMultiColorAttachmentFramebuffer(e, t, i);
					n.bindFramebuffer(n.READ_FRAMEBUFFER, s._MSAAFramebuffer), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, s._framebuffer), n.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, n.COLOR_BUFFER_BIT, n.NEAREST)
				}!e.texture?.generateMipMaps || t || e.isCube || this.generateMipmaps(e.texture), i && (s._MSAAFramebuffer && this._bindUnboundFramebuffer(s._framebuffer), i()), this._bindUnboundFramebuffer(null)
			}
			_finalizePipelineContext(e) {
				return ym(e, this._gl, this.validateShaderPrograms)
			}
			updateTextureData(e, t, i, s, n, a, r = 0, o = 0, l = !1) {
				const h = this._gl,
					c = this._getWebGLTextureType(e.type),
					u = this._getInternalFormat(e.format);
				this._unpackFlipY(e.invertY);
				let m = h.TEXTURE_2D,
					d = h.TEXTURE_2D;
				e.isCube && (d = h.TEXTURE_CUBE_MAP_POSITIVE_X + r, m = h.TEXTURE_CUBE_MAP), this._bindTextureDirectly(m, e, !0), h.texSubImage2D(d, o, i, s, n, a, u, c, t), l && this._gl.generateMipmap(d), this._bindTextureDirectly(m, null)
			}
			setIntArray2(e, t) {
				return !(!e || t.length % 2 != 0) && (this._gl.uniform2iv(e, t), !0)
			}
			setUInt(e, t) {
				return !!e && (this._gl.uniform1ui(e, t), !0)
			}
			bindInstancesBuffer(e, t, i = !0) {
				this.bindArrayBuffer(e);
				let s = 0;
				if (i)
					for (let e = 0; e < t.length; e++) {
						s += 4 * t[e].attributeSize
					}
				for (let i = 0; i < t.length; i++) {
					const n = t[i];
					void 0 === n.index && (n.index = this._currentEffect.getAttributeLocationByName(n.attributeName)), n.index < 0 || (this._vertexAttribArraysEnabled[n.index] || (this._gl.enableVertexAttribArray(n.index), this._vertexAttribArraysEnabled[n.index] = !0), this._vertexAttribPointer(e, n.index, n.attributeSize, n.attributeType || this._gl.FLOAT, n.normalized || !1, s, n.offset), this._gl.vertexAttribDivisor(n.index, void 0 === n.divisor ? 1 : n.divisor), this._currentInstanceLocations.push(n.index), this._currentInstanceBuffers.push(e))
				}
			}
			bindUniformBlock(e, t, i) {
				const s = e.program,
					n = this._gl.getUniformBlockIndex(s, t);
				this._gl.uniformBlockBinding(s, n, i)
			}
			_uploadArrayBufferViewToTexture(e, t, i = 0, s = 0) {
				const n = this._gl,
					a = e.isCube ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D;
				this._bindTextureDirectly(a, e, !0), this._uploadDataToTextureDirectly(e, t, i, s), this._bindTextureDirectly(a, null, !0)
			}
			static set ShadersRepository(e) {
				xm.ShadersRepository = e
			}
			_updateRenderBuffer(e, t, i, s, n, a, r, o = !0) {
				const l = this._gl;
				return l.bindRenderbuffer(l.RENDERBUFFER, e), s > 1 && l.renderbufferStorageMultisample ? l.renderbufferStorageMultisample(l.RENDERBUFFER, s, a, t, i) : l.renderbufferStorage(l.RENDERBUFFER, n, t, i), l.framebufferRenderbuffer(l.FRAMEBUFFER, r, l.RENDERBUFFER, e), o && l.bindRenderbuffer(l.RENDERBUFFER, null), e
			}
			setTexture(e, t, i, s) {
				void 0 !== e && (t && (this._boundUniforms[e] = t), this._setTexture(e, i))
			}
			drawUnIndexed(e, t, i, s) {
				this.drawArraysType(e ? 0 : 1, t, i, s)
			}
			setUIntArray3(e, t) {
				return !(!e || t.length % 3 != 0) && (this._gl.uniform3uiv(e, t), !0)
			}
			setMatrix2x2(e, t) {
				return !!e && (this._gl.uniformMatrix2fv(e, !1, t), !0)
			}
			attachContextLostEvent(e) {
				this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1)
			}
			updateTextureDimensions(e, t, i, s = 1) {}
			_initGLContext() {
				this._caps = {
					maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
					maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
					maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
					maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
					maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
					maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
					maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
					maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
					maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
					maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
					maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
					parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
					standardDerivatives: this._webGLVersion > 1 || null !== this._gl.getExtension("OES_standard_derivatives"),
					maxAnisotropy: 1,
					astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
					bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
					s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
					s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
					pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
					etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
					etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
					textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
					uintIndices: this._webGLVersion > 1 || null !== this._gl.getExtension("OES_element_index_uint"),
					fragmentDepthSupported: this._webGLVersion > 1 || null !== this._gl.getExtension("EXT_frag_depth"),
					highPrecisionShaderSupported: !1,
					timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
					supportOcclusionQuery: this._webGLVersion > 1,
					canUseTimestampForTimerQuery: !1,
					drawBuffersExtension: !1,
					maxMSAASamples: 1,
					colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
					supportFloatTexturesResolve: !1,
					rg11b10ufColorRenderable: !1,
					colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")),
					textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")),
					textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")),
					textureHalfFloatRender: !1,
					textureFloatLinearFiltering: !1,
					textureFloatRender: !1,
					textureHalfFloatLinearFiltering: !1,
					vertexArrayObject: !1,
					instancedArrays: !1,
					textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")),
					texelFetch: 1 !== this._webGLVersion,
					blendMinMax: !1,
					multiview: this._gl.getExtension("OVR_multiview2"),
					oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
					depthTextureExtension: !1,
					canUseGLInstanceID: this._webGLVersion > 1,
					canUseGLVertexID: this._webGLVersion > 1,
					supportComputeShaders: !1,
					supportSRGBBuffers: !1,
					supportTransformFeedbacks: this._webGLVersion > 1,
					textureMaxLevel: this._webGLVersion > 1,
					texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,
					disableMorphTargetTexture: !1
				}, this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat, this._caps.rg11b10ufColorRenderable = this._caps.colorBufferFloat, this._glVersion = this._gl.getParameter(this._gl.VERSION);
				const e = this._gl.getExtension("WEBGL_debug_renderer_info");
				if (null != e && (this._glRenderer = this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"), this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"), 36193 !== this._gl.HALF_FLOAT_OES && (this._gl.HALF_FLOAT_OES = 36193), 34842 !== this._gl.RGBA16F && (this._gl.RGBA16F = 34842), 34836 !== this._gl.RGBA32F && (this._gl.RGBA32F = 34836), 35056 !== this._gl.DEPTH24_STENCIL8 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.timerQuery && (1 === this._webGLVersion && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = (this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) ?? 0) > 0), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.textureFloatLinearFiltering = !(!this._caps.textureFloat || !this._gl.getExtension("OES_texture_float_linear")), this._caps.textureFloatRender = !(!this._caps.textureFloat || !this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")), this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR), this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT), this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2, this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), this._webGLVersion > 1 && 5131 !== this._gl.HALF_FLOAT_OES && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._webGLVersion > 1) this._caps.drawBuffersExtension = !0, this._caps.maxMSAASamples = null !== this._maxMSAASamplesOverride ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
				else {
					const e = this._gl.getExtension("WEBGL_draw_buffers");
					if (null !== e) {
						this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = e.drawBuffersWEBGL.bind(e), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
						for (let t = 0; t < 16; t++) this._gl["COLOR_ATTACHMENT" + t + "_WEBGL"] = e["COLOR_ATTACHMENT" + t + "_WEBGL"]
					}
				}
				if (this._webGLVersion > 1) this._caps.depthTextureExtension = !0;
				else {
					const e = this._gl.getExtension("WEBGL_depth_texture");
					null != e && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = e.UNSIGNED_INT_24_8_WEBGL)
				}
				if (this.disableVertexArrayObjects) this._caps.vertexArrayObject = !1;
				else if (this._webGLVersion > 1) this._caps.vertexArrayObject = !0;
				else {
					const e = this._gl.getExtension("OES_vertex_array_object");
					null != e && (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = e.createVertexArrayOES.bind(e), this._gl.bindVertexArray = e.bindVertexArrayOES.bind(e), this._gl.deleteVertexArray = e.deleteVertexArrayOES.bind(e))
				}
				if (this._webGLVersion > 1) this._caps.instancedArrays = !0;
				else {
					const e = this._gl.getExtension("ANGLE_instanced_arrays");
					null != e ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = e.drawArraysInstancedANGLE.bind(e), this._gl.drawElementsInstanced = e.drawElementsInstancedANGLE.bind(e), this._gl.vertexAttribDivisor = e.vertexAttribDivisorANGLE.bind(e)) : this._caps.instancedArrays = !1
				}
				if (this._gl.getShaderPrecisionFormat) {
					const e = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT),
						t = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
					e && t && (this._caps.highPrecisionShaderSupported = 0 !== e.precision && 0 !== t.precision)
				}
				if (this._webGLVersion > 1) this._caps.blendMinMax = !0;
				else {
					const e = this._gl.getExtension("EXT_blend_minmax");
					null != e && (this._caps.blendMinMax = !0, this._gl.MAX = e.MAX_EXT, this._gl.MIN = e.MIN_EXT)
				}
				if (!this._caps.supportSRGBBuffers) {
					if (this._webGLVersion > 1) this._caps.supportSRGBBuffers = !0, this._glSRGBExtensionValues = {
						SRGB: WebGL2RenderingContext.SRGB,
						SRGB8: WebGL2RenderingContext.SRGB8,
						SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8
					};
					else {
						const e = this._gl.getExtension("EXT_sRGB");
						null != e && (this._caps.supportSRGBBuffers = !0, this._glSRGBExtensionValues = {
							SRGB: e.SRGB_EXT,
							SRGB8: e.SRGB_ALPHA_EXT,
							SRGB8_ALPHA8: e.SRGB_ALPHA_EXT
						})
					}
					this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !(!this._creationOptions || !this._creationOptions.forceSRGBBufferSupportState)
				}
				this._depthCullingState.depthTest = !0, this._depthCullingState.depthFunc = this._gl.LEQUAL, this._depthCullingState.depthMask = !0, this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
				for (let e = 0; e < this._maxSimultaneousTextures; e++) this._nextFreeTextureSlots.push(e);
				"Mali-G72" === this._glRenderer && (this._caps.disableMorphTargetTexture = !0)
			}
			_canRenderToHalfFloatFramebuffer() {
				return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2)
			}
			disableAttributeByIndex(e) {
				this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1
			}
			_getUseSRGBBuffer(e, t) {
				return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || t)
			}
			updateAndBindInstancesBuffer(e, t, i) {
				if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), void 0 !== i[0].index) this.bindInstancesBuffer(e, i, !0);
				else
					for (let t = 0; t < 4; t++) {
						const s = i[t];
						this._vertexAttribArraysEnabled[s] || (this._gl.enableVertexAttribArray(s), this._vertexAttribArraysEnabled[s] = !0), this._vertexAttribPointer(e, s, 4, this._gl.FLOAT, !1, 64, 16 * t), this._gl.vertexAttribDivisor(s, 1), this._currentInstanceLocations.push(s), this._currentInstanceBuffers.push(e)
					}
			}
			unbindAllTextures() {
				for (let e = 0; e < this._maxSimultaneousTextures; e++) this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))
			}
			getRenderWidth(e = !1) {
				return !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth
			}
			static get IsSupportedAsync() {
				return Promise.resolve(this.isSupported())
			}
			createRawShaderProgram(e, t, i, s, n = null) {
				const a = pm(this._gl);
				return a._contextWasLost = this._contextWasLost, a.validateShaderPrograms = this.validateShaderPrograms, _m(e, t, i, s || this._gl, n)
			}
			_clearEmptyResources() {
				this._dummyFramebuffer = null, super._clearEmptyResources()
			}
			setUInt2(e, t, i) {
				return !!e && (this._gl.uniform2ui(e, t, i), !0)
			}
			areAllEffectsReady() {
				for (const e in this._compiledEffects) {
					if (!this._compiledEffects[e].isReady()) return !1
				}
				return !0
			}
			_bindIndexBufferWithCache(e) {
				null != e && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits)
			}
			createEffect(e, t, i, s, n, a, r, o, l, h = 0) {
				const c = "string" == typeof e ? e : e.vertexToken || e.vertexSource || e.vertexElement || e.vertex,
					u = "string" == typeof e ? e : e.fragmentToken || e.fragmentSource || e.fragmentElement || e.fragment,
					m = this._getGlobalDefines();
				let d = n ?? t.defines ?? "";
				m && (d += m);
				const f = c + "+" + u + "@" + d;
				if (this._compiledEffects[f]) {
					const e = this._compiledEffects[f];
					return r && e.isReady() && r(e), e._refCount++, e
				}
				this._gl && pm(this._gl);
				const p = new xm(e, t, i, s, this, n, a, r, o, l, f, t.shaderLanguage ?? h);
				return this._compiledEffects[f] = p, p
			}
			get needPOTTextures() {
				return this._webGLVersion < 2 || this.forcePOTTextures
			}
			dispose() {
				var e;
				Cu() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost), this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored))), super.dispose(), this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.unbindAllAttributes(), this._boundUniforms = {}, this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers.length = 0, this._currentProgram = null, this._creationOptions.loseContextOnDispose && this._gl.getExtension("WEBGL_lose_context")?.loseContext(), e = this._gl, dm.delete(e)
			}
			unbindAllAttributes() {
				if (this._mustWipeVertexAttributes) {
					this._mustWipeVertexAttributes = !1;
					for (let e = 0; e < this._caps.maxVertexAttribs; e++) this.disableAttributeByIndex(e)
				} else
					for (let e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++) e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e)
			}
			_bindTextureDirectly(e, t, i = !1, s = !1) {
				let n = !1;
				const a = t && t._associatedChannel > -1;
				i && a && (this._activeChannel = t._associatedChannel);
				if (this._boundTexturesCache[this._activeChannel] !== t || s) {
					if (this._activateCurrentTexture(), t && t.isMultiview) throw Qc.Error(["_bindTextureDirectly called with a multiview texture!", e, t]), "_bindTextureDirectly called with a multiview texture!";
					this._gl.bindTexture(e, t?._hardwareTexture?.underlyingResource ?? null), this._boundTexturesCache[this._activeChannel] = t, t && (t._associatedChannel = this._activeChannel)
				} else i && (n = !0, this._activateCurrentTexture());
				return a && !i && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel), n
			}
			_getShaderProcessingContext(e) {
				return null
			}
			bindVertexArrayObject(e, t) {
				this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = null != t && t.is32Bits, this._mustWipeVertexAttributes = !0)
			}
			setIntArray4(e, t) {
				return !(!e || t.length % 4 != 0) && (this._gl.uniform4iv(e, t), !0)
			}
			setArray2(e, t) {
				return !(!e || t.length % 2 != 0) && (this._gl.uniform2fv(e, t), !0)
			}
			_releaseEffect(e) {
				this._compiledEffects[e._key] && delete this._compiledEffects[e._key];
				const t = e.getPipelineContext();
				t && this._deletePipelineContext(t)
			}
			_activateCurrentTexture() {
				this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel)
			}
			get _supportsHardwareTextureRescaling() {
				return !1
			}
			updateArrayBuffer(e) {
				this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)
			}
			_getSamplingParameters(e, t) {
				const i = this._gl;
				let s = i.NEAREST,
					n = i.NEAREST;
				switch (e) {
					case 11:
						s = i.LINEAR, n = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;
						break;
					case 3:
						s = i.LINEAR, n = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;
						break;
					case 8:
						s = i.NEAREST, n = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;
						break;
					case 4:
						s = i.NEAREST, n = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;
						break;
					case 5:
						s = i.NEAREST, n = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;
						break;
					case 6:
						s = i.NEAREST, n = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;
						break;
					case 7:
						s = i.NEAREST, n = i.LINEAR;
						break;
					case 1:
						s = i.NEAREST, n = i.NEAREST;
						break;
					case 9:
						s = i.LINEAR, n = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;
						break;
					case 10:
						s = i.LINEAR, n = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;
						break;
					case 2:
						s = i.LINEAR, n = i.LINEAR;
						break;
					case 12:
						s = i.LINEAR, n = i.NEAREST
				}
				return {
					min: n,
					mag: s
				}
			}
			setFloat2(e, t, i) {
				return !!e && (this._gl.uniform2f(e, t, i), !0)
			}
			createDrawContext() {}
			_deletePipelineContext(e) {
				const t = e;
				t && t.program && (t.program.__SPECTOR_rebuildProgram = null, Am(t), this._gl.deleteProgram(t.program))
			}
			_releaseTexture(e) {
				this._deleteTexture(e._hardwareTexture), this.unbindAllTextures();
				const t = this._internalTexturesCache.indexOf(e); - 1 !== t && this._internalTexturesCache.splice(t, 1), e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureLow && e._lodTextureLow.dispose(), e._irradianceTexture && e._irradianceTexture.dispose()
			}
			createIndexBuffer(e, t, i) {
				const s = this._gl.createBuffer(),
					n = new Td(s);
				if (!s) throw new Error("Unable to create index buffer");
				this.bindIndexBuffer(n);
				const a = this._normalizeIndexData(e);
				return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, a, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), n.references = 1, n.is32Bits = 4 === a.BYTES_PER_ELEMENT, n
			}
			setIntArray3(e, t) {
				return !(!e || t.length % 3 != 0) && (this._gl.uniform3iv(e, t), !0)
			}
			_getInternalFormat(e, t = !1) {
				let i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
				switch (e) {
					case 0:
						i = this._gl.ALPHA;
						break;
					case 1:
						i = this._gl.LUMINANCE;
						break;
					case 2:
						i = this._gl.LUMINANCE_ALPHA;
						break;
					case 6:
						i = this._gl.RED;
						break;
					case 7:
						i = this._gl.RG;
						break;
					case 4:
						i = t ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
						break;
					case 5:
						i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA
				}
				if (this._webGLVersion > 1) switch (e) {
					case 8:
						i = this._gl.RED_INTEGER;
						break;
					case 9:
						i = this._gl.RG_INTEGER;
						break;
					case 10:
						i = this._gl.RGB_INTEGER;
						break;
					case 11:
						i = this._gl.RGBA_INTEGER
				}
				return i
			}
			static isSupported() {
				if (null !== this._HasMajorPerformanceCaveat) return !this._HasMajorPerformanceCaveat;
				if (null === this._IsSupported) try {
					const e = Dm._CreateCanvas(1, 1),
						t = e.getContext("webgl") || e.getContext("experimental-webgl");
					this._IsSupported = null != t && !!window.WebGLRenderingContext
				} catch (e) {
					this._IsSupported = !1
				}
				return this._IsSupported
			}
			_createHardwareTexture() {
				return new wd(this._createTexture(), this._gl)
			}
			_getTextureWrapMode(e) {
				switch (e) {
					case 1:
						return this._gl.REPEAT;
					case 0:
						return this._gl.CLAMP_TO_EDGE;
					case 2:
						return this._gl.MIRRORED_REPEAT
				}
				return this._gl.REPEAT
			}
			_executeWhenRenderingStateIsCompiled(e, t) {
				! function(e, t) {
					const i = e;
					if (!i.isParallelCompiled) return void t(e);
					const s = i.onCompiled;
					i.onCompiled = () => {
						s?.(), t(e)
					}
				}(e, t)
			}
			_prepareWebGLTexture(e, t, i, s, n, a, r, o, l, h) {
				const c = this.getCaps().maxTextureSize,
					u = Math.min(c, this.needPOTTextures ? md(s.width, c) : s.width),
					m = Math.min(c, this.needPOTTextures ? md(s.height, c) : s.height),
					d = this._gl;
				d && (e._hardwareTexture ? (this._bindTextureDirectly(d.TEXTURE_2D, e, !0), this._unpackFlipY(void 0 === n || !!n), e.baseWidth = s.width, e.baseHeight = s.height, e.width = u, e.height = m, e.isReady = !0, e.type = -1 !== e.type ? e.type : 0, e.format = -1 !== e.format ? e.format : h ?? (".jpg" !== t || e._useSRGBBuffer ? 5 : 4), o(u, m, s, t, e, (() => {
					this._prepareWebGLTextureContinuation(e, i, a, r, l)
				})) || this._prepareWebGLTextureContinuation(e, i, a, r, l)) : i && i.removePendingData(e))
			}
			setMatrices(e, t) {
				return !!e && (this._gl.uniformMatrix4fv(e, !1, t), !0)
			}
			createDynamicVertexBuffer(e, t) {
				return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW)
			}
			drawArraysType(e, t, i, s) {
				this.applyStates(), this._reportDrawCall();
				const n = this._drawMode(e);
				s ? this._gl.drawArraysInstanced(n, t, i, s) : this._gl.drawArrays(n, t, i)
			}
			_isRenderingStateCompiled(e) {
				const t = e;
				return !this._isDisposed && !t._isDisposed && (!!this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) && (this._finalizePipelineContext(t), !0))
			}
			bindSamplers(e) {
				const t = e.getPipelineContext();
				this._setProgram(t.program);
				const i = e.getSamplers();
				for (let t = 0; t < i.length; t++) {
					const s = e.getUniform(i[t]);
					s && (this._boundUniforms[t] = s)
				}
				this._currentEffect = null
			}
			_bindTexture(e, t, i) {
				if (void 0 === e) return;
				t && (t._associatedChannel = e), this._activeChannel = e;
				const s = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D;
				this._bindTextureDirectly(s, t)
			}
			getAttributes(e, t) {
				const i = [],
					s = e;
				for (let e = 0; e < t.length; e++) try {
					i.push(this._gl.getAttribLocation(s.program, t[e]))
				} catch (e) {
					i.push(-1)
				}
				return i
			}
			_createInternalTexture(e, t, i = !0, s = 0) {
				let n, a = !1,
					r = 0,
					o = 3,
					l = 5,
					h = !1,
					c = 1;
				void 0 !== t && "object" == typeof t ? (a = !!t.generateMipMaps, r = void 0 === t.type ? 0 : t.type, o = void 0 === t.samplingMode ? 3 : t.samplingMode, l = void 0 === t.format ? 5 : t.format, h = void 0 !== t.useSRGBBuffer && t.useSRGBBuffer, c = t.samples ?? 1, n = t.label) : a = !!t, h && (h = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU)), (1 !== r || this._caps.textureFloatLinearFiltering) && (2 !== r || this._caps.textureHalfFloatLinearFiltering) || (o = 1), 1 !== r || this._caps.textureFloat || (r = 0, Qc.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));
				const u = this._gl,
					m = new Pm(this, s),
					d = e.width || e,
					f = e.height || e,
					p = e.depth || 0,
					_ = e.layers || 0,
					g = this._getSamplingParameters(o, a),
					v = 0 !== _ ? u.TEXTURE_2D_ARRAY : 0 !== p ? u.TEXTURE_3D : u.TEXTURE_2D,
					y = this._getRGBABufferInternalSizedFormat(r, l, h),
					S = this._getInternalFormat(l),
					E = this._getWebGLTextureType(r);
				return this._bindTextureDirectly(v, m), 0 !== _ ? (m.is2DArray = !0, u.texImage3D(v, 0, y, d, f, _, 0, S, E, null)) : 0 !== p ? (m.is3D = !0, u.texImage3D(v, 0, y, d, f, p, 0, S, E, null)) : u.texImage2D(v, 0, y, d, f, 0, S, E, null), u.texParameteri(v, u.TEXTURE_MAG_FILTER, g.mag), u.texParameteri(v, u.TEXTURE_MIN_FILTER, g.min), u.texParameteri(v, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(v, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), a && this._gl.generateMipmap(v), this._bindTextureDirectly(v, null), m._useSRGBBuffer = h, m.baseWidth = d, m.baseHeight = f, m.width = d, m.height = f, m.depth = _, m.isReady = !0, m.samples = c, m.generateMipMaps = a, m.samplingMode = o, m.type = r, m.format = l, m.label = n, this._internalTexturesCache.push(m), m
			}
			unbindInstanceAttributes() {
				let e;
				for (let t = 0, i = this._currentInstanceLocations.length; t < i; t++) {
					const i = this._currentInstanceBuffers[t];
					e != i && i.references && (e = i, this.bindArrayBuffer(i));
					const s = this._currentInstanceLocations[t];
					this._gl.vertexAttribDivisor(s, 0)
				}
				this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0
			}
			_getRGBABufferInternalSizedFormat(e, t, i = !1) {
				if (1 === this._webGLVersion) {
					if (void 0 !== t) switch (t) {
						case 0:
							return this._gl.ALPHA;
						case 1:
							return this._gl.LUMINANCE;
						case 2:
							return this._gl.LUMINANCE_ALPHA;
						case 4:
							return i ? this._glSRGBExtensionValues.SRGB : this._gl.RGB
					}
					return this._gl.RGBA
				}
				switch (e) {
					case 3:
						switch (t) {
							case 6:
								return this._gl.R8_SNORM;
							case 7:
								return this._gl.RG8_SNORM;
							case 4:
								return this._gl.RGB8_SNORM;
							case 8:
								return this._gl.R8I;
							case 9:
								return this._gl.RG8I;
							case 10:
								return this._gl.RGB8I;
							case 11:
								return this._gl.RGBA8I;
							default:
								return this._gl.RGBA8_SNORM
						}
					case 0:
						switch (t) {
							case 6:
								return this._gl.R8;
							case 7:
								return this._gl.RG8;
							case 4:
								return i ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8;
							case 5:
								return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
							case 8:
								return this._gl.R8UI;
							case 9:
								return this._gl.RG8UI;
							case 10:
								return this._gl.RGB8UI;
							case 11:
								return this._gl.RGBA8UI;
							case 0:
								return this._gl.ALPHA;
							case 1:
								return this._gl.LUMINANCE;
							case 2:
								return this._gl.LUMINANCE_ALPHA;
							default:
								return this._gl.RGBA8
						}
					case 4:
						switch (t) {
							case 8:
								return this._gl.R16I;
							case 9:
								return this._gl.RG16I;
							case 10:
								return this._gl.RGB16I;
							default:
								return this._gl.RGBA16I
						}
					case 5:
						switch (t) {
							case 8:
								return this._gl.R16UI;
							case 9:
								return this._gl.RG16UI;
							case 10:
								return this._gl.RGB16UI;
							default:
								return this._gl.RGBA16UI
						}
					case 6:
						switch (t) {
							case 8:
								return this._gl.R32I;
							case 9:
								return this._gl.RG32I;
							case 10:
								return this._gl.RGB32I;
							default:
								return this._gl.RGBA32I
						}
					case 7:
						switch (t) {
							case 8:
								return this._gl.R32UI;
							case 9:
								return this._gl.RG32UI;
							case 10:
								return this._gl.RGB32UI;
							default:
								return this._gl.RGBA32UI
						}
					case 1:
						switch (t) {
							case 6:
								return this._gl.R32F;
							case 7:
								return this._gl.RG32F;
							case 4:
								return this._gl.RGB32F;
							default:
								return this._gl.RGBA32F
						}
					case 2:
						switch (t) {
							case 6:
								return this._gl.R16F;
							case 7:
								return this._gl.RG16F;
							case 4:
								return this._gl.RGB16F;
							default:
								return this._gl.RGBA16F
						}
					case 10:
						return this._gl.RGB565;
					case 13:
						return this._gl.R11F_G11F_B10F;
					case 14:
						return this._gl.RGB9_E5;
					case 8:
						return this._gl.RGBA4;
					case 9:
						return this._gl.RGB5_A1;
					case 11:
						switch (t) {
							case 5:
							default:
								return this._gl.RGB10_A2;
							case 11:
								return this._gl.RGB10_A2UI
						}
				}
				return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8
			}
			set name(e) {
				this._name = e
			}
			static get ShadersRepository() {
				return xm.ShadersRepository
			}
			bindFramebuffer(e, t = 0, i, s, n, a = 0, r = 0) {
				const o = e;
				this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._bindUnboundFramebuffer(o._MSAAFramebuffer ? o._MSAAFramebuffer : o._framebuffer);
				const l = this._gl;
				e.isMulti || (e.is2DArray || e.is3D ? l.framebufferTextureLayer(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, e.texture._hardwareTexture?.underlyingResource, a, r) : e.isCube ? l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.texture._hardwareTexture?.underlyingResource, a) : o._currentLOD !== a && (l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, e.texture._hardwareTexture?.underlyingResource, a), o._currentLOD = a));
				const h = e._depthStencilTexture;
				if (h) {
					e.is3D && (e.texture.width === h.width && e.texture.height === h.height && e.texture.depth === h.depth || Qc.Warn("Depth/Stencil attachment for 3D target must have same dimensions as color attachment"));
					const i = e._depthStencilTextureWithStencil ? l.DEPTH_STENCIL_ATTACHMENT : l.DEPTH_ATTACHMENT;
					e.is2DArray || e.is3D ? l.framebufferTextureLayer(l.FRAMEBUFFER, i, h._hardwareTexture?.underlyingResource, a, r) : e.isCube ? l.framebufferTexture2D(l.FRAMEBUFFER, i, l.TEXTURE_CUBE_MAP_POSITIVE_X + t, h._hardwareTexture?.underlyingResource, a) : l.framebufferTexture2D(l.FRAMEBUFFER, i, l.TEXTURE_2D, h._hardwareTexture?.underlyingResource, a)
				}
				this._cachedViewport && !n ? this.setViewport(this._cachedViewport, i, s) : (i || (i = e.width, a && (i /= Math.pow(2, a))), s || (s = e.height, a && (s /= Math.pow(2, a))), this._viewport(0, 0, i, s)), this.wipeCaches()
			}
			setInt3(e, t, i, s) {
				return !!e && (this._gl.uniform3i(e, t, i, s), !0)
			}
			releaseEffects() {
				const e = Object.keys(this._compiledEffects);
				for (const t of e) {
					this._compiledEffects[t].dispose()
				}
				this._compiledEffects = {}
			}
			generateMipmaps(e) {
				const t = this._getTextureTarget(e);
				this._bindTextureDirectly(t, e, !0), this._gl.generateMipmap(t), this._bindTextureDirectly(t, null)
			}
			setArray4(e, t) {
				return !(!e || t.length % 4 != 0) && (this._gl.uniform4fv(e, t), !0)
			}
			setState(e, t = 0, i, s = !1, n, a, r = 0) {
				(this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e);
				const o = this.cullBackFaces ?? n ?? 1 ? this._gl.BACK : this._gl.FRONT;
				(this._depthCullingState.cullFace !== o || i) && (this._depthCullingState.cullFace = o), this.setZOffset(t), this.setZOffsetUnits(r);
				const l = s ? this._gl.CW : this._gl.CCW;
				(this._depthCullingState.frontFace !== l || i) && (this._depthCullingState.frontFace = l), this._stencilStateComposer.stencilMaterial = a
			}
			_unpackFlipY(e) {
				this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e))
			}
			getGlInfo() {
				return {
					vendor: this._glVendor,
					renderer: this._glRenderer,
					version: this._glVersion
				}
			}
			_bindUnboundFramebuffer(e) {
				this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e)
			}
			_getUnpackAlignement() {
				return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)
			}
			readPixels(e, t, i, s, n = !0, a = !0) {
				const r = n ? 4 : 3,
					o = n ? this._gl.RGBA : this._gl.RGB,
					l = new Uint8Array(s * i * r);
				return a && this.flushFramebuffer(), this._gl.readPixels(e, t, i, s, o, this._gl.UNSIGNED_BYTE, l), Promise.resolve(l)
			}
			setUInt3(e, t, i, s) {
				return !!e && (this._gl.uniform3ui(e, t, i, s), !0)
			}
			createShaderProgram(e, t, i, s, n, a = null) {
				const r = pm(this._gl);
				return r._contextWasLost = this._contextWasLost, r.validateShaderPrograms = this.validateShaderPrograms, gm(e, t, i, s, n || this._gl, a)
			}
			recordVertexArrayObject(e, t, i, s) {
				const n = this._gl.createVertexArray();
				if (!n) throw new Error("Unable to create VAO");
				return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(n), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, i, s), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), n
			}
			getUniforms(e, t) {
				const i = new Array,
					s = e;
				for (let e = 0; e < t.length; e++) i.push(this._gl.getUniformLocation(s.program, t[e]));
				return i
			}
			bindArrayBuffer(e) {
				this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ARRAY_BUFFER)
			}
			_getTextureTarget(e) {
				return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D
			}
			_setTexture(e, t, i = !1, s = !1, n = "") {
				if (!t) return null != this._boundTexturesCache[e] && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))), !1;
				if (t.video) {
					this._activeChannel = e;
					const i = t.getInternalTexture();
					i && (i._associatedChannel = e), t.update()
				} else if (4 === t.delayLoadState) return t.delayLoad(), !1;
				let a;
				a = s ? t.depthStencilTexture : t.isReady() ? t.getInternalTexture() : t.isCube ? this.emptyCubeTexture : t.is3D ? this.emptyTexture3D : t.is2DArray ? this.emptyTexture2DArray : this.emptyTexture, !i && a && (a._associatedChannel = e);
				let r = !0;
				this._boundTexturesCache[e] === a && (i || this._bindSamplerUniformToChannel(a._associatedChannel, e), r = !1), this._activeChannel = e;
				const o = this._getTextureTarget(a);
				if (r && this._bindTextureDirectly(o, a, i), a && !a.isMultiview) {
					if (a.isCube && a._cachedCoordinatesMode !== t.coordinatesMode) {
						a._cachedCoordinatesMode = t.coordinatesMode;
						const e = 3 !== t.coordinatesMode && 5 !== t.coordinatesMode ? 1 : 0;
						t.wrapU = e, t.wrapV = e
					}
					a._cachedWrapU !== t.wrapU && (a._cachedWrapU = t.wrapU, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), a)), a._cachedWrapV !== t.wrapV && (a._cachedWrapV = t.wrapV, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), a)), a.is3D && a._cachedWrapR !== t.wrapR && (a._cachedWrapR = t.wrapR, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), a)), this._setAnisotropicLevel(o, a, t.anisotropicFilteringLevel)
				}
				return !0
			}
			restoreDefaultFramebuffer() {
				this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches()
			}
			_getWebGLTextureType(e) {
				if (1 === this._webGLVersion) {
					switch (e) {
						case 1:
							return this._gl.FLOAT;
						case 2:
							return this._gl.HALF_FLOAT_OES;
						case 0:
							return this._gl.UNSIGNED_BYTE;
						case 8:
							return this._gl.UNSIGNED_SHORT_4_4_4_4;
						case 9:
							return this._gl.UNSIGNED_SHORT_5_5_5_1;
						case 10:
							return this._gl.UNSIGNED_SHORT_5_6_5
					}
					return this._gl.UNSIGNED_BYTE
				}
				switch (e) {
					case 3:
						return this._gl.BYTE;
					case 0:
						return this._gl.UNSIGNED_BYTE;
					case 4:
						return this._gl.SHORT;
					case 5:
						return this._gl.UNSIGNED_SHORT;
					case 6:
						return this._gl.INT;
					case 7:
						return this._gl.UNSIGNED_INT;
					case 1:
						return this._gl.FLOAT;
					case 2:
						return this._gl.HALF_FLOAT;
					case 8:
						return this._gl.UNSIGNED_SHORT_4_4_4_4;
					case 9:
						return this._gl.UNSIGNED_SHORT_5_5_5_1;
					case 10:
						return this._gl.UNSIGNED_SHORT_5_6_5;
					case 11:
						return this._gl.UNSIGNED_INT_2_10_10_10_REV;
					case 12:
						return this._gl.UNSIGNED_INT_24_8;
					case 13:
						return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
					case 14:
						return this._gl.UNSIGNED_INT_5_9_9_9_REV;
					case 15:
						return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV
				}
				return this._gl.UNSIGNED_BYTE
			}
			endFrame() {
				super.endFrame(), this._badOS && this.flushFramebuffer()
			}
			setUIntArray4(e, t) {
				return !(!e || t.length % 4 != 0) && (this._gl.uniform4uiv(e, t), !0)
			}
		};
	Nd._TempClearColorUint32 = new Uint32Array(4), Nd._TempClearColorInt32 = new Int32Array(4), Nd.ExceptionList = [{
		key: "Chrome/63.0",
		capture: "63\\.0\\.3239\\.(\\d+)",
		captureConstraint: 108,
		targets: ["uniformBuffer"]
	}, {
		key: "Firefox/58",
		capture: null,
		captureConstraint: null,
		targets: ["uniformBuffer"]
	}, {
		key: "Firefox/59",
		capture: null,
		captureConstraint: null,
		targets: ["uniformBuffer"]
	}, {
		key: "Chrome/72.+?Mobile",
		capture: null,
		captureConstraint: null,
		targets: ["vao"]
	}, {
		key: "Chrome/73.+?Mobile",
		capture: null,
		captureConstraint: null,
		targets: ["vao"]
	}, {
		key: "Chrome/74.+?Mobile",
		capture: null,
		captureConstraint: null,
		targets: ["vao"]
	}, {
		key: "Mac OS.+Chrome/71",
		capture: null,
		captureConstraint: null,
		targets: ["vao"]
	}, {
		key: "Mac OS.+Chrome/72",
		capture: null,
		captureConstraint: null,
		targets: ["vao"]
	}, {
		key: "Mac OS.+Chrome",
		capture: null,
		captureConstraint: null,
		targets: ["uniformBuffer"]
	}, {
		key: "Chrome/12\\d\\..+?Mobile",
		capture: null,
		captureConstraint: null,
		targets: ["uniformBuffer"]
	}, {
		key: ".*AppleWebKit.*(15.4).*Safari",
		capture: null,
		captureConstraint: null,
		targets: ["antialias", "maxMSAASamples"]
	}, {
		key: ".*(15.4).*AppleWebKit.*Safari",
		capture: null,
		captureConstraint: null,
		targets: ["antialias", "maxMSAASamples"]
	}], Nd.CollisionsEpsilon = .001, Nd._ConcatenateShader = ju, Nd._IsSupported = null, Nd._HasMajorPerformanceCaveat = null, Nd.CeilingPOT = cd, Nd.FloorPOT = ud, Nd.NearestPOT = hd, Nd.GetExponentOfTwo = md, Nd.QueueNewFrame = km;
	var Id = class {
			get instantaneousFrameTime() {
				return this._rollingFrameTime.history(0)
			}
			reset() {
				this._lastFrameTimeMs = null, this._rollingFrameTime.reset()
			}
			get isSaturated() {
				return this._rollingFrameTime.isSaturated()
			}
			get instantaneousFPS() {
				const e = this._rollingFrameTime.history(0);
				return 0 === e ? 0 : 1e3 / e
			}
			enable() {
				this._enabled = !0
			}
			get averageFPS() {
				return 1e3 / this._rollingFrameTime.average
			}
			get averageFrameTimeVariance() {
				return this._rollingFrameTime.variance
			}
			disable() {
				this._enabled = !1, this._lastFrameTimeMs = null
			}
			get isEnabled() {
				return this._enabled
			}
			get averageFrameTime() {
				return this._rollingFrameTime.average
			}
			sampleFrame(e = Pu.Now) {
				if (this._enabled) {
					if (null != this._lastFrameTimeMs) {
						const t = e - this._lastFrameTimeMs;
						this._rollingFrameTime.add(t)
					}
					this._lastFrameTimeMs = e
				}
			}
			constructor(e = 30) {
				this._enabled = !0, this._rollingFrameTime = new Pd(e)
			}
		},
		Pd = class {
			isSaturated() {
				return this._sampleCount >= this._samples.length
			}
			_wrapPosition(e) {
				const t = this._samples.length;
				return (e % t + t) % t
			}
			reset() {
				this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0
			}
			history(e) {
				if (e >= this._sampleCount || e >= this._samples.length) return 0;
				const t = this._wrapPosition(this._pos - 1);
				return this._samples[this._wrapPosition(t - e)]
			}
			constructor(e) {
				this._samples = new Array(e), this.reset()
			}
			add(e) {
				let t;
				if (this.isSaturated()) {
					const e = this._samples[this._pos];
					t = e - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (e - this.average)
				} else this._sampleCount++;
				t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length
			}
		};

	function kd(e) {
		if (e.requestPointerLock) {
			const t = e.requestPointerLock();
			t instanceof Promise ? t.then((() => {
				e.focus()
			})).catch((() => {})) : e.focus()
		}
	}
	Nd.prototype.setAlphaMode = function(e, t = !1) {
		if (this._alphaMode !== e) {
			switch (e) {
				case 0:
					this._alphaState.alphaBlend = !1;
					break;
				case 7:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 8:
				case 14:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
					break;
				case 2:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 6:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 1:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 3:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 4:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 5:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 9:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0;
					break;
				case 10:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
					break;
				case 11:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 12:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO), this._alphaState.alphaBlend = !0;
					break;
				case 13:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
					break;
				case 15:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO), this._alphaState.alphaBlend = !0;
					break;
				case 16:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
					break;
				case 17:
					this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0
			}
			t || (this.depthCullingState.depthMask = 0 === e), this._alphaMode = e
		} else if (!t) {
			const t = 0 === e;
			this.depthCullingState.depthMask !== t && (this.depthCullingState.depthMask = t)
		}
	}, Nd.prototype._readTexturePixelsSync = function(e, t, i, s = -1, n = 0, a = null, r = !0, o = !1, l = 0, h = 0) {
		const c = this._gl;
		if (!c) throw new Error("Engine does not have gl rendering context.");
		if (!this._dummyFramebuffer) {
			const e = c.createFramebuffer();
			if (!e) throw new Error("Unable to create dummy framebuffer");
			this._dummyFramebuffer = e
		}
		c.bindFramebuffer(c.FRAMEBUFFER, this._dummyFramebuffer), s > -1 ? c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_CUBE_MAP_POSITIVE_X + s, e._hardwareTexture?.underlyingResource, n) : c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, e._hardwareTexture?.underlyingResource, n);
		let u = void 0 !== e.type ? this._getWebGLTextureType(e.type) : c.UNSIGNED_BYTE;
		if (o) a || (a = function(e, t, i = !1, s) {
			switch (e) {
				case 3: {
					const e = (ArrayBuffer, new Int8Array(t));
					return s && e.set(new Int8Array(s)), e
				}
				case 0: {
					const e = (ArrayBuffer, new Uint8Array(t));
					return s && e.set(new Uint8Array(s)), e
				}
				case 4: {
					const e = t instanceof ArrayBuffer ? new Int16Array(t) : new Int16Array(i ? t / 2 : t);
					return s && e.set(new Int16Array(s)), e
				}
				case 5:
				case 8:
				case 9:
				case 10:
				case 2: {
					const e = t instanceof ArrayBuffer ? new Uint16Array(t) : new Uint16Array(i ? t / 2 : t);
					return s && e.set(new Uint16Array(s)), e
				}
				case 6: {
					const e = t instanceof ArrayBuffer ? new Int32Array(t) : new Int32Array(i ? t / 4 : t);
					return s && e.set(new Int32Array(s)), e
				}
				case 7:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15: {
					const e = t instanceof ArrayBuffer ? new Uint32Array(t) : new Uint32Array(i ? t / 4 : t);
					return s && e.set(new Uint32Array(s)), e
				}
				case 1: {
					const e = t instanceof ArrayBuffer ? new Float32Array(t) : new Float32Array(i ? t / 4 : t);
					return s && e.set(new Float32Array(s)), e
				}
			}
			const n = (ArrayBuffer, new Uint8Array(t));
			return s && n.set(new Uint8Array(s)), n
		}(e.type, 4 * t * i));
		else if (u === c.UNSIGNED_BYTE) a || (a = new Uint8Array(4 * t * i)), u = c.UNSIGNED_BYTE;
		else a || (a = new Float32Array(4 * t * i)), u = c.FLOAT;
		return r && this.flushFramebuffer(), c.readPixels(l, h, t, i, c.RGBA, u, a), c.bindFramebuffer(c.FRAMEBUFFER, this._currentFramebuffer), a
	}, Nd.prototype._readTexturePixels = function(e, t, i, s = -1, n = 0, a = null, r = !0, o = !1, l = 0, h = 0) {
		return Promise.resolve(this._readTexturePixelsSync(e, t, i, s, n, a, r, o, l, h))
	}, Nd.prototype.updateDynamicIndexBuffer = function(e, t, i = 0) {
		let s;
		this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(e), s = e.is32Bits ? t instanceof Uint32Array ? t : new Uint32Array(t) : t instanceof Uint16Array ? t : new Uint16Array(t), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, s, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding()
	}, Nd.prototype.updateDynamicVertexBuffer = function(e, t, i, s) {
		this.bindArrayBuffer(e), void 0 === i && (i = 0);
		const n = t.byteLength || t.length;
		void 0 === s || s >= n && 0 === i ? t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, new Float32Array(t)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, t) : t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(t).subarray(i, i + s)) : (t = t instanceof ArrayBuffer ? new Uint8Array(t, i, s) : new Uint8Array(t.buffer, t.byteOffset + i, s), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t)), this._resetVertexBufferBinding()
	}, Dm.prototype.displayLoadingUI = function() {
		if (!Cu()) return;
		const e = this.loadingScreen;
		e && e.displayLoadingUI()
	}, Dm.prototype.hideLoadingUI = function() {
		if (!Cu()) return;
		const e = this._loadingScreen;
		e && e.hideLoadingUI()
	}, Object.defineProperty(Dm.prototype, "loadingScreen", {
		get: function() {
			return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = Dm.DefaultLoadingScreenFactory(this._renderingCanvas)), this._loadingScreen
		},
		set: function(e) {
			this._loadingScreen = e
		},
		enumerable: !0,
		configurable: !0
	}), Object.defineProperty(Dm.prototype, "loadingUIText", {
		set: function(e) {
			this.loadingScreen.loadingUIText = e
		},
		enumerable: !0,
		configurable: !0
	}), Object.defineProperty(Dm.prototype, "loadingUIBackgroundColor", {
		set: function(e) {
			this.loadingScreen.loadingUIBackgroundColor = e
		},
		enumerable: !0,
		configurable: !0
	}), Dm.prototype.getInputElement = function() {
		return this._renderingCanvas
	}, Dm.prototype.getRenderingCanvasClientRect = function() {
		return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null
	}, Dm.prototype.getInputElementClientRect = function() {
		return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null
	}, Dm.prototype.getAspectRatio = function(e, t = !1) {
		const i = e.viewport;
		return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height)
	}, Dm.prototype.getScreenAspectRatio = function() {
		return this.getRenderWidth(!0) / this.getRenderHeight(!0)
	}, Dm.prototype._verifyPointerLock = function() {
		this._onPointerLockChange?.()
	}, Dm.prototype.setAlphaEquation = function(e) {
		if (this._alphaEquation !== e) {
			switch (e) {
				case 0:
					this._alphaState.setAlphaEquationParameters(32774, 32774);
					break;
				case 1:
					this._alphaState.setAlphaEquationParameters(32778, 32778);
					break;
				case 2:
					this._alphaState.setAlphaEquationParameters(32779, 32779);
					break;
				case 3:
					this._alphaState.setAlphaEquationParameters(32776, 32776);
					break;
				case 4:
					this._alphaState.setAlphaEquationParameters(32775, 32775);
					break;
				case 5:
					this._alphaState.setAlphaEquationParameters(32775, 32774)
			}
			this._alphaEquation = e
		}
	}, Dm.prototype.getInputElement = function() {
		return this._renderingCanvas
	}, Dm.prototype.getDepthFunction = function() {
		return this._depthCullingState.depthFunc
	}, Dm.prototype.setDepthFunction = function(e) {
		this._depthCullingState.depthFunc = e
	}, Dm.prototype.setDepthFunctionToGreater = function() {
		this.setDepthFunction(516)
	}, Dm.prototype.setDepthFunctionToGreaterOrEqual = function() {
		this.setDepthFunction(518)
	}, Dm.prototype.setDepthFunctionToLess = function() {
		this.setDepthFunction(513)
	}, Dm.prototype.setDepthFunctionToLessOrEqual = function() {
		this.setDepthFunction(515)
	}, Dm.prototype.getDepthWrite = function() {
		return this._depthCullingState.depthMask
	}, Dm.prototype.setDepthWrite = function(e) {
		this._depthCullingState.depthMask = e
	}, Dm.prototype.getStencilBuffer = function() {
		return this._stencilState.stencilTest
	}, Dm.prototype.setStencilBuffer = function(e) {
		this._stencilState.stencilTest = e
	}, Dm.prototype.getStencilMask = function() {
		return this._stencilState.stencilMask
	}, Dm.prototype.setStencilMask = function(e) {
		this._stencilState.stencilMask = e
	}, Dm.prototype.getStencilFunction = function() {
		return this._stencilState.stencilFunc
	}, Dm.prototype.getStencilFunctionReference = function() {
		return this._stencilState.stencilFuncRef
	}, Dm.prototype.getStencilFunctionMask = function() {
		return this._stencilState.stencilFuncMask
	}, Dm.prototype.setStencilFunction = function(e) {
		this._stencilState.stencilFunc = e
	}, Dm.prototype.setStencilFunctionReference = function(e) {
		this._stencilState.stencilFuncRef = e
	}, Dm.prototype.setStencilFunctionMask = function(e) {
		this._stencilState.stencilFuncMask = e
	}, Dm.prototype.getStencilOperationFail = function() {
		return this._stencilState.stencilOpStencilFail
	}, Dm.prototype.getStencilOperationDepthFail = function() {
		return this._stencilState.stencilOpDepthFail
	}, Dm.prototype.getStencilOperationPass = function() {
		return this._stencilState.stencilOpStencilDepthPass
	}, Dm.prototype.setStencilOperationFail = function(e) {
		this._stencilState.stencilOpStencilFail = e
	}, Dm.prototype.setStencilOperationDepthFail = function(e) {
		this._stencilState.stencilOpDepthFail = e
	}, Dm.prototype.setStencilOperationPass = function(e) {
		this._stencilState.stencilOpStencilDepthPass = e
	}, Dm.prototype.cacheStencilState = function() {
		this._cachedStencilBuffer = this.getStencilBuffer(), this._cachedStencilFunction = this.getStencilFunction(), this._cachedStencilMask = this.getStencilMask(), this._cachedStencilOperationPass = this.getStencilOperationPass(), this._cachedStencilOperationFail = this.getStencilOperationFail(), this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(), this._cachedStencilReference = this.getStencilFunctionReference()
	}, Dm.prototype.restoreStencilState = function() {
		this.setStencilFunction(this._cachedStencilFunction), this.setStencilMask(this._cachedStencilMask), this.setStencilBuffer(this._cachedStencilBuffer), this.setStencilOperationPass(this._cachedStencilOperationPass), this.setStencilOperationFail(this._cachedStencilOperationFail), this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail), this.setStencilFunctionReference(this._cachedStencilReference)
	}, Dm.prototype.setAlphaConstants = function(e, t, i, s) {
		this._alphaState.setAlphaBlendConstants(e, t, i, s)
	}, Dm.prototype.getAlphaMode = function() {
		return this._alphaMode
	}, Dm.prototype.getAlphaEquation = function() {
		return this._alphaEquation
	}, Dm.prototype.getRenderPassNames = function() {
		return this._renderPassNames
	}, Dm.prototype.getCurrentRenderPassName = function() {
		return this._renderPassNames[this.currentRenderPassId]
	}, Dm.prototype.createRenderPassId = function(e) {
		const t = ++Dm._RenderPassIdCounter;
		return this._renderPassNames[t] = e ?? "NONAME", t
	}, Dm.prototype.releaseRenderPassId = function(e) {
		this._renderPassNames[e] = void 0;
		for (let t = 0; t < this.scenes.length; ++t) {
			const i = this.scenes[t];
			for (let t = 0; t < i.meshes.length; ++t) {
				const s = i.meshes[t];
				if (s.subMeshes)
					for (let t = 0; t < s.subMeshes.length; ++t) {
						s.subMeshes[t]._removeDrawWrapper(e)
					}
			}
		}
	}, Dm.prototype.createDepthStencilTexture = function(e, t, i) {
		if (t.isCube) {
			const i = e.width || e;
			return this._createDepthStencilCubeTexture(i, t)
		}
		return this._createDepthStencilTexture(e, t, i)
	};
	var Dd = class e {
		addCount(t, i) {
			e.Enabled && (this._current += t, i && this._fetchResult())
		}
		get min() {
			return this._min
		}
		get lastSecAverage() {
			return this._lastSecAverage
		}
		get max() {
			return this._max
		}
		get current() {
			return this._current
		}
		get average() {
			return this._average
		}
		endFrame() {
			this._fetchResult()
		}
		beginMonitoring() {
			e.Enabled && (this._startMonitoringTime = Pu.Now)
		}
		get total() {
			return this._totalAccumulated
		}
		constructor() {
			this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0
		}
		endMonitoring(t = !0) {
			if (!e.Enabled) return;
			t && this.fetchNewFrame();
			const i = Pu.Now;
			this._current = i - this._startMonitoringTime, t && this._fetchResult()
		}
		get count() {
			return this._totalValueCount
		}
		fetchNewFrame() {
			this._totalValueCount++, this._current = 0, this._lastSecValueCount++
		}
		_fetchResult() {
			this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;
			const e = Pu.Now;
			e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0)
		}
	};
	Dd.Enabled = !0, Dm.AudioEngineFactory = (e, t, i) => new Od(e, t, i);
	var Od = class {
			_displayMuteButton() {
				if (this.useCustomUnlockedButton || this._muteButton) return;
				this._muteButton = document.createElement("BUTTON"), this._muteButton.className = "babylonUnmuteIcon", this._muteButton.id = "babylonUnmuteIconBtn", this._muteButton.title = "Unmute";
				const e = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(" + (window.SVGSVGElement ? "data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E" : "https://cdn.babylonjs.com/Assets/audio.png") + ");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }",
					t = document.createElement("style");
				t.appendChild(document.createTextNode(e)), document.getElementsByTagName("head")[0].appendChild(t), document.body.appendChild(this._muteButton), this._moveButtonToTopLeft(), this._muteButton.addEventListener("touchend", (() => {
					this._triggerRunningState()
				}), !0), this._muteButton.addEventListener("click", (() => {
					this.unlock()
				}), !0), window.addEventListener("resize", this._onResize)
			}
			dispose() {
				this.canUseWebAudio && this._audioContextInitialized && (this._connectedAnalyser && this._audioContext && (this._connectedAnalyser.stopDebugCanvas(), this._connectedAnalyser.dispose(), this.masterGain.disconnect(), this.masterGain.connect(this._audioContext.destination), this._connectedAnalyser = null), this.masterGain.gain.value = 1), this.WarnedWebAudioUnsupported = !1, this._hideMuteButton(), window.removeEventListener("resize", this._onResize), this.onAudioUnlockedObservable.clear(), this.onAudioLockedObservable.clear()
			}
			getGlobalVolume() {
				return this.canUseWebAudio && this._audioContextInitialized ? this.masterGain.gain.value : -1
			}
			unlock() {
				if ("running" === this._audioContext?.state) return this._hideMuteButton(), void(this.unlocked || (this.unlocked = !0, this.onAudioUnlockedObservable.notifyObservers(this)));
				this._tryToRun ? this._audioContext?.suspend().then((() => {
					this._tryToRun = !1, this._triggerRunningState()
				})) : this._triggerRunningState()
			}
			_hideMuteButton() {
				this._muteButton && (document.body.removeChild(this._muteButton), this._muteButton = null)
			}
			get audioContext() {
				return this._audioContextInitialized || this._initializeAudioContext(), this._audioContext
			}
			_triggerRunningState() {
				this._tryToRun || (this._tryToRun = !0, this._resumeAudioContext().then((() => {
					this._tryToRun = !1, this._muteButton && this._hideMuteButton(), this.unlocked = !0, this.onAudioUnlockedObservable.notifyObservers(this)
				})).catch((() => {
					this._tryToRun = !1, this.unlocked = !1
				})))
			}
			_resumeAudioContext() {
				return this._audioContext?.resume ? this._audioContext.resume() : Promise.resolve()
			}
			_triggerSuspendedState() {
				this.unlocked = !1, this.onAudioLockedObservable.notifyObservers(this), this._displayMuteButton()
			}
			lock() {
				this._triggerSuspendedState()
			}
			connectToAnalyser(e) {
				this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(), this.canUseWebAudio && this._audioContextInitialized && this._audioContext && (this._connectedAnalyser = e, this.masterGain.disconnect(), this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination))
			}
			_resumeAudioContextOnStateChange() {
				this._audioContext?.addEventListener("statechange", (() => {
					this.unlocked && "running" !== this._audioContext?.state && this._resumeAudioContext()
				}), {
					once: !0,
					passive: !0,
					signal: AbortSignal.timeout(3e3)
				})
			}
			constructor(e = null, t = null, i = null) {
				if (this._audioContext = null, this._audioContextInitialized = !1, this._muteButton = null, this._audioDestination = null, this.canUseWebAudio = !1, this.WarnedWebAudioUnsupported = !1, this.isMP3supported = !1, this.isOGGsupported = !1, this.unlocked = !1, this.useCustomUnlockedButton = !1, this.onAudioUnlockedObservable = new kc, this.onAudioLockedObservable = new kc, this._tryToRun = !1, this._onResize = () => {
						this._moveButtonToTopLeft()
					}, !Cu()) return;
				void 0 !== window.AudioContext && (this.canUseWebAudio = !0);
				const s = document.createElement("audio");
				this._hostElement = e, this._audioContext = t, this._audioDestination = i;
				try {
					s && s.canPlayType && (s.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") || s.canPlayType("audio/mp3").replace(/^no$/, "")) && (this.isMP3supported = !0)
				} catch (e) {}
				try {
					s && s.canPlayType && s.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (this.isOGGsupported = !0)
				} catch (e) {}
			}
			setGlobalVolume(e) {
				this.canUseWebAudio && this._audioContextInitialized && (this.masterGain.gain.value = e)
			}
			_initializeAudioContext() {
				try {
					this.canUseWebAudio && (this._audioContext || (this._audioContext = new AudioContext), this.masterGain = this._audioContext.createGain(), this.masterGain.gain.value = 1, this._audioDestination || (this._audioDestination = this._audioContext.destination), this.masterGain.connect(this._audioDestination), this._audioContextInitialized = !0, "running" === this._audioContext.state && this._triggerRunningState())
				} catch (e) {
					this.canUseWebAudio = !1, Qc.Error("Web Audio: " + e.message)
				}
			}
			_moveButtonToTopLeft() {
				this._hostElement && this._muteButton && (this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px", this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px")
			}
		},
		Fd = class e extends Nd {
			_sharedInit(e) {
				super._sharedInit(e),
					function(e, t, i) {
						e._onCanvasFocus = () => {
							e.onCanvasFocusObservable.notifyObservers(e)
						}, e._onCanvasBlur = () => {
							e.onCanvasBlurObservable.notifyObservers(e)
						}, e._onCanvasContextMenu = t => {
							e.disableContextMenu && t.preventDefault()
						}, t.addEventListener("focus", e._onCanvasFocus), t.addEventListener("blur", e._onCanvasBlur), t.addEventListener("contextmenu", e._onCanvasContextMenu), e._onBlur = () => {
							e.disablePerformanceMonitorInBackground && e.performanceMonitor.disable(), e._windowIsBackground = !0
						}, e._onFocus = () => {
							e.disablePerformanceMonitorInBackground && e.performanceMonitor.enable(), e._windowIsBackground = !1
						}, e._onCanvasPointerOut = i => {
							document.elementFromPoint(i.clientX, i.clientY) !== t && e.onCanvasPointerOutObservable.notifyObservers(i)
						};
						const s = e.getHostWindow();
						s && "function" == typeof s.addEventListener && (s.addEventListener("blur", e._onBlur), s.addEventListener("focus", e._onFocus)), t.addEventListener("pointerout", e._onCanvasPointerOut), i.doNotHandleTouchAction || function(e) {
							e && e.setAttribute && (e.setAttribute("touch-action", "none"), e.style.touchAction = "none", e.style.webkitTapHighlightColor = "transparent")
						}(t), !Dm.audioEngine && i.audioEngine && Dm.AudioEngineFactory && (Dm.audioEngine = Dm.AudioEngineFactory(e.getRenderingCanvas(), e.getAudioContext(), e.getAudioDestination())), wu() && (e._onFullscreenChange = () => {
							e.isFullscreen = !!document.fullscreenElement, e.isFullscreen && e._pointerLockRequested && t && kd(t)
						}, document.addEventListener("fullscreenchange", e._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", e._onFullscreenChange, !1), e._onPointerLockChange = () => {
							e.isPointerLock = document.pointerLockElement === t
						}, document.addEventListener("pointerlockchange", e._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", e._onPointerLockChange, !1)), e.enableOfflineSupport = void 0 !== Dm.OfflineProviderFactory, e._deterministicLockstep = !!i.deterministicLockstep, e._lockstepMaxSteps = i.lockstepMaxSteps || 0, e._timeStep = i.timeStep || 1 / 60
					}(this, e, this._creationOptions)
			}
			_loadFileAsync(e, t, i) {
				return new Promise(((s, n) => {
					this._loadFile(e, (e => {
						s(e)
					}), void 0, t, i, ((e, t) => {
						n(t)
					}))
				}))
			}
			static get LastCreatedEngine() {
				return Dc.LastCreatedEngine
			}
			createShaderProgram(e, t, i, s, n, a = null) {
				n = n || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this);
				const r = super.createShaderProgram(e, t, i, s, n, a);
				return this.onAfterShaderCompilationObservable.notifyObservers(this), r
			}
			deleteInstancesBuffer(e) {
				this._gl.deleteBuffer(e)
			}
			_renderLoop() {
				if (this._frameHandler = 0, !this._contextWasLost) {
					let e = !0;
					(this.isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1), e && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame())
				}
				this._activeRenderLoops.length > 0 && 0 === this._frameHandler && (this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester), this._frameHandler = this.customAnimationFrameRequester.requestID) : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()))
			}
			static get Version() {
				return Dm.Version
			}
			updateTextureComparisonFunction(e, t) {
				if (1 === this.webGLVersion) return void Qc.Error("WebGL 1 does not support texture comparison.");
				const i = this._gl;
				e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0), 0 === t ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), 0 === t ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), e._comparisonFunction = t
			}
			getFragmentShaderSource(e) {
				const t = this._gl.getAttachedShaders(e);
				return t ? this._gl.getShaderSource(t[1]) : null
			}
			scissorClear(e, t, i, s, n) {
				this.enableScissor(e, t, i, s), this.clear(n, !0, !0, !0), this.disableScissor()
			}
			_uploadImageToTexture(e, t, i = 0, s = 0) {
				const n = this._gl,
					a = this._getWebGLTextureType(e.type),
					r = this._getInternalFormat(e.format),
					o = this._getRGBABufferInternalSizedFormat(e.type, r),
					l = e.isCube ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D;
				this._bindTextureDirectly(l, e, !0), this._unpackFlipY(e.invertY);
				let h = n.TEXTURE_2D;
				e.isCube && (h = n.TEXTURE_CUBE_MAP_POSITIVE_X + i), n.texImage2D(h, s, o, r, a, t), this._bindTextureDirectly(l, null, !0)
			}
			_createImageBitmapFromSource(e, t) {
				return function(e, t, i) {
					return new Promise(((s, n) => {
						const a = new Image;
						a.onload = () => {
							a.decode().then((() => {
								e.createImageBitmap(a, i).then((e => {
									s(e)
								}))
							}))
						}, a.onerror = () => {
							n(`Error loading image ${a.src}`)
						}, a.src = t
					}))
				}(this, e, t)
			}
			enterPointerlock() {
				this._renderingCanvas && kd(this._renderingCanvas)
			}
			dispose() {
				this.hideLoadingUI(), this._rescalePostProcess && this._rescalePostProcess.dispose(),
					function(e, t) {
						1 === Dc.Instances.length && Dm.audioEngine && (Dm.audioEngine.dispose(), Dm.audioEngine = null);
						const i = e.getHostWindow();
						i && "function" == typeof i.removeEventListener && (i.removeEventListener("blur", e._onBlur), i.removeEventListener("focus", e._onFocus)), t && (t.removeEventListener("focus", e._onCanvasFocus), t.removeEventListener("blur", e._onCanvasBlur), t.removeEventListener("pointerout", e._onCanvasPointerOut), t.removeEventListener("contextmenu", e._onCanvasContextMenu)), wu() && (document.removeEventListener("fullscreenchange", e._onFullscreenChange), document.removeEventListener("mozfullscreenchange", e._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", e._onFullscreenChange), document.removeEventListener("msfullscreenchange", e._onFullscreenChange), document.removeEventListener("pointerlockchange", e._onPointerLockChange), document.removeEventListener("mspointerlockchange", e._onPointerLockChange), document.removeEventListener("mozpointerlockchange", e._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", e._onPointerLockChange))
					}(this, this._renderingCanvas), super.dispose()
			}
			get _supportsHardwareTextureRescaling() {
				return !!e._RescalePostProcessFactory
			}
			createInstancesBuffer(e) {
				const t = this._gl.createBuffer();
				if (!t) throw new Error("Unable to create instance buffer");
				const i = new Td(t);
				return i.Yk = e, this.bindArrayBuffer(i), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), i.references = 1, i
			}
			disableScissor() {
				const e = this._gl;
				e.disable(e.SCISSOR_TEST)
			}
			static get Instances() {
				return Dc.Instances
			}
			set framebufferDimensionsObject(e) {
				this._framebufferDimensionsObject = e, this._framebufferDimensionsObject && this.onResizeObservable.notifyObservers(this)
			}
			resizeImageBitmap(e, t, i) {
				return function(e, t, i, s) {
					const n = e.createCanvas(i, s).getContext("2d");
					if (!n) throw new Error("Unable to get 2d context for resizeImageBitmap");
					return n.drawImage(t, 0, 0), n.getImageData(0, 0, i, s).data
				}(this, e, t, i)
			}
			_releaseRenderTargetWrapper(e) {
				super._releaseRenderTargetWrapper(e), this.scenes.forEach((t => {
					t.postProcesses.forEach((t => {
						t._outputTexture === e && (t._outputTexture = null)
					})), t.cameras.forEach((t => {
						t._postProcesses.forEach((t => {
							t && t._outputTexture === e && (t._outputTexture = null)
						}))
					}))
				}))
			}
			_initGLContext() {
				super._initGLContext(), this._rescalePostProcess = null
			}
			beginFrame() {
				this._measureFps(), super.beginFrame()
			}
			exitFullscreen() {
				this.isFullscreen && function() {
					const e = document;
					document.exitFullscreen ? document.exitFullscreen() : e.webkitCancelFullScreen && e.webkitCancelFullScreen()
				}()
			}
			get performanceMonitor() {
				return this._performanceMonitor
			}
			_deletePipelineContext(e) {
				const t = e;
				t && t.program && t.transformFeedback && (this.deleteTransformFeedback(t.transformFeedback), t.transformFeedback = null), super._deletePipelineContext(e)
			}
			_measureFps() {
				this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0
			}
			_rebuildBuffers() {
				for (const e of this.scenes) e.resetCachedMaterial(), e._rebuildGeometries();
				for (const e of this._virtualScenes) e.resetCachedMaterial(), e._rebuildGeometries();
				super._rebuildBuffers()
			}
			_readPixelsAsync(e, t, i, s, n, a, r) {
				if (this._webGLVersion < 2) throw new Error("_readPixelsAsync only work on WebGL2+");
				const o = this._gl,
					l = o.createBuffer();
				o.bindBuffer(o.PIXEL_PACK_BUFFER, l), o.bufferData(o.PIXEL_PACK_BUFFER, r.byteLength, o.STREAM_READ), o.readPixels(e, t, i, s, n, a, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
				const h = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
				return h ? (o.flush(), this._clientWaitAsync(h, 0, 10).then((() => (o.deleteSync(h), o.bindBuffer(o.PIXEL_PACK_BUFFER, l), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, r), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), o.deleteBuffer(l), r)))) : null
			}
			getFontOffset(e) {
				return function(e) {
					const t = document.createElement("span");
					t.textContent = "Hg", t.style.font = e;
					const i = document.createElement("div");
					i.style.display = "inline-block", i.style.width = "1px", i.style.height = "0px", i.style.verticalAlign = "bottom";
					const s = document.createElement("div");
					s.style.whiteSpace = "nowrap", s.appendChild(t), s.appendChild(i), document.body.appendChild(s);
					let n = 0,
						a = 0;
					try {
						a = i.getBoundingClientRect().top - t.getBoundingClientRect().top, i.style.verticalAlign = "baseline", n = i.getBoundingClientRect().top - t.getBoundingClientRect().top
					} finally {
						document.body.removeChild(s)
					}
					return {
						ascent: n,
						height: a,
						descent: a - n
					}
				}(e)
			}
			setDitheringState(e) {
				e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER)
			}
			_createShaderProgram(e, t, i, s, n = null) {
				const a = s.createProgram();
				if (e.program = a, !a) throw new Error("Unable to create program");
				if (s.attachShader(a, t), s.attachShader(a, i), this.webGLVersion > 1 && n) {
					const t = this.createTransformFeedback();
					this.bindTransformFeedback(t), this.setTranformFeedbackVaryings(a, n), e.transformFeedback = t
				}
				return s.linkProgram(a), this.webGLVersion > 1 && n && this.bindTransformFeedback(null), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), a
			}
			_cancelFrame() {
				if (this.customAnimationFrameRequester) {
					if (0 !== this._frameHandler) {
						this._frameHandler = 0;
						const {
							cancelAnimationFrame: e
						} = this.customAnimationFrameRequester;
						e && e(this.customAnimationFrameRequester.requestID)
					}
				} else super._cancelFrame()
			}
			switchFullscreen(e) {
				this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(e)
			}
			static get NpmPackage() {
				return Dm.NpmPackage
			}
			_clientWaitAsync(e, t = 0, i = 10) {
				const s = this._gl;
				return new Promise(((n, a) => {
					const r = () => {
						const o = s.clientWaitSync(e, t, 0);
						o != s.WAIT_FAILED ? o != s.TIMEOUT_EXPIRED ? n() : setTimeout(r, i) : a()
					};
					r()
				}))
			}
			static get LastCreatedScene() {
				return Dc.LastCreatedScene
			}
			setRasterizerState(e) {
				e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD)
			}
			enableScissor(e, t, i, s) {
				const n = this._gl;
				n.enable(n.SCISSOR_TEST), n.scissor(e, t, i, s)
			}
			static DefaultLoadingScreenFactory(e) {
				return Dm.DefaultLoadingScreenFactory(e)
			}
			enterFullscreen(e) {
				this.isFullscreen || (this._pointerLockRequested = e, this._renderingCanvas && function(e) {
					const t = e.requestFullscreen || e.webkitRequestFullscreen;
					t && t.call(e)
				}(this._renderingCanvas))
			}
			constructor(e, t, i, s = !1) {
				if (super(e, t, i, s), this.customAnimationFrameRequester = null, this._performanceMonitor = new Id, this._drawCalls = new Dd, e && (this._features.supportRenderPasses = !0, i = this._creationOptions, e.getContext)) {
					const t = e;
					this._sharedInit(t)
				}
			}
			_releaseTexture(e) {
				super._releaseTexture(e)
			}
			_rescaleTexture(t, i, s, n, a) {
				this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
				const r = this.createRenderTargetTexture({
					width: i.width,
					height: i.height
				}, {
					generateMipMaps: !1,
					type: 0,
					samplingMode: 2,
					generateDepthBuffer: !1,
					generateStencilBuffer: !1
				});
				if (!this._rescalePostProcess && e._RescalePostProcessFactory && (this._rescalePostProcess = e._RescalePostProcessFactory(this)), this._rescalePostProcess) {
					this._rescalePostProcess.externalTextureSamplerBinding = !0;
					const e = () => {
							this._rescalePostProcess.onApply = function(e) {
								e._bindTexture("textureSampler", t)
							};
							let e = s;
							e || (e = this.scenes[this.scenes.length - 1]), e.postProcessManager.directRender([this._rescalePostProcess], r, !0), this._bindTextureDirectly(this._gl.TEXTURE_2D, i, !0), this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, n, 0, 0, i.width, i.height, 0), this.unBindFramebuffer(r), r.dispose(), a && a()
						},
						o = this._rescalePostProcess.getEffect();
					o ? o.executeWhenCompiled(e) : this._rescalePostProcess.onEffectCreatedObservable.addOnce((t => {
						t.executeWhenCompiled(e)
					}))
				}
			}
			setDirectViewport(e, t, i, s) {
				const n = this._cachedViewport;
				return this._cachedViewport = null, this._viewport(e, t, i, s), n
			}
			exitPointerlock() {
				document.exitPointerLock && document.exitPointerLock()
			}
			static MarkAllMaterialsAsDirty(t, i) {
				for (let s = 0; s < e.Instances.length; s++) {
					const n = e.Instances[s];
					for (let e = 0; e < n.scenes.length; e++) n.scenes[e].markAllMaterialsAsDirty(t, i)
				}
			}
			wrapWebGLTexture(e, t = !1, i = 3, s = 0, n = 0) {
				const a = new wd(e, this._gl),
					r = new Pm(this, 0, !0);
				return r._hardwareTexture = a, r.baseWidth = s, r.baseHeight = n, r.width = s, r.height = n, r.isReady = !0, r.useMipMaps = t, this.updateTextureSamplingMode(i, r), r
			}
			getVertexShaderSource(e) {
				const t = this._gl.getAttachedShaders(e);
				return t ? this._gl.getShaderSource(t[0]) : null
			}
		};
	Fd.ALPHA_DISABLE = 0, Fd.ALPHA_ADD = 1, Fd.ALPHA_COMBINE = 2, Fd.ALPHA_SUBTRACT = 3, Fd.ALPHA_MULTIPLY = 4, Fd.ALPHA_MAXIMIZED = 5, Fd.ALPHA_ONEONE = 6, Fd.ALPHA_PREMULTIPLIED = 7, Fd.ALPHA_PREMULTIPLIED_PORTERDUFF = 8, Fd.ALPHA_INTERPOLATE = 9, Fd.ALPHA_SCREENMODE = 10, Fd.DELAYLOADSTATE_NONE = 0, Fd.DELAYLOADSTATE_LOADED = 1, Fd.DELAYLOADSTATE_LOADING = 2, Fd.DELAYLOADSTATE_NOTLOADED = 4, Fd.NEVER = 512, Fd.ALWAYS = 519, Fd.LESS = 513, Fd.EQUAL = 514, Fd.LEQUAL = 515, Fd.GREATER = 516, Fd.GEQUAL = 518, Fd.NOTEQUAL = 517, Fd.KEEP = 7680, Fd.REPLACE = 7681, Fd.INCR = 7682, Fd.DECR = 7683, Fd.INVERT = 5386, Fd.INCR_WRAP = 34055, Fd.DECR_WRAP = 34056, Fd.TEXTURE_CLAMP_ADDRESSMODE = 0, Fd.TEXTURE_WRAP_ADDRESSMODE = 1, Fd.TEXTURE_MIRROR_ADDRESSMODE = 2, Fd.TEXTUREFORMAT_ALPHA = 0, Fd.TEXTUREFORMAT_LUMINANCE = 1, Fd.TEXTUREFORMAT_LUMINANCE_ALPHA = 2, Fd.TEXTUREFORMAT_RGB = 4, Fd.TEXTUREFORMAT_RGBA = 5, Fd.TEXTUREFORMAT_RED = 6, Fd.TEXTUREFORMAT_R = 6, Fd.TEXTUREFORMAT_RG = 7, Fd.TEXTUREFORMAT_RED_INTEGER = 8, Fd.TEXTUREFORMAT_R_INTEGER = 8, Fd.TEXTUREFORMAT_RG_INTEGER = 9, Fd.TEXTUREFORMAT_RGB_INTEGER = 10, Fd.TEXTUREFORMAT_RGBA_INTEGER = 11, Fd.TEXTURETYPE_UNSIGNED_BYTE = 0, Fd.TEXTURETYPE_UNSIGNED_INT = 0, Fd.TEXTURETYPE_FLOAT = 1, Fd.TEXTURETYPE_HALF_FLOAT = 2, Fd.TEXTURETYPE_BYTE = 3, Fd.TEXTURETYPE_SHORT = 4, Fd.TEXTURETYPE_UNSIGNED_SHORT = 5, Fd.TEXTURETYPE_INT = 6, Fd.TEXTURETYPE_UNSIGNED_INTEGER = 7, Fd.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8, Fd.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9, Fd.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10, Fd.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11, Fd.TEXTURETYPE_UNSIGNED_INT_24_8 = 12, Fd.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13, Fd.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14, Fd.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15, Fd.TEXTURE_NEAREST_SAMPLINGMODE = 1, Fd.TEXTURE_BILINEAR_SAMPLINGMODE = 2, Fd.TEXTURE_TRILINEAR_SAMPLINGMODE = 3, Fd.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8, Fd.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11, Fd.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3, Fd.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4, Fd.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5, Fd.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6, Fd.TEXTURE_NEAREST_LINEAR = 7, Fd.TEXTURE_NEAREST_NEAREST = 1, Fd.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9, Fd.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10, Fd.TEXTURE_LINEAR_LINEAR = 2, Fd.TEXTURE_LINEAR_NEAREST = 12, Fd.TEXTURE_EXPLICIT_MODE = 0, Fd.TEXTURE_SPHERICAL_MODE = 1, Fd.TEXTURE_PLANAR_MODE = 2, Fd.TEXTURE_CUBIC_MODE = 3, Fd.TEXTURE_PROJECTION_MODE = 4, Fd.TEXTURE_SKYBOX_MODE = 5, Fd.TEXTURE_INVCUBIC_MODE = 6, Fd.TEXTURE_EQUIRECTANGULAR_MODE = 7, Fd.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8, Fd.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, Fd.SCALEMODE_FLOOR = 1, Fd.SCALEMODE_NEAREST = 2, Fd.SCALEMODE_CEILING = 3;
	var Ld = class {
		getTextureCoordinates(e = eu.UVKind) {
			if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(e)) return null;
			const t = this.pickedMesh.getIndices();
			if (!t) return null;
			const i = this.pickedMesh.getVerticesData(e);
			if (!i) return null;
			let s = Fc.FromArray(i, 2 * t[3 * this.faceId]),
				n = Fc.FromArray(i, 2 * t[3 * this.faceId + 1]),
				a = Fc.FromArray(i, 2 * t[3 * this.faceId + 2]);
			return s = s.scale(this.bu), n = n.scale(this.bv), a = a.scale(1 - this.bu - this.bv), new Fc(s.x + n.x + a.x, s.y + n.y + a.y)
		}
		constructor() {
			this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshFaceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.thinInstanceIndex = -1, this.ray = null, this.originMesh = null, this.aimTransform = null, this.gripTransform = null
		}
		getNormal(e = !1, t = !0) {
			if (!this.pickedMesh || t && !this.pickedMesh.isVerticesDataPresent(eu.NormalKind)) return null;
			let i, s = this.pickedMesh.getIndices();
			0 === s?.length && (s = null);
			const n = Vc.Vector3[0],
				a = Vc.Vector3[1],
				r = Vc.Vector3[2];
			if (t) {
				const e = this.pickedMesh.getVerticesData(eu.NormalKind);
				let t = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId], n) : n.copyFromFloats(e[3 * this.faceId * 3], e[3 * this.faceId * 3 + 1], e[3 * this.faceId * 3 + 2]),
					o = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId + 1], a) : a.copyFromFloats(e[3 * (3 * this.faceId + 1)], e[3 * (3 * this.faceId + 1) + 1], e[3 * (3 * this.faceId + 1) + 2]),
					l = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId + 2], r) : r.copyFromFloats(e[3 * (3 * this.faceId + 2)], e[3 * (3 * this.faceId + 2) + 1], e[3 * (3 * this.faceId + 2) + 2]);
				t = t.scale(this.bu), o = o.scale(this.bv), l = l.scale(1 - this.bu - this.bv), i = new Lc(t.x + o.x + l.x, t.y + o.y + l.y, t.z + o.z + l.z)
			} else {
				const e = this.pickedMesh.getVerticesData(eu.PositionKind),
					t = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId], n) : n.copyFromFloats(e[3 * this.faceId * 3], e[3 * this.faceId * 3 + 1], e[3 * this.faceId * 3 + 2]),
					o = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId + 1], a) : a.copyFromFloats(e[3 * (3 * this.faceId + 1)], e[3 * (3 * this.faceId + 1) + 1], e[3 * (3 * this.faceId + 1) + 2]),
					l = s ? Lc.FromArrayToRef(e, 3 * s[3 * this.faceId + 2], r) : r.copyFromFloats(e[3 * (3 * this.faceId + 2)], e[3 * (3 * this.faceId + 2) + 1], e[3 * (3 * this.faceId + 2) + 2]),
					h = t.subtract(o),
					c = l.subtract(o);
				i = Lc.Cross(h, c)
			}
			const o = (e, t) => {
				let i = e.getWorldMatrix();
				e.nonUniformScaling && (Vc.Matrix[0].copyFrom(i), i = Vc.Matrix[0], i.setTranslationFromFloats(0, 0, 0), i.invert(), i.transposeToRef(Vc.Matrix[1]), i = Vc.Matrix[1]), Lc.TransformNormalToRef(t, i, t)
			};
			if (e && o(this.pickedMesh, i), this.ray) {
				const t = Vc.Vector3[0].copyFrom(i);
				e || o(this.pickedMesh, t), Lc.Dot(t, this.ray.direction) > 0 && i.negateInPlace()
			}
			return i.normalize(), i
		}
	};
	Nd.prototype.createUniformBuffer = function(e, t) {
		const i = this._gl.createBuffer();
		if (!i) throw new Error("Unable to create uniform buffer");
		const s = new Td(i);
		return this.bindUniformBuffer(s), e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), s.references = 1, s
	}, Nd.prototype.createDynamicUniformBuffer = function(e, t) {
		const i = this._gl.createBuffer();
		if (!i) throw new Error("Unable to create dynamic uniform buffer");
		const s = new Td(i);
		return this.bindUniformBuffer(s), e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), s.references = 1, s
	}, Nd.prototype.updateUniformBuffer = function(e, t, i, s) {
		this.bindUniformBuffer(e), void 0 === i && (i = 0), void 0 === s ? t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, t) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, new Float32Array(t)) : t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, t.subarray(i, i + s)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(t).subarray(i, i + s)), this.bindUniformBuffer(null)
	}, Nd.prototype.bindUniformBuffer = function(e) {
		this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, e ? e.underlyingResource : null)
	}, Nd.prototype.bindUniformBufferBase = function(e, t, i) {
		this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, t, e ? e.underlyingResource : null)
	}, Nd.prototype.bindUniformBlock = function(e, t, i) {
		const s = e.program,
			n = this._gl.getUniformBlockIndex(s, t);
		4294967295 !== n && this._gl.uniformBlockBinding(s, n, i)
	};
	var Bd = class e {
		_buffersEqual(e, t) {
			for (let i = 0; i < e.length; ++i)
				if (e[i] !== t[i]) return !1;
			return !0
		}
		_updateUInt3ForEffect(e, t, i, s, n = "") {
			this._currentEffect.setUInt3(e + n, t, i, s)
		}
		_updateColor3ForEffect(e, t, i = "") {
			this._currentEffect.setColor3(e + i, t)
		}
		bindUniformBuffer() {
			!this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName)
		}
		_updateArrayForUniform(e, t) {
			this.updateUniformArray(e, t, t.length)
		}
		create() {
			this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0)
		}
		isDynamic() {
			return void 0 !== this._dynamic
		}
		addMatrix2x2(e) {
			this.addUniform(e, 8)
		}
		addColor3(e, t) {
			const i = [t.r, t.g, t.b];
			this.addUniform(e, i)
		}
		_updateInt2ForUniform(t, i, s) {
			e._TempBufferInt32View[0] = i, e._TempBufferInt32View[1] = s, this.updateUniform(t, e._TempBuffer, 2)
		}
		get currentEffect() {
			return this._currentEffect
		}
		_createNewBuffer() {
			this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++, this._buffer = this._buffers[this._bufferIndex][0], this._createBufferOnWrite = !1, this._needSync = !0) : this._rebuild()
		}
		_updateColor4ForUniform(t, i, s) {
			e._TempBuffer[0] = i.r, e._TempBuffer[1] = i.g, e._TempBuffer[2] = i.b, e._TempBuffer[3] = s, this.updateUniform(t, e._TempBuffer, 4)
		}
		_updateMatrix2x2ForUniform(t, i) {
			for (let t = 0; t < 2; t++) e._TempBuffer[4 * t] = i[2 * t], e._TempBuffer[4 * t + 1] = i[2 * t + 1], e._TempBuffer[4 * t + 2] = 0, e._TempBuffer[4 * t + 3] = 0;
			this.updateUniform(t, e._TempBuffer, 8)
		}
		update() {
			if (!this._noUBO)
				if (this.bindUniformBuffer(), this._buffer)
					if (this._dynamic || this._needSync) {
						if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
							if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) return this._needSync = !1, void(this._createBufferOnWrite = this._engine._features.trackUbosInFrame);
							this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1])
						}
						this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._engine._features._collectUbosUpdatedInFrame && (e._UpdatedUbosInFrame[this._name] || (e._UpdatedUbosInFrame[this._name] = 0), e._UpdatedUbosInFrame[this._name]++), this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame
					} else this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
			else this.create()
		}
		addMatrix(e, t) {
			this.addUniform(e, Array.prototype.slice.call(t.asArray()))
		}
		get _numBuffers() {
			return this._buffers.length
		}
		addVector3(e, t) {
			const i = [t.x, t.y, t.z];
			this.addUniform(e, i)
		}
		dispose() {
			if (this._noUBO) return;
			const e = this._engine._uniformBuffers,
				t = e.indexOf(this);
			if (-1 !== t && (e[t] = e[e.length - 1], e.pop()), this._engine._features.trackUbosInFrame && this._buffers)
				for (let e = 0; e < this._buffers.length; ++e) {
					const t = this._buffers[e][0];
					this._engine._releaseBuffer(t)
				} else this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null)
		}
		_updateMatrix2x2ForEffect(e, t) {
			this._currentEffect.setMatrix2x2(e, t)
		}
		_updateIntForUniform(t, i) {
			e._TempBufferInt32View[0] = i, this.updateUniform(t, e._TempBuffer, 1)
		}
		_updateFloat2ForUniform(t, i, s) {
			e._TempBuffer[0] = i, e._TempBuffer[1] = s, this.updateUniform(t, e._TempBuffer, 2)
		}
		_updateIntForEffect(e, t, i = "") {
			this._currentEffect.setInt(e + i, t)
		}
		_updateFloatForEffect(e, t) {
			this._currentEffect.setFloat(e, t)
		}
		_updateFloat2ForEffect(e, t, i, s = "") {
			this._currentEffect.setFloat2(e + s, t, i)
		}
		get _indexBuffer() {
			return this._bufferIndex
		}
		_fillAlignment(e) {
			let t;
			if (t = e <= 2 ? e : 4, this._uniformLocationPointer % t != 0) {
				const e = this._uniformLocationPointer;
				this._uniformLocationPointer += t - this._uniformLocationPointer % t;
				const i = this._uniformLocationPointer - e;
				for (let e = 0; e < i; e++) this._data.push(0)
			}
		}
		_updateArrayForEffect(e, t) {
			this._currentEffect.setArray(e, t)
		}
		_updateIntArrayForEffect(e, t) {
			this._currentEffect.setIntArray(e, t)
		}
		_updateVector4ForEffect(e, t) {
			this._currentEffect.setVector4(e, t)
		}
		_updateUInt2ForUniform(t, i, s) {
			e._TempBufferUInt32View[0] = i, e._TempBufferUInt32View[1] = s, this.updateUniform(t, e._TempBuffer, 2)
		}
		_updateUIntArrayForUniform(t, i) {
			e._TempBufferUInt32View.set(i), this.updateUniformArray(t, e._TempBuffer, i.length)
		}
		_copyBuffer(e, t) {
			for (let i = 0; i < e.length; ++i) t[i] = e[i]
		}
		_updateUInt4ForEffect(e, t, i, s, n, a = "") {
			this._currentEffect.setUInt4(e + a, t, i, s, n)
		}
		_updateInt2ForEffect(e, t, i, s = "") {
			this._currentEffect.setInt2(e + s, t, i)
		}
		_updateVector3ForEffect(e, t) {
			this._currentEffect.setVector3(e, t)
		}
		_updateInt3ForUniform(t, i, s, n) {
			e._TempBufferInt32View[0] = i, e._TempBufferInt32View[1] = s, e._TempBufferInt32View[2] = n, this.updateUniform(t, e._TempBuffer, 3)
		}
		get isSync() {
			return !this._needSync
		}
		_updateFloatForUniform(t, i) {
			e._TempBuffer[0] = i, this.updateUniform(t, e._TempBuffer, 1)
		}
		constructor(e, t, i, s, n = !1) {
			this._valueCache = {}, this._engine = e, this._noUBO = !e.supportsUniformBuffers || n, this._dynamic = i, this._name = s ?? "no-name", this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformArraySizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._engine._features.trackUbosInFrame && (this._buffers = [], this._bufferIndex = -1, this._createBufferOnWrite = !1, this._currentFrameId = 0), this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateFloatArray = this._updateFloatArrayForEffect, this.updateArray = this._updateArrayForEffect, this.updateIntArray = this._updateIntArrayForEffect, this.updateUIntArray = this._updateUIntArrayForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateMatrices = this._updateMatricesForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect, this.updateDirectColor4 = this._updateDirectColor4ForEffect, this.updateInt = this._updateIntForEffect, this.updateInt2 = this._updateInt2ForEffect, this.updateInt3 = this._updateInt3ForEffect, this.updateInt4 = this._updateInt4ForEffect, this.updateUInt = this._updateUIntForEffect, this.updateUInt2 = this._updateUInt2ForEffect, this.updateUInt3 = this._updateUInt3ForEffect, this.updateUInt4 = this._updateUInt4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateFloatArray = this._updateFloatArrayForUniform, this.updateArray = this._updateArrayForUniform, this.updateIntArray = this._updateIntArrayForUniform, this.updateUIntArray = this._updateUIntArrayForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateMatrices = this._updateMatricesForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform, this.updateDirectColor4 = this._updateDirectColor4ForUniform, this.updateInt = this._updateIntForUniform, this.updateInt2 = this._updateInt2ForUniform, this.updateInt3 = this._updateInt3ForUniform, this.updateInt4 = this._updateInt4ForUniform, this.updateUInt = this._updateUIntForUniform, this.updateUInt2 = this._updateUInt2ForUniform, this.updateUInt3 = this._updateUInt3ForUniform, this.updateUInt4 = this._updateUInt4ForUniform)
		}
		_updateUIntForUniform(t, i) {
			e._TempBufferUInt32View[0] = i, this.updateUniform(t, e._TempBuffer, 1)
		}
		_updateMatrixForEffect(e, t) {
			this._currentEffect.setMatrix(e, t)
		}
		_updateColor3ForUniform(t, i) {
			e._TempBuffer[0] = i.r, e._TempBuffer[1] = i.g, e._TempBuffer[2] = i.b, this.updateUniform(t, e._TempBuffer, 3)
		}
		addFloat3(e, t, i, s) {
			const n = [t, i, s];
			this.addUniform(e, n)
		}
		_updateUInt3ForUniform(t, i, s, n) {
			e._TempBufferUInt32View[0] = i, e._TempBufferUInt32View[1] = s, e._TempBufferUInt32View[2] = n, this.updateUniform(t, e._TempBuffer, 3)
		}
		_updateFloat3ForUniform(t, i, s, n) {
			e._TempBuffer[0] = i, e._TempBuffer[1] = s, e._TempBuffer[2] = n, this.updateUniform(t, e._TempBuffer, 3)
		}
		_updateDirectColor4ForEffect(e, t, i = "") {
			this._currentEffect.setDirectColor4(e + i, t)
		}
		unbindEffect() {
			this._currentEffect = void 0, this._currentEffectName = void 0
		}
		_updateMatrix3x3ForUniform(t, i) {
			for (let t = 0; t < 3; t++) e._TempBuffer[4 * t] = i[3 * t], e._TempBuffer[4 * t + 1] = i[3 * t + 1], e._TempBuffer[4 * t + 2] = i[3 * t + 2], e._TempBuffer[4 * t + 3] = 0;
			this.updateUniform(t, e._TempBuffer, 12)
		}
		_updateInt3ForEffect(e, t, i, s, n = "") {
			this._currentEffect.setInt3(e + n, t, i, s)
		}
		addMatrix3x3(e) {
			this.addUniform(e, 12)
		}
		_updateInt4ForEffect(e, t, i, s, n, a = "") {
			this._currentEffect.setInt4(e + a, t, i, s, n)
		}
		_updateVector4ForUniform(t, i) {
			e._TempBuffer[0] = i.x, e._TempBuffer[1] = i.y, e._TempBuffer[2] = i.z, e._TempBuffer[3] = i.w, this.updateUniform(t, e._TempBuffer, 4)
		}
		_updateVector3ForUniform(t, i) {
			e._TempBuffer[0] = i.x, e._TempBuffer[1] = i.y, e._TempBuffer[2] = i.z, this.updateUniform(t, e._TempBuffer, 3)
		}
		_updateFloatArrayForUniform(e, t) {
			this.updateUniformArray(e, t, t.length)
		}
		bindToEffect(e, t) {
			this._currentEffect = e, this._currentEffectName = t
		}
		_updateMatricesForUniform(e, t) {
			this.updateUniform(e, t, t.length)
		}
		_updateDirectColor4ForUniform(t, i) {
			e._TempBuffer[0] = i.r, e._TempBuffer[1] = i.g, e._TempBuffer[2] = i.b, e._TempBuffer[3] = i.a, this.updateUniform(t, e._TempBuffer, 4)
		}
		_updateFloatArrayForEffect(e, t) {
			this._currentEffect.setFloatArray(e, t)
		}
		_getNames() {
			const e = [];
			let t = 0;
			for (const i in this._uniformLocations)
				if (e.push(i), 10 == ++t) break;
			return e.join(",")
		}
		updateUniformDirectly(e, t) {
			this.updateUniform(e, t, t.length), this.update()
		}
		_updateUIntArrayForEffect(e, t) {
			this._currentEffect.setUIntArray(e, t)
		}
		get useUbo() {
			return !this._noUBO
		}
		_updateFloat4ForUniform(t, i, s, n, a) {
			e._TempBuffer[0] = i, e._TempBuffer[1] = s, e._TempBuffer[2] = n, e._TempBuffer[3] = a, this.updateUniform(t, e._TempBuffer, 4)
		}
		_updateIntArrayForUniform(t, i) {
			e._TempBufferInt32View.set(i), this.updateUniformArray(t, e._TempBuffer, i.length)
		}
		setDataBuffer(e) {
			if (!this._buffers) return this._buffer === e;
			for (let t = 0; t < this._buffers.length; ++t) {
				if (this._buffers[t][0] === e) return this._bufferIndex = t, this._buffer = e, this._createBufferOnWrite = !1, this._currentEffect = void 0, !0
			}
			return !1
		}
		_rebuild() {
			!this._noUBO && this._bufferData && (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()) : this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()), this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]), this._bufferIndex = this._buffers.length - 1, this._createBufferOnWrite = !1))
		}
		_updateMatrix3x3ForEffect(e, t) {
			this._currentEffect.setMatrix3x3(e, t)
		}
		updateUniformArray(e, t, i) {
			this._checkNewFrame();
			const s = this._uniformLocations[e];
			if (void 0 === s) return void Qc.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
			this._buffer || this.create();
			const n = this._uniformArraySizes[e];
			if (this._dynamic)
				for (let e = 0; e < i; e++) this._bufferData[s + e] = t[e];
			else {
				let e = !1,
					a = 0,
					r = 0;
				for (let o = 0; o < i; o++)
					if (this._bufferData[s + 4 * r + a] !== dd.FloatRound(t[o]) && (e = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + 4 * r + a] = t[o]), a++, a === n.strideSize) {
						for (; a < 4; a++) this._bufferData[s + 4 * r + a] = 0;
						a = 0, r++
					} this._needSync = this._needSync || e
			}
		}
		_cacheMatrix(e, t) {
			this._checkNewFrame();
			const i = this._valueCache[e],
				s = t.updateFlag;
			return (void 0 === i || i !== s) && (this._valueCache[e] = s, !0)
		}
		_updateFloat4ForEffect(e, t, i, s, n, a = "") {
			this._currentEffect.setFloat4(e + a, t, i, s, n)
		}
		_checkNewFrame() {
			this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId, this._createBufferOnWrite = !1, this._buffers && this._buffers.length > 0 ? (this._needSync = 0 !== this._bufferIndex, this._bufferIndex = 0, this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1)
		}
		updateUniform(e, t, i) {
			this._checkNewFrame();
			let s = this._uniformLocations[e];
			if (void 0 === s) {
				if (this._buffer) return void Qc.Error("Cannot add an uniform after UBO has been created. uniformName=" + e);
				this.addUniform(e, i), s = this._uniformLocations[e]
			}
			if (this._buffer || this.create(), this._dynamic)
				for (let e = 0; e < i; e++) this._bufferData[s + e] = t[e];
			else {
				let e = !1;
				for (let n = 0; n < i; n++)(16 === i && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[s + n] !== Math.fround(t[n])) && (e = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + n] = t[n]);
				this._needSync = this._needSync || e
			}
		}
		get name() {
			return this._name
		}
		bindTexture(e, t) {
			this._currentEffect._bindTexture(e, t)
		}
		_updateInt4ForUniform(t, i, s, n, a) {
			e._TempBufferInt32View[0] = i, e._TempBufferInt32View[1] = s, e._TempBufferInt32View[2] = n, e._TempBufferInt32View[3] = a, this.updateUniform(t, e._TempBuffer, 4)
		}
		_updateUInt2ForEffect(e, t, i, s = "") {
			this._currentEffect.setUInt2(e + s, t, i)
		}
		_updateMatricesForEffect(e, t) {
			this._currentEffect.setMatrices(e, t)
		}
		getData() {
			return this._bufferData
		}
		_updateUInt4ForUniform(t, i, s, n, a) {
			e._TempBufferUInt32View[0] = i, e._TempBufferUInt32View[1] = s, e._TempBufferUInt32View[2] = n, e._TempBufferUInt32View[3] = a, this.updateUniform(t, e._TempBuffer, 4)
		}
		addColor4(e, t, i) {
			const s = [t.r, t.g, t.b, i];
			this.addUniform(e, s)
		}
		_updateUIntForEffect(e, t, i = "") {
			this._currentEffect.setUInt(e + i, t)
		}
		addFloat2(e, t, i) {
			const s = [t, i];
			this.addUniform(e, s)
		}
		getBuffer() {
			return this._buffer
		}
		addUniform(e, t, i = 0) {
			if (this._noUBO) return;
			if (void 0 !== this._uniformLocations[e]) return;
			let s;
			if (i > 0) {
				if (t instanceof Array) throw "addUniform should not be use with Array in UBO: " + e;
				if (this._fillAlignment(4), this._uniformArraySizes[e] = {
						strideSize: t,
						arraySize: i
					}, 16 == t) t *= i;
				else {
					t = t * i + (4 - t) * i
				}
				s = [];
				for (let e = 0; e < t; e++) s.push(0)
			} else {
				if (t instanceof Array) s = t, t = s.length;
				else {
					s = [];
					for (let e = 0; e < t; e++) s.push(0)
				}
				this._fillAlignment(t)
			}
			this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t;
			for (let e = 0; e < t; e++) this._data.push(s[e]);
			this._needSync = !0
		}
		_rebuildAfterContextLost() {
			this._engine._features.trackUbosInFrame && (this._buffers = [], this._currentFrameId = 0), this._rebuild()
		}
		_updateMatrixForUniform(e, t) {
			this._cacheMatrix(e, t) && this.updateUniform(e, t.asArray(), 16)
		}
		_updateFloat3ForEffect(e, t, i, s, n = "") {
			this._currentEffect.setFloat3(e + n, t, i, s)
		}
		setTexture(e, t) {
			this._currentEffect.setTexture(e, t)
		}
		_updateColor4ForEffect(e, t, i, s = "") {
			this._currentEffect.setColor4(e + s, t, i)
		}
	};
	Bd._UpdatedUbosInFrame = {}, Bd._MAX_UNIFORM_SIZE = 256, Bd._TempBuffer = new Float32Array(Bd._MAX_UNIFORM_SIZE), Bd._TempBufferInt32View = new Int32Array(Bd._TempBuffer.buffer), Bd._TempBufferUInt32View = new Uint32Array(Bd._TempBuffer.buffer);
	var Gd, Hd, Ud = class {
		constructor() {
			this._checkCollisions = !1, this._collisionMask = -1, this._collisionGroup = -1, this._surroundingMeshes = null, this._collider = null, this._oldPositionForCollisions = new Lc(0, 0, 0), this._diffPositionForCollisions = new Lc(0, 0, 0), this._collisionResponse = !0
		}
	};
	(Hd = Gd || (Gd = {}))[Hd.LOCAL = 0] = "LOCAL", Hd[Hd.WORLD = 1] = "WORLD", Hd[Hd.BONE = 2] = "BONE";
	var Vd, Wd, zd = class {};
	zd.X = new Lc(1, 0, 0), zd.Y = new Lc(0, 1, 0), zd.Z = new Lc(0, 0, 1), (Wd = Vd || (Vd = {}))[Wd.X = 0] = "X", Wd[Wd.Y = 1] = "Y", Wd[Wd.Z = 2] = "Z";
	var Xd = class {
			constructor() {
				this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = Lc.Zero(), this.subDiv = {
					max: 1,
					X: 1,
					Y: 1,
					Z: 1
				}, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1
			}
		},
		Yd = class {
			constructor() {
				this._hasVertexAlpha = !1, this._useVertexColors = !0, this._numBoneInfluencers = 4, this._applyFog = !0, this._receiveShadows = !1, this._facetData = new Xd, this._visibility = 1, this._skeleton = null, this._layerMask = 268435455, this._computeBonesUsingShaders = !0, this._isActive = !1, this._onlyForInstances = !1, this._isActiveIntermediate = !1, this._onlyForInstancesIntermediate = !1, this._actAsRegularMesh = !1, this._currentLOD = null, this._currentLODIsUpToDate = !1, this._collisionRetryCount = 3, this._morphTargetManager = null, this._renderingGroupId = 0, this._bakedVertexAnimationManager = null, this._material = null, this._positions = null, this._pointerOverDisableMeshTesting = !1, this._meshCollisionData = new Ud, this._enableDistantPicking = !1, this._rawBoundingInfo = null, this._sideOrientationHint = !1, this._inheritVisibility = !1
			}
		},
		jd = class e extends Jc {
			getLOD(e) {
				return this
			}
			set layerMask(e) {
				e !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = e, this._resyncLightSources())
			}
			get numBoneInfluencers() {
				return this._internalAbstractMeshDataInfo._numBoneInfluencers
			}
			createNormals(e) {
				const t = this.getVerticesData(eu.PositionKind),
					i = this.getIndices();
				let s;
				return s = this.isVerticesDataPresent(eu.NormalKind) ? this.getVerticesData(eu.NormalKind) : [], Mu.ComputeNormals(t, i, s, {
					useRightHandedSystem: this.getScene().useRightHandedSystem
				}), this.setVerticesData(eu.NormalKind, s, e), this
			}
			_removeLightSource(e, t) {
				const i = this._lightSources.indexOf(e); - 1 !== i && (this._lightSources.splice(i, 1), this._markSubMeshesAsLightDirty(t))
			}
			movePOV(e, t, i) {
				return this.position.addInPlace(this.calcMovePOV(e, t, i)), this
			}
			static get BILLBOARDMODE_USE_POSITION() {
				return Jc.BILLBOARDMODE_USE_POSITION
			}
			set partitioningSubdivisions(e) {
				this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = e
			}
			enableEdgesRendering(e, t, i) {
				throw ic("EdgesRenderer")
			}
			set collisionGroup(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(e) ? -1 : e
			}
			_resyncLightSource(e) {
				const t = e.isEnabled() && e.canAffectMesh(this),
					i = this._lightSources.indexOf(e);
				let s = !1;
				if (-1 === i) {
					if (!t) return;
					this._lightSources.push(e)
				} else {
					if (t) return;
					s = !0, this._lightSources.splice(i, 1)
				}
				this._markSubMeshesAsLightDirty(s)
			}
			get material() {
				return this._internalAbstractMeshDataInfo._material
			}
			updateVerticesData(e, t, i, s) {
				return this
			}
			isCompletelyInFrustum(e) {
				return this.getBoundingInfo().isCompletelyInFrustum(e)
			}
			set material(e) {
				this._setMaterial(e)
			}
			get surroundingMeshes() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes
			}
			getVerticesData(e) {
				return null
			}
			set rawBoundingInfo(e) {
				this._internalAbstractMeshDataInfo._rawBoundingInfo = e
			}
			dispose(e, t = !1) {
				let i;
				const s = this.getScene();
				for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.ik] = void 0), s.freeActiveMeshes(), s.freeRenderingGroups(), s.renderingManager.maintainStateBetweenFrames && s.renderingManager.restoreDispachedFlags(), void 0 !== this.actionManager && null !== this.actionManager && (this.actionManager.disposeWhenUnowned && !this._scene.meshes.some((e => e !== this && e.actionManager === this.actionManager)) && this.actionManager.dispose(), this.actionManager = null), this._internalAbstractMeshDataInfo._skeleton = null, this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null), i = 0; i < this._intersectionsInProgress.length; i++) {
					const e = this._intersectionsInProgress[i],
						t = e._intersectionsInProgress.indexOf(this);
					e._intersectionsInProgress.splice(t, 1)
				}
				this._intersectionsInProgress.length = 0;
				s.lights.forEach((e => {
					let t = e.includedOnlyMeshes.indexOf(this); - 1 !== t && e.includedOnlyMeshes.splice(t, 1), t = e.excludedMeshes.indexOf(this), -1 !== t && e.excludedMeshes.splice(t, 1);
					const i = e.getShadowGenerators();
					if (i) {
						const e = i.values();
						for (let i = e.next(); !0 !== i.done; i = e.next()) {
							const e = i.value.getShadowMap();
							e && e.Tk && (t = e.Tk.indexOf(this), -1 !== t && e.Tk.splice(t, 1))
						}
					}
				})), "InstancedMesh" === this.getClassName() && "InstancedLinesMesh" === this.getClassName() || this.releaseSubMeshes();
				const n = s.getEngine();
				if (null !== this._occlusionQuery && (this.isOcclusionQueryInProgress = !1, n.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), n.wipeCaches(), s.removeMesh(this), this._parentContainer) {
					const e = this._parentContainer.meshes.indexOf(this);
					e > -1 && this._parentContainer.meshes.splice(e, 1), this._parentContainer = null
				}
				if (t && this.material && ("MultiMaterial" === this.material.getClassName() ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)), !e)
					for (i = 0; i < s.particleSystems.length; i++) s.particleSystems[i].emitter === this && (s.particleSystems[i].dispose(), i--);
				this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(), this._uniformBuffer.dispose(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), super.dispose(e, t)
			}
			intersectsPoint(e) {
				return this.getBoundingInfo().intersectsPoint(e)
			}
			get useVertexColors() {
				return this._internalAbstractMeshDataInfo._useVertexColors
			}
			_resyncLightSources() {
				this._lightSources.length = 0;
				for (const e of this.getScene().lights) e.isEnabled() && e.canAffectMesh(this) && this._lightSources.push(e);
				this._markSubMeshesAsLightDirty()
			}
			get collisionGroup() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup
			}
			_preActivateForIntermediateRendering(e) {}
			set enableDistantPicking(e) {
				this._internalAbstractMeshDataInfo._enableDistantPicking = e
			}
			static get BILLBOARDMODE_X() {
				return Jc.BILLBOARDMODE_X
			}
			getRawBoundingInfo() {
				return this.rawBoundingInfo ?? this.getBoundingInfo()
			}
			get facetNb() {
				return this._internalAbstractMeshDataInfo._facetData.facetNb
			}
			get collisionResponse() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse
			}
			get checkCollisions() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions
			}
			set isVisible(e) {
				this._isVisible = e
			}
			getFacetPositionToRef(e, t) {
				const i = this.getFacetLocalPositions()[e],
					s = this.getWorldMatrix();
				return Lc.TransformCoordinatesToRef(i, s, t), this
			}
			set onCollisionPositionChange(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e)
			}
			_collideForSubMesh(e, t, i) {
				if (this._generatePointsArray(), !this._positions) return this;
				if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) {
					e._lastColliderTransformMatrix = t.clone(), e._lastColliderWorldVertices = [], e._trianglePlanes = [];
					const i = e.verticesStart,
						s = e.verticesStart + e.verticesCount;
					for (let n = i; n < s; n++) e._lastColliderWorldVertices.push(Lc.TransformCoordinates(this._positions[n], t))
				}
				return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial(), this, this._shouldConvertRHS(), 7 === e.getMaterial()?.fillMode), this
			}
			getNormalsData(e = !1, t = !1) {
				return this._getData({
					applySkeleton: e,
					applyMorph: t,
					updatePositionsArray: !1
				}, null, eu.NormalKind)
			}
			set surroundingMeshes(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = e
			}
			get isFacetDataEnabled() {
				return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled
			}
			isInFrustum(e) {
				return this.getBoundingInfo().isInFrustum(e, this.cullingStrategy)
			}
			set bakedVertexAnimationManager(e) {
				this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== e && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = e, this._markSubMeshesAsAttributesDirty())
			}
			_markSubMeshesAsDirty(e) {
				if (this.subMeshes)
					for (const t of this.subMeshes)
						for (let i = 0; i < t._drawWrappers.length; ++i) {
							const s = t._drawWrappers[i];
							s && s.defines && s.defines.markAllAsDirty && e(s.defines)
						}
			}
			getFacetDataParameters() {
				return this._internalAbstractMeshDataInfo._facetData.facetParameters
			}
			set pointerOverDisableMeshTesting(e) {
				this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = e
			}
			get rawBoundingInfo() {
				return this._internalAbstractMeshDataInfo._rawBoundingInfo
			}
			constructor(t, i = null) {
				switch (super(t, i, !1), this._internalAbstractMeshDataInfo = new Yd, this._waitingMaterialId = null, this.cullingStrategy = e.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, this.onCollideObservable = new kc, this.onCollisionPositionChangeObservable = new kc, this.onMaterialChangedObservable = new kc, this.definedFacingForward = !0, this._occlusionQuery = null, this._renderingGroup = null, this.alphaIndex = Number.MAX_VALUE, this._isVisible = !0, this.isPickable = !0, this.isNearPickable = !1, this.isNearGrabbable = !1, this.showSubMeshesBoundingBox = !1, this.isBlocker = !1, this.enablePointerMoveEvents = !1, this.outlineColor = Tc.Red(), this.outlineWidth = .02, this.overlayColor = Tc.Red(), this.overlayAlpha = .5, this.useOctreeForRenderingSelection = !0, this.useOctreeForPicking = !0, this.useOctreeForCollisions = !0, this.alwaysSelectAsActiveMesh = !1, this.doNotSyncBoundingInfo = !1, this.actionManager = null, this.ellipsoid = new Lc(.5, 1, .5), this.ellipsoidOffset = new Lc(0, 0, 0), this.edgesWidth = 1, this.edgesColor = new wc(1, 0, 0, 1), this._edgesRenderer = null, this._masterMesh = null, this._boundingInfo = null, this._boundingInfoIsDirty = !0, this._renderId = 0, this._intersectionsInProgress = new Array, this._unIndexed = !1, this._lightSources = new Array, this._waitingData = {
						lods: null,
						actions: null,
						freezeWorldMatrix: null
					}, this._bonesTransformMatrices = null, this._transformMatrixTexture = null, this.onRebuildObservable = new kc, this._onCollisionPositionChange = (e, t, i = null) => {
						t.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Fd.CollisionsEpsilon && this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), i && this.onCollideObservable.notifyObservers(i), this.onCollisionPositionChangeObservable.notifyObservers(this.position)
					}, (i = this.getScene()).addMesh(this), this._resyncLightSources(), this._uniformBuffer = new Bd(this.getScene().getEngine(), void 0, void 0, t, !this.getScene().getEngine().isWebGPU), this._buildUniformLayout(), i.performancePriority) {
					case 2:
						this.doNotSyncBoundingInfo = !0;
					case 1:
						this.alwaysSelectAsActiveMesh = !0, this.isPickable = !1
				}
			}
			getFacetLocalPartitioning() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				return e.facetPartitioning || this.updateFacetData(), e.facetPartitioning
			}
			alignWithNormal(e, t) {
				t || (t = zd.Y);
				const i = Vc.Vector3[0],
					s = Vc.Vector3[1];
				return Lc.CrossToRef(t, e, s), Lc.CrossToRef(e, s, i), this.rotationQuaternion ? Gc.RotationQuaternionFromAxisToRef(i, e, s, this.rotationQuaternion) : Lc.RotationFromAxisToRef(i, e, s, this.rotation), this
			}
			getClassName() {
				return "AbstractMesh"
			}
			_getEffectiveParent() {
				return this._masterMesh && this.billboardMode !== Jc.BILLBOARDMODE_NONE ? this._masterMesh : super._getEffectiveParent()
			}
			resetDrawCache(e) {
				if (this.subMeshes)
					for (const t of this.subMeshes) t.resetDrawCache(e)
			}
			_syncGeometryWithMorphTargetManager() {}
			_updateSubMeshesBoundingInfo(e) {
				if (!this.subMeshes) return this;
				const t = this.subMeshes.length;
				for (let i = 0; i < t; i++) {
					const s = this.subMeshes[i];
					(t > 1 || !s.IsGlobal) && s.updateBoundingInfo(e)
				}
				return this
			}
			set collisionMask(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(e) ? -1 : e
			}
			_postActivate() {}
			get hasBoundingInfo() {
				return null !== this._boundingInfo
			}
			clone(e, t, i) {
				return null
			}
			getMeshUniformBuffer() {
				return this._uniformBuffer
			}
			_updateBoundingInfo() {
				return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new yu(Lc.Zero(), Lc.Zero(), this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this
			}
			intersects(e, t, i, s = !1, n, a = !1) {
				const r = new Ld,
					o = this.getClassName(),
					l = "InstancedLinesMesh" === o || "LinesMesh" === o || "GreasedLineMesh" === o ? this.intersectionThreshold : 0,
					h = this.getBoundingInfo();
				if (!this.subMeshes) return r;
				if (!(a || e.intersectsSphere(h.boundingSphere, l) && e.intersectsBox(h.boundingBox, l))) return r;
				if (s) return r.hit = !a, r.pickedMesh = a ? null : this, r.distance = a ? 0 : Lc.Distance(e.origin, h.boundingSphere.center), r.subMeshId = 0, r;
				if (!this._generatePointsArray()) return r;
				let c = null;
				const u = this._scene.getIntersectingSubMeshCandidates(this, e),
					m = u.length;
				let d = !1;
				for (let e = 0; e < m; e++) {
					const t = u.data[e].getMaterial();
					if (t && (7 == t.fillMode || 0 == t.fillMode || 1 == t.fillMode || 2 == t.fillMode || 4 == t.fillMode)) {
						d = !0;
						break
					}
				}
				if (!d) return r.hit = !0, r.pickedMesh = this, r.distance = Lc.Distance(e.origin, h.boundingSphere.center), r.subMeshId = -1, r;
				for (let s = 0; s < m; s++) {
					const n = u.data[s];
					if (m > 1 && !a && !n.canIntersects(e)) continue;
					const r = n.intersects(e, this._positions, this.getIndices(), t, i);
					if (r && (t || !c || r.distance < c.distance) && (c = r, c.subMeshId = s, t)) break
				}
				if (c) {
					const t = n ?? this.getWorldMatrix(),
						i = Vc.Vector3[0],
						s = Vc.Vector3[1];
					Lc.TransformCoordinatesToRef(e.origin, t, i), e.direction.scaleToRef(c.distance, s);
					const a = Lc.TransformNormal(s, t).addInPlace(i);
					return r.hit = !0, r.distance = Lc.Distance(i, a), r.pickedPoint = a, r.pickedMesh = this, r.bu = c.bu || 0, r.bv = c.bv || 0, r.subMeshFaceId = c.faceId, r.faceId = c.faceId + u.data[c.subMeshId].indexStart / (-1 !== this.getClassName().indexOf("LinesMesh") ? 2 : 3), r.subMeshId = c.subMeshId, r
				}
				return r
			}
			get morphTargetManager() {
				return this._internalAbstractMeshDataInfo._morphTargetManager
			}
			toString(e) {
				let t = "Name: " + this.name + ", isInstance: " + ("InstancedMesh" !== this.getClassName() ? "YES" : "NO");
				t += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
				const i = this._internalAbstractMeshDataInfo._skeleton;
				return i && (t += ", skeleton: " + i.name), e && (t += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], t += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")), t
			}
			static get BILLBOARDMODE_Y() {
				return Jc.BILLBOARDMODE_Y
			}
			get partitioningBBoxRatio() {
				return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio
			}
			getFacetLocalPositions() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				return e.facetPositions || this.updateFacetData(), e.facetPositions
			}
			isVerticesDataPresent(e) {
				return !1
			}
			set Lk(e) {
				this._internalAbstractMeshDataInfo._renderingGroupId = e
			}
			get facetDepthSortFrom() {
				return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom
			}
			get collisionRetryCount() {
				return this._internalAbstractMeshDataInfo._collisionRetryCount
			}
			_buildUniformLayout() {
				this._uniformBuffer.addUniform("world", 16), this._uniformBuffer.addUniform("visibility", 1), this._uniformBuffer.create()
			}
			updateFacetData() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				e.facetDataEnabled || this._initFacetData();
				const t = this.getVerticesData(eu.PositionKind),
					i = this.getIndices(),
					s = this.getVerticesData(eu.NormalKind),
					n = this.getBoundingInfo();
				if (e.facetDepthSort && !e.facetDepthSortEnabled) {
					if (e.facetDepthSortEnabled = !0, i instanceof Uint16Array) e.depthSortedIndices = new Uint16Array(i);
					else if (i instanceof Uint32Array) e.depthSortedIndices = new Uint32Array(i);
					else {
						let t = !1;
						for (let e = 0; e < i.length; e++)
							if (i[e] > 65535) {
								t = !0;
								break
							} e.depthSortedIndices = t ? new Uint32Array(i) : new Uint16Array(i)
					}
					if (e.facetDepthSortFunction = function(e, t) {
							return t.sqDistance - e.sqDistance
						}, !e.facetDepthSortFrom) {
						const t = this.getScene().activeCamera;
						e.facetDepthSortFrom = t ? t.position : Lc.Zero()
					}
					e.depthSortedFacets = [];
					for (let t = 0; t < e.facetNb; t++) {
						const i = {
							ind: 3 * t,
							sqDistance: 0
						};
						e.depthSortedFacets.push(i)
					}
					e.invertedMatrix = Hc.Identity(), e.facetDepthSortOrigin = Lc.Zero()
				}
				e.bbSize.x = n.maximum.x - n.minimum.x > pc ? n.maximum.x - n.minimum.x : pc, e.bbSize.y = n.maximum.y - n.minimum.y > pc ? n.maximum.y - n.minimum.y : pc, e.bbSize.z = n.maximum.z - n.minimum.z > pc ? n.maximum.z - n.minimum.z : pc;
				let a = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y;
				if (a = a > e.bbSize.z ? a : e.bbSize.z, e.subDiv.max = e.partitioningSubdivisions, e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / a), e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / a), e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / a), e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X, e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y, e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z, e.facetParameters.facetNormals = this.getFacetLocalNormals(), e.facetParameters.facetPositions = this.getFacetLocalPositions(), e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), e.facetParameters.bInfo = n, e.facetParameters.bbSize = e.bbSize, e.facetParameters.subDiv = e.subDiv, e.facetParameters.ratio = this.partitioningBBoxRatio, e.facetParameters.depthSort = e.facetDepthSort, e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(e.invertedMatrix), Lc.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin), e.facetParameters.distanceTo = e.facetDepthSortOrigin), e.facetParameters.depthSortedFacets = e.depthSortedFacets, s && Mu.ComputeNormals(t, i, s, e.facetParameters), e.facetDepthSort && e.facetDepthSortEnabled) {
					e.depthSortedFacets.sort(e.facetDepthSortFunction);
					const t = e.depthSortedIndices.length / 3 | 0;
					for (let s = 0; s < t; s++) {
						const t = e.depthSortedFacets[s].ind;
						e.depthSortedIndices[3 * s] = i[t], e.depthSortedIndices[3 * s + 1] = i[t + 1], e.depthSortedIndices[3 * s + 2] = i[t + 2]
					}
					this.updateIndices(e.depthSortedIndices, void 0, !0)
				}
				return this
			}
			set receiveShadows(e) {
				this._internalAbstractMeshDataInfo._receiveShadows !== e && (this._internalAbstractMeshDataInfo._receiveShadows = e, this._markSubMeshesAsLightDirty())
			}
			get hasInstances() {
				return !1
			}
			_checkCollision(e) {
				if (!this.getBoundingInfo()._checkCollision(e)) return this;
				const t = Vc.Matrix[0],
					i = Vc.Matrix[1];
				return Hc.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t), this.worldMatrixFromCache.multiplyToRef(t, i), this._processCollisionsForSubMeshes(e, i), this
			}
			_refreshBoundingInfo(e, t) {
				if (e) {
					const i = Eu(e, 0, this.getTotalVertices(), t);
					this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new yu(i.minimum, i.maximum)
				}
				if (this.subMeshes)
					for (let t = 0; t < this.subMeshes.length; t++) this.subMeshes[t].refreshBoundingInfo(e);
				this._updateBoundingInfo()
			}
			get applyFog() {
				return this._internalAbstractMeshDataInfo._applyFog
			}
			get enableDistantPicking() {
				return this._internalAbstractMeshDataInfo._enableDistantPicking
			}
			_activate(e, t) {
				return this._renderId = e, !0
			}
			set mustDepthSortFacets(e) {
				this._internalAbstractMeshDataInfo._facetData.facetDepthSort = e
			}
			disableFacetData() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				return e.facetDataEnabled && (e.facetDataEnabled = !1, e.facetPositions = [], e.facetNormals = [], e.facetPartitioning = new Array, e.facetParameters = null, e.depthSortedIndices = new Uint32Array(0)), this
			}
			set hasVertexAlpha(e) {
				this._internalAbstractMeshDataInfo._hasVertexAlpha !== e && (this._internalAbstractMeshDataInfo._hasVertexAlpha = e, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty())
			}
			calcRotatePOV(e, t, i) {
				const s = this.definedFacingForward ? 1 : -1;
				return new Lc(e * s, t, i * s)
			}
			_getData(t, i, s = eu.PositionKind) {
				const n = t.cache,
					a = e => {
						if (n) {
							const t = n._vertexData || (n._vertexData = {});
							return t[e] || this.copyVerticesData(e, t), t[e]
						}
						return this.getVerticesData(e)
					};
				if (i || (i = a(s)), !i) return null;
				if (n ? (n._outputData ? n._outputData.set(i) : n._outputData = new Float32Array(i), i = n._outputData) : (t.applyMorph && this.morphTargetManager || t.applySkeleton && this.skeleton) && (i = i.slice()), t.applyMorph && this.morphTargetManager && function(e, t, i) {
						let s = null;
						switch (t) {
							case eu.PositionKind:
								s = e => e.getPositions();
								break;
							case eu.NormalKind:
								s = e => e.getNormals();
								break;
							case eu.TangentKind:
								s = e => e.getTangents();
								break;
							case eu.UVKind:
								s = e => e.getUVs();
								break;
							default:
								return
						}
						for (let t = 0; t < e.length; t++) {
							let n = e[t];
							for (let a = 0; a < i.numTargets; a++) {
								const r = i.getTarget(a),
									o = r.influence;
								if (0 !== o) {
									const i = s(r);
									i && (n += (i[t] - e[t]) * o)
								}
							}
							e[t] = n
						}
					}(i, s, this.morphTargetManager), t.applySkeleton && this.skeleton) {
					const t = a(eu.MatricesIndicesKind),
						n = a(eu.MatricesWeightsKind);
					if (n && t) {
						const r = this.numBoneInfluencers > 4,
							o = r ? a(eu.MatricesIndicesExtraKind) : null,
							l = r ? a(eu.MatricesWeightsExtraKind) : null,
							h = this.skeleton.getTransformMatrices(this);
						e._ApplySkeleton(i, s, h, t, n, o, l)
					}
				}
				if (!1 !== t.updatePositionsArray && s === eu.PositionKind) {
					const e = this._internalAbstractMeshDataInfo._positions || [],
						t = e.length;
					if (e.length = i.length / 3, t < e.length)
						for (let i = t; i < e.length; i++) e[i] = new Lc;
					for (let t = 0, s = 0; t < e.length; t++, s += 3) e[t].copyFromFloats(i[s], i[s + 1], i[s + 2]);
					this._internalAbstractMeshDataInfo._positions = e
				}
				return i
			}
			get isAnInstance() {
				return !1
			}
			get isBlocked() {
				return !1
			}
			setMaterialForRenderPass(e, t) {
				this.resetDrawCache(e), this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []), this._internalAbstractMeshDataInfo._materialForRenderPass[e] = t
			}
			static _ApplySkeleton(e, t, i, s, n, a, r) {
				! function(e, t, i, s, n, a, r) {
					const o = Vc.Vector3[0],
						l = Vc.Matrix[0],
						h = Vc.Matrix[1],
						c = t === eu.NormalKind ? Lc.TransformNormalFromFloatsToRef : Lc.TransformCoordinatesFromFloatsToRef;
					for (let t = 0, u = 0; t < e.length; t += 3, u += 4) {
						let m, d;
						for (l.reset(), m = 0; m < 4; m++) d = n[u + m], d > 0 && (Hc.FromFloat32ArrayToRefScaled(i, Math.floor(16 * s[u + m]), d, h), l.addToSelf(h));
						if (a && r)
							for (m = 0; m < 4; m++) d = r[u + m], d > 0 && (Hc.FromFloat32ArrayToRefScaled(i, Math.floor(16 * a[u + m]), d, h), l.addToSelf(h));
						c(e[t], e[t + 1], e[t + 2], l, o), o.toArray(e, t)
					}
				}(e, t, i, s, n, a, r)
			}
			set skeleton(e) {
				const t = this._internalAbstractMeshDataInfo._skeleton;
				t && t.needInitialSkinMatrix && t._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._internalAbstractMeshDataInfo._skeleton = e, this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty()
			}
			_markSubMeshesAsLightDirty(e = !1) {
				this._markSubMeshesAsDirty((t => t.markAsLightDirty(e)))
			}
			get collider() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._collider
			}
			getConnectedParticleSystems() {
				return this._scene.particleSystems.filter((e => e.emitter === this))
			}
			setBoundingInfo(e) {
				return this._boundingInfo = e, this
			}
			get inheritVisibility() {
				return this._internalAbstractMeshDataInfo._inheritVisibility
			}
			getWorldMatrix() {
				return this._masterMesh && this.billboardMode === Jc.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : super.getWorldMatrix()
			}
			set useVertexColors(e) {
				this._internalAbstractMeshDataInfo._useVertexColors !== e && (this._internalAbstractMeshDataInfo._useVertexColors = e, this._markSubMeshesAsAttributesDirty())
			}
			getTotalIndices() {
				return 0
			}
			get visibility() {
				return this._internalAbstractMeshDataInfo._visibility
			}
			getMaterialForRenderPass(e) {
				return this._internalAbstractMeshDataInfo._materialForRenderPass?.[e]
			}
			static get BILLBOARDMODE_NONE() {
				return Jc.BILLBOARDMODE_NONE
			}
			_getActionManagerForTrigger(e, t = !0) {
				if (this.actionManager && (t || this.actionManager.isRecursive)) {
					if (!e) return this.actionManager;
					if (this.actionManager.hasSpecificTrigger(e)) return this.actionManager
				}
				return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null
			}
			get useBones() {
				return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(eu.MatricesIndicesKind) && this.isVerticesDataPresent(eu.MatricesWeightsKind)
			}
			_refreshBoundingInfoDirect(e) {
				if (this._boundingInfo ? this._boundingInfo.reConstruct(e.minimum, e.maximum) : this._boundingInfo = new yu(e.minimum, e.maximum), this.subMeshes)
					for (let e = 0; e < this.subMeshes.length; e++) this.subMeshes[e].refreshBoundingInfo(null);
				this._updateBoundingInfo()
			}
			calcMovePOV(e, t, i) {
				const s = new Hc;
				(this.rotationQuaternion ? this.rotationQuaternion : Gc.Jk(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(s);
				const n = Lc.Zero(),
					a = this.definedFacingForward ? -1 : 1;
				return Lc.TransformCoordinatesFromFloatsToRef(e * a, t, i * a, s, n), n
			}
			get collisionMask() {
				return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask
			}
			get partitioningSubdivisions() {
				return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions
			}
			get bakedVertexAnimationManager() {
				return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager
			}
			getFacetLocalNormals() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				return e.facetNormals || this.updateFacetData(), e.facetNormals
			}
			setVerticesData(e, t, i, s) {
				return this
			}
			moveWithCollisions(e) {
				this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
				const t = this.getScene().collisionCoordinator;
				return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = t.createCollider()), this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid, t.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, e, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.ik), this
			}
			set collisionResponse(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = e
			}
			get skeleton() {
				return this._internalAbstractMeshDataInfo._skeleton
			}
			getPositionData(e = !1, t = !1, i = null) {
				return this._getData({
					applySkeleton: e,
					applyMorph: t,
					updatePositionsArray: !1
				}, i, eu.PositionKind)
			}
			setIndices(e, t) {
				return this
			}
			intersectsMesh(e, t = !1, i) {
				const s = this.getBoundingInfo(),
					n = e.getBoundingInfo();
				if (s.intersects(n, t)) return !0;
				if (i)
					for (const i of this.getChildMeshes())
						if (i.intersectsMesh(e, t, !0)) return !0;
				return !1
			}
			get hasVertexAlpha() {
				return this._internalAbstractMeshDataInfo._hasVertexAlpha
			}
			get mustDepthSortFacets() {
				return this._internalAbstractMeshDataInfo._facetData.facetDepthSort
			}
			rotatePOV(e, t, i) {
				return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)), this
			}
			set morphTargetManager(e) {
				this._internalAbstractMeshDataInfo._morphTargetManager !== e && (this._internalAbstractMeshDataInfo._morphTargetManager = e, this._syncGeometryWithMorphTargetManager())
			}
			set numBoneInfluencers(e) {
				this._internalAbstractMeshDataInfo._numBoneInfluencers !== e && (this._internalAbstractMeshDataInfo._numBoneInfluencers = e, this._markSubMeshesAsAttributesDirty())
			}
			disableEdgesRendering() {
				throw ic("EdgesRenderer")
			}
			releaseSubMeshes() {
				if (this.subMeshes)
					for (; this.subMeshes.length;) this.subMeshes[0].dispose();
				else this.subMeshes = [];
				return this
			}
			getClosestFacetAtLocalCoordinates(e, t, i, s, n = !1, a = !0) {
				let r = null,
					o = 0,
					l = 0,
					h = 0,
					c = 0,
					u = 0,
					m = 0,
					d = 0,
					f = 0;
				const p = this.getFacetLocalPositions(),
					_ = this.getFacetLocalNormals(),
					g = this.getFacetsAtLocalCoordinates(e, t, i);
				if (!g) return null;
				let v, y, S, E = Number.MAX_VALUE,
					A = E;
				for (let b = 0; b < g.length; b++) v = g[b], y = _[v], S = p[v], c = (e - S.x) * y.x + (t - S.y) * y.y + (i - S.z) * y.z, (!n || n && a && c >= 0 || n && !a && c <= 0) && (c = y.x * S.x + y.y * S.y + y.z * S.z, u = -(y.x * e + y.y * t + y.z * i - c) / (y.x * y.x + y.y * y.y + y.z * y.z), m = e + y.x * u, d = t + y.y * u, f = i + y.z * u, o = m - e, l = d - t, h = f - i, A = o * o + l * l + h * h, A < E && (E = A, r = v, s && (s.x = m, s.y = d, s.z = f)));
				return r
			}
			getClosestFacetAtCoordinates(e, t, i, s, n = !1, a = !0) {
				const r = this.getWorldMatrix(),
					o = Vc.Matrix[5];
				r.invertToRef(o);
				const l = Vc.Vector3[8];
				Lc.TransformCoordinatesFromFloatsToRef(e, t, i, o, l);
				const h = this.getClosestFacetAtLocalCoordinates(l.x, l.y, l.z, s, n, a);
				return s && Lc.TransformCoordinatesFromFloatsToRef(s.x, s.y, s.z, r, s), h
			}
			set partitioningBBoxRatio(e) {
				this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = e
			}
			_initFacetData() {
				const e = this._internalAbstractMeshDataInfo._facetData;
				e.facetNormals || (e.facetNormals = []), e.facetPositions || (e.facetPositions = []), e.facetPartitioning || (e.facetPartitioning = new Array), e.facetNb = this.getIndices().length / 3 | 0, e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10, e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01;
				for (let t = 0; t < e.facetNb; t++) e.facetNormals[t] = Lc.Zero(), e.facetPositions[t] = Lc.Zero();
				return e.facetDataEnabled = !0, this
			}
			_unFreeze() {}
			set computeBonesUsingShaders(e) {
				this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty())
			}
			set inheritVisibility(e) {
				this._internalAbstractMeshDataInfo._inheritVisibility = e
			}
			getFacetNormalToRef(e, t) {
				const i = this.getFacetLocalNormals()[e];
				return Lc.TransformNormalToRef(i, this.getWorldMatrix(), t), this
			}
			get computeBonesUsingShaders() {
				return this._internalAbstractMeshDataInfo._computeBonesUsingShaders
			}
			get pointerOverDisableMeshTesting() {
				return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting
			}
			getBoundingInfo() {
				return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1, this._updateBoundingInfo()), this._boundingInfo)
			}
			getIndices() {
				return null
			}
			getFacetsAtLocalCoordinates(e, t, i) {
				const s = this.getBoundingInfo(),
					n = this._internalAbstractMeshDataInfo._facetData,
					a = Math.floor((e - s.minimum.x * n.partitioningBBoxRatio) * n.subDiv.X * n.partitioningBBoxRatio / n.bbSize.x),
					r = Math.floor((t - s.minimum.y * n.partitioningBBoxRatio) * n.subDiv.Y * n.partitioningBBoxRatio / n.bbSize.y),
					o = Math.floor((i - s.minimum.z * n.partitioningBBoxRatio) * n.subDiv.Z * n.partitioningBBoxRatio / n.bbSize.z);
				return a < 0 || a > n.subDiv.max || r < 0 || r > n.subDiv.max || o < 0 || o > n.subDiv.max ? null : n.facetPartitioning[a + n.subDiv.max * r + n.subDiv.max * n.subDiv.max * o]
			}
			normalizeToUnitCube(e = !0, t = !1, i) {
				return super.normalizeToUnitCube(e, t, i)
			}
			_freeze() {}
			_generatePointsArray() {
				return !1
			}
			set checkCollisions(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = e
			}
			_markSubMeshesAsAttributesDirty() {
				this._markSubMeshesAsDirty((e => e.markAsAttributesDirty()))
			}
			get lightSources() {
				return this._lightSources
			}
			markAsDirty(e) {
				return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this
			}
			set applyFog(e) {
				this._internalAbstractMeshDataInfo._applyFog !== e && (this._internalAbstractMeshDataInfo._applyFog = e, this._markSubMeshesAsMiscDirty())
			}
			_updateNonUniformScalingState(e) {
				return !!super._updateNonUniformScalingState(e) && (this._markSubMeshesAsMiscDirty(), !0)
			}
			get isVisible() {
				if (!this._isVisible || !this.inheritVisibility || !this._parentNode) return this._isVisible;
				if (this._isVisible) {
					let e = this._parentNode;
					for (; e;) {
						const t = e.isVisible;
						if (void 0 !== t) return t;
						e = e.parent
					}
				}
				return this._isVisible
			}
			_rebuild(e = !1) {
				if (this.onRebuildObservable.notifyObservers(this), null !== this._occlusionQuery && (this._occlusionQuery = null), this.subMeshes) {
					for (const e of this.subMeshes) e._rebuild();
					this.resetDrawCache()
				}
			}
			updateIndices(e, t, i = !1) {
				return this
			}
			get layerMask() {
				return this._internalAbstractMeshDataInfo._layerMask
			}
			set onCollide(e) {
				this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(e)
			}
			set visibility(e) {
				if (this._internalAbstractMeshDataInfo._visibility === e) return;
				const t = this._internalAbstractMeshDataInfo._visibility;
				this._internalAbstractMeshDataInfo._visibility = e, (1 === t && 1 !== e || 1 !== t && 1 === e) && this._markSubMeshesAsDirty((e => {
					e.markAsMiscDirty(), e.markAsPrePassDirty()
				}))
			}
			set facetDepthSortFrom(e) {
				this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = e
			}
			get receiveShadows() {
				return this._internalAbstractMeshDataInfo._receiveShadows
			}
			getFacetNormal(e) {
				const t = Lc.Zero();
				return this.getFacetNormalToRef(e, t), t
			}
			_setMaterial(e) {
				this._internalAbstractMeshDataInfo._material !== e && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.ik] = void 0), this._internalAbstractMeshDataInfo._material = e, e && e.meshMap && (e.meshMap[this.ik] = this), this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && (this.resetDrawCache(), this._unBindEffect()))
			}
			set collisionRetryCount(e) {
				this._internalAbstractMeshDataInfo._collisionRetryCount = e
			}
			_getWorldMatrixDeterminant() {
				return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : super._getWorldMatrixDeterminant()
			}
			_afterComputeWorldMatrix() {
				this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0)
			}
			buildBoundingInfo(e, t, i) {
				return this._boundingInfo = new yu(e, t, i), this._boundingInfo
			}
			get hasThinInstances() {
				return !1
			}
			getTotalVertices() {
				return 0
			}
			getFacetPosition(e) {
				const t = Lc.Zero();
				return this.getFacetPositionToRef(e, t), t
			}
			_markSubMeshesAsMiscDirty() {
				this._markSubMeshesAsDirty((e => e.markAsMiscDirty()))
			}
			static get BILLBOARDMODE_Z() {
				return Jc.BILLBOARDMODE_Z
			}
			get Lk() {
				return this._internalAbstractMeshDataInfo._renderingGroupId
			}
			_shouldConvertRHS() {
				return !1
			}
			_processCollisionsForSubMeshes(e, t) {
				const i = this._scene.getCollidingSubMeshCandidates(this, e),
					s = i.length;
				for (let n = 0; n < s; n++) {
					const a = i.data[n];
					s > 1 && !a._checkCollision(e) || this._collideForSubMesh(a, t, e)
				}
				return this
			}
			static get BILLBOARDMODE_ALL() {
				return Jc.BILLBOARDMODE_ALL
			}
			_unBindEffect() {
				for (const e of this.subMeshes) e.setEffect(null)
			}
			_preActivate() {}
			transferToEffect(e) {
				const t = this._uniformBuffer;
				t.updateMatrix("world", e), t.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility), t.update()
			}
			_checkOcclusionQuery() {
				return !1
			}
		};
	jd.OCCLUSION_TYPE_NONE = 0, jd.OCCLUSION_TYPE_OPTIMISTIC = 1, jd.OCCLUSION_TYPE_STRICT = 2, jd.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0, jd.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1, jd.CULLINGSTRATEGY_STANDARD = 0, jd.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1, jd.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2, jd.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3, Gh([ec.filter(((...[e, t, i, s, n]) => !(Array.isArray(e) || Array.isArray(t) || Array.isArray(i) || Array.isArray(s) || Array.isArray(n))))], jd, "_ApplySkeleton", null), cc("BABYLON.AbstractMesh", jd);
	var Kd = class {
		getClassName() {
			return "MaterialStencilState"
		}
		constructor() {
			this.reset()
		}
		set enabled(e) {
			this._enabled = e
		}
		set opStencilFail(e) {
			this._opStencilFail = e
		}
		set funcMask(e) {
			this._funcMask = e
		}
		set mask(e) {
			this._mask = e
		}
		set funcRef(e) {
			this._funcRef = e
		}
		reset() {
			this.enabled = !1, this.mask = 255, this.func = 519, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = 7680, this.opDepthFail = 7680, this.opStencilDepthPass = 7681
		}
		get funcRef() {
			return this._funcRef
		}
		set func(e) {
			this._func = e
		}
		serialize() {
			return Xc.Serialize(this)
		}
		get func() {
			return this._func
		}
		copyTo(e) {
			Xc.Clone((() => e), this)
		}
		get funcMask() {
			return this._funcMask
		}
		get opDepthFail() {
			return this._opDepthFail
		}
		get opStencilDepthPass() {
			return this._opStencilDepthPass
		}
		set opStencilDepthPass(e) {
			this._opStencilDepthPass = e
		}
		get opStencilFail() {
			return this._opStencilFail
		}
		get enabled() {
			return this._enabled
		}
		set opDepthFail(e) {
			this._opDepthFail = e
		}
		parse(e, t, i) {
			Xc.Parse((() => this), e, t, i)
		}
		get mask() {
			return this._mask
		}
	};
	Gh([Xh()], Kd.prototype, "func", null), Gh([Xh()], Kd.prototype, "funcRef", null), Gh([Xh()], Kd.prototype, "funcMask", null), Gh([Xh()], Kd.prototype, "opStencilFail", null), Gh([Xh()], Kd.prototype, "opDepthFail", null), Gh([Xh()], Kd.prototype, "opStencilDepthPass", null), Gh([Xh()], Kd.prototype, "mask", null), Gh([Xh()], Kd.prototype, "enabled", null);
	var $d = class {
		static CompareLightsPriority(e, t) {
			return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority
		}
	};

	function Jd(e) {
		-1 === e.indexOf("vClipPlane") && e.push("vClipPlane"), -1 === e.indexOf("vClipPlane2") && e.push("vClipPlane2"), -1 === e.indexOf("vClipPlane3") && e.push("vClipPlane3"), -1 === e.indexOf("vClipPlane4") && e.push("vClipPlane4"), -1 === e.indexOf("vClipPlane5") && e.push("vClipPlane5"), -1 === e.indexOf("vClipPlane6") && e.push("vClipPlane6")
	}

	function qd(e, t, i) {
		const s = !!(e.clipPlane ?? t.clipPlane),
			n = !!(e.clipPlane2 ?? t.clipPlane2),
			a = !!(e.clipPlane3 ?? t.clipPlane3),
			r = !!(e.clipPlane4 ?? t.clipPlane4),
			o = !!(e.clipPlane5 ?? t.clipPlane5),
			l = !!(e.clipPlane6 ?? t.clipPlane6);
		s && i.push("#define CLIPPLANE"), n && i.push("#define CLIPPLANE2"), a && i.push("#define CLIPPLANE3"), r && i.push("#define CLIPPLANE4"), o && i.push("#define CLIPPLANE5"), l && i.push("#define CLIPPLANE6")
	}

	function Qd(e, t, i) {
		let s = t.clipPlane ?? i.clipPlane;
		Zd(e, "vClipPlane", s), s = t.clipPlane2 ?? i.clipPlane2, Zd(e, "vClipPlane2", s), s = t.clipPlane3 ?? i.clipPlane3, Zd(e, "vClipPlane3", s), s = t.clipPlane4 ?? i.clipPlane4, Zd(e, "vClipPlane4", s), s = t.clipPlane5 ?? i.clipPlane5, Zd(e, "vClipPlane5", s), s = t.clipPlane6 ?? i.clipPlane6, Zd(e, "vClipPlane6", s)
	}

	function Zd(e, t, i) {
		i && e.setFloat4(t, i.normal.x, i.normal.y, i.normal.z, i.d)
	}
	$d.FALLOFF_DEFAULT = 0, $d.FALLOFF_PHYSICAL = 1, $d.FALLOFF_GLTF = 2, $d.FALLOFF_STANDARD = 3, $d.LIGHTMAP_DEFAULT = 0, $d.LIGHTMAP_SPECULAR = 1, $d.LIGHTMAP_SHADOWSONLY = 2, $d.INTENSITYMODE_AUTOMATIC = 0, $d.INTENSITYMODE_LUMINOUSPOWER = 1, $d.INTENSITYMODE_LUMINOUSINTENSITY = 2, $d.INTENSITYMODE_ILLUMINANCE = 3, $d.INTENSITYMODE_LUMINANCE = 4, $d.LIGHTTYPEID_POINTLIGHT = 0, $d.LIGHTTYPEID_DIRECTIONALLIGHT = 1, $d.LIGHTTYPEID_SPOTLIGHT = 2, $d.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
	var ef = Tc.Black(),
		tf = {
			NUM_MORPH_INFLUENCERS: 0
		};

	function sf(e, t, i) {
		if (!e || e.LOGARITHMICDEPTH || e.indexOf && e.indexOf("LOGARITHMICDEPTH") >= 0) {
			const e = i.activeCamera;
			1 === e.mode && Qc.Error("Logarithmic depth is not compatible with orthographic cameras!", 20), t.setFloat("logarithmicDepthConstant", 2 / (Math.log(e.maxZ + 1) / Math.LN2))
		}
	}

	function nf(e, t, i, s = !1) {
		i && e.fogEnabled && (!t || t.applyFog) && 0 !== e.fogMode && (i.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), s ? (e.fogColor.toLinearSpaceToRef(ef, e.getEngine().useExactSrgbConversions), i.setColor3("vFogColor", ef)) : i.setColor3("vFogColor", e.fogColor))
	}

	function af(e, t, i) {
		tf.NUM_MORPH_INFLUENCERS = i, rf(e, t, tf)
	}

	function rf(e, t, i) {
		const s = i.NUM_MORPH_INFLUENCERS;
		if (s > 0 && Dc.LastCreatedEngine) {
			const n = Dc.LastCreatedEngine.getCaps().maxVertexAttribs,
				a = t.morphTargetManager;
			if (a?.isUsingTextureForTargets) return;
			const r = a && a.supportsNormals && i.NORMAL,
				o = a && a.supportsTangents && i.TANGENT,
				l = a && a.supportsUVs && i.UV1;
			for (let i = 0; i < s; i++) e.push("position" + i), r && e.push("normal" + i), o && e.push("tangent" + i), l && e.push("uv_" + i), e.length > n && Qc.Error("Cannot add more vertex attributes for mesh " + t.name)
		}
	}

	function of(e, t = !1) {
		e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"), t && (e.push("previousWorld0"), e.push("previousWorld1"), e.push("previousWorld2"), e.push("previousWorld3"))
	}

	function lf(e, t) {
		const i = e.morphTargetManager;
		e && i && t.setFloatArray("morphTargetInfluences", i.influences)
	}

	function hf(e, t) {
		t.bindToEffect(e, "Scene")
	}

	function cf(e, t, i) {
		t._needUVs = !0, t[i] = !0, e.optimizeUVAllocation && e.getTextureMatrix().isIdentityAs3x2() ? (t[i + "DIRECTUV"] = e.coordinatesIndex + 1, t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[i + "DIRECTUV"] = 0
	}

	function uf(e, t, i) {
		const s = e.getTextureMatrix();
		t.updateMatrix(i + "Matrix", s)
	}

	function mf(e, t, i) {
		i.BAKED_VERTEX_ANIMATION_TEXTURE && i.INSTANCES && e.push("bakedVertexAnimationSettingsInstanced")
	}

	function df(e, t, i) {
		var s;
		if (t && e && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) {
			const n = e.skeleton;
			if (n.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) {
				const i = n.getTransformMatrixTexture(e);
				t.setTexture("boneSampler", i), t.setFloat("boneTextureWidth", 4 * (n.bones.length + 1))
			} else {
				const a = n.getTransformMatrices(e);
				a && (t.setMatrices("mBones", a), i && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (i.previousBones[e.ik] || (i.previousBones[e.ik] = a.slice()), t.setMatrices("mPreviousBones", i.previousBones[e.ik]), s = a, i.previousBones[e.ik].set(s)))
			}
		}
	}

	function ff(e, t, i, s, n, a = !0) {
		e._bindLight(t, i, s, n, a)
	}

	function pf(e, t, i, s, n = 4) {
		const a = Math.min(t.lightSources.length, n);
		for (let n = 0; n < a; n++) {
			ff(t.lightSources[n], n, e, i, "boolean" == typeof s ? s : s.SPECULARTERM, t.receiveShadows)
		}
	}

	function _f(e, t, i, s) {
		i.NUM_BONE_INFLUENCERS > 0 && (s.addCPUSkinningFallback(0, t), e.push("matricesIndices"), e.push("matricesWeights"), i.NUM_BONE_INFLUENCERS > 4 && (e.push("matricesIndicesExtra"), e.push("matricesWeightsExtra")))
	}

	function gf(e, t) {
		(t.INSTANCES || t.THIN_INSTANCES) && of(e, !!t.PREPASS_VELOCITY), t.INSTANCESCOLOR && e.push("instanceColor")
	}

	function vf(e, t, i = 4, s = 0) {
		let n = 0;
		for (let a = 0; a < i && e["LIGHT" + a]; a++) a > 0 && (n = s + a, t.addFallback(n, "LIGHT" + a)), e.SHADOWS || (e["SHADOW" + a] && t.addFallback(s, "SHADOW" + a), e["SHADOWPCF" + a] && t.addFallback(s, "SHADOWPCF" + a), e["SHADOWPCSS" + a] && t.addFallback(s, "SHADOWPCSS" + a), e["SHADOWPOISSON" + a] && t.addFallback(s, "SHADOWPOISSON" + a), e["SHADOWESM" + a] && t.addFallback(s, "SHADOWESM" + a), e["SHADOWCLOSEESM" + a] && t.addFallback(s, "SHADOWCLOSEESM" + a));
		return n++
	}

	function yf(e, t) {
		return t.fogEnabled && e.applyFog && 0 !== t.fogMode
	}

	function Sf(e, t, i, s, n, a, r, o = !1) {
		r._areMiscDirty && (r.LOGARITHMICDEPTH = i, r.POINTSIZE = s, r.FOG = n && yf(e, t), r.NONUNIFORMSCALING = e.nonUniformScaling, r.ALPHATEST = a, r.DECAL_AFTER_DETAIL = o)
	}

	function Ef(e, t, i, s, n = 4, a = !1) {
		if (!i._areLightsDirty) return i._needNormals;
		let r = 0;
		const o = {
			needNormals: i._needNormals,
			needRebuild: !1,
			lightmapMode: !1,
			shadowEnabled: !1,
			specularEnabled: !1
		};
		if (e.lightsEnabled && !a)
			for (const a of t.lightSources)
				if (Af(e, t, a, r, i, s, o), r++, r === n) break;
		i.SPECULARTERM = o.specularEnabled, i.SHADOWS = o.shadowEnabled;
		for (let e = r; e < n; e++) void 0 !== i["LIGHT" + e] && (i["LIGHT" + e] = !1, i["HEMILIGHT" + e] = !1, i["POINTLIGHT" + e] = !1, i["DIRLIGHT" + e] = !1, i["SPOTLIGHT" + e] = !1, i["SHADOW" + e] = !1, i["SHADOWCSM" + e] = !1, i["SHADOWCSMDEBUG" + e] = !1, i["SHADOWCSMNUM_CASCADES" + e] = !1, i["SHADOWCSMUSESHADOWMAXZ" + e] = !1, i["SHADOWCSMNOBLEND" + e] = !1, i["SHADOWCSM_RIGHTHANDED" + e] = !1, i["SHADOWPCF" + e] = !1, i["SHADOWPCSS" + e] = !1, i["SHADOWPOISSON" + e] = !1, i["SHADOWESM" + e] = !1, i["SHADOWCLOSEESM" + e] = !1, i["SHADOWCUBE" + e] = !1, i["SHADOWLOWQUALITY" + e] = !1, i["SHADOWMEDIUMQUALITY" + e] = !1);
		const l = e.getEngine().getCaps();
		return void 0 === i.SHADOWFLOAT && (o.needRebuild = !0), i.SHADOWFLOAT = o.shadowEnabled && (l.textureFloatRender && l.textureFloatLinearFiltering || l.textureHalfFloatRender && l.textureHalfFloatLinearFiltering), i.LIGHTMAPEXCLUDED = o.lightmapMode, o.needRebuild && i.rebuild(), o.needNormals
	}

	function Af(e, t, i, s, n, a, r) {
		switch (r.needNormals = !0, void 0 === n["LIGHT" + s] && (r.needRebuild = !0), n["LIGHT" + s] = !0, n["SPOTLIGHT" + s] = !1, n["HEMILIGHT" + s] = !1, n["POINTLIGHT" + s] = !1, n["DIRLIGHT" + s] = !1, i.prepareLightSpecificDefines(n, s), n["LIGHT_FALLOFF_PHYSICAL" + s] = !1, n["LIGHT_FALLOFF_GLTF" + s] = !1, n["LIGHT_FALLOFF_STANDARD" + s] = !1, i.falloffType) {
			case $d.FALLOFF_GLTF:
				n["LIGHT_FALLOFF_GLTF" + s] = !0;
				break;
			case $d.FALLOFF_PHYSICAL:
				n["LIGHT_FALLOFF_PHYSICAL" + s] = !0;
				break;
			case $d.FALLOFF_STANDARD:
				n["LIGHT_FALLOFF_STANDARD" + s] = !0
		}
		if (a && !i.specular.equalsFloats(0, 0, 0) && (r.specularEnabled = !0), n["SHADOW" + s] = !1, n["SHADOWCSM" + s] = !1, n["SHADOWCSMDEBUG" + s] = !1, n["SHADOWCSMNUM_CASCADES" + s] = !1, n["SHADOWCSMUSESHADOWMAXZ" + s] = !1, n["SHADOWCSMNOBLEND" + s] = !1, n["SHADOWCSM_RIGHTHANDED" + s] = !1, n["SHADOWPCF" + s] = !1, n["SHADOWPCSS" + s] = !1, n["SHADOWPOISSON" + s] = !1, n["SHADOWESM" + s] = !1, n["SHADOWCLOSEESM" + s] = !1, n["SHADOWCUBE" + s] = !1, n["SHADOWLOWQUALITY" + s] = !1, n["SHADOWMEDIUMQUALITY" + s] = !1, t && t.receiveShadows && e.shadowsEnabled && i.shadowEnabled) {
			const t = i.getShadowGenerator(e.activeCamera) ?? i.getShadowGenerator();
			if (t) {
				const e = t.getShadowMap();
				e && e.Tk && e.Tk.length > 0 && (r.shadowEnabled = !0, t.prepareDefines(n, s))
			}
		}
		i.lightmapMode != $d.LIGHTMAP_DEFAULT ? (r.lightmapMode = !0, n["LIGHTMAPEXCLUDED" + s] = !0, n["LIGHTMAPNOSPECULAR" + s] = i.lightmapMode == $d.LIGHTMAP_SHADOWSONLY) : (n["LIGHTMAPEXCLUDED" + s] = !1, n["LIGHTMAPNOSPECULAR" + s] = !1)
	}

	function bf(e, t, i, s, n, a = null, r = !1) {
		let o = Rf(e, s);
		!1 !== a && (o = function(e, t, i) {
			let s = !1;
			const n = !!(e.clipPlane ?? t.clipPlane),
				a = !!(e.clipPlane2 ?? t.clipPlane2),
				r = !!(e.clipPlane3 ?? t.clipPlane3),
				o = !!(e.clipPlane4 ?? t.clipPlane4),
				l = !!(e.clipPlane5 ?? t.clipPlane5),
				h = !!(e.clipPlane6 ?? t.clipPlane6);
			return i.CLIPPLANE !== n && (i.CLIPPLANE = n, s = !0), i.CLIPPLANE2 !== a && (i.CLIPPLANE2 = a, s = !0), i.CLIPPLANE3 !== r && (i.CLIPPLANE3 = r, s = !0), i.CLIPPLANE4 !== o && (i.CLIPPLANE4 = o, s = !0), i.CLIPPLANE5 !== l && (i.CLIPPLANE5 = l, s = !0), i.CLIPPLANE6 !== h && (i.CLIPPLANE6 = h, s = !0), s
		}(i, e, s)), s.DEPTHPREPASS !== !t.getColorWrite() && (s.DEPTHPREPASS = !s.DEPTHPREPASS, o = !0), s.INSTANCES !== n && (s.INSTANCES = n, o = !0), s.THIN_INSTANCES !== r && (s.THIN_INSTANCES = r, o = !0), o && s.markAsUnprocessed()
	}

	function xf(e, t) {
		if (e.useBones && e.computeBonesUsingShaders && e.skeleton) {
			t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers;
			const i = void 0 !== t.BONETEXTURE;
			if (e.skeleton.isUsingTextureForMatrices && i) t.BONETEXTURE = !0;
			else {
				t.BonesPerMesh = e.skeleton.bones.length + 1, t.BONETEXTURE = !i && void 0;
				const s = e.getScene().prePassRenderer;
				if (s && s.enabled) {
					const i = -1 === s.excludedSkinnedMesh.indexOf(e);
					t.BONES_VELOCITY_ENABLED = i
				}
			}
		} else t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0, void 0 !== t.BONETEXTURE && (t.BONETEXTURE = !1)
	}

	function Mf(e, t, i, s, n = !1, a = !0, r = !0) {
		if (!t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs) return !1;
		t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent("normal"), t._needNormals && e.isVerticesDataPresent("tangent") && (t.TANGENT = !0);
		for (let i = 1; i <= 6; ++i) t["UV" + i] = !!t._needUVs && e.isVerticesDataPresent(`uv${1===i?"":i}`);
		if (i) {
			const i = e.useVertexColors && e.isVerticesDataPresent("color");
			t.VERTEXCOLOR = i, t.VERTEXALPHA = e.hasVertexAlpha && i && a
		}
		return e.isVerticesDataPresent("instanceColor") && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0), s && xf(e, t), n && function(e, t) {
			const i = e.morphTargetManager;
			i ? (t.MORPHTARGETS_UV = i.supportsUVs && t.UV1, t.MORPHTARGETS_TANGENT = i.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = i.supportsNormals && t.NORMAL, t.NUM_MORPH_INFLUENCERS = i.numMaxInfluencers || i.numInfluencers, t.MORPHTARGETS = t.NUM_MORPH_INFLUENCERS > 0, t.MORPHTARGETS_TEXTURE = i.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1, t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0)
		}(e, t), r && function(e, t) {
			const i = e.bakedVertexAnimationManager;
			t.BAKED_VERTEX_ANIMATION_TEXTURE = !(!i || !i.isEnabled)
		}(e, t), !0
	}

	function Cf(e, t) {
		if (e.activeCamera) {
			const i = t.MULTIVIEW;
			t.MULTIVIEW = null !== e.activeCamera.outputRenderTarget && e.activeCamera.outputRenderTarget.getViewCount() > 1, t.MULTIVIEW != i && t.markAsUnprocessed()
		}
	}

	function Tf(e, t, i) {
		const s = t.ORDER_INDEPENDENT_TRANSPARENCY,
			n = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
		t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && i, t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering, s === t.ORDER_INDEPENDENT_TRANSPARENCY && n === t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS || t.markAsUnprocessed()
	}

	function wf(e, t, i) {
		const s = t.PREPASS;
		if (!t._arePrePassDirty) return;
		const n = [{
			type: 1,
			define: "PREPASS_POSITION",
			index: "PREPASS_POSITION_INDEX"
		}, {
			type: 2,
			define: "PREPASS_VELOCITY",
			index: "PREPASS_VELOCITY_INDEX"
		}, {
			type: 3,
			define: "PREPASS_REFLECTIVITY",
			index: "PREPASS_REFLECTIVITY_INDEX"
		}, {
			type: 0,
			define: "PREPASS_IRRADIANCE",
			index: "PREPASS_IRRADIANCE_INDEX"
		}, {
			type: 7,
			define: "PREPASS_ALBEDO_SQRT",
			index: "PREPASS_ALBEDO_SQRT_INDEX"
		}, {
			type: 5,
			define: "PREPASS_DEPTH",
			index: "PREPASS_DEPTH_INDEX"
		}, {
			type: 6,
			define: "PREPASS_NORMAL",
			index: "PREPASS_NORMAL_INDEX"
		}];
		if (e.prePassRenderer && e.prePassRenderer.enabled && i) {
			t.PREPASS = !0, t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount, t.PREPASS_NORMAL_WORLDSPACE = e.prePassRenderer.generateNormalsInWorldSpace;
			for (let i = 0; i < n.length; i++) {
				const s = e.prePassRenderer.getIndex(n[i].type); - 1 !== s ? (t[n[i].define] = !0, t[n[i].index] = s) : t[n[i].define] = !1
			}
		} else {
			t.PREPASS = !1;
			for (let e = 0; e < n.length; e++) t[n[e].define] = !1
		}
		t.PREPASS != s && (t.markAsUnprocessed(), t.markAsImageProcessingDirty())
	}

	function Rf(e, t) {
		let i = !1;
		if (e.activeCamera) {
			const s = t.CAMERA_ORTHOGRAPHIC ? 1 : 0,
				n = t.CAMERA_PERSPECTIVE ? 1 : 0,
				a = 1 === e.activeCamera.mode ? 1 : 0,
				r = 0 === e.activeCamera.mode ? 1 : 0;
			(s ^ a || n ^ r) && (t.CAMERA_ORTHOGRAPHIC = 1 === a, t.CAMERA_PERSPECTIVE = 1 === r, i = !0)
		}
		return i
	}

	function Nf(e, t, i, s, n = null, a = !1) {
		n && n.push("Light" + e), a || (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e), i.push("shadowTexture" + e), i.push("depthTexture" + e), t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e), s && (i.push("projectionLightTexture" + e), t.push("textureProjectionMatrix" + e)))
	}

	function If(e, t, i, s = 4) {
		let n, a = null;
		if (e.uniformsNames) {
			const r = e;
			n = r.uniformsNames, a = r.uniformBuffersNames, t = r.samplers, i = r.defines, s = r.maxSimultaneousLights || 0
		} else n = e, t || (t = []);
		for (let e = 0; e < s && i["LIGHT" + e]; e++) Nf(e, n, t, i["PROJECTEDLIGHTTEXTURE" + e], a);
		i.NUM_MORPH_INFLUENCERS && (n.push("morphTargetInfluences"), n.push("morphTargetCount")), i.BAKED_VERTEX_ANIMATION_TEXTURE && (n.push("bakedVertexAnimationSettings"), n.push("bakedVertexAnimationTextureSizeInverted"), n.push("bakedVertexAnimationTime"), t.push("bakedVertexAnimationTexture"))
	}
	var Pf = class e {
		get hasRenderTargetTextures() {
			return this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._eventInfo.hasRenderTargetTextures
		}
		_preBind(t, i = null) {
			const s = this._scene.getEngine(),
				n = (null == i ? this.sideOrientation : i) === e.ClockWiseSideOrientation;
			return s.enableEffect(t || this._getDrawWrapper()), s.setState(this.backFaceCulling, this.zOffset, !1, n, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits), n
		}
		set backFaceCulling(t) {
			this._backFaceCulling !== t && (this._backFaceCulling = t, this.markAsDirty(e.TextureDirtyFlag))
		}
		_serializePlugins(e) {
			if (e.plugins = {}, this.pluginManager)
				for (const t of this.pluginManager._plugins) e.plugins[t.getClassName()] = t.serialize()
		}
		get wireframe() {
			switch (this._fillMode) {
				case e.WireFrameFillMode:
				case e.LineListDrawMode:
				case e.LineLoopDrawMode:
				case e.LineStripDrawMode:
					return !0
			}
			return this._scene.forceWireframe
		}
		_markAllSubMeshesAsTexturesDirty() {
			this._markAllSubMeshesAsDirty(e._TextureDirtyCallBack)
		}
		get onEffectCreatedObservable() {
			return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new kc), this._onEffectCreatedObservable
		}
		set needDepthPrePass(e) {
			this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0))
		}
		get onBindObservable() {
			return this._onBindObservable || (this._onBindObservable = new kc), this._onBindObservable
		}
		getBindedMeshes() {
			if (this.meshMap) {
				const e = [];
				for (const t in this.meshMap) {
					const i = this.meshMap[t];
					i && e.push(i)
				}
				return e
			}
			return this._scene.meshes.filter((e => e.material === this))
		}
		unfreeze() {
			this.markDirty(), this.checkReadyOnlyOnce = !1
		}
		needAlphaBlending() {
			return !this._disableAlphaBlending && this.alpha < 1
		}
		clone(e) {
			return null
		}
		set blockDirtyMechanism(e) {
			this._blockDirtyMechanism !== e && (this._blockDirtyMechanism = e, e || this.markDirty())
		}
		_markScenePrePassDirty() {
			if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) return;
			const e = this.getScene().enablePrePassRenderer();
			e && e.markAsDirty()
		}
		_getEffectiveOrientation(e) {
			return null !== this.sideOrientation ? this.sideOrientation : e.sideOrientation
		}
		getClassName() {
			return "Material"
		}
		_markAllSubMeshesAsLightsDirty() {
			this._markAllSubMeshesAsDirty(e._LightsDirtyCallBack)
		}
		unbind() {
			if (this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), 0 !== this.depthFunction) {
				this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState)
			}
			if (this.disableDepthWrite) {
				this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState)
			}
			if (this.disableColorWrite) {
				this._scene.getEngine().setColorWrite(this._cachedColorWriteState)
			}
		}
		bindView(e) {
			this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix())
		}
		constructor(t, i, s) {
			this.shadowDepthWrapper = null, this.allowShaderHotSwapping = !0, this._shaderLanguage = 0, this.metadata = null, this.reservedDataStore = null, this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this._alpha = 1, this._backFaceCulling = !0, this._cullBackFaces = !0, this._blockDirtyMechanism = !1, this.sideOrientation = null, this.onCompiled = null, this.onError = null, this.getRenderTargetTextures = null, this.doNotSerialize = !1, this._storeEffectOnSubMeshes = !1, this.animations = null, this.onDisposeObservable = new kc, this._onDisposeObserver = null, this._onUnBindObservable = null, this._onBindObserver = null, this._alphaMode = 2, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.disableColorWrite = !1, this.forceDepthWrite = !1, this.depthFunction = 0, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this.zOffsetUnits = 0, this.stencil = new Kd, this._useUBO = !1, this._fillMode = e.TriangleFillMode, this._cachedDepthWriteState = !1, this._cachedColorWriteState = !1, this._cachedDepthFunctionState = 0, this._indexInSceneMaterialArray = -1, this.meshMap = null, this._parentContainer = null, this._uniformBufferLayoutBuilt = !1, this._eventInfo = {}, this._callbackPluginEventGeneric = () => {}, this._callbackPluginEventIsReadyForSubMesh = () => {}, this._callbackPluginEventPrepareDefines = () => {}, this._callbackPluginEventPrepareDefinesBeforeAttributes = () => {}, this._callbackPluginEventHardBindForSubMesh = () => {}, this._callbackPluginEventBindForSubMesh = () => {}, this._callbackPluginEventHasRenderTargetTextures = () => {}, this._callbackPluginEventFillRenderTargetTextures = () => {}, this._forceAlphaTest = !1, this._transparencyMode = null, this.name = t;
			const n = i || Dc.LastCreatedScene;
			n && (this._scene = n, this._dirtyCallbacks = {}, this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this), this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this), this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this), this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this), this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this), this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this), this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this), this.id = t || dd.RandomId(), this.ik = this._scene.getUniqueId(), this._materialContext = this._scene.getEngine().createMaterialContext(), this._drawWrapper = new Au(this._scene.getEngine(), !1), this._drawWrapper.materialContext = this._materialContext, this._uniformBuffer = new Bd(this._scene.getEngine(), void 0, void 0, t), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, s || this._scene.addMaterial(this), this._scene.useMaterialMeshMap && (this.meshMap = {}), e.OnEventObservable.notifyObservers(this, 1))
		}
		get shaderLanguage() {
			return this._shaderLanguage
		}
		releaseVertexArrayObject(e, t) {
			const i = e.geometry;
			if (i)
				if (this._storeEffectOnSubMeshes) {
					if (e.subMeshes)
						for (const s of e.subMeshes) i._releaseVertexArrayObject(s.effect), t && s.effect && s.effect.dispose()
				} else i._releaseVertexArrayObject(this._drawWrapper.effect)
		}
		_markAllSubMeshesAsFresnelDirty() {
			this._markAllSubMeshesAsDirty(e._FresnelDirtyCallBack)
		}
		getActiveTextures() {
			return this._eventInfo.activeTextures = [], this._callbackPluginEventGeneric(512, this._eventInfo), this._eventInfo.activeTextures
		}
		bindViewProjection(e) {
			this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.setMatrix("projection", this.getScene().getProjectionMatrix()))
		}
		atomicMaterialsUpdate(e) {
			this.blockDirtyMechanism = !0;
			try {
				e(this)
			} finally {
				this.blockDirtyMechanism = !1
			}
		}
		_checkScenePerformancePriority() {
			if (0 !== this._scene.performancePriority) {
				this.checkReadyOnlyOnce = !0;
				const e = this._scene.onScenePerformancePriorityChangedObservable.addOnce((() => {
					this.checkReadyOnlyOnce = !1
				}));
				this.onDisposeObservable.add((() => {
					this._scene.onScenePerformancePriorityChangedObservable.remove(e)
				}))
			}
		}
		set transparencyMode(t) {
			this._transparencyMode !== t && (this._transparencyMode = t, this._forceAlphaTest = t === e.MATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty())
		}
		getAlphaTestTexture() {
			return null
		}
		set wireframe(t) {
			this.fillMode = t ? e.WireFrameFillMode : e.TriangleFillMode
		}
		_markAllSubMeshesAsFresnelAndMiscDirty() {
			this._markAllSubMeshesAsDirty(e._FresnelAndMiscDirtyCallBack)
		}
		_shouldTurnAlphaTestOn(e) {
			return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting()
		}
		get useLogarithmicDepth() {
			return this._useLogarithmicDepth
		}
		get alpha() {
			return this._alpha
		}
		forceCompilationAsync(e, t) {
			return new Promise(((i, s) => {
				this.forceCompilation(e, (() => {
					i()
				}), t, (e => {
					s(e)
				}))
			}))
		}
		get isPrePassCapable() {
			return !1
		}
		_markAllSubMeshesAsTexturesAndMiscDirty() {
			this._markAllSubMeshesAsDirty(e._TextureAndMiscDirtyCallBack)
		}
		get backFaceCulling() {
			return this._backFaceCulling
		}
		get alphaMode() {
			return this._alphaMode
		}
		needAlphaTesting() {
			return !!this._forceAlphaTest
		}
		bindOnlyWorldMatrix(e) {}
		set alpha(t) {
			if (this._alpha === t) return;
			const i = this._alpha;
			this._alpha = t, 1 !== i && 1 !== t || this.markAsDirty(e.MiscDirtyFlag + e.PrePassDirtyFlag)
		}
		bind(e, t) {}
		toString(e) {
			return "Name: " + this.name
		}
		set fillMode(t) {
			this._fillMode !== t && (this._fillMode = t, this.markAsDirty(e.MiscDirtyFlag))
		}
		set alphaMode(t) {
			this._alphaMode !== t && (this._alphaMode = t, this.markAsDirty(e.TextureDirtyFlag))
		}
		_markAllSubMeshesAsMiscDirty() {
			this._markAllSubMeshesAsDirty(e._MiscDirtyCallBack)
		}
		dispose(e, t, i) {
			const s = this.getScene();
			if (s.stopAnimation(this), s.freeProcessedMaterials(), s.removeMaterial(this), this._eventInfo.forceDisposeTextures = t, this._callbackPluginEventGeneric(2, this._eventInfo), this._parentContainer) {
				const e = this._parentContainer.materials.indexOf(this);
				e > -1 && this._parentContainer.materials.splice(e, 1), this._parentContainer = null
			}
			if (!0 !== i)
				if (this.meshMap)
					for (const t in this.meshMap) {
						const i = this.meshMap[t];
						i && (i.material = null, this.releaseVertexArrayObject(i, e))
					} else {
						const t = s.meshes;
						for (const i of t) i.material !== this || i.wk || (i.material = null, this.releaseVertexArrayObject(i, e))
					}
			this._uniformBuffer.dispose(), e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(), this._drawWrapper.effect = null), this.metadata = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear(), this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear(), this._eventInfo && (this._eventInfo = {})
		}
		markAsDirty(t) {
			this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism || (e._DirtyCallbackArray.length = 0, t & e.TextureDirtyFlag && e._DirtyCallbackArray.push(e._TextureDirtyCallBack), t & e.LightDirtyFlag && e._DirtyCallbackArray.push(e._LightsDirtyCallBack), t & e.FresnelDirtyFlag && e._DirtyCallbackArray.push(e._FresnelDirtyCallBack), t & e.AttributesDirtyFlag && e._DirtyCallbackArray.push(e._AttributeDirtyCallBack), t & e.MiscDirtyFlag && e._DirtyCallbackArray.push(e._MiscDirtyCallBack), t & e.PrePassDirtyFlag && e._DirtyCallbackArray.push(e._PrePassDirtyCallBack), e._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(e._RunDirtyCallBacks), this.getScene().resetCachedMaterial())
		}
		getAnimatables() {
			return this._eventInfo.animatables = [], this._callbackPluginEventGeneric(256, this._eventInfo), this._eventInfo.animatables
		}
		get onUnBindObservable() {
			return this._onUnBindObservable || (this._onUnBindObservable = new kc), this._onUnBindObservable
		}
		_markAllSubMeshesAsImageProcessingDirty() {
			this._markAllSubMeshesAsDirty(e._ImageProcessingDirtyCallBack)
		}
		get fogEnabled() {
			return this._fogEnabled
		}
		bindForSubMesh(e, t, i) {
			const s = i._drawWrapper;
			this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), s._forceRebindOnNextCall = !1
		}
		get pointsCloud() {
			switch (this._fillMode) {
				case e.PointFillMode:
				case e.PointListDrawMode:
					return !0
			}
			return this._scene.forcePointsCloud
		}
		set onDispose(e) {
			this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
		}
		_markAllSubMeshesAsDirty(e) {
			if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) return;
			const t = this.getScene().meshes;
			for (const i of t)
				if (i.subMeshes)
					for (const t of i.subMeshes)
						if (t.getMaterial(!1) === this)
							for (const i of t._drawWrappers) i && i.defines && i.defines.markAllAsDirty && this._materialContext === i.materialContext && e(i.defines)
		}
		serialize() {
			const e = Xc.Serialize(this);
			return e.stencil = this.stencil.serialize(), e.ik = this.ik, this._serializePlugins(e), e
		}
		set onBind(e) {
			this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e)
		}
		get isFrozen() {
			return this.checkReadyOnlyOnce
		}
		get _isMaterial() {
			return !0
		}
		_markAllSubMeshesAsAttributesDirty() {
			this._markAllSubMeshesAsDirty(e._AttributeDirtyCallBack)
		}
		bindEyePosition(e, t) {
			this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t)
		}
		_afterBind(e, t = null, i) {
			if (this._scene._cachedMaterial = this, this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1, hf(t, this.getScene().getSceneUniformBuffer()), this._scene.finalizeSceneUbo()), this._scene._cachedVisibility = e ? e.visibility : 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) {
				const e = this._scene.getEngine();
				this._cachedDepthWriteState = e.getDepthWrite(), e.setDepthWrite(!1)
			}
			if (this.disableColorWrite) {
				const e = this._scene.getEngine();
				this._cachedColorWriteState = e.getColorWrite(), e.setColorWrite(!1)
			}
			if (0 !== this.depthFunction) {
				const e = this._scene.getEngine();
				this._cachedDepthFunctionState = e.getDepthFunction() || 0, e.setDepthFunction(this.depthFunction)
			}
		}
		get cullBackFaces() {
			return this._cullBackFaces
		}
		_markAllSubMeshesAsPrePassDirty() {
			this._markAllSubMeshesAsDirty(e._MiscDirtyCallBack)
		}
		buildUniformLayout() {
			const e = this._uniformBuffer;
			this._eventInfo.ubo = e, this._callbackPluginEventGeneric(8, this._eventInfo), e.create(), this._uniformBufferLayoutBuilt = !0
		}
		resetDrawCache() {
			const e = this.getScene().meshes;
			for (const t of e)
				if (t.subMeshes)
					for (const e of t.subMeshes) e.getMaterial() === this && e.resetDrawCache()
		}
		_markAllSubMeshesAsAllDirty() {
			this._markAllSubMeshesAsDirty(e._AllDirtyCallBack)
		}
		get blockDirtyMechanism() {
			return this._blockDirtyMechanism
		}
		_setDrawWrapper(e) {
			this._drawWrapper = e
		}
		get needDepthPrePass() {
			return this._needDepthPrePass
		}
		set pointsCloud(t) {
			this.fillMode = t ? e.PointFillMode : e.TriangleFillMode
		}
		set cullBackFaces(t) {
			this._cullBackFaces !== t && (this._cullBackFaces = t, this.markAsDirty(e.TextureDirtyFlag))
		}
		hasTexture(e) {
			return this._eventInfo.hasTexture = !1, this._eventInfo.texture = e, this._callbackPluginEventGeneric(1024, this._eventInfo), this._eventInfo.hasTexture
		}
		setPrePassRenderer(e) {
			return !1
		}
		static _ParsePlugins(e, t, i, s) {
			if (e.plugins)
				for (const n in e.plugins) {
					const a = e.plugins[n];
					let r = t.pluginManager?.getPlugin(a.name);
					if (!r) {
						const e = dd.Instantiate("BABYLON." + n);
						e && (r = new e(t))
					}
					r?.parse(a, i, s)
				}
		}
		getEffect() {
			return this._drawWrapper.effect
		}
		forceCompilation(e, t, i, s) {
			const n = {
					clipPlane: !1,
					useInstances: !1,
					...i
				},
				a = this.getScene(),
				r = this.allowShaderHotSwapping;
			this.allowShaderHotSwapping = !1;
			const o = () => {
				if (!this._scene || !this._scene.getEngine()) return;
				const i = a.clipPlane;
				if (n.clipPlane && (a.clipPlane = new vd(0, 0, 0, 1)), this._storeEffectOnSubMeshes) {
					let i = !0,
						a = null;
					if (e.subMeshes) {
						const t = new bu(0, 0, 0, 0, 0, e, void 0, !1, !1);
						t.materialDefines && (t.materialDefines._renderId = -1), this.isReadyForSubMesh(e, t, n.useInstances) || (t.effect && t.effect.getCompilationError() && t.effect.allFallbacksProcessed() ? a = t.effect.getCompilationError() : (i = !1, setTimeout(o, 16)))
					}
					i && (this.allowShaderHotSwapping = r, a && s && s(a), t && t(this))
				} else this.isReady() ? (this.allowShaderHotSwapping = r, t && t(this)) : setTimeout(o, 16);
				n.clipPlane && (a.clipPlane = i)
			};
			o()
		}
		freeze() {
			this.markDirty(), this.checkReadyOnlyOnce = !0
		}
		get canRenderToMRT() {
			return !1
		}
		isReadyForSubMesh(e, t, i) {
			const s = t.materialDefines;
			return !!s && (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = s, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), this._eventInfo.isReadyForSubMesh)
		}
		get _disableAlphaBlending() {
			return this._transparencyMode === e.MATERIAL_OPAQUE || this._transparencyMode === e.MATERIAL_ALPHATEST
		}
		getScene() {
			return this._scene
		}
		get fillMode() {
			return this._fillMode
		}
		static Parse(e, t, i) {
			if (e.customType) {
				if ("BABYLON.PBRMaterial" === e.customType && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial", !BABYLON.LegacyPBRMaterial)) return Qc.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."), null
			} else e.customType = "BABYLON.StandardMaterial";
			const s = dd.Instantiate(e.customType).Parse(e, t, i);
			return s._loadedUniqueId = e.ik, s
		}
		isReady(e, t) {
			return !0
		}
		markDirty(t = !1) {
			const i = this.getScene().meshes;
			for (const e of i)
				if (e.subMeshes)
					for (const i of e.subMeshes)
						if (i.getMaterial() === this)
							for (const e of i._drawWrappers) e && this._materialContext === e.materialContext && (e._wasPreviouslyReady = !1, e._wasPreviouslyUsingInstances = null, e._forceRebindOnNextCall = t);
			t && this.markAsDirty(e.AllDirtyFlag)
		}
		get transparencyMode() {
			return this._transparencyMode
		}
		_getDrawWrapper() {
			return this._drawWrapper
		}
		set fogEnabled(t) {
			this._fogEnabled !== t && (this._fogEnabled = t, this.markAsDirty(e.MiscDirtyFlag))
		}
		needAlphaBlendingForMesh(e) {
			return e.visibility < 1 || !this._disableAlphaBlending && (e.hasVertexAlpha || this.needAlphaBlending())
		}
		set useLogarithmicDepth(e) {
			const t = this.getScene().getEngine().getCaps().fragmentDepthSupported;
			e && !t && Qc.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."), this._useLogarithmicDepth = e && t, this._markAllSubMeshesAsMiscDirty()
		}
		_clonePlugins(t, i) {
			const s = {};
			if (this._serializePlugins(s), e._ParsePlugins(s, t, this._scene, i), this.pluginManager)
				for (const e of this.pluginManager._plugins) {
					const i = t.pluginManager.getPlugin(e.name);
					i && e.copyTo(i)
				}
		}
	};
	Pf.TriangleFillMode = 0, Pf.WireFrameFillMode = 1, Pf.PointFillMode = 2, Pf.PointListDrawMode = 3, Pf.LineListDrawMode = 4, Pf.LineLoopDrawMode = 5, Pf.LineStripDrawMode = 6, Pf.TriangleStripDrawMode = 7, Pf.TriangleFanDrawMode = 8, Pf.ClockWiseSideOrientation = 0, Pf.CounterClockWiseSideOrientation = 1, Pf.TextureDirtyFlag = 1, Pf.LightDirtyFlag = 2, Pf.FresnelDirtyFlag = 4, Pf.AttributesDirtyFlag = 8, Pf.MiscDirtyFlag = 16, Pf.PrePassDirtyFlag = 32, Pf.AllDirtyFlag = 63, Pf.MATERIAL_OPAQUE = 0, Pf.MATERIAL_ALPHATEST = 1, Pf.MATERIAL_ALPHABLEND = 2, Pf.MATERIAL_ALPHATESTANDBLEND = 3, Pf.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0, Pf.MATERIAL_NORMALBLENDMETHOD_RNM = 1, Pf.OnEventObservable = new kc, Pf._AllDirtyCallBack = e => e.markAllAsDirty(), Pf._ImageProcessingDirtyCallBack = e => e.markAsImageProcessingDirty(), Pf._TextureDirtyCallBack = e => e.markAsTexturesDirty(), Pf._FresnelDirtyCallBack = e => e.markAsFresnelDirty(), Pf._MiscDirtyCallBack = e => e.markAsMiscDirty(), Pf._PrePassDirtyCallBack = e => e.markAsPrePassDirty(), Pf._LightsDirtyCallBack = e => e.markAsLightDirty(), Pf._AttributeDirtyCallBack = e => e.markAsAttributesDirty(), Pf._FresnelAndMiscDirtyCallBack = e => {
		Pf._FresnelDirtyCallBack(e), Pf._MiscDirtyCallBack(e)
	}, Pf._TextureAndMiscDirtyCallBack = e => {
		Pf._TextureDirtyCallBack(e), Pf._MiscDirtyCallBack(e)
	}, Pf._DirtyCallbackArray = [], Pf._RunDirtyCallBacks = e => {
		for (const t of Pf._DirtyCallbackArray) t(e)
	}, Gh([Xh()], Pf.prototype, "id", void 0), Gh([Xh()], Pf.prototype, "uniqueId", void 0), Gh([Xh()], Pf.prototype, "name", void 0), Gh([Xh()], Pf.prototype, "metadata", void 0), Gh([Xh()], Pf.prototype, "checkReadyOnEveryCall", void 0), Gh([Xh()], Pf.prototype, "checkReadyOnlyOnce", void 0), Gh([Xh()], Pf.prototype, "state", void 0), Gh([Xh("alpha")], Pf.prototype, "_alpha", void 0), Gh([Xh("backFaceCulling")], Pf.prototype, "_backFaceCulling", void 0), Gh([Xh("cullBackFaces")], Pf.prototype, "_cullBackFaces", void 0), Gh([Xh()], Pf.prototype, "sideOrientation", void 0), Gh([Xh("alphaMode")], Pf.prototype, "_alphaMode", void 0), Gh([Xh()], Pf.prototype, "_needDepthPrePass", void 0), Gh([Xh()], Pf.prototype, "disableDepthWrite", void 0), Gh([Xh()], Pf.prototype, "disableColorWrite", void 0), Gh([Xh()], Pf.prototype, "forceDepthWrite", void 0), Gh([Xh()], Pf.prototype, "depthFunction", void 0), Gh([Xh()], Pf.prototype, "separateCullingPass", void 0), Gh([Xh("fogEnabled")], Pf.prototype, "_fogEnabled", void 0), Gh([Xh()], Pf.prototype, "pointSize", void 0), Gh([Xh()], Pf.prototype, "zOffset", void 0), Gh([Xh()], Pf.prototype, "zOffsetUnits", void 0), Gh([Xh()], Pf.prototype, "pointsCloud", null), Gh([Xh()], Pf.prototype, "fillMode", null), Gh([Xh()], Pf.prototype, "useLogarithmicDepth", null), Gh([Xh()], Pf.prototype, "transparencyMode", null);
	var kf = class e extends Pf {
		getSubMaterial(e) {
			return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e]
		}
		getChildren() {
			return this.subMaterials
		}
		constructor(e, t) {
			super(e, t, !0), this._waitingSubMaterialsUniqueIds = [], this.getScene().addMultiMaterial(this), this.subMaterials = [], this._storeEffectOnSubMeshes = !0
		}
		getClassName() {
			return "MultiMaterial"
		}
		_hookArray(e) {
			const t = e.push;
			e.push = (...i) => {
				const s = t.apply(e, i);
				return this._markAllSubMeshesAsTexturesDirty(), s
			};
			const i = e.splice;
			e.splice = (t, s) => {
				const n = i.apply(e, [t, s]);
				return this._markAllSubMeshesAsTexturesDirty(), n
			}
		}
		hasTexture(e) {
			if (super.hasTexture(e)) return !0;
			for (let t = 0; t < this.subMaterials.length; t++)
				if (this.subMaterials[t]?.hasTexture(e)) return !0;
			return !1
		}
		get subMaterials() {
			return this._subMaterials
		}
		static ParseMultiMaterial(t, i) {
			const s = new e(t.name, i);
			return s.id = t.id, s._loadedUniqueId = t.ik, nc && nc.AddTagsTo(s, t.tags), t.materialsUniqueIds ? s._waitingSubMaterialsUniqueIds = t.materialsUniqueIds : t.materials.forEach((e => s.subMaterials.push(i.getLastMaterialById(e)))), s
		}
		clone(t, i) {
			const s = new e(t, this.getScene());
			for (let e = 0; e < this.subMaterials.length; e++) {
				let n = null;
				const a = this.subMaterials[e];
				n = i && a ? a.clone(t + "-" + a.name) : this.subMaterials[e], s.subMaterials.push(n)
			}
			return s
		}
		isReadyForSubMesh(e, t, i) {
			for (let s = 0; s < this.subMaterials.length; s++) {
				const n = this.subMaterials[s];
				if (n) {
					if (n._storeEffectOnSubMeshes) {
						if (!n.isReadyForSubMesh(e, t, i)) return !1;
						continue
					}
					if (!n.isReady(e)) return !1
				}
			}
			return !0
		}
		set subMaterials(e) {
			this._subMaterials = e, this._hookArray(e)
		}
		dispose(e, t, i) {
			const s = this.getScene();
			if (!s) return;
			if (i)
				for (let i = 0; i < this.subMaterials.length; i++) {
					const s = this.subMaterials[i];
					s && s.dispose(e, t)
				}
			const n = s.multiMaterials.indexOf(this);
			n >= 0 && s.multiMaterials.splice(n, 1), super.dispose(e, t)
		}
		serialize() {
			const e = {};
			e.name = this.name, e.id = this.id, e.ik = this.ik, nc && (e.tags = nc.GetTags(this)), e.materialsUniqueIds = [], e.materials = [];
			for (let t = 0; t < this.subMaterials.length; t++) {
				const i = this.subMaterials[t];
				i ? (e.materialsUniqueIds.push(i.ik), e.materials.push(i.id)) : (e.materialsUniqueIds.push(null), e.materials.push(null))
			}
			return e
		}
		getActiveTextures() {
			return super.getActiveTextures().concat(...this.subMaterials.map((e => e ? e.getActiveTextures() : [])))
		}
	};
	cc("BABYLON.MultiMaterial", kf);
	var Df = class {};
	Df.NAME_EFFECTLAYER = "EffectLayer", Df.NAME_LAYER = "Layer", Df.NAME_LENSFLARESYSTEM = "LensFlareSystem", Df.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer", Df.NAME_PARTICLESYSTEM = "ParticleSystem", Df.NAME_GAMEPAD = "Gamepad", Df.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue", Df.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer", Df.NAME_PREPASSRENDERER = "PrePassRenderer", Df.NAME_DEPTHRENDERER = "DepthRenderer", Df.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer", Df.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager", Df.NAME_SPRITE = "Sprite", Df.NAME_SUBSURFACE = "SubSurface", Df.NAME_OUTLINERENDERER = "Outline", Df.NAME_PROCEDURALTEXTURE = "ProceduralTexture", Df.NAME_SHADOWGENERATOR = "ShadowGenerator", Df.NAME_OCTREE = "Octree", Df.NAME_PHYSICSENGINE = "PhysicsEngine", Df.NAME_AUDIO = "Audio", Df.NAME_FLUIDRENDERER = "FluidRenderer", Df.STEP_ISREADYFORMESH_EFFECTLAYER = 0, Df.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0, Df.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0, Df.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0, Df.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1, Df.STEP_BEFORECAMERADRAW_PREPASS = 0, Df.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1, Df.STEP_BEFORECAMERADRAW_LAYER = 2, Df.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0, Df.STEP_BEFORERENDERTARGETDRAW_LAYER = 1, Df.STEP_BEFORERENDERINGMESH_PREPASS = 0, Df.STEP_BEFORERENDERINGMESH_OUTLINE = 1, Df.STEP_AFTERRENDERINGMESH_PREPASS = 0, Df.STEP_AFTERRENDERINGMESH_OUTLINE = 1, Df.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0, Df.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1, Df.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0, Df.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1, Df.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0, Df.STEP_BEFORECLEAR_PREPASS = 1, Df.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0, Df.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0, Df.STEP_AFTERRENDERTARGETDRAW_LAYER = 1, Df.STEP_AFTERCAMERADRAW_PREPASS = 0, Df.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1, Df.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2, Df.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3, Df.STEP_AFTERCAMERADRAW_LAYER = 4, Df.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5, Df.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0, Df.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0, Df.STEP_AFTERRENDER_AUDIO = 0, Df.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0, Df.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1, Df.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2, Df.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3, Df.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0, Df.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1, Df.STEP_POINTERMOVE_SPRITE = 0, Df.STEP_POINTERDOWN_SPRITE = 0, Df.STEP_POINTERUP_SPRITE = 0;
	var Of = class e extends Array {
			static Create() {
				return Object.create(e.prototype)
			}
			constructor(e) {
				super(...e)
			}
			clear() {
				this.length = 0
			}
			registerStep(e, t, i) {
				let s = 0,
					n = Number.MAX_VALUE;
				for (; s < this.length; s++) {
					if (n = this[s].index, e < n) break
				}
				this.splice(s, 0, {
					index: e,
					component: t,
					action: i.bind(t)
				})
			}
		},
		Ff = class {
			constructor(e, t) {
				this.distanceOrScreenCoverage = e, this.mesh = t
			}
		},
		Lf = class {},
		Bf = class {
			constructor() {
				this.visibleInstances = {}, this.batchCache = new Gf, this.batchCacheReplacementModeInFrozenMode = new Gf, this.instancesBufferSize = 2048
			}
		},
		Gf = class {
			constructor() {
				this.mustReturn = !1, this.visibleInstances = new Array, this.renderSelf = [], this.hardwareInstancedRendering = []
			}
		},
		Hf = class {
			constructor() {
				this.instancesCount = 0, this.matrixBuffer = null, this.previousMatrixBuffer = null, this.matrixBufferSize = 512, this.matrixData = null, this.boundingVectors = [], this.worldMatrices = null
			}
		},
		Uf = class {
			constructor() {
				this._areNormalsFrozen = !1, this._source = null, this.meshMap = null, this._preActivateId = -1, this._LODLevels = new Array, this._useLODScreenCoverage = !1, this._effectiveMaterial = null, this._forcedInstanceCount = 0, this._overrideRenderingFillMode = null
			}
		},
		Vf = class e extends jd {
			registerAfterRender(e) {
				return this.onAfterRenderObservable.add(e), this
			}
			dispose(e, t = !1) {
				this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0);
				const i = this._internalMeshDataInfo;
				if (i._onBeforeDrawObservable && i._onBeforeDrawObservable.clear(), i._onBeforeBindObservable && i._onBeforeBindObservable.clear(), i._onBeforeRenderObservable && i._onBeforeRenderObservable.clear(), i._onAfterRenderObservable && i._onAfterRenderObservable.clear(), i._onBetweenPassObservable && i._onBetweenPassObservable.clear(), this._scene.useClonedMeshMap) {
					if (i.meshMap)
						for (const e in i.meshMap) {
							const t = i.meshMap[e];
							t && (t._internalMeshDataInfo._source = null, i.meshMap[e] = void 0)
						}
					i._source && i._source._internalMeshDataInfo.meshMap && (i._source._internalMeshDataInfo.meshMap[this.ik] = void 0)
				} else {
					const e = this.getScene().meshes;
					for (const t of e) {
						const e = t;
						e._internalMeshDataInfo && e._internalMeshDataInfo._source && e._internalMeshDataInfo._source === this && (e._internalMeshDataInfo._source = null)
					}
				}
				i._source = null, this._instanceDataStorage.visibleInstances = {}, this._disposeInstanceSpecificData(), this._disposeThinInstanceSpecificData(), this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), super.dispose(e, t)
			}
			removeVerticesData(e) {
				this._geometry && this._geometry.removeVerticesData(e)
			}
			updateIndices(e, t, i = !1) {
				return this._geometry ? (this._geometry.updateIndices(e, t, i), this) : this
			}
			static Ak(e, t, i, s, n, a, r, o, l) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			static gk(e, t, i, s, n, a) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_draw(e, t, i) {
				if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this;
				this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
				const s = this.getScene().getEngine();
				return this._unIndexed || t == Pf.PointFillMode ? s.drawArraysType(t, e.verticesStart, e.verticesCount, this.forcedInstanceCount || i) : t == Pf.WireFrameFillMode ? s.drawElementsType(t, 0, e._linesIndexCount, this.forcedInstanceCount || i) : s.drawElementsType(t, e.indexStart, e.indexCount, this.forcedInstanceCount || i), this
			}
			static dk(e, t, i, s, n) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_renderWithThinInstances(e, t, i, s) {
				const n = this._thinInstanceDataStorage?.instancesCount ?? 0;
				this.getScene()._activeIndices.addCount(e.indexCount * n, !1), s._currentDrawContext && (s._currentDrawContext.useInstancing = !0), this._bind(e, i, t), this._draw(e, t, n), this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, n) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)), s.unbindInstanceAttributes()
			}
			get onBeforeDrawObservable() {
				return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new kc), this._internalMeshDataInfo._onBeforeDrawObservable
			}
			isVerticesDataPresent(e, t) {
				return this._geometry ? !t && void 0 !== this._userInstancedBuffersStorage?.vertexBuffers[e] || this._geometry.isVerticesDataPresent(e) : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e)
			}
			unfreezeNormals() {
				return this._internalMeshDataInfo._areNormalsFrozen = !1, this
			}
			_getInstancesRenderList(e, t = !1) {
				if (this._instanceDataStorage.isFrozen) {
					if (t) return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e] = !1, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e] = !0, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
					if (this._instanceDataStorage.previousBatch) return this._instanceDataStorage.previousBatch
				}
				const i = this.getScene(),
					s = i._isInIntermediateRendering(),
					n = s ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances,
					a = this._instanceDataStorage.batchCache;
				if (a.mustReturn = !1, a.renderSelf[e] = t || !n && this.isEnabled() && this.isVisible, a.visibleInstances[e] = null, this._instanceDataStorage.visibleInstances && !t) {
					const t = this._instanceDataStorage.visibleInstances,
						n = i.getRenderId(),
						r = s ? t.intermediateDefaultRenderId : t.defaultRenderId;
					a.visibleInstances[e] = t[n], !a.visibleInstances[e] && r && (a.visibleInstances[e] = t[r])
				}
				return a.hardwareInstancedRendering[e] = !t && this._instanceDataStorage.hardwareInstancedRendering && null !== a.visibleInstances[e] && void 0 !== a.visibleInstances[e], this._instanceDataStorage.previousBatch = a, a
			}
			set useLODScreenCoverage(e) {
				this._internalMeshDataInfo._useLODScreenCoverage = e, this._sortLODLevels()
			}
			optimizeIndices(e) {
				const t = this.getIndices(),
					i = this.getVerticesData(eu.PositionKind);
				if (!i || !t) return this;
				const s = [];
				for (let e = 0; e < i.length; e += 3) s.push(Lc.FromArray(i, e));
				const n = [];
				return fd.SyncAsyncForLoop(s.length, 40, (e => {
					const t = s.length - 1 - e,
						i = s[t];
					for (let e = 0; e < t; ++e) {
						const a = s[e];
						if (i.equals(a)) {
							n[t] = e;
							break
						}
					}
				}), (() => {
					for (let e = 0; e < t.length; ++e) t[e] = n[t[e]] || t[e];
					const i = this.subMeshes.slice(0);
					this.setIndices(t), this.subMeshes = i, e && e(this)
				})), this
			}
			getTotalVertices() {
				return null === this._geometry || void 0 === this._geometry ? 0 : this._geometry.getTotalVertices()
			}
			registerBeforeRender(e) {
				return this.onBeforeRenderObservable.add(e), this
			}
			get onBeforeRenderObservable() {
				return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new kc), this._internalMeshDataInfo._onBeforeRenderObservable
			}
			get onAfterRenderObservable() {
				return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new kc), this._internalMeshDataInfo._onAfterRenderObservable
			}
			static _instancedMeshFactory(e, t) {
				throw ic("InstancedMesh")
			}
			setPositionsForCPUSkinning() {
				const e = this._internalMeshDataInfo;
				if (!e._sourcePositions) {
					const t = this.getVerticesData(eu.PositionKind);
					if (!t) return e._sourcePositions;
					e._sourcePositions = new Float32Array(t), this.isVertexBufferUpdatable(eu.PositionKind) || this.setVerticesData(eu.PositionKind, t, !0)
				}
				return e._sourcePositions
			}
			makeGeometryUnique() {
				if (!this._geometry) return this;
				if (1 === this._geometry.meshes.length) return this;
				const e = this._geometry,
					t = this._geometry.copy(bd.RandomId());
				return e.releaseForMesh(this, !0), t.applyToMesh(this), this
			}
			static _k(e, t, i, s, n) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			isInFrustum(e) {
				return 2 !== this.delayLoadState && (!!super.isInFrustum(e) && (this._checkDelayState(), !0))
			}
			_resetPointsArrayCache() {
				return this._geometry && this._geometry._resetPointsArrayCache(), this
			}
			_afterComputeWorldMatrix() {
				super._afterComputeWorldMatrix(), this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1))
			}
			static * _MergeMeshesCoroutine(t, i = !0, s, n, a, r, o) {
				if (0 === (t = t.filter(Boolean)).length) return null;
				let l;
				if (!s) {
					let e = 0;
					for (l = 0; l < t.length; l++)
						if (e += t[l].getTotalVertices(), e >= 65536) return Qc.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), null
				}
				r && (a = !1);
				const h = new Array,
					c = new Array,
					u = new Array,
					m = t[0].sideOrientation;
				for (l = 0; l < t.length; l++) {
					const e = t[l];
					if (e.isAnInstance) return Qc.Warn("Cannot merge instance meshes."), null;
					if (m !== e.sideOrientation) return Qc.Warn("Cannot merge meshes with different sideOrientation values."), null;
					if (a && u.push(e.getTotalIndices()), r)
						if (e.material) {
							const t = e.material;
							if (t instanceof kf) {
								for (let e = 0; e < t.subMaterials.length; e++) h.indexOf(t.subMaterials[e]) < 0 && h.push(t.subMaterials[e]);
								for (let i = 0; i < e.subMeshes.length; i++) c.push(h.indexOf(t.subMaterials[e.subMeshes[i].materialIndex])), u.push(e.subMeshes[i].indexCount)
							} else {
								h.indexOf(t) < 0 && h.push(t);
								for (let i = 0; i < e.subMeshes.length; i++) c.push(h.indexOf(t)), u.push(e.subMeshes[i].indexCount)
							}
						} else
							for (let t = 0; t < e.subMeshes.length; t++) c.push(0), u.push(e.subMeshes[t].indexCount)
				}
				const d = t[0],
					f = e => {
						const t = e.computeWorldMatrix(!0);
						return {
							vertexData: Mu.ExtractFromMesh(e, !1, !1),
							transform: t
						}
					},
					{
						vertexData: p,
						transform: _
					} = f(d);
				o && (yield);
				const g = new Array(t.length - 1);
				for (let e = 1; e < t.length; e++) g[e - 1] = f(t[e]), o && (yield);
				const v = p._mergeCoroutine(_, g, s, o, !i);
				let y = v.next();
				for (; !y.done;) o && (yield), y = v.next();
				const S = y.value;
				n || (n = new e(d.name + "_merged", d.getScene()));
				const E = S._applyToCoroutine(n, void 0, o);
				let A = E.next();
				for (; !A.done;) o && (yield), A = E.next();
				if (n.checkCollisions = d.checkCollisions, n.sideOrientation = d.sideOrientation, i)
					for (l = 0; l < t.length; l++) t[l].dispose();
				if (a || r) {
					n.releaseSubMeshes(), l = 0;
					let e = 0;
					for (; l < u.length;) bu.CreateFromIndices(0, e, u[l], n, void 0, !1), e += u[l], l++;
					for (const e of n.subMeshes) e.refreshBoundingInfo();
					n.computeWorldMatrix(!0)
				}
				if (r) {
					const e = new kf(d.name + "_merged", d.getScene());
					e.subMaterials = h;
					for (let e = 0; e < n.subMeshes.length; e++) n.subMeshes[e].materialIndex = c[e];
					n.material = e
				} else n.material = d.material;
				return n
			}
			get forceWorldMatrixInstancedBufferUpdate() {
				return this._instanceDataStorage.forceMatrixUpdates
			}
			set material(e) {
				e && (this.material && null === this.material.sideOrientation || this._internalAbstractMeshDataInfo._sideOrientationHint) && (e.sideOrientation = null), this._setMaterial(e)
			}
			static CreateGroundFromHeightMap(e, t, i, s, n, a, r, o, l, h, c) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_invalidateInstanceVertexArrayObject() {}
			get isUnIndexed() {
				return this._unIndexed
			}
			get material() {
				return this._internalAbstractMeshDataInfo._material
			}
			_unBindEffect() {
				super._unBindEffect();
				for (const e of this.instances) e._unBindEffect()
			}
			createInstance(t) {
				return e._instancedMeshFactory(t, this)
			}
			_rebuild(e = !1) {
				if (this._instanceDataStorage.instancesBuffer && (e && this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null), this._userInstancedBuffersStorage) {
					for (const t in this._userInstancedBuffersStorage.vertexBuffers) {
						const i = this._userInstancedBuffersStorage.vertexBuffers[t];
						i && (e && i.dispose(), this._userInstancedBuffersStorage.vertexBuffers[t] = null)
					}
					this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {})
				}
				this._internalMeshDataInfo._effectiveMaterial = null, super._rebuild(e)
			}
			static Parse(t, i, s) {
				let n;
				if (n = t.type && "LinesMesh" === t.type ? e._LinesMeshParser(t, i) : t.type && "GroundMesh" === t.type ? e._GroundMeshParser(t, i) : t.type && "GoldbergMesh" === t.type ? e._GoldbergMeshParser(t, i) : t.type && "GreasedLineMesh" === t.type ? e._GreasedLineMeshParser(t, i) : t.type && "TrailMesh" === t.type ? e._TrailMeshParser(t, i) : new e(t.name, i), n.id = t.id, n._waitingParsedUniqueId = t.ik, nc && nc.AddTagsTo(n, t.tags), n.position = Lc.FromArray(t.position), void 0 !== t.metadata && (n.metadata = t.metadata), t.rotationQuaternion ? n.rotationQuaternion = Gc.FromArray(t.rotationQuaternion) : t.rotation && (n.rotation = Lc.FromArray(t.rotation)), n.scaling = Lc.FromArray(t.scaling), t.localMatrix ? n.setPreTransformMatrix(Hc.FromArray(t.localMatrix)) : t.pivotMatrix && n.setPivotMatrix(Hc.FromArray(t.pivotMatrix)), n.setEnabled(t.isEnabled), n.isVisible = t.isVisible, n.infiniteDistance = t.infiniteDistance, n.alwaysSelectAsActiveMesh = !!t.alwaysSelectAsActiveMesh, n.showBoundingBox = t.showBoundingBox, n.showSubMeshesBoundingBox = t.showSubMeshesBoundingBox, void 0 !== t.applyFog && (n.applyFog = t.applyFog), void 0 !== t.pickable && (n.isPickable = t.pickable), void 0 !== t.alphaIndex && (n.alphaIndex = t.alphaIndex), n.receiveShadows = t.receiveShadows, void 0 !== t.billboardMode && (n.billboardMode = t.billboardMode), void 0 !== t.visibility && (n.visibility = t.visibility), n.checkCollisions = t.checkCollisions, n.doNotSyncBoundingInfo = !!t.doNotSyncBoundingInfo, t.ellipsoid && (n.ellipsoid = Lc.FromArray(t.ellipsoid)), t.ellipsoidOffset && (n.ellipsoidOffset = Lc.FromArray(t.ellipsoidOffset)), null != t.overrideMaterialSideOrientation && (n.sideOrientation = t.overrideMaterialSideOrientation), void 0 !== t.sideOrientation && (n.sideOrientation = t.sideOrientation), void 0 !== t.isBlocker && (n.isBlocker = t.isBlocker), n._shouldGenerateFlatShading = t.useFlatShading, t.freezeWorldMatrix && (n._waitingData.freezeWorldMatrix = t.freezeWorldMatrix), void 0 !== t.parentId && (n._waitingParentId = t.parentId), void 0 !== t.parentInstanceIndex && (n._waitingParentInstanceIndex = t.parentInstanceIndex), void 0 !== t.actions && (n._waitingData.actions = t.actions), void 0 !== t.overlayAlpha && (n.overlayAlpha = t.overlayAlpha), void 0 !== t.overlayColor && (n.overlayColor = Tc.FromArray(t.overlayColor)), void 0 !== t.renderOverlay && (n.renderOverlay = t.renderOverlay), n.isUnIndexed = !!t.isUnIndexed, n.hasVertexAlpha = t.hasVertexAlpha, t.delayLoadingFile ? (n.delayLoadState = 4, n.delayLoadingFile = s + t.delayLoadingFile, n.buildBoundingInfo(Lc.FromArray(t.boundingBoxMinimum), Lc.FromArray(t.boundingBoxMaximum)), t._binaryInfo && (n._binaryInfo = t._binaryInfo), n._delayInfo = [], t.hasUVs && n._delayInfo.push(eu.UVKind), t.hasUVs2 && n._delayInfo.push(eu.UV2Kind), t.hasUVs3 && n._delayInfo.push(eu.UV3Kind), t.hasUVs4 && n._delayInfo.push(eu.UV4Kind), t.hasUVs5 && n._delayInfo.push(eu.UV5Kind), t.hasUVs6 && n._delayInfo.push(eu.UV6Kind), t.hasColors && n._delayInfo.push(eu.ColorKind), t.hasMatricesIndices && n._delayInfo.push(eu.MatricesIndicesKind), t.hasMatricesWeights && n._delayInfo.push(eu.MatricesWeightsKind), n._delayLoadingFunction = bd._ImportGeometry, Ed.ForceFullSceneLoadingForIncremental && n._checkDelayState()) : bd._ImportGeometry(t, n), t.materialUniqueId ? n._waitingMaterialId = t.materialUniqueId : t.materialId && (n._waitingMaterialId = t.materialId), t.morphTargetManagerId > -1 && (n.morphTargetManager = i.getMorphTargetManagerById(t.morphTargetManagerId)), void 0 !== t.skeletonId && null !== t.skeletonId && (n.skeleton = i.getLastSkeletonById(t.skeletonId), t.numBoneInfluencers && (n.numBoneInfluencers = t.numBoneInfluencers)), t.animations) {
					for (let e = 0; e < t.animations.length; e++) {
						const i = t.animations[e],
							s = uc("BABYLON.Animation");
						s && n.animations.push(s.Parse(i))
					}
					jc.ParseAnimationRanges(n, t, i)
				}
				if (t.autoAnimate && i.beginAnimation(n, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), t.layerMask && !isNaN(t.layerMask) ? n.layerMask = Math.abs(parseInt(t.layerMask)) : n.layerMask = 268435455, t.physicsImpostor && (n.physicsImpostor = e._PhysicsImpostorParser(i, n, t)), t.lodMeshIds && (n._waitingData.lods = {
						ids: t.lodMeshIds,
						distances: t.lodDistances ? t.lodDistances : null,
						coverages: t.lodCoverages ? t.lodCoverages : null
					}), t.instances)
					for (let s = 0; s < t.instances.length; s++) {
						const a = t.instances[s],
							r = n.createInstance(a.name);
						if (a.id && (r.id = a.id), nc && (a.tags ? nc.AddTagsTo(r, a.tags) : nc.AddTagsTo(r, t.tags)), r.position = Lc.FromArray(a.position), void 0 !== a.metadata && (r.metadata = a.metadata), void 0 !== a.parentId && (r._waitingParentId = a.parentId), void 0 !== a.parentInstanceIndex && (r._waitingParentInstanceIndex = a.parentInstanceIndex), void 0 !== a.isEnabled && null !== a.isEnabled && r.setEnabled(a.isEnabled), void 0 !== a.isVisible && null !== a.isVisible && (r.isVisible = a.isVisible), void 0 !== a.isPickable && null !== a.isPickable && (r.isPickable = a.isPickable), a.rotationQuaternion ? r.rotationQuaternion = Gc.FromArray(a.rotationQuaternion) : a.rotation && (r.rotation = Lc.FromArray(a.rotation)), r.scaling = Lc.FromArray(a.scaling), null != a.checkCollisions && null != a.checkCollisions && (r.checkCollisions = a.checkCollisions), null != a.pickable && null != a.pickable && (r.isPickable = a.pickable), null != a.showBoundingBox && null != a.showBoundingBox && (r.showBoundingBox = a.showBoundingBox), null != a.showSubMeshesBoundingBox && null != a.showSubMeshesBoundingBox && (r.showSubMeshesBoundingBox = a.showSubMeshesBoundingBox), null != a.alphaIndex && null != a.showSubMeshesBoundingBox && (r.alphaIndex = a.alphaIndex), a.physicsImpostor && (r.physicsImpostor = e._PhysicsImpostorParser(i, r, a)), void 0 !== a.actions && (r._waitingData.actions = a.actions), a.animations) {
							for (let e = 0; e < a.animations.length; e++) {
								const t = a.animations[e],
									i = uc("BABYLON.Animation");
								i && r.animations.push(i.Parse(t))
							}
							jc.ParseAnimationRanges(r, a, i), a.autoAnimate && i.beginAnimation(r, a.autoAnimateFrom, a.autoAnimateTo, a.autoAnimateLoop, a.autoAnimateSpeed || 1)
						}
					}
				if (t.thinInstances) {
					const e = t.thinInstances;
					if (n.thinInstanceEnablePicking = !!e.enablePicking, e.matrixData ? (n.thinInstanceSetBuffer("matrix", new Float32Array(e.matrixData), 16, !1), n._thinInstanceDataStorage.matrixBufferSize = e.matrixBufferSize, n._thinInstanceDataStorage.instancesCount = e.instancesCount) : n._thinInstanceDataStorage.matrixBufferSize = e.matrixBufferSize, t.thinInstances.userThinInstance) {
						const e = t.thinInstances.userThinInstance;
						for (const t in e.data) n.thinInstanceSetBuffer(t, new Float32Array(e.data[t]), e.strides[t], !1), n._userThinInstanceBuffersStorage.sizes[t] = e.sizes[t]
					}
				}
				return n
			}
			clone(t = "", i = null, s, n = !0) {
				return new e(t, this.getScene(), i, this, s, n)
			}
			static Center(t) {
				const i = t instanceof Array ? e.MinMax(t) : t;
				return Lc.Center(i.min, i.max)
			}
			toString(e) {
				let t = super.toString(e);
				if (t += ", n vertices: " + this.getTotalVertices(), t += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations)
					for (let i = 0; i < this.animations.length; i++) t += ", animation[0]: " + this.animations[i].toString(e);
				if (e)
					if (this._geometry) {
						const e = this.getIndices(),
							i = this.getVerticesData(eu.PositionKind);
						i && e && (t += ", flat shading: " + (i.length / 3 === e.length ? "YES" : "NO"))
					} else t += ", flat shading: UNKNOWN";
				return t
			}
			get cloneMeshMap() {
				return this._internalMeshDataInfo.meshMap
			}
			static ExtrudeShapeCustom(e, t, i, s, n, a, r, o, l, h, c, u) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			static MergeMeshesAsync(t, i = !0, s, n, a, r) {
				return o = e._MergeMeshesCoroutine(t, i, s, n, a, r, !0), l = function(e = 25) {
					let t;
					return (i, s, n) => {
						const a = performance.now();
						void 0 === t || a - t > e ? (t = a, setTimeout((() => {
							tu(i, s, n)
						}), 0)) : tu(i, s, n)
					}
				}(), new Promise(((e, t) => {
					iu(o, l, e, t, h)
				}));
				var o, l, h
			}
			static CreateDashedLines(e, t, i, s, n, a, r, o) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			unregisterAfterRender(e) {
				return this.onAfterRenderObservable.removeCallback(e), this
			}
			convertToFlatShadedMesh() {
				return this._convertToUnIndexedMesh(!0)
			}
			isReady(e = !1, t = !1) {
				if (2 === this.delayLoadState) return !1;
				if (!super.isReady(e)) return !1;
				if (!this.subMeshes || 0 === this.subMeshes.length) return !0;
				if (!e) return !0;
				const i = this.getEngine(),
					s = this.getScene(),
					n = t || i.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
				this.computeWorldMatrix();
				const a = this.material || s.defaultMaterial;
				if (a)
					if (a._storeEffectOnSubMeshes)
						for (const e of this.subMeshes) {
							const t = e.getMaterial();
							if (t)
								if (t._storeEffectOnSubMeshes) {
									if (!t.isReadyForSubMesh(this, e, n)) return !1
								} else if (!t.isReady(this, n)) return !1
						} else if (!a.isReady(this, n)) return !1;
				const r = i.currentRenderPassId;
				for (const e of this.lightSources) {
					const t = e.getShadowGenerators();
					if (!t) continue;
					const s = t.values();
					for (let e = s.next(); !0 !== e.done; e = s.next()) {
						const t = e.value;
						if (t && (!t.getShadowMap()?.Tk || t.getShadowMap()?.Tk && -1 !== t.getShadowMap()?.Tk?.indexOf(this))) {
							const e = t.getShadowMap().renderPassIds ?? [i.currentRenderPassId];
							for (let s = 0; s < e.length; ++s) {
								i.currentRenderPassId = e[s];
								for (const e of this.subMeshes)
									if (!t.isReady(e, n, e.getMaterial()?.needAlphaBlendingForMesh(this) ?? !1)) return i.currentRenderPassId = r, !1
							}
							i.currentRenderPassId = r
						}
					}
				}
				for (const e of this._internalMeshDataInfo._LODLevels)
					if (e.mesh && !e.mesh.isReady(n)) return !1;
				return !0
			}
			_disposeThinInstanceSpecificData() {}
			_shouldConvertRHS() {
				return this._scene.useRightHandedSystem && this.sideOrientation === Pf.CounterClockWiseSideOrientation
			}
			convertToUnIndexedMesh() {
				return this._convertToUnIndexedMesh()
			}
			get sideOrientation() {
				return this._internalMeshDataInfo._sideOrientation
			}
			renderWithRenderPassId(e, t, i, s, n = !0) {
				const a = this._scene.getEngine(),
					r = a.currentRenderPassId;
				if (void 0 !== e && (a.currentRenderPassId = e), s)(!n || n && s.isInFrustum(this._scene._frustumPlanes)) && this.render(s, !!t, i);
				else
					for (let e = 0; e < this.subMeshes.length; e++) {
						const s = this.subMeshes[e];
						(!n || n && s.isInFrustum(this._scene._frustumPlanes)) && this.render(s, !!t, i)
					}
				return void 0 !== e && (a.currentRenderPassId = r), this
			}
			_renderWithInstances(t, i, s, n, a) {
				const r = s.visibleInstances[t._id],
					o = r ? r.length : 0,
					l = this._instanceDataStorage,
					h = l.instancesBufferSize;
				let c = l.instancesBuffer,
					u = l.instancesPreviousBuffer;
				const m = 16 * (o + 1) * 4;
				for (; l.instancesBufferSize < m;) l.instancesBufferSize *= 2;
				l.instancesData && h == l.instancesBufferSize || (l.instancesData = new Float32Array(l.instancesBufferSize / 4)), (this._scene.needsPreviousWorldMatrices && !l.instancesPreviousData || h != l.instancesBufferSize) && (l.instancesPreviousData = new Float32Array(l.instancesBufferSize / 4));
				let d = 0,
					f = 0;
				const p = s.renderSelf[t._id],
					_ = !c || h !== l.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !l.instancesPreviousBuffer;
				if (this._instanceDataStorage.manualUpdate || l.isFrozen && !_) f = (p ? 1 : 0) + o;
				else {
					const i = this.getWorldMatrix();
					if (p && (this._scene.needsPreviousWorldMatrices && (l.masterMeshPreviousWorldMatrix ? (l.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData, d), l.masterMeshPreviousWorldMatrix.copyFrom(i)) : (l.masterMeshPreviousWorldMatrix = i.clone(), l.masterMeshPreviousWorldMatrix.copyToArray(l.instancesPreviousData, d))), i.copyToArray(l.instancesData, d), d += 16, f++), r) {
						if (e.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && t.getMaterial()?.needAlphaBlendingForMesh(t.getRenderingMesh())) {
							const e = this._scene.activeCamera.globalPosition;
							for (let t = 0; t < r.length; t++) {
								const i = r[t];
								i._distanceToCamera = Lc.Distance(i.getBoundingInfo().boundingSphere.centerWorld, e)
							}
							r.sort(((e, t) => e._distanceToCamera > t._distanceToCamera ? -1 : e._distanceToCamera < t._distanceToCamera ? 1 : 0))
						}
						for (let e = 0; e < r.length; e++) {
							const t = r[e],
								i = t.getWorldMatrix();
							i.copyToArray(l.instancesData, d), this._scene.needsPreviousWorldMatrices && (t._previousWorldMatrix ? (t._previousWorldMatrix.copyToArray(l.instancesPreviousData, d), t._previousWorldMatrix.copyFrom(i)) : (t._previousWorldMatrix = i.clone(), t._previousWorldMatrix.copyToArray(l.instancesPreviousData, d))), d += 16, f++
						}
					}
				}
				return _ ? (c && c.dispose(), u && u.dispose(), c = new Zc(a, l.instancesData, !0, 16, !1, !0), l.instancesBuffer = c, this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
					data: {},
					vertexBuffers: {},
					strides: {},
					sizes: {},
					vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
				}), this._userInstancedBuffersStorage.vertexBuffers.world0 = c.createVertexBuffer("world0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.world1 = c.createVertexBuffer("world1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.world2 = c.createVertexBuffer("world2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.world3 = c.createVertexBuffer("world3", 12, 4), this._scene.needsPreviousWorldMatrices && (u = new Zc(a, l.instancesPreviousData, !0, 16, !1, !0), l.instancesPreviousBuffer = u, this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = u.createVertexBuffer("previousWorld0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = u.createVertexBuffer("previousWorld1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = u.createVertexBuffer("previousWorld2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = u.createVertexBuffer("previousWorld3", 12, 4)), this._invalidateInstanceVertexArrayObject()) : this._instanceDataStorage.isFrozen && !this._instanceDataStorage.forceMatrixUpdates || (c.updateDirectly(l.instancesData, 0, f), !this._scene.needsPreviousWorldMatrices || this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.previousManualUpdate || u.updateDirectly(l.instancesPreviousData, 0, f)), this._processInstancedBuffers(r, p), this.getScene()._activeIndices.addCount(t.indexCount * f, !1), a._currentDrawContext && (a._currentDrawContext.useInstancing = !0), this._bind(t, n, i), this._draw(t, i, f), !this._scene.needsPreviousWorldMatrices || _ || !this._instanceDataStorage.manualUpdate || this._instanceDataStorage.isFrozen && !this._instanceDataStorage.forceMatrixUpdates || this._instanceDataStorage.previousManualUpdate || u.updateDirectly(l.instancesData, 0, f), a.unbindInstanceAttributes(), this
			}
			unregisterBeforeRender(e) {
				return this.onBeforeRenderObservable.removeCallback(e), this
			}
			bakeCurrentTransformIntoVertices(e = !0) {
				return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.resetLocalMatrix(e), this
			}
			get overrideRenderingFillMode() {
				return this._internalMeshDataInfo._overrideRenderingFillMode
			}
			_disposeInstanceSpecificData() {}
			getAnimatables() {
				const e = [];
				return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e
			}
			getVerticesDataKinds(e) {
				if (!this._geometry) {
					const e = [];
					return this._delayInfo && this._delayInfo.forEach((function(t) {
						e.push(t)
					})), e
				}
				const t = this._geometry.getVerticesDataKinds();
				if (!e && this._userInstancedBuffersStorage)
					for (const e in this._userInstancedBuffersStorage.vertexBuffers) - 1 === t.indexOf(e) && t.push(e);
				return t
			}
			static CreateTube(e, t, i, s, n, a, r, o, l, h) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			static CreateDecal(e, t, i, s, n, a) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			static ExtrudePolygon(e, t, i, s, n, a, r, o) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			get hasThinInstances() {
				return (this.forcedInstanceCount || this._thinInstanceDataStorage.instancesCount || 0) > 0
			}
			set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e) {
				this._instanceDataStorage.previousManualUpdate = e
			}
			isVertexBufferUpdatable(e, t) {
				if (!this._geometry) return !!this._delayInfo && -1 !== this._delayInfo.indexOf(e);
				if (!t) {
					const t = this._userInstancedBuffersStorage?.vertexBuffers[e];
					if (t) return t.isUpdatable()
				}
				return this._geometry.isVertexBufferUpdatable(e)
			}
			getLOD(e, t) {
				const i = this._internalMeshDataInfo;
				if (!i._LODLevels || 0 === i._LODLevels.length) return this;
				const s = t || this.getBoundingInfo().boundingSphere,
					n = e.mode === Sd.ORTHOGRAPHIC_CAMERA ? e.minZ : s.centerWorld.subtract(e.globalPosition).length();
				let a = n,
					r = 1;
				if (i._useLODScreenCoverage) {
					const t = e.screenArea;
					let i = s.radiusWorld * e.minZ / n;
					i = i * i * Math.PI, a = i / t, r = -1
				}
				if (r * i._LODLevels[i._LODLevels.length - 1].distanceOrScreenCoverage > r * a) return this.onLODLevelSelection && this.onLODLevelSelection(a, this, this), this;
				for (let e = 0; e < i._LODLevels.length; e++) {
					const t = i._LODLevels[e];
					if (r * t.distanceOrScreenCoverage < r * a) {
						if (t.mesh) {
							if (4 === t.mesh.delayLoadState) return t.mesh._checkDelayState(), this;
							if (2 === t.mesh.delayLoadState) return this;
							t.mesh._preActivate(), t.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)
						}
						return this.onLODLevelSelection && this.onLODLevelSelection(a, this, t.mesh), t.mesh
					}
				}
				return this.onLODLevelSelection && this.onLODLevelSelection(a, this, this), this
			}
			static Rk(e, t, i, s, n, a) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			static CreateIcoSphere(e, t, i) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			markVerticesDataAsUpdatable(e, t = !0) {
				const i = this.getVertexBuffer(e);
				i && i.isUpdatable() !== t && this.setVerticesData(e, this.getVerticesData(e), t)
			}
			static CreateCapsule(e, t, i) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			toLeftHanded() {
				return this._geometry ? (this._geometry.toLeftHanded(), this) : this
			}
			static CreateTorus(e, t, i, s, n, a, r) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			set onBeforeDraw(e) {
				this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e)
			}
			static Nk(e, t, i, s, n, a, r, o, l) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_postActivate() {
				this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer), this.edgesRenderer.customInstances.push(this.getWorldMatrix()))
			}
			getLODLevelAtDistance(e) {
				const t = this._internalMeshDataInfo;
				for (let i = 0; i < t._LODLevels.length; i++) {
					const s = t._LODLevels[i];
					if (s.distanceOrScreenCoverage === e) return s.mesh
				}
				return null
			}
			_createGlobalSubMesh(e) {
				const t = this.getTotalVertices();
				if (!t || !this.getIndices()) return null;
				if (this.subMeshes && this.subMeshes.length > 0) {
					const i = this.getIndices();
					if (!i) return null;
					const s = i.length;
					let n = !1;
					if (e) n = !0;
					else
						for (const e of this.subMeshes) {
							if (e.indexStart + e.indexCount > s) {
								n = !0;
								break
							}
							if (e.verticesStart + e.verticesCount > t) {
								n = !0;
								break
							}
						}
					if (!n) return this.subMeshes[0]
				}
				return this.releaseSubMeshes(), new bu(0, 0, t, 0, this.getTotalIndices(), this)
			}
			get onBeforeBindObservable() {
				return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new kc), this._internalMeshDataInfo._onBeforeBindObservable
			}
			_bind(e, t, i, s = !0) {
				if (!this._geometry) return this;
				const n = this.getScene().getEngine();
				let a;
				if (this._unIndexed) a = null;
				else switch (this._getRenderingFillMode(i)) {
					case Pf.PointFillMode:
						a = null;
						break;
					case Pf.WireFrameFillMode:
						a = e._getLinesIndexBuffer(this.getIndices(), n);
						break;
					default:
					case Pf.TriangleFillMode:
						a = this._geometry.getIndexBuffer()
				}
				return this._bindDirect(t, a, s)
			}
			removeInstance(e) {
				const t = e._indexInSourceMeshInstanceArray;
				if (-1 != t) {
					if (t !== this.instances.length - 1) {
						const e = this.instances[this.instances.length - 1];
						this.instances[t] = e, e._indexInSourceMeshInstanceArray = t
					}
					e._indexInSourceMeshInstanceArray = -1, this.instances.pop()
				}
			}
			_getFlattenedNormals(e, t) {
				const i = new Float32Array(3 * e.length);
				let s = 0;
				const n = this.sideOrientation === (this._scene.useRightHandedSystem ? 1 : 0);
				for (let a = 0; a < e.length; a += 3) {
					const r = Lc.FromArray(t, 3 * e[a]),
						o = Lc.FromArray(t, 3 * e[a + 1]),
						l = Lc.FromArray(t, 3 * e[a + 2]),
						h = r.subtract(o),
						c = l.subtract(o),
						u = Lc.Normalize(Lc.Cross(h, c));
					n && u.scaleInPlace(-1);
					for (let e = 0; e < 3; e++) i[s++] = u.x, i[s++] = u.y, i[s++] = u.z
				}
				return i
			}
			static ExtendToGoldberg(e) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			forceSharedVertices() {
				const e = Mu.ExtractFromMesh(this),
					t = e.uvs,
					i = e.indices,
					s = e.positions,
					n = e.colors,
					a = e.matricesIndices,
					r = e.matricesWeights,
					o = e.matricesIndicesExtra,
					l = e.matricesWeightsExtra;
				if (void 0 === i || void 0 === s || null === i || null === s) Qc.Warn("VertexData contains empty entries");
				else {
					const h = new Array,
						c = new Array,
						u = new Array,
						m = new Array,
						d = new Array,
						f = new Array,
						p = new Array,
						_ = new Array;
					let g = new Array,
						v = 0;
					const y = {};
					let S, E;
					for (let e = 0; e < i.length; e += 3) {
						E = [i[e], i[e + 1], i[e + 2]], g = [];
						for (let e = 0; e < 3; e++) {
							g[e] = "";
							for (let t = 0; t < 3; t++) Math.abs(s[3 * E[e] + t]) < 1e-8 && (s[3 * E[e] + t] = 0), g[e] += s[3 * E[e] + t] + "|"
						}
						if (g[0] != g[1] && g[0] != g[2] && g[1] != g[2])
							for (let e = 0; e < 3; e++) {
								if (S = y[g[e]], void 0 === S) {
									y[g[e]] = v, S = v++;
									for (let t = 0; t < 3; t++) h.push(s[3 * E[e] + t]);
									if (null != n)
										for (let t = 0; t < 4; t++) m.push(n[4 * E[e] + t]);
									if (null != t)
										for (let i = 0; i < 2; i++) u.push(t[2 * E[e] + i]);
									if (null != a)
										for (let t = 0; t < 4; t++) d.push(a[4 * E[e] + t]);
									if (null != r)
										for (let t = 0; t < 4; t++) f.push(r[4 * E[e] + t]);
									if (null != o)
										for (let t = 0; t < 4; t++) p.push(o[4 * E[e] + t]);
									if (null != l)
										for (let t = 0; t < 4; t++) _.push(l[4 * E[e] + t])
								}
								c.push(S)
							}
					}
					const A = new Array;
					Mu.ComputeNormals(h, c, A), e.positions = h, e.indices = c, e.normals = A, null != t && (e.uvs = u), null != n && (e.colors = m), null != a && (e.matricesIndices = d), null != r && (e.matricesWeights = f), null != o && (e.matricesIndicesExtra = p), null != r && (e.matricesWeightsExtra = _), e.applyToMesh(this, this.isVertexBufferUpdatable(eu.PositionKind))
				}
			}
			get worldMatrixInstancedBuffer() {
				return this._instanceDataStorage.instancesData
			}
			_syncGeometryWithMorphTargetManager() {
				if (!this.geometry) return;
				this._markSubMeshesAsAttributesDirty();
				const e = this._internalAbstractMeshDataInfo._morphTargetManager;
				if (e && e.vertexCount) {
					if (e.vertexCount !== this.getTotalVertices()) return Qc.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."), void(this.morphTargetManager = null);
					if (e.isUsingTextureForTargets) return;
					for (let t = 0; t < e.numInfluencers; t++) {
						const i = e.getActiveTarget(t),
							s = i.getPositions();
						if (!s) return void Qc.Error("Invalid morph target. Target must have positions.");
						this.geometry.setVerticesData(eu.PositionKind + t, s, !1, 3);
						const n = i.getNormals();
						n && this.geometry.setVerticesData(eu.NormalKind + t, n, !1, 3);
						const a = i.getTangents();
						a && this.geometry.setVerticesData(eu.TangentKind + t, a, !1, 3);
						const r = i.getUVs();
						r && this.geometry.setVerticesData(eu.UVKind + "_" + t, r, !1, 2)
					}
				} else {
					let e = 0;
					for (; this.geometry.isVerticesDataPresent(eu.PositionKind + e);) this.geometry.removeVerticesData(eu.PositionKind + e), this.geometry.isVerticesDataPresent(eu.NormalKind + e) && this.geometry.removeVerticesData(eu.NormalKind + e), this.geometry.isVerticesDataPresent(eu.TangentKind + e) && this.geometry.removeVerticesData(eu.TangentKind + e), this.geometry.isVerticesDataPresent(eu.UVKind + e) && this.geometry.removeVerticesData(eu.UVKind + "_" + e), e++
				}
			}
			flipFaces(e = !1) {
				const t = Mu.ExtractFromMesh(this);
				let i;
				if (e && this.isVerticesDataPresent(eu.NormalKind) && t.normals)
					for (i = 0; i < t.normals.length; i++) t.normals[i] *= -1;
				if (t.indices) {
					let e;
					for (i = 0; i < t.indices.length; i += 3) e = t.indices[i + 1], t.indices[i + 1] = t.indices[i + 2], t.indices[i + 2] = e
				}
				return t.applyToMesh(this, this.isVertexBufferUpdatable(eu.PositionKind)), this
			}
			get areNormalsFrozen() {
				return this._internalMeshDataInfo._areNormalsFrozen
			}
			get useLODScreenCoverage() {
				return this._internalMeshDataInfo._useLODScreenCoverage
			}
			_registerInstanceForRenderId(e, t) {
				return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {
					defaultRenderId: t,
					selfDefaultRenderId: this._renderId
				}), this._instanceDataStorage.visibleInstances[t] || (void 0 !== this._instanceDataStorage.previousRenderId && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null), this._instanceDataStorage.previousRenderId = t, this._instanceDataStorage.visibleInstances[t] = new Array), this._instanceDataStorage.visibleInstances[t].push(e), this
			}
			synchronizeInstances() {
				for (let e = 0; e < this.instances.length; e++) {
					this.instances[e]._syncSubMeshes()
				}
				return this
			}
			getVertexBuffer(e, t) {
				return this._geometry ? (t ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[e]) ?? this._geometry.getVertexBuffer(e) : null
			}
			_getRenderingFillMode(e) {
				const t = this.getScene();
				return t.forcePointsCloud ? Pf.PointFillMode : t.forceWireframe ? Pf.WireFrameFillMode : this.overrideRenderingFillMode ?? e
			}
			applySkeleton(e) {
				if (!this.geometry) return this;
				if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) return this;
				if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(eu.PositionKind)) return this;
				if (!this.isVerticesDataPresent(eu.MatricesIndicesKind)) return this;
				if (!this.isVerticesDataPresent(eu.MatricesWeightsKind)) return this;
				const t = this.isVerticesDataPresent(eu.NormalKind),
					i = this._internalMeshDataInfo;
				if (!i._sourcePositions) {
					const e = this.subMeshes.slice();
					this.setPositionsForCPUSkinning(), this.subMeshes = e
				}
				t && !i._sourceNormals && this.setNormalsForCPUSkinning();
				let s = this.getVerticesData(eu.PositionKind);
				if (!s) return this;
				s instanceof Float32Array || (s = new Float32Array(s));
				let n = this.getVerticesData(eu.NormalKind);
				if (t) {
					if (!n) return this;
					n instanceof Float32Array || (n = new Float32Array(n))
				}
				const a = this.getVerticesData(eu.MatricesIndicesKind),
					r = this.getVerticesData(eu.MatricesWeightsKind);
				if (!r || !a) return this;
				const o = this.numBoneInfluencers > 4,
					l = o ? this.getVerticesData(eu.MatricesIndicesExtraKind) : null,
					h = o ? this.getVerticesData(eu.MatricesWeightsExtraKind) : null,
					c = e.getTransformMatrices(this),
					u = Lc.Zero(),
					m = new Hc,
					d = new Hc;
				let f, p = 0;
				for (let e = 0; e < s.length; e += 3, p += 4) {
					let _;
					for (f = 0; f < 4; f++) _ = r[p + f], _ > 0 && (Hc.FromFloat32ArrayToRefScaled(c, Math.floor(16 * a[p + f]), _, d), m.addToSelf(d));
					if (o)
						for (f = 0; f < 4; f++) _ = h[p + f], _ > 0 && (Hc.FromFloat32ArrayToRefScaled(c, Math.floor(16 * l[p + f]), _, d), m.addToSelf(d));
					Lc.TransformCoordinatesFromFloatsToRef(i._sourcePositions[e], i._sourcePositions[e + 1], i._sourcePositions[e + 2], m, u), u.toArray(s, e), t && (Lc.TransformNormalFromFloatsToRef(i._sourceNormals[e], i._sourceNormals[e + 1], i._sourceNormals[e + 2], m, u), u.toArray(n, e)), m.reset()
				}
				return this.updateVerticesData(eu.PositionKind, s), t && this.updateVerticesData(eu.NormalKind, n), this
			}
			_convertToUnIndexedMesh(e = !1) {
				const t = this.getVerticesDataKinds(),
					i = this.getIndices(),
					s = {},
					n = (e, t) => {
						const s = new Float32Array(i.length * t);
						let n = 0;
						for (let a = 0; a < i.length; a++)
							for (let r = 0; r < t; r++) s[n++] = e[i[a] * t + r];
						return s
					},
					a = this.getBoundingInfo(),
					r = this.geometry ? this.subMeshes.slice(0) : [];
				for (const e of t) s[e] = this.getVerticesData(e);
				for (const a of t) {
					const t = this.getVertexBuffer(a),
						r = t.getSize();
					if (e && a === eu.NormalKind) {
						const e = this._getFlattenedNormals(i, s[eu.PositionKind]);
						this.setVerticesData(eu.NormalKind, e, t.isUpdatable(), r)
					} else this.setVerticesData(a, n(s[a], r), t.isUpdatable(), r)
				}
				if (this.morphTargetManager) {
					for (let t = 0; t < this.morphTargetManager.numTargets; t++) {
						const s = this.morphTargetManager.getTarget(t),
							a = s.getPositions();
						s.setPositions(n(a, 3));
						const r = s.getNormals();
						r && s.setNormals(e ? this._getFlattenedNormals(i, a) : n(r, 3));
						const o = s.getTangents();
						o && s.setTangents(n(o, 3));
						const l = s.getUVs();
						l && s.setUVs(n(l, 2))
					}
					this.morphTargetManager.synchronize()
				}
				for (let e = 0; e < i.length; e++) i[e] = e;
				this.setIndices(i), this._unIndexed = !0, this.releaseSubMeshes();
				for (const e of r) {
					const t = e.getBoundingInfo();
					bu.AddToMesh(e.materialIndex, e.indexStart, e.indexCount, e.indexStart, e.indexCount, this).setBoundingInfo(t)
				}
				return this.setBoundingInfo(a), this.synchronizeInstances(), this
			}
			setVerticesData(e, t, i = !1, s) {
				if (this._geometry) this._geometry.setVerticesData(e, t, i, s);
				else {
					const s = new Mu;
					s.set(t, e);
					const n = this.getScene();
					new bd(bd.RandomId(), n, s, i, this)
				}
				return this
			}
			_preActivate() {
				const e = this._internalMeshDataInfo,
					t = this.getScene().getRenderId();
				return e._preActivateId === t || (e._preActivateId = t, this._instanceDataStorage.visibleInstances = null), this
			}
			serialize(e = {}) {
				e.name = this.name, e.id = this.id, e.ik = this.ik, e.type = this.getClassName(), nc && nc.HasTags(this) && (e.tags = nc.GetTags(this)), e.position = this.position.asArray(), this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()), e.scaling = this.scaling.asArray(), this._postMultiplyPivotMatrix ? e.pivotMatrix = this.getPivotMatrix().asArray() : e.localMatrix = this.getPivotMatrix().asArray(), e.isEnabled = this.isEnabled(!1), e.isVisible = this.isVisible, e.infiniteDistance = this.infiniteDistance, e.pickable = this.isPickable, e.receiveShadows = this.receiveShadows, e.billboardMode = this.billboardMode, e.visibility = this.visibility, e.alwaysSelectAsActiveMesh = this.alwaysSelectAsActiveMesh, e.checkCollisions = this.checkCollisions, e.ellipsoid = this.ellipsoid.asArray(), e.ellipsoidOffset = this.ellipsoidOffset.asArray(), e.doNotSyncBoundingInfo = this.doNotSyncBoundingInfo, e.isBlocker = this.isBlocker, e.sideOrientation = this.sideOrientation, this.parent && this.parent._serializeAsParent(e), e.isUnIndexed = this.isUnIndexed;
				const t = this._geometry;
				if (t && this.subMeshes) {
					e.geometryUniqueId = t.ik, e.geometryId = t.id, e.subMeshes = [];
					for (let t = 0; t < this.subMeshes.length; t++) {
						const i = this.subMeshes[t];
						e.subMeshes.push({
							materialIndex: i.materialIndex,
							verticesStart: i.verticesStart,
							verticesCount: i.verticesCount,
							indexStart: i.indexStart,
							indexCount: i.indexCount
						})
					}
				}
				if (this.material ? this.material.doNotSerialize || (e.materialUniqueId = this.material.ik, e.materialId = this.material.id) : (this.material = null, e.materialUniqueId = this._scene.defaultMaterial.ik, e.materialId = this._scene.defaultMaterial.id), this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.ik), this.skeleton && (e.skeletonId = this.skeleton.id, e.numBoneInfluencers = this.numBoneInfluencers), this.getScene()._getComponent(Df.NAME_PHYSICSENGINE)) {
					const t = this.getPhysicsImpostor();
					t && (e.physicsMass = t.getParam("mass"), e.physicsFriction = t.getParam("friction"), e.physicsRestitution = t.getParam("mass"), e.physicsImpostor = t.type)
				}
				this.metadata && (e.metadata = this.metadata), e.instances = [];
				for (let t = 0; t < this.instances.length; t++) {
					const i = this.instances[t];
					if (i.doNotSerialize) continue;
					const s = {
						name: i.name,
						id: i.id,
						isEnabled: i.isEnabled(!1),
						isVisible: i.isVisible,
						isPickable: i.isPickable,
						checkCollisions: i.checkCollisions,
						position: i.position.asArray(),
						scaling: i.scaling.asArray()
					};
					if (i.parent && i.parent._serializeAsParent(s), i.rotationQuaternion ? s.rotationQuaternion = i.rotationQuaternion.asArray() : i.rotation && (s.rotation = i.rotation.asArray()), this.getScene()._getComponent(Df.NAME_PHYSICSENGINE)) {
						const e = i.getPhysicsImpostor();
						e && (s.physicsMass = e.getParam("mass"), s.physicsFriction = e.getParam("friction"), s.physicsRestitution = e.getParam("mass"), s.physicsImpostor = e.type)
					}
					i.metadata && (s.metadata = i.metadata), i.actionManager && (s.actions = i.actionManager.serialize(i.name)), e.instances.push(s), Xc.AppendSerializedAnimations(i, s), s.ranges = i.serializeAnimationRanges()
				}
				if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (e.thinInstances = {
						instancesCount: this._thinInstanceDataStorage.instancesCount,
						matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
						matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
						enablePicking: this.thinInstanceEnablePicking
					}, this._userThinInstanceBuffersStorage)) {
					const t = {
						data: {},
						sizes: {},
						strides: {}
					};
					for (const e in this._userThinInstanceBuffersStorage.data) t.data[e] = Array.from(this._userThinInstanceBuffersStorage.data[e]), t.sizes[e] = this._userThinInstanceBuffersStorage.sizes[e], t.strides[e] = this._userThinInstanceBuffersStorage.strides[e];
					e.thinInstances.userThinInstance = t
				}
				return Xc.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.layerMask = this.layerMask, e.alphaIndex = this.alphaIndex, e.hasVertexAlpha = this.hasVertexAlpha, e.overlayAlpha = this.overlayAlpha, e.overlayColor = this.overlayColor.asArray(), e.renderOverlay = this.renderOverlay, e.applyFog = this.applyFog, this.actionManager && (e.actions = this.actionManager.serialize(this.name)), e
			}
			set overridenInstanceCount(e) {
				this._instanceDataStorage.overridenInstanceCount = e
			}
			set sideOrientation(e) {
				this._internalMeshDataInfo._sideOrientation = e, this._internalAbstractMeshDataInfo._sideOrientationHint = this._scene.useRightHandedSystem && 1 === e || !this._scene.useRightHandedSystem && 0 === e
			}
			_processInstancedBuffers(e, t) {}
			getClassName() {
				return "Mesh"
			}
			getVerticesData(e, t, i, s) {
				if (!this._geometry) return null;
				let n = s ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[e]?.getFloatData(this.instances.length + 1, i || t && 1 !== this._geometry.meshes.length);
				return n || (n = this._geometry.getVerticesData(e, t, i)), n
			}
			get hasInstances() {
				return this.instances.length > 0
			}
			get computeBonesUsingShaders() {
				return this._internalAbstractMeshDataInfo._computeBonesUsingShaders
			}
			_unFreeze() {
				this._instanceDataStorage.isFrozen = !1, this._instanceDataStorage.previousBatch = null
			}
			_checkDelayState() {
				const e = this.getScene();
				return this._geometry ? this._geometry.load(e) : 4 === this.delayLoadState && (this.delayLoadState = 2, this._queueLoad(e)), this
			}
			static CreatePolyhedron(e, t, i) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_freeze() {
				if (this.subMeshes) {
					for (let e = 0; e < this.subMeshes.length; e++) this._getInstancesRenderList(e);
					this._internalMeshDataInfo._effectiveMaterial = null, this._instanceDataStorage.isFrozen = !0
				}
			}
			setIndices(e, t = null, i = !1) {
				if (this._geometry) this._geometry.setIndices(e, t, i);
				else {
					const t = new Mu;
					t.indices = e;
					const s = this.getScene();
					new bd(bd.RandomId(), s, t, i, this)
				}
				return this
			}
			static MinMax(e) {
				let t = null,
					i = null;
				return e.forEach((function(e) {
					const s = e.getBoundingInfo().boundingBox;
					t && i ? (t.minimizeInPlace(s.minimumWorld), i.maximizeInPlace(s.maximumWorld)) : (t = s.minimumWorld, i = s.maximumWorld)
				})), t && i ? {
					min: t,
					max: i
				} : {
					min: Lc.Zero(),
					max: Lc.Zero()
				}
			}
			removeLODLevel(e) {
				const t = this._internalMeshDataInfo;
				for (let i = 0; i < t._LODLevels.length; i++) t._LODLevels[i].mesh === e && (t._LODLevels.splice(i, 1), e && (e._masterMesh = null));
				return this._sortLODLevels(), this
			}
			static CreateGround(e, t, i, s, n, a) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			_copySource(e, t, i = !0) {
				const s = this.getScene();
				if (e._geometry && e._geometry.applyToMesh(this), Iu.DeepCopy(e, this, ["name", "material", "skeleton", "instances", "parent", "uniqueId", "source", "metadata", "morphTargetManager", "hasInstances", "worldMatrixInstancedBuffer", "previousWorldMatrixInstancedBuffer", "hasLODLevels", "geometry", "isBlocked", "areNormalsFrozen", "facetNb", "isFacetDataEnabled", "lightSources", "useBones", "isAnInstance", "collider", "edgesRenderer", "forward", "up", "right", "absolutePosition", "absoluteScaling", "absoluteRotationQuaternion", "isWorldMatrixFrozen", "nonUniformScaling", "behaviors", "worldMatrixFromCache", "hasThinInstances", "cloneMeshMap", "hasBoundingInfo", "physicsBody", "physicsImpostor"], ["_poseMatrix"]), this._internalMeshDataInfo._source = e, s.useClonedMeshMap && (e._internalMeshDataInfo.meshMap || (e._internalMeshDataInfo.meshMap = {}), e._internalMeshDataInfo.meshMap[this.ik] = this), this._originalBuilderSideOrientation = e._originalBuilderSideOrientation, this._creationDataStorage = e._creationDataStorage, e._ranges) {
					const t = e._ranges;
					for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && t[e] && this.createAnimationRange(e, t[e].from, t[e].to)
				}
				if (e.metadata && e.metadata.clone ? this.metadata = e.metadata.clone() : this.metadata = e.metadata, this._internalMetadata = e._internalMetadata, nc && nc.HasTags(e) && nc.AddTagsTo(this, nc.GetTags(e, !0)), this.setEnabled(e.isEnabled(!1)), this.parent = e.parent, this.setPivotMatrix(e.getPivotMatrix(), this._postMultiplyPivotMatrix), this.id = this.name + "." + e.id, this.material = e.material, !t) {
					const t = e.getDescendants(!0);
					for (let e = 0; e < t.length; e++) {
						const i = t[e];
						i.clone && i.clone(this.name + "." + i.name, this)
					}
				}
				if (e.morphTargetManager && (this.morphTargetManager = e.morphTargetManager), s.getPhysicsEngine) {
					const t = s.getPhysicsEngine();
					if (i && t)
						if (1 === t.getPluginVersion()) {
							const i = t.getImpostorForPhysicsObject(e);
							i && (this.physicsImpostor = i.clone(this))
						} else 2 === t.getPluginVersion() && e.physicsBody && e.physicsBody.clone(this)
				}
				for (let t = 0; t < s.particleSystems.length; t++) {
					const i = s.particleSystems[t];
					i.emitter === e && i.clone(i.name, this)
				}
				this.skeleton = e.skeleton, this.refreshBoundingInfo(!0, !0), this.computeWorldMatrix(!0)
			}
			_processRendering(e, t, i, s, n, a, r, o) {
				const l = this.getScene(),
					h = l.getEngine();
				if (s = this._getRenderingFillMode(s), a && t.getRenderingMesh().hasThinInstances) return this._renderWithThinInstances(t, s, i, h), this;
				if (a) this._renderWithInstances(t, s, n, i, h);
				else {
					h._currentDrawContext && (h._currentDrawContext.useInstancing = !1);
					let i = 0;
					n.renderSelf[t._id] && (r && r(!1, e.getWorldMatrix(), o), i++, this._draw(t, s, this._instanceDataStorage.overridenInstanceCount));
					const a = n.visibleInstances[t._id];
					if (a) {
						const e = a.length;
						i += e;
						for (let i = 0; i < e; i++) {
							const e = a[i].getWorldMatrix();
							r && r(!0, e, o), this._draw(t, s)
						}
					}
					l._activeIndices.addCount(t.indexCount * i, !1)
				}
				return this
			}
			subdivide(e) {
				if (e < 1) return;
				const t = this.getTotalIndices();
				let i = t / e | 0,
					s = 0;
				for (; i % 3 != 0;) i++;
				this.releaseSubMeshes();
				for (let n = 0; n < e && !(s >= t); n++) bu.CreateFromIndices(0, s, n === e - 1 ? t - s : i, this, void 0, !1), s += i;
				this.refreshBoundingInfo(), this.synchronizeInstances()
			}
			addLODLevel(e, t) {
				if (t && t._masterMesh) return Qc.Warn("You cannot use a mesh as LOD level twice"), this;
				const i = new Ff(e, t);
				return this._internalMeshDataInfo._LODLevels.push(i), t && (t._masterMesh = this), this._sortLODLevels(), this
			}
			validateSkinning() {
				const e = this.getVerticesData(eu.MatricesWeightsExtraKind),
					t = this.getVerticesData(eu.MatricesWeightsKind);
				if (null === t || null == this.skeleton) return {
					skinned: !1,
					valid: !0,
					report: "not skinned"
				};
				const i = t.length;
				let s = 0,
					n = 0,
					a = 0,
					r = 0;
				const o = null === e ? 4 : 8,
					l = [];
				for (let e = 0; e <= o; e++) l[e] = 0;
				for (let h = 0; h < i; h += 4) {
					let i = t[h],
						c = i,
						u = 0 === c ? 0 : 1;
					for (let n = 1; n < o; n++) {
						const a = n < 4 ? t[h + n] : e[h + n - 4];
						a > i && s++, 0 !== a && u++, c += a, i = a
					}
					if (l[u]++, u > a && (a = u), 0 === c) n++;
					else {
						const i = 1 / c;
						let s = 0;
						for (let n = 0; n < o; n++) s += n < 4 ? Math.abs(t[h + n] - t[h + n] * i) : Math.abs(e[h + n - 4] - e[h + n - 4] * i);
						s > .001 && r++
					}
				}
				const h = this.skeleton.bones.length,
					c = this.getVerticesData(eu.MatricesIndicesKind),
					u = this.getVerticesData(eu.MatricesIndicesExtraKind);
				let m = 0;
				for (let e = 0; e < i; e += 4)
					for (let t = 0; t < o; t++) {
						const i = t < 4 ? c[e + t] : u[e + t - 4];
						(i >= h || i < 0) && m++
					}
				return {
					skinned: !0,
					valid: 0 === n && 0 === r && 0 === m,
					report: "Number of Weights = " + i / 4 + "\nMaximum influences = " + a + "\nMissing Weights = " + n + "\nNot Sorted = " + s + "\nNot Normalized = " + r + "\nWeightCounts = [" + l + "]\nNumber of bones = " + h + "\nBad Bone Indices = " + m
				}
			}
			get _positions() {
				return this._internalAbstractMeshDataInfo._positions || this._geometry && this._geometry._positions || null
			}
			instantiateHierarchy(e = null, t, i) {
				const s = 0 === this.getTotalVertices() || t && t.doNotInstantiate && (!0 === t.doNotInstantiate || t.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), e || this.parent, !0) : this.createInstance("instance of " + (this.name || this.id));
				s.parent = e || this.parent, s.position = this.position.clone(), s.scaling = this.scaling.clone(), this.rotationQuaternion ? s.rotationQuaternion = this.rotationQuaternion.clone() : s.rotation = this.rotation.clone(), i && i(this, s);
				for (const e of this.getChildTransformNodes(!0)) "InstancedMesh" === e.getClassName() && "Mesh" === s.getClassName() && e.wk === this ? e.instantiateHierarchy(s, {
					doNotInstantiate: t && t.doNotInstantiate || !1,
					newSourcedMesh: s
				}, i) : e.instantiateHierarchy(s, t, i);
				return s
			}
			set isUnIndexed(e) {
				this._unIndexed !== e && (this._unIndexed = e, this._markSubMeshesAsAttributesDirty())
			}
			get overrideMaterialSideOrientation() {
				return this.sideOrientation
			}
			static _PhysicsImpostorParser(e, t, i) {
				throw ic("PhysicsImpostor")
			}
			get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
				return this._instanceDataStorage.previousManualUpdate
			}
			refreshBoundingInfo(e = !1, t = !1) {
				if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) return this;
				let i;
				i = "object" == typeof e ? e : {
					applySkeleton: e,
					applyMorph: t
				};
				const s = this.geometry ? this.geometry.boundingBias : null;
				return this._refreshBoundingInfo(this._getData(i, null, eu.PositionKind), s), this
			}
			addInstance(e) {
				e._indexInSourceMeshInstanceArray = this.instances.length, this.instances.push(e)
			}
			static _GetDefaultSideOrientation(t) {
				return t || e.FRONTSIDE
			}
			set forceWorldMatrixInstancedBufferUpdate(e) {
				this._instanceDataStorage.forceMatrixUpdates = e
			}
			updateVerticesData(e, t, i, s) {
				return this._geometry ? (s ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i), this) : this
			}
			get _isMesh() {
				return !0
			}
			cleanMatrixWeights() {
				this.isVerticesDataPresent(eu.MatricesWeightsKind) && (this.isVerticesDataPresent(eu.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights())
			}
			setMaterialByID(e) {
				return this.setMaterialById(e)
			}
			applyDisplacementMapFromBuffer(e, t, i, s, n, a, r, o = !1) {
				if (!this.isVerticesDataPresent(eu.PositionKind) || !this.isVerticesDataPresent(eu.NormalKind) || !this.isVerticesDataPresent(eu.UVKind)) return Qc.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"), this;
				const l = this.getVerticesData(eu.PositionKind, !0, !0),
					h = this.getVerticesData(eu.NormalKind),
					c = this.getVerticesData(eu.UVKind);
				let u = Lc.Zero();
				const m = Lc.Zero(),
					d = Fc.Zero();
				a = a || Fc.Zero(), r = r || new Fc(1, 1);
				for (let o = 0; o < l.length; o += 3) {
					Lc.FromArrayToRef(l, o, u), Lc.FromArrayToRef(h, o, m), Fc.FromArrayToRef(c, o / 3 * 2, d);
					const f = 4 * ((Math.abs(d.x * r.x + a.x % 1) * (t - 1) % t | 0) + (Math.abs(d.y * r.y + a.y % 1) * (i - 1) % i | 0) * t),
						p = .3 * (e[f] / 255) + .59 * (e[f + 1] / 255) + .11 * (e[f + 2] / 255);
					m.normalize(), m.scaleInPlace(s + (n - s) * p), u = u.add(m), u.toArray(l, o)
				}
				return Mu.ComputeNormals(l, this.getIndices(), h), o ? (this.setVerticesData(eu.PositionKind, l), this.setVerticesData(eu.NormalKind, h), this.setVerticesData(eu.UVKind, c)) : (this.updateVerticesData(eu.PositionKind, l), this.updateVerticesData(eu.NormalKind, h)), this
			}
			static ka(e, t, i, s, n, a, r) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			get source() {
				return this._internalMeshDataInfo._source
			}
			_preActivateForIntermediateRendering(e) {
				return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e), this
			}
			static CreateHemisphere(e, t, i, s) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			render(e, t, i) {
				const s = this.getScene();
				this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1;
				const n = s.activeCameras?.length ?? 0;
				if ((n > 1 && s.activeCamera === s.activeCameras[0] || n <= 1) && this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) return this;
				const a = this._getInstancesRenderList(e._id, !!i);
				if (a.mustReturn) return this;
				if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this;
				const r = s.getEngine();
				let o = 0,
					l = null;
				this.ignoreCameraMaxZ && s.activeCamera && !s._isInIntermediateRendering() && (o = s.activeCamera.maxZ, l = s.activeCamera, s.activeCamera.maxZ = 0, s.updateTransformMatrix(!0)), this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
				const h = e.getRenderingMesh(),
					c = a.hardwareInstancedRendering[e._id] || h.hasThinInstances || !!this._userInstancedBuffersStorage && !e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,
					u = this._instanceDataStorage,
					m = e.getMaterial();
				if (!m) return l && (l.maxZ = o, s.updateTransformMatrix(!0)), this;
				if (u.isFrozen && this._internalMeshDataInfo._effectiveMaterial && this._internalMeshDataInfo._effectiveMaterial === m) {
					if (m._storeEffectOnSubMeshes && !e._drawWrapper?._wasPreviouslyReady || !m._storeEffectOnSubMeshes && !m._getDrawWrapper()._wasPreviouslyReady) return l && (l.maxZ = o, s.updateTransformMatrix(!0)), this
				} else {
					if (m._storeEffectOnSubMeshes) {
						if (!m.isReadyForSubMesh(this, e, c)) return l && (l.maxZ = o, s.updateTransformMatrix(!0)), this
					} else if (!m.isReady(this, c)) return l && (l.maxZ = o, s.updateTransformMatrix(!0)), this;
					this._internalMeshDataInfo._effectiveMaterial = m
				}
				let d;
				t && r.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode), d = this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? e._drawWrapper : this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
				const f = d?.effect ?? null;
				for (const t of s._beforeRenderingMeshStage) t.action(this, e, a, f);
				if (!d || !f) return l && (l.maxZ = o, s.updateTransformMatrix(!0)), this;
				const p = i || this;
				let _;
				if (u.isFrozen || !this._internalMeshDataInfo._effectiveMaterial.backFaceCulling && null === this._internalMeshDataInfo._effectiveMaterial.sideOrientation && !this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting) _ = u.sideOrientation;
				else {
					const e = p._getWorldMatrixDeterminant();
					_ = this._internalMeshDataInfo._effectiveMaterial._getEffectiveOrientation(this), e < 0 && (_ = _ === Pf.ClockWiseSideOrientation ? Pf.CounterClockWiseSideOrientation : Pf.ClockWiseSideOrientation), u.sideOrientation = _
				}
				const g = this._internalMeshDataInfo._effectiveMaterial._preBind(d, _);
				this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && r.setDepthWrite(!0);
				const v = this._internalMeshDataInfo._effectiveMaterial,
					y = v.fillMode;
				this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this), c || this._bind(e, f, y, !1);
				const S = p.getWorldMatrix();
				v._storeEffectOnSubMeshes ? v.bindForSubMesh(S, this, e) : v.bind(S, this), !v.backFaceCulling && v.separateCullingPass && (r.setState(!0, v.zOffset, !1, !g, v.cullBackFaces, v.stencil, v.zOffsetUnits), this._processRendering(this, e, f, y, a, c, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), r.setState(!0, v.zOffset, !1, g, v.cullBackFaces, v.stencil, v.zOffsetUnits), this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)), this._processRendering(this, e, f, y, a, c, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), this._internalMeshDataInfo._effectiveMaterial.unbind();
				for (const t of s._afterRenderingMeshStage) t.action(this, e, a, f);
				return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this), l && (l.maxZ = o, s.updateTransformMatrix(!0)), 2 !== s.performancePriority || u.isFrozen || this._freeze(), this
			}
			static Pk(e, t, i, s, n) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			increaseVertices(e = 1) {
				const t = Mu.ExtractFromMesh(this),
					i = t.indices && !Array.isArray(t.indices) && Array.from ? Array.from(t.indices) : t.indices,
					s = t.positions && !Array.isArray(t.positions) && Array.from ? Array.from(t.positions) : t.positions,
					n = t.uvs && !Array.isArray(t.uvs) && Array.from ? Array.from(t.uvs) : t.uvs,
					a = t.normals && !Array.isArray(t.normals) && Array.from ? Array.from(t.normals) : t.normals;
				if (i && s) {
					t.indices = i, t.positions = s, n && (t.uvs = n), a && (t.normals = a);
					const r = e + 1,
						o = new Array;
					for (let e = 0; e < r + 1; e++) o[e] = new Array;
					let l, h;
					const c = new Lc(0, 0, 0),
						u = new Lc(0, 0, 0),
						m = new Fc(0, 0),
						d = new Array,
						f = new Array,
						p = new Array;
					let _, g, v, y = s.length;
					n && (g = n.length), a && (v = a.length);
					for (let e = 0; e < i.length; e += 3) {
						f[0] = i[e], f[1] = i[e + 1], f[2] = i[e + 2];
						for (let e = 0; e < 3; e++)
							if (l = f[e], h = f[(e + 1) % 3], void 0 === p[l] && void 0 === p[h] ? (p[l] = new Array, p[h] = new Array) : (void 0 === p[l] && (p[l] = new Array), void 0 === p[h] && (p[h] = new Array)), void 0 === p[l][h] && void 0 === p[h][l]) {
								p[l][h] = [], c.x = (s[3 * h] - s[3 * l]) / r, c.y = (s[3 * h + 1] - s[3 * l + 1]) / r, c.z = (s[3 * h + 2] - s[3 * l + 2]) / r, a && (u.x = (a[3 * h] - a[3 * l]) / r, u.y = (a[3 * h + 1] - a[3 * l + 1]) / r, u.z = (a[3 * h + 2] - a[3 * l + 2]) / r), n && (m.x = (n[2 * h] - n[2 * l]) / r, m.y = (n[2 * h + 1] - n[2 * l + 1]) / r), p[l][h].push(l);
								for (let e = 1; e < r; e++) p[l][h].push(s.length / 3), s[y++] = s[3 * l] + e * c.x, s[y++] = s[3 * l + 1] + e * c.y, s[y++] = s[3 * l + 2] + e * c.z, a && (a[v++] = a[3 * l] + e * u.x, a[v++] = a[3 * l + 1] + e * u.y, a[v++] = a[3 * l + 2] + e * u.z), n && (n[g++] = n[2 * l] + e * m.x, n[g++] = n[2 * l + 1] + e * m.y);
								p[l][h].push(h), p[h][l] = new Array, _ = p[l][h].length;
								for (let e = 0; e < _; e++) p[h][l][e] = p[l][h][_ - 1 - e]
							} o[0][0] = i[e], o[1][0] = p[i[e]][i[e + 1]][1], o[1][1] = p[i[e]][i[e + 2]][1];
						for (let t = 2; t < r; t++) {
							o[t][0] = p[i[e]][i[e + 1]][t], o[t][t] = p[i[e]][i[e + 2]][t], c.x = (s[3 * o[t][t]] - s[3 * o[t][0]]) / t, c.y = (s[3 * o[t][t] + 1] - s[3 * o[t][0] + 1]) / t, c.z = (s[3 * o[t][t] + 2] - s[3 * o[t][0] + 2]) / t, a && (u.x = (a[3 * o[t][t]] - a[3 * o[t][0]]) / t, u.y = (a[3 * o[t][t] + 1] - a[3 * o[t][0] + 1]) / t, u.z = (a[3 * o[t][t] + 2] - a[3 * o[t][0] + 2]) / t), n && (m.x = (n[2 * o[t][t]] - n[2 * o[t][0]]) / t, m.y = (n[2 * o[t][t] + 1] - n[2 * o[t][0] + 1]) / t);
							for (let e = 1; e < t; e++) o[t][e] = s.length / 3, s[y++] = s[3 * o[t][0]] + e * c.x, s[y++] = s[3 * o[t][0] + 1] + e * c.y, s[y++] = s[3 * o[t][0] + 2] + e * c.z, a && (a[v++] = a[3 * o[t][0]] + e * u.x, a[v++] = a[3 * o[t][0] + 1] + e * u.y, a[v++] = a[3 * o[t][0] + 2] + e * u.z), n && (n[g++] = n[2 * o[t][0]] + e * m.x, n[g++] = n[2 * o[t][0] + 1] + e * m.y)
						}
						o[r] = p[i[e + 1]][i[e + 2]], d.push(o[0][0], o[1][0], o[1][1]);
						for (let e = 1; e < r; e++) {
							let t;
							for (t = 0; t < e; t++) d.push(o[e][t], o[e + 1][t], o[e + 1][t + 1]), d.push(o[e][t], o[e + 1][t + 1], o[e][t + 1]);
							d.push(o[e][t], o[e + 1][t], o[e + 1][t + 1])
						}
					}
					t.indices = d, t.applyToMesh(this, this.isVertexBufferUpdatable(eu.PositionKind))
				} else Qc.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions")
			}
			_normalizeSkinWeightsAndExtra() {
				const e = this.getVerticesData(eu.MatricesWeightsExtraKind),
					t = this.getVerticesData(eu.MatricesWeightsKind),
					i = t.length;
				for (let s = 0; s < i; s += 4) {
					let i = t[s] + t[s + 1] + t[s + 2] + t[s + 3];
					if (i += e[s] + e[s + 1] + e[s + 2] + e[s + 3], 0 === i) t[s] = 1;
					else {
						const n = 1 / i;
						t[s] *= n, t[s + 1] *= n, t[s + 2] *= n, t[s + 3] *= n, e[s] *= n, e[s + 1] *= n, e[s + 2] *= n, e[s + 3] *= n
					}
				}
				this.setVerticesData(eu.MatricesWeightsKind, t), this.setVerticesData(eu.MatricesWeightsKind, e)
			}
			freezeNormals() {
				return this._internalMeshDataInfo._areNormalsFrozen = !0, this
			}
			setIndexBuffer(e, t, i) {
				let s = this._geometry;
				s || (s = new bd(bd.RandomId(), this.getScene(), void 0, void 0, this)), s.setIndexBuffer(e, t, i)
			}
			static CreateTiledGround(e, t, i, s, n, a, r, o, l) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			set manualUpdateOfWorldMatrixInstancedBuffer(e) {
				this._instanceDataStorage.manualUpdate = e
			}
			_generatePointsArray() {
				return !!this._geometry && this._geometry._generatePointsArray()
			}
			copyVerticesData(e, t) {
				this._geometry && this._geometry.copyVerticesData(e, t)
			}
			getIndices(e, t) {
				return this._geometry ? this._geometry.getIndices(e, t) : []
			}
			static ExtrudeShape(e, t, i, s, n, a, r, o, l, h) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			applyDisplacementMap(e, t, i, s, n, a, r = !1, o) {
				const l = this.getScene();
				return dd.LoadImage(e, (e => {
					const o = e.width,
						l = e.height,
						h = this.getEngine().createCanvas(o, l).getContext("2d");
					h.drawImage(e, 0, 0);
					const c = h.getImageData(0, 0, o, l).data;
					this.applyDisplacementMapFromBuffer(c, o, l, t, i, n, a, r), s && s(this)
				}), o || (() => {}), l.offlineProvider), this
			}
			set computeBonesUsingShaders(e) {
				this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (e && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(eu.PositionKind, this._internalMeshDataInfo._sourcePositions, !0), this._internalMeshDataInfo._sourceNormals && this.setVerticesData(eu.NormalKind, this._internalMeshDataInfo._sourceNormals, !0), this._internalMeshDataInfo._sourcePositions = null, this._internalMeshDataInfo._sourceNormals = null), this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty())
			}
			setMaterialById(e) {
				const t = this.getScene().materials;
				let i;
				for (i = t.length - 1; i > -1; i--)
					if (t[i].id === e) return this.material = t[i], this;
				const s = this.getScene().multiMaterials;
				for (i = s.length - 1; i > -1; i--)
					if (s[i].id === e) return this.material = s[i], this;
				return this
			}
			get geometry() {
				return this._geometry
			}
			getTotalIndices() {
				return this._geometry ? this._geometry.getTotalIndices() : 0
			}
			_normalizeSkinFourWeights() {
				const e = this.getVerticesData(eu.MatricesWeightsKind),
					t = e.length;
				for (let i = 0; i < t; i += 4) {
					const t = e[i] + e[i + 1] + e[i + 2] + e[i + 3];
					if (0 === t) e[i] = 1;
					else {
						const s = 1 / t;
						e[i] *= s, e[i + 1] *= s, e[i + 2] *= s, e[i + 3] *= s
					}
				}
				this.setVerticesData(eu.MatricesWeightsKind, e)
			}
			static CreateTorusKnot(e, t, i, s, n, a, r, o, l, h) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			get previousWorldMatrixInstancedBuffer() {
				return this._instanceDataStorage.instancesPreviousData
			}
			_queueLoad(e) {
				e.addPendingData(this);
				const t = -1 !== this.delayLoadingFile.indexOf(".babylonbinarymeshdata");
				return dd.LoadFile(this.delayLoadingFile, (t => {
					t instanceof ArrayBuffer ? this._delayLoadingFunction(t, this) : this._delayLoadingFunction(JSON.parse(t), this), this.instances.forEach((e => {
						e.refreshBoundingInfo(), e._syncSubMeshes()
					})), this.delayLoadState = 1, e.removePendingData(this)
				}), (() => {}), e.offlineProvider, t), this
			}
			bakeTransformIntoVertices(e) {
				if (!this.isVerticesDataPresent(eu.PositionKind)) return this;
				const t = this.subMeshes.splice(0);
				this._resetPointsArrayCache();
				let i = this.getVerticesData(eu.PositionKind);
				const s = Lc.Zero();
				let n;
				for (n = 0; n < i.length; n += 3) Lc.TransformCoordinatesFromFloatsToRef(i[n], i[n + 1], i[n + 2], e, s).toArray(i, n);
				if (this.setVerticesData(eu.PositionKind, i, this.getVertexBuffer(eu.PositionKind).isUpdatable()), this.isVerticesDataPresent(eu.NormalKind)) {
					for (i = this.getVerticesData(eu.NormalKind), n = 0; n < i.length; n += 3) Lc.TransformNormalFromFloatsToRef(i[n], i[n + 1], i[n + 2], e, s).normalize().toArray(i, n);
					this.setVerticesData(eu.NormalKind, i, this.getVertexBuffer(eu.NormalKind).isUpdatable())
				}
				if (this.isVerticesDataPresent(eu.TangentKind)) {
					for (i = this.getVerticesData(eu.TangentKind), n = 0; n < i.length; n += 4) Lc.TransformNormalFromFloatsToRef(i[n], i[n + 1], i[n + 2], e, s).normalize().toArray(i, n);
					this.setVerticesData(eu.TangentKind, i, this.getVertexBuffer(eu.TangentKind).isUpdatable())
				}
				return e.determinant() < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = t, this
			}
			constructor(t, i = null, s = null, n = null, a, r = !0) {
				super(t, i), this._internalMeshDataInfo = new Uf, this.delayLoadState = 0, this.instances = [], this._creationDataStorage = null, this._geometry = null, this._instanceDataStorage = new Bf, this._thinInstanceDataStorage = new Hf, this._shouldGenerateFlatShading = !1, this._originalBuilderSideOrientation = e.DEFAULTSIDE, this.ignoreCameraMaxZ = !1, i = this.getScene(), this._scene.useRightHandedSystem ? this.sideOrientation = 0 : this.sideOrientation = 1, this._onBeforeDraw = (e, t, i) => {
					e && i && (this._uniformBuffer ? this.transferToEffect(t) : i.bindOnlyWorldMatrix(t))
				}, n && this._copySource(n, a, r), null !== s && (this.parent = s), this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays, this._internalMeshDataInfo._onMeshReadyObserverAdded = e => {
					e.unregisterOnNextCall = !0, this.isReady(!0) ? this.onMeshReadyObservable.notifyObservers(this) : this._internalMeshDataInfo._checkReadinessObserver || (this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add((() => {
						this.isReady(!0) && (this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), this._internalMeshDataInfo._checkReadinessObserver = null, this.onMeshReadyObservable.notifyObservers(this))
					})))
				}, this.onMeshReadyObservable = new kc(this._internalMeshDataInfo._onMeshReadyObserverAdded), n && n.onClonedObservable.notifyObservers(this)
			}
			set overrideMaterialSideOrientation(e) {
				this.sideOrientation = e, this.material && (this.material.sideOrientation = null)
			}
			static MergeMeshes(t, i = !0, s, n, a, r) {
				return su(e._MergeMeshesCoroutine(t, i, s, n, a, r, !1))
			}
			setVerticesBuffer(e, t = !0) {
				return this._geometry || (this._geometry = bd.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(e, null, t), this
			}
			get hasLODLevels() {
				return this._internalMeshDataInfo._LODLevels.length > 0
			}
			getLODLevels() {
				return this._internalMeshDataInfo._LODLevels
			}
			_bindDirect(e, t, i = !0) {
				return this._geometry ? (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(e), i && this._userInstancedBuffersStorage && !this.hasThinInstances ? this._geometry._bind(e, t, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects) : this._geometry._bind(e, t), this) : this
			}
			updateMeshPositions(e, t = !0) {
				const i = this.getVerticesData(eu.PositionKind);
				if (!i) return this;
				if (e(i), this.updateVerticesData(eu.PositionKind, i, !1, !1), t) {
					const e = this.getIndices(),
						t = this.getVerticesData(eu.NormalKind);
					if (!t) return this;
					Mu.ComputeNormals(i, e, t), this.updateVerticesData(eu.NormalKind, t, !1, !1)
				}
				return this
			}
			get manualUpdateOfWorldMatrixInstancedBuffer() {
				return this._instanceDataStorage.manualUpdate
			}
			setNormalsForCPUSkinning() {
				const e = this._internalMeshDataInfo;
				if (!e._sourceNormals) {
					const t = this.getVerticesData(eu.NormalKind);
					if (!t) return e._sourceNormals;
					e._sourceNormals = new Float32Array(t), this.isVertexBufferUpdatable(eu.NormalKind) || this.setVerticesData(eu.NormalKind, t, !0)
				}
				return e._sourceNormals
			}
			get onBetweenPassObservable() {
				return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new kc), this._internalMeshDataInfo._onBetweenPassObservable
			}
			set forcedInstanceCount(e) {
				this._internalMeshDataInfo._forcedInstanceCount = e
			}
			_sortLODLevels() {
				const e = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
				this._internalMeshDataInfo._LODLevels.sort(((t, i) => t.distanceOrScreenCoverage < i.distanceOrScreenCoverage ? e : t.distanceOrScreenCoverage > i.distanceOrScreenCoverage ? -e : 0))
			}
			static CreatePolygon(e, t, i, s, n, a, r) {
				throw new Error("Import MeshBuilder to populate this function")
			}
			get forcedInstanceCount() {
				return this._internalMeshDataInfo._forcedInstanceCount
			}
			set overrideRenderingFillMode(e) {
				this._internalMeshDataInfo._overrideRenderingFillMode = e
			}
			get isBlocked() {
				return null !== this._masterMesh && void 0 !== this._masterMesh
			}
		};
	Vf.FRONTSIDE = Mu.FRONTSIDE, Vf.BACKSIDE = Mu.BACKSIDE, Vf.DOUBLESIDE = Mu.DOUBLESIDE, Vf.DEFAULTSIDE = Mu.DEFAULTSIDE, Vf.NO_CAP = 0, Vf.CAP_START = 1, Vf.CAP_END = 2, Vf.CAP_ALL = 3, Vf.NO_FLIP = 0, Vf.FLIP_TILE = 1, Vf.ROTATE_TILE = 2, Vf.FLIP_ROW = 3, Vf.ROTATE_ROW = 4, Vf.FLIP_N_ROTATE_TILE = 5, Vf.FLIP_N_ROTATE_ROW = 6, Vf.CENTER = 0, Vf.LEFT = 1, Vf.RIGHT = 2, Vf.TOP = 3, Vf.BOTTOM = 4, Vf.INSTANCEDMESH_SORT_TRANSPARENT = !1, Vf._GroundMeshParser = (e, t) => {
		throw ic("GroundMesh")
	}, Vf._GoldbergMeshParser = (e, t) => {
		throw ic("GoldbergMesh")
	}, Vf._LinesMeshParser = (e, t) => {
		throw ic("LinesMesh")
	}, Vf._GreasedLineMeshParser = (e, t) => {
		throw ic("GreasedLineMesh")
	}, Vf._GreasedLineRibbonMeshParser = (e, t) => {
		throw ic("GreasedLineRibbonMesh")
	}, Vf._TrailMeshParser = (e, t) => {
		throw ic("TrailMesh")
	}, cc("BABYLON.Mesh", Vf);
	var Wf, zf, Xf, Yf, jf = class {
			constructor(e) {
				this.mesh = new Vf("hitMarker", e), this.mesh.updatable = !0, this.mesh.hasVertexAlpha = !0, this.mesh.layerMask = 536870912, this.mesh.visibility = .2, this.positions = [1, 2.5, 0, 0, 3, 0, -1, 2.5, 0];
				this.colors = new Array(12).fill(0), this.colors[0] = 1, this.colors[4] = 1, this.colors[8] = 1, this.colors[7] = 1;
				var t = new Mu;
				return t.positions = this.positions, t.indices = [0, 1, 2], t.colors = this.colors, t.applyToMesh(this.mesh, !0), this.mesh.material = e.getMaterialByName("ui"), this.mesh
			}
		},
		Kf = class {
			hit(e, t) {
				if (0 === this.container.visibility) return;
				let i, s = Math.atan2(e, t),
					n = -Math.radRange(s);
				for (let e of this.markers)
					if (0 === e.mesh.visibility) {
						i = e;
						break
					} if (!i) {
					let e = 1e3;
					for (let t of this.markers) {
						let s = Math.abs(Math.radRange(t.angle - n));
						s < e && (e = s, i = t)
					}
				}
				i.angle = n, i.mesh.scaling.x = 1.1, i.mesh.scaling.y = 1.1, i.mesh.visibility = 5, i.mesh.rotation.z = n
			}
			show() {
				this.container.setEnabled(!0)
			}
			resize() {
				let e = .1 * kh.engine.getRenderHeight();
				this.container.scaling.x = e, this.container.scaling.y = e
			}
			constructor(e) {
				this.container = new Jc("hitMarkers", e), this.container.layerMask = 536870912, this.markers = [];
				for (let t = 0; t < 4; t++) {
					let t = new jf(e);
					t.parent = this.container, this.markers.push({
						mesh: t,
						angle: 0
					})
				}
			}
			hide() {
				this.container.setEnabled(!1)
			}
			update(e, t) {
				if (this.container.isEnabled()) {
					this.container.rotation.z = t;
					for (let t of this.markers)
						if (t.mesh.visibility > 0) {
							t.mesh.visibility = Math.max(0, t.mesh.visibility - .06 * e);
							let i = Math.max(1, t.mesh.scaling.x - .01 * e);
							t.mesh.scaling.x = i, t.mesh.scaling.y = i
						}
				}
			}
		},
		$f = class extends Pf {
			constructor(e, t, i = !0) {
				super(e, t), this._normalMatrix = new Hc, this._storeEffectOnSubMeshes = i
			}
			bind(e, t) {
				t && this.bindForSubMesh(e, t, t.subMeshes[0])
			}
			bindOnlyNormalMatrix(e) {
				this._activeEffect.setMatrix("normalMatrix", e)
			}
			_mustRebind(e, t, i, s = 1) {
				return i._drawWrapper._forceRebindOnNextCall || e.isCachedMaterialInvalid(this, t, s)
			}
			getEffect() {
				return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect()
			}
			isReady(e, t) {
				return !!e && (!this._storeEffectOnSubMeshes || (!e.subMeshes || 0 === e.subMeshes.length || this.isReadyForSubMesh(e, e.subMeshes[0], t)))
			}
			_afterBind(e, t = null, i) {
				super._afterBind(e, t, i), this.getScene()._cachedEffect = t, i ? i._drawWrapper._forceRebindOnNextCall = !1 : this._drawWrapper._forceRebindOnNextCall = !1
			}
			dispose(e, t, i) {
				this._activeEffect = void 0, super.dispose(e, t, i)
			}
			bindOnlyWorldMatrix(e) {
				this._activeEffect.setMatrix("world", e)
			}
			_isReadyForSubMesh(e) {
				const t = e.materialDefines;
				return !(this.checkReadyOnEveryCall || !e.effect || !t || t._renderId !== this.getScene().getRenderId())
			}
		};
	(zf = Wf || (Wf = {}))[zf.Float = 1] = "Float", zf[zf.Int = 2] = "Int", zf[zf.Vector2 = 4] = "Vector2", zf[zf.Vector3 = 8] = "Vector3", zf[zf.Vector4 = 16] = "Vector4", zf[zf.Color3 = 32] = "Color3", zf[zf.Color4 = 64] = "Color4", zf[zf.Matrix = 128] = "Matrix", zf[zf.Object = 256] = "Object", zf[zf.AutoDetect = 1024] = "AutoDetect", zf[zf.BasedOnInput = 2048] = "BasedOnInput", zf[zf.All = 4095] = "All", (Yf = Xf || (Xf = {}))[Yf.Vertex = 1] = "Vertex", Yf[Yf.Fragment = 2] = "Fragment", Yf[Yf.Neutral = 4] = "Neutral", Yf[Yf.VertexAndFragment = 3] = "VertexAndFragment", h();
	var Jf, qf, Qf, Zf, ep = class {
			_declareOutput(e, t) {
				return this._declareLocalVar(e.associatedVariableName, e.type, t)
			}
			_declareLocalVar(e, t, i) {
				return 1 === this.shaderLanguage ? `${i?"const":"var"} ${e}: ${this._getShaderType(t)}` : `${this._getShaderType(t)} ${e}`
			}
			_generateTextureSampleCubeLOD(e, t, i) {
				return 1 === this.shaderLanguage ? `${this._samplerCubeFunc()}(${t},${t+"Sampler"}, ${e}, ${i})` : `${this._samplerCubeFunc()}(${t}, ${e}, ${i})`
			}
			_generateTextureSample(e, t) {
				return 1 === this.shaderLanguage ? `${this._samplerFunc()}(${t},${t+"Sampler"}, ${e})` : `${this._samplerFunc()}(${t}, ${e})`
			}
			_emitExtension(e, t, i = "") {
				this.extensions[e] || (i && (t = `#if ${i}\n${t}\n#endif`), this.extensions[e] = t)
			}
			_toLinearSpace(e) {
				return 1 === this.shaderLanguage && (e.type === Wf.Color3 || e.type === Wf.Vector3) ? `toLinearSpaceVec3(${e.associatedVariableName})` : `toLinearSpace(${e.associatedVariableName})`
			}
			_generateTextureSampleCube(e, t) {
				return 1 === this.shaderLanguage ? `${this._samplerCubeFunc()}(${t},${t+"Sampler"}, ${e})` : `${this._samplerCubeFunc()}(${t}, ${e})`
			}
			_excludeVariableName(e) {
				this.sharedData.variableNames[e] = 0
			}
			_emitFunctionFromInclude(t, i, s, n = "") {
				const a = t + n;
				if (this.functions[a]) return;
				const r = e.GetIncludesShadersStore(this.shaderLanguage);
				if (!(s && (s.removeAttributes || s.removeUniforms || s.removeVaryings || s.removeIfDef || s.replaceStrings))) return s && s.repeatKey ? this.functions[a] = `#include<${t}>${s.substitutionVars?"("+s.substitutionVars+")":""}[0..${s.repeatKey}]\n` : this.functions[a] = `#include<${t}>${s?.substitutionVars?"("+s?.substitutionVars+")":""}\n`, void(this.sharedData.emitComments && (this.functions[a] = i + "\n" + this.functions[a]));
				if (this.functions[a] = r[t], this.sharedData.emitComments && (this.functions[a] = i + "\n" + this.functions[a]), s.removeIfDef && (this.functions[a] = this.functions[a].replace(/^\s*?#ifdef.+$/gm, ""), this.functions[a] = this.functions[a].replace(/^\s*?#endif.*$/gm, ""), this.functions[a] = this.functions[a].replace(/^\s*?#else.*$/gm, ""), this.functions[a] = this.functions[a].replace(/^\s*?#elif.*$/gm, "")), s.removeAttributes && (this.functions[a] = this.functions[a].replace(/\s*?attribute .+?;/g, "\n")), s.removeUniforms && (this.functions[a] = this.functions[a].replace(/\s*?uniform .*?;/g, "\n")), s.removeVaryings && (this.functions[a] = this.functions[a].replace(/\s*?(varying|in) .+?;/g, "\n")), s.replaceStrings)
					for (let e = 0; e < s.replaceStrings.length; e++) {
						const t = s.replaceStrings[e];
						this.functions[a] = this.functions[a].replace(t.search, t.replace)
					}
			}
			_emitCodeFromInclude(t, i, s) {
				const n = e.GetIncludesShadersStore(this.shaderLanguage);
				if (s && s.repeatKey) return `#include<${t}>${s.substitutionVars?"("+s.substitutionVars+")":""}[0..${s.repeatKey}]\n`;
				let a = n[t] + "\n";
				if (this.sharedData.emitComments && (a = i + "\n" + a), !s) return a;
				if (s.replaceStrings)
					for (let e = 0; e < s.replaceStrings.length; e++) {
						const t = s.replaceStrings[e];
						a = a.replace(t.search, t.replace)
					}
				return a
			}
			_convertInnerFunctionsToWGSL(e) {
				return e.replace(new RegExp("inversesqrt", "g"), "inverseSqrt")
			}
			_emitVaryingFromString(e, t, i = "", s = !1) {
				if (-1 !== this.sharedData.varyings.indexOf(e)) return !1;
				this.sharedData.varyings.push(e), i && (i.startsWith("defined(") ? this.sharedData.varyingDeclaration += `#if ${i}\n` : this.sharedData.varyingDeclaration += `${s?"#ifndef":"#ifdef"} ${i}\n`);
				const n = this._getShaderType(t);
				return 1 === this.shaderLanguage ? this.sharedData.varyingDeclaration += `varying ${e}: ${n};\n` : this.sharedData.varyingDeclaration += `varying ${n} ${e};\n`, i && (this.sharedData.varyingDeclaration += "#endif\n"), !0
			}
			get _repeatableContentAnchor() {
				return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`
			}
			_registerTempVariable(e) {
				return -1 === this.sharedData.temps.indexOf(e) && (this.sharedData.temps.push(e), !0)
			}
			_convertTernaryOperandsToWGSL(e) {
				return e.replace(new RegExp("\\[(.*?)\\?(.*?):(.*)\\]", "g"), ((e, t, i, s) => `select(${s}, ${i}, ${t})`))
			}
			_convertModOperatorsToWGSL(e) {
				return e.replace(new RegExp("mod\\((.+?),\\s*(.+?)\\)", "g"), ((e, t, i) => `((${t})%(${i}))`))
			}
			_convertConstToWGSL(e) {
				return e.replace(new RegExp("const var", "g"), "const")
			}
			_generateTernary(e, t, i) {
				return 1 === this.shaderLanguage ? `select(${t}, ${e}, ${i})` : `(${i}) ? ${e} : ${t}`
			}
			_generateTextureSampleLOD(e, t, i) {
				return 1 === this.shaderLanguage ? `${this._samplerLODFunc()}(${t},${t+"Sampler"}, ${e}, ${i})` : `${this._samplerLODFunc()}(${t}, ${e}, ${i})`
			}
			_convertFunctionsToWGSL(e) {
				const t = /var\s+(\w+)\s*:\s*(\w+)\((.*)\)/g;
				let i;
				for (; null !== (i = t.exec(e));) {
					const t = i[1],
						s = i[2],
						n = i[3].replace(/var\s/g, "");
					e = e.replace(i[0], `fn ${t}(${n}) -> ${s}`)
				}
				return e
			}
			finalize(e) {
				const t = e.sharedData.emitComments,
					i = this.target === Xf.Fragment;
				1 === this.shaderLanguage ? this.compilationString = i ? `\n${t?"//Entry point\n":""}@fragment\nfn main(input: FragmentInputs) -> FragmentOutputs {\n${this.compilationString}` : `\n${t?"//Entry point\n":""}@vertex\nfn main(input: VertexInputs) -> FragmentInputs{\n${this.compilationString}` : this.compilationString = `\n${t?"//Entry point\n":""}void main(void) {\n${this.compilationString}`, this._constantDeclaration && (this.compilationString = `\n${t?"//Constants\n":""}${this._constantDeclaration}\n${this.compilationString}`);
				let s = "";
				for (const e in this.functions) s += this.functions[e] + "\n";
				if (this.compilationString = `\n${s}\n${this.compilationString}`, !i && this._varyingTransfer && (this.compilationString = `${this.compilationString}\n${this._varyingTransfer}`), this._injectAtEnd && (this.compilationString = `${this.compilationString}\n${this._injectAtEnd}`), this.compilationString = `${this.compilationString}\n}`, this.sharedData.varyingDeclaration && (this.compilationString = `\n${t?"//Varyings\n":""}${this.sharedData.varyingDeclaration}\n${this.compilationString}`), this._samplerDeclaration && (this.compilationString = `\n${t?"//Samplers\n":""}${this._samplerDeclaration}\n${this.compilationString}`), this._uniformDeclaration && (this.compilationString = `\n${t?"//Uniforms\n":""}${this._uniformDeclaration}\n${this.compilationString}`), this._attributeDeclaration && !i && (this.compilationString = `\n${t?"//Attributes\n":""}${this._attributeDeclaration}\n${this.compilationString}`), 1 !== this.shaderLanguage) {
					this.compilationString = "precision highp float;\n" + this.compilationString, this.compilationString = "#if defined(WEBGL2) || defined(WEBGPU)\nprecision highp sampler2DArray;\n#endif\n" + this.compilationString, i && (this.compilationString = "#if defined(PREPASS)\r\n#extension GL_EXT_draw_buffers : require\r\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r\nhighp vec4 gl_FragColor;\r\n#endif\r\n" + this.compilationString);
					for (const e in this.extensions) {
						const t = this.extensions[e];
						this.compilationString = `\n${t}\n${this.compilationString}`
					}
				}
				this._builtCompilationString = this.compilationString
			}
			_emit2DSampler(e, t = "", i = !1) {
				(this.samplers.indexOf(e) < 0 || i) && (t && (this._samplerDeclaration += `#if ${t}\n`), 1 === this.shaderLanguage ? (this._samplerDeclaration += `var ${e+"Sampler"}: sampler;\n`, this._samplerDeclaration += `var ${e}: texture_2d<f32>;\n`) : this._samplerDeclaration += `uniform sampler2D ${e};\n`, t && (this._samplerDeclaration += "#endif\n"), i || this.samplers.push(e))
			}
			_getGLType(e) {
				switch (e) {
					case Wf.Float:
						return "float";
					case Wf.Int:
						return "int";
					case Wf.Vector2:
						return "vec2";
					case Wf.Color3:
					case Wf.Vector3:
						return "vec3";
					case Wf.Color4:
					case Wf.Vector4:
						return "vec4";
					case Wf.Matrix:
						return "mat4"
				}
				return ""
			}
			_babylonSLtoWGSL(e) {
				return e = this._convertVariableDeclarationToWGSL("void", "voidnull", e), e = this._convertVariableDeclarationToWGSL("bool", "bool", e), e = this._convertVariableDeclarationToWGSL("int", "i32", e), e = this._convertVariableDeclarationToWGSL("uint", "u32", e), e = this._convertVariableDeclarationToWGSL("float", "f32", e), e = this._convertVariableDeclarationToWGSL("vec2", "vec2f", e), e = this._convertVariableDeclarationToWGSL("vec3", "vec3f", e), e = this._convertVariableDeclarationToWGSL("vec4", "vec4f", e), e = this._convertVariableDeclarationToWGSL("mat2", "mat2x2f", e), e = this._convertVariableDeclarationToWGSL("mat3", "mat3x3f", e), e = this._convertVariableDeclarationToWGSL("mat4", "mat4x4f", e), e = this._convertVariableConstructorsToWGSL("float", "f32", e), e = this._convertVariableConstructorsToWGSL("vec2", "vec2f", e), e = this._convertVariableConstructorsToWGSL("vec3", "vec3f", e), e = this._convertVariableConstructorsToWGSL("vec4", "vec4f", e), e = this._convertVariableConstructorsToWGSL("mat2", "mat2x2f", e), e = this._convertVariableConstructorsToWGSL("mat3", "mat3x3f", e), e = this._convertVariableConstructorsToWGSL("mat4", "mat4x4f", e), e = this._convertTernaryOperandsToWGSL(e), e = this._convertModOperatorsToWGSL(e), e = this._convertConstToWGSL(e), e = this._convertInnerFunctionsToWGSL(e), e = (e = this._convertOutParametersToWGSL(e)).replace(/\[\*\]/g, "*"), e = (e = (e = (e = this._convertFunctionsToWGSL(e)).replace(/\s->\svoidnull/g, "")).replace(/dFdx/g, "dpdx")).replace(/dFdy/g, "dpdy")
			}
			_getFreeVariableName(e) {
				return e = e.replace(/[^a-zA-Z_]+/g, ""), void 0 === this.sharedData.variableNames[e] ? (this.sharedData.variableNames[e] = 0, "output" === e || "texture" === e ? e + this.sharedData.variableNames[e] : e) : (this.sharedData.variableNames[e]++, e + this.sharedData.variableNames[e])
			}
			_getFreeDefineName(e) {
				return void 0 === this.sharedData.defineNames[e] ? this.sharedData.defineNames[e] = 0 : this.sharedData.defineNames[e]++, e + this.sharedData.defineNames[e]
			}
			_convertOutParametersToWGSL(e) {
				return e.replace(new RegExp("out\\s+var\\s+(\\w+)\\s*:\\s*(\\w+)", "g"), "$1: ptr<function, $2>")
			}
			_emitFloat(e) {
				return e.toString() === e.toFixed(0) ? `${e}.0` : e.toString()
			}
			_getShaderType(e) {
				const t = 1 === this.shaderLanguage;
				switch (e) {
					case Wf.Float:
						return t ? "f32" : "float";
					case Wf.Int:
						return t ? "i32" : "int";
					case Wf.Vector2:
						return t ? "vec2f" : "vec2";
					case Wf.Color3:
					case Wf.Vector3:
						return t ? "vec3f" : "vec3";
					case Wf.Color4:
					case Wf.Vector4:
						return t ? "vec4f" : "vec4";
					case Wf.Matrix:
						return t ? "mat4x4f" : "mat4"
				}
				return ""
			}
			_emitFunction(e, t, i) {
				this.functions[e] || (this.sharedData.emitComments && (t = i + "\n" + t), this.functions[e] = t)
			}
			constructor() {
				this.supportUniformBuffers = !1, this.attributes = [], this.uniforms = [], this.constants = [], this.samplers = [], this.functions = {}, this.extensions = {}, this.prePassOutput = {}, this.counters = {}, this._attributeDeclaration = "", this._uniformDeclaration = "", this._constantDeclaration = "", this._samplerDeclaration = "", this._varyingTransfer = "", this._injectAtEnd = "", this._repeatableContentAnchorIndex = 0, this._builtCompilationString = "", this.compilationString = ""
			}
			_getVaryingName(e) {
				return 1 === this.shaderLanguage ? (this.target !== Xf.Fragment ? "vertexOutputs." : "fragmentInputs.") + e : e
			}
			get fSuffix() {
				return 1 === this.shaderLanguage ? "f" : ""
			}
			_convertTernaryOperandsToGLSL(e) {
				return e.replace(new RegExp("\\[(.+?)\\?(.+?):(.+)\\]", "g"), ((e, t, i, s) => `${t} ? ${i} : ${s}`))
			}
			_emitCubeSampler(e, t = "", i = !1) {
				(this.samplers.indexOf(e) < 0 || i) && (t && (this._samplerDeclaration += `#if ${t}\n`), 1 === this.shaderLanguage ? (this._samplerDeclaration += `var ${e+"Sampler"}: sampler;\n`, this._samplerDeclaration += `var ${e}: texture_cube<f32>;\n`) : this._samplerDeclaration += `uniform samplerCube ${e};\n`, t && (this._samplerDeclaration += "#endif\n"), i || this.samplers.push(e))
			}
			_emit2DArraySampler(e) {
				this.samplers.indexOf(e) < 0 && (this._samplerDeclaration += `uniform sampler2DArray ${e};\n`, this.samplers.push(e))
			}
			_emitUniformFromString(e, t, i = "", s = !1) {
				if (-1 !== this.uniforms.indexOf(e)) return;
				this.uniforms.push(e), i && (i.startsWith("defined(") ? this._uniformDeclaration += `#if ${i}\n` : this._uniformDeclaration += `${s?"#ifndef":"#ifdef"} ${i}\n`);
				const n = this._getShaderType(t);
				1 === this.shaderLanguage ? this._uniformDeclaration += `uniform ${e}: ${n};\n` : this._uniformDeclaration += `uniform ${n} ${e};\n`, i && (this._uniformDeclaration += "#endif\n")
			}
			get shaderLanguage() {
				return this.sharedData.nodeMaterial.shaderLanguage
			}
			_samplerCubeFunc() {
				return 1 === this.shaderLanguage ? "textureSample" : "textureCube"
			}
			_samplerFunc() {
				return 1 === this.shaderLanguage ? "textureSample" : "texture2D"
			}
			_samplerLODFunc() {
				return 1 === this.shaderLanguage ? "textureSampleLevel" : "texture2DLodEXT"
			}
			_convertVariableDeclarationToWGSL(e, t, i) {
				return i.replace(new RegExp(`(${e})\\s+(\\w+)`, "g"), `var $2: ${t}`)
			}
			_babylonSLtoGLSL(e) {
				return e = e.replace(/\[\*\]/g, ""), e = this._convertTernaryOperandsToGLSL(e)
			}
			_convertVariableConstructorsToWGSL(e, t, i) {
				return i.replace(new RegExp(`(${e})\\(`, "g"), ` ${t}(`)
			}
		},
		tp = class {
			constructor() {
				this.temps = [], this.varyings = [], this.varyingDeclaration = "", this.inputBlocks = [], this.textureBlocks = [], this.bindableBlocks = [], this.forcedBindableBlocks = [], this.blocksWithFallbacks = [], this.blocksWithDefines = [], this.repeatableContentBlocks = [], this.dynamicUniformBlocks = [], this.blockingBlocks = [], this.animatedInputs = [], this.variableNames = {}, this.defineNames = {}, this.hints = {
					needWorldViewMatrix: !1,
					needWorldViewProjectionMatrix: !1,
					needAlphaBlending: !1,
					needAlphaTesting: !1
				}, this.checks = {
					emitVertex: !1,
					emitFragment: !1,
					notConnectedNonOptionalInputs: new Array
				}, this.allowEmptyVertexProgram = !1, this.variableNames.position = 0, this.variableNames.normal = 0, this.variableNames.tangent = 0, this.variableNames.uv = 0, this.variableNames.uv2 = 0, this.variableNames.uv3 = 0, this.variableNames.uv4 = 0, this.variableNames.uv5 = 0, this.variableNames.uv6 = 0, this.variableNames.color = 0, this.variableNames.matricesIndices = 0, this.variableNames.matricesWeights = 0, this.variableNames.matricesIndicesExtra = 0, this.variableNames.matricesWeightsExtra = 0, this.variableNames.diffuseBase = 0, this.variableNames.specularBase = 0, this.variableNames.worldPos = 0, this.variableNames.shadow = 0, this.variableNames.view = 0, this.variableNames.vTBN = 0, this.defineNames.MAINUV0 = 0, this.defineNames.MAINUV1 = 0, this.defineNames.MAINUV2 = 0, this.defineNames.MAINUV3 = 0, this.defineNames.MAINUV4 = 0, this.defineNames.MAINUV5 = 0, this.defineNames.MAINUV6 = 0, this.defineNames.MAINUV7 = 0
			}
			emitErrors() {
				let e = "";
				this.checks.emitVertex || this.allowEmptyVertexProgram || (e += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\n"), this.checks.emitFragment || (e += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\n");
				for (const t of this.checks.notConnectedNonOptionalInputs) e += `input ${t.name} from block ${t.ownerBlock.name}[${t.ownerBlock.getClassName()}] is not connected and is not optional.\n`;
				if (e) throw "Build of NodeMaterial failed:\n" + e
			}
		},
		ip = class {
			markAsImageProcessingDirty() {
				this._areImageProcessingDirty = !0, this._isDirty = !0
			}
			isEqual(e) {
				if (this._keys.length !== e._keys.length) return !1;
				for (let t = 0; t < this._keys.length; t++) {
					const i = this._keys[t];
					if (this[i] !== e[i]) return !1
				}
				return !0
			}
			toString() {
				let e = "";
				for (let t = 0; t < this._keys.length; t++) {
					const i = this._keys[t],
						s = this[i];
					switch (typeof s) {
						case "number":
						case "string":
							e += "#define " + i + " " + s + "\n";
							break;
						default:
							s && (e += "#define " + i + "\n")
					}
				}
				return e
			}
			markAsPrePassDirty() {
				this._arePrePassDirty = !0, this._isDirty = !0
			}
			markAsFresnelDirty() {
				this._areFresnelDirty = !0, this._isDirty = !0
			}
			_setDefaultValue(e) {
				const t = this._externalProperties?.[e]?.type ?? typeof this[e],
					i = this._externalProperties?.[e]?.default;
				switch (t) {
					case "number":
						this[e] = i ?? 0;
						break;
					case "string":
						this[e] = i ?? "";
						break;
					default:
						this[e] = i ?? !1
				}
			}
			constructor(e) {
				if (this._keys = [], this._isDirty = !0, this._areLightsDirty = !0, this._areLightsDisposed = !1, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1, this._externalProperties = e, e)
					for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t)
			}
			cloneTo(e) {
				this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
				for (let t = 0; t < this._keys.length; t++) {
					const i = this._keys[t];
					e[i] = this[i]
				}
			}
			markAsProcessed() {
				this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areLightsDisposed = !1, this._areMiscDirty = !1, this._arePrePassDirty = !1, this._areImageProcessingDirty = !1
			}
			rebuild() {
				this._keys.length = 0;
				for (const e of Object.keys(this)) "_" !== e[0] && this._keys.push(e);
				if (this._externalProperties)
					for (const e in this._externalProperties) - 1 === this._keys.indexOf(e) && this._keys.push(e)
			}
			reset() {
				this._keys.forEach((e => this._setDefaultValue(e)))
			}
			markAsUnprocessed() {
				this._isDirty = !0
			}
			markAsLightDirty(e = !1) {
				this._areLightsDirty = !0, this._areLightsDisposed = this._areLightsDisposed || e, this._isDirty = !0
			}
			markAsMiscDirty() {
				this._areMiscDirty = !0, this._isDirty = !0
			}
			markAsTexturesDirty() {
				this._areTexturesDirty = !0, this._isDirty = !0
			}
			get isDirty() {
				return this._isDirty
			}
			markAllAsDirty() {
				this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !1, this._areImageProcessingDirty = !0, this._isDirty = !0
			}
			markAsAttributesDirty() {
				this._areAttributesDirty = !0, this._isDirty = !0
			}
		};
	(qf = Jf || (Jf = {}))[qf.Compatible = 0] = "Compatible", qf[qf.TypeIncompatible = 1] = "TypeIncompatible", qf[qf.TargetIncompatible = 2] = "TargetIncompatible", qf[qf.HierarchyIssue = 3] = "HierarchyIssue", (Zf = Qf || (Qf = {}))[Zf.Input = 0] = "Input", Zf[Zf.Output = 1] = "Output";
	var sp = class e {
			get connectedPoint() {
				return this._connectedPoint
			}
			get connectInputBlock() {
				return this.isConnectedToInputBlock ? this.connectedPoint.ownerBlock : null
			}
			get innerType() {
				return this._linkedConnectionSource && this._linkedConnectionSource.isConnected ? this.type : this._type
			}
			get _linkedConnectionSource() {
				return this._linkedConnectionSourceBackingField
			}
			checkCompatibilityState(t) {
				const i = this._ownerBlock,
					s = t.ownerBlock;
				if (i.target === Xf.Fragment) {
					if (s.target === Xf.Vertex) return 2;
					for (const e of s.outputs)
						if (e.ownerBlock.target != Xf.Neutral && e.isConnectedInVertexShader) return 2
				}
				if (this.type !== t.type && t.innerType !== Wf.AutoDetect) return e.AreEquivalentTypes(this.type, t.type) || t.acceptedConnectionPointTypes && -1 !== t.acceptedConnectionPointTypes.indexOf(this.type) || t._acceptedConnectionPointType && e.AreEquivalentTypes(t._acceptedConnectionPointType.type, this.type) ? 0 : 1;
				if (t.excludedConnectionPointTypes && -1 !== t.excludedConnectionPointTypes.indexOf(this.type)) return 1;
				let n = s,
					a = i;
				return 0 === this.direction && (n = i, a = s), n.isAnAncestorOf(a) ? 3 : 0
			}
			dispose() {
				this.onConnectionObservable.clear(), this.onDisconnectionObservable.clear(), this.onTypeChangedObservable.clear(), this._connectedPoint = null, this._typeConnectionSource = null, this._linkedConnectionSource = null
			}
			constructor(e, t, i) {
				this._connectedPointBackingField = null, this._endpoints = new Array, this._typeConnectionSourceBackingField = null, this._defaultConnectionPointTypeBackingField = null, this._linkedConnectionSourceBackingField = null, this._acceptedConnectionPointType = null, this._type = Wf.Float, this._enforceAssociatedVariableName = !1, this.needDualDirectionValidation = !1, this.acceptedConnectionPointTypes = [], this.excludedConnectionPointTypes = [], this.onConnectionObservable = new kc, this.onDisconnectionObservable = new kc, this.onTypeChangedObservable = new kc, this._isTypeChangeObservableNotifying = !1, this.isExposedOnFrame = !1, this.exposedPortPosition = -1, this._prioritizeVertex = !1, this._target = Xf.VertexAndFragment, this._ownerBlock = t, this.name = e, this._direction = i
			}
			get direction() {
				return this._direction
			}
			serialize(e = !0) {
				const t = {};
				return t.name = this.name, t.displayName = this.displayName, e && this.connectedPoint && (t.inputName = this.name, t.targetBlockId = this.connectedPoint.ownerBlock.ik, t.targetConnectionName = this.connectedPoint.name, t.isExposedOnFrame = !0, t.exposedPortPosition = this.exposedPortPosition), (this.isExposedOnFrame || this.exposedPortPosition >= 0) && (t.isExposedOnFrame = !0, t.exposedPortPosition = this.exposedPortPosition), t
			}
			get ownerBlock() {
				return this._ownerBlock
			}
			_updateTypeDependentState(e) {
				const t = this.type;
				e(), this.type !== t && this._notifyTypeChanged()
			}
			createCustomInputBlock() {
				return null
			}
			get _defaultConnectionPointType() {
				return this._defaultConnectionPointTypeBackingField
			}
			connectTo(e, t = !1) {
				if (!t && !this.canConnectTo(e)) throw "Cannot connect these two connectors.";
				return this._endpoints.push(e), e._connectedPoint = this, this._enforceAssociatedVariableName = !1, this.onConnectionObservable.notifyObservers(e), e.onConnectionObservable.notifyObservers(this), this
			}
			get isConnectedToInputBlock() {
				return null !== this.connectedPoint && this.connectedPoint.ownerBlock.isInput
			}
			get declarationVariableName() {
				return this._ownerBlock.isInput ? this._ownerBlock.declarationVariableName : this._enforceAssociatedVariableName && this._associatedVariableName || !this._connectedPoint ? this._associatedVariableName : this._connectedPoint.declarationVariableName
			}
			get isConnectedInFragmentShader() {
				if (this.target === Xf.Fragment) return !0;
				if (!this.hasEndpoints) return !1;
				for (const e of this._endpoints) {
					if (e.ownerBlock.target === Xf.Fragment) return !0;
					if ((e.ownerBlock.target === Xf.Neutral || e.ownerBlock.target === Xf.VertexAndFragment) && e.ownerBlock.isConnectedInFragmentShader()) return !0
				}
				return !1
			}
			get type() {
				if (this._type === Wf.AutoDetect) {
					if (this._ownerBlock.isInput) return this._ownerBlock.type;
					if (this._connectedPoint) return this._connectedPoint.type;
					if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) return this._linkedConnectionSource.type
				}
				if (this._type === Wf.BasedOnInput) {
					if (this._typeConnectionSource) return !this._typeConnectionSource.isConnected && this._defaultConnectionPointType ? this._defaultConnectionPointType : this._typeConnectionSource.type;
					if (this._defaultConnectionPointType) return this._defaultConnectionPointType
				}
				return this._type
			}
			get isDirectlyConnectedToVertexOutput() {
				if (!this.hasEndpoints) return !1;
				for (const e of this._endpoints) {
					if (e.ownerBlock.target === Xf.Vertex) return !0;
					if ((e.ownerBlock.target === Xf.Neutral || e.ownerBlock.target === Xf.VertexAndFragment) && e.ownerBlock.outputs.some((e => e.isDirectlyConnectedToVertexOutput))) return !0
				}
				return !1
			}
			set _defaultConnectionPointType(e) {
				this._updateTypeDependentState((() => this._defaultConnectionPointTypeBackingField = e))
			}
			get target() {
				return this._prioritizeVertex && this._ownerBlock ? this._target !== Xf.VertexAndFragment ? this._target : this._ownerBlock.target === Xf.Fragment ? Xf.Fragment : Xf.Vertex : this._target
			}
			addExcludedConnectionPointFromAllowedTypes(e) {
				let t = 1;
				for (; t < Wf.All;) e & t || this.excludedConnectionPointTypes.push(t), t <<= 1
			}
			get isConnectedInVertexShader() {
				if (this.target === Xf.Vertex) return !0;
				if (!this.hasEndpoints) return !1;
				for (const e of this._endpoints) {
					if (e.ownerBlock.target === Xf.Vertex) return !0;
					if (e.target === Xf.Vertex) return !0;
					if ((e.ownerBlock.target === Xf.Neutral || e.ownerBlock.target === Xf.VertexAndFragment) && e.ownerBlock.outputs.some((e => e.isConnectedInVertexShader))) return !0
				}
				return !1
			}
			get _typeConnectionSource() {
				return this._typeConnectionSourceBackingField
			}
			get sourceBlock() {
				return this._connectedPoint ? this._connectedPoint.ownerBlock : null
			}
			static AreEquivalentTypes(e, t) {
				switch (e) {
					case Wf.Vector3:
						if (t === Wf.Color3) return !0;
						break;
					case Wf.Vector4:
						if (t === Wf.Color4) return !0;
						break;
					case Wf.Color3:
						if (t === Wf.Vector3) return !0;
						break;
					case Wf.Color4:
						if (t === Wf.Vector4) return !0
				}
				return !1
			}
			set _typeConnectionSource(e) {
				this._typeConnectionSourceBackingField !== e && (this._typeConnectionSourceTypeChangedObserver?.remove(), this._updateTypeDependentState((() => this._typeConnectionSourceBackingField = e)), this._typeConnectionSourceBackingField && (this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add((() => {
					this._notifyTypeChanged()
				}))))
			}
			disconnectFrom(e) {
				const t = this._endpoints.indexOf(e);
				return -1 === t || (this._endpoints.splice(t, 1), e._connectedPoint = null, this._enforceAssociatedVariableName = !1, e._enforceAssociatedVariableName = !1, this.onDisconnectionObservable.notifyObservers(e), e.onDisconnectionObservable.notifyObservers(this)), this
			}
			set target(e) {
				this._target = e
			}
			get hasEndpoints() {
				return this._endpoints && this._endpoints.length > 0
			}
			set _linkedConnectionSource(e) {
				this._linkedConnectionSourceBackingField !== e && (this._linkedConnectionSourceTypeChangedObserver?.remove(), this._updateTypeDependentState((() => this._linkedConnectionSourceBackingField = e)), this._linkedConnectionSourceBackingField && (this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add((() => {
					this._notifyTypeChanged()
				}))))
			}
			set type(e) {
				this._updateTypeDependentState((() => this._type = e))
			}
			canConnectTo(e) {
				return 0 === this.checkCompatibilityState(e)
			}
			set _connectedPoint(e) {
				this._connectedPointBackingField !== e && (this._connectedPointTypeChangedObserver?.remove(), this._updateTypeDependentState((() => this._connectedPointBackingField = e)), this._connectedPointBackingField && (this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add((() => {
					this._notifyTypeChanged()
				}))))
			}
			get endpoints() {
				return this._endpoints
			}
			get connectedBlocks() {
				return 0 === this._endpoints.length ? [] : this._endpoints.map((e => e.ownerBlock))
			}
			set associatedVariableName(e) {
				this._associatedVariableName = e
			}
			get isConnected() {
				return null !== this.connectedPoint || this.hasEndpoints
			}
			get associatedVariableName() {
				return this._ownerBlock.isInput ? this._ownerBlock.associatedVariableName : this._enforceAssociatedVariableName && this._associatedVariableName || !this._connectedPoint ? this._associatedVariableName : this._connectedPoint.associatedVariableName
			}
			getClassName() {
				return "NodeMaterialConnectionPoint"
			}
			_notifyTypeChanged() {
				this._isTypeChangeObservableNotifying || (this._isTypeChangeObservableNotifying = !0, this.onTypeChangedObservable.notifyObservers(this.type), this._isTypeChangeObservableNotifying = !1)
			}
			get _connectedPoint() {
				return this._connectedPointBackingField
			}
		},
		np = class {
			static get UniqueId() {
				const e = this._UniqueIdCounter;
				return this._UniqueIdCounter++, e
			}
		};
	np._UniqueIdCounter = 1;
	var ap = class {
			clone(e, t = "") {
				const i = this.serialize(),
					s = uc(i.customType);
				if (s) {
					const n = new s;
					return n._deserialize(i, e, t), n
				}
				return null
			}
			isAnAncestorOf(e) {
				for (const t of this._outputs)
					if (t.hasEndpoints)
						for (const i of t.endpoints) {
							if (i.ownerBlock === e) return !0;
							if (i.ownerBlock.isAnAncestorOf(e)) return !0
						}
				return !1
			}
			_buildBlock(e) {}
			registerInput(e, t, i = !1, s, n) {
				return (n = n ?? new sp(e, this, 0)).type = t, n.isOptional = i, s && (n.target = s), this._inputs.push(n), this
			}
			getFirstAvailableOutput(e = null) {
				for (const t of this._outputs)
					if (!e || !e.target || e.target === Xf.Neutral || e.target & t.target) return t;
				return null
			}
			set target(e) {
				this._target & e || (this._target = e)
			}
			dispose() {
				this.onCodeIsReadyObservable.clear();
				for (const e of this.inputs) e.dispose();
				for (const e of this.outputs) e.dispose()
			}
			_writeFloat(e) {
				let t = e.toString();
				return -1 === t.indexOf(".") && (t += ".0"), `${t}`
			}
			isReady(e, t, i, s = !1) {
				return !0
			}
			get codeIsReady() {
				return this._codeIsReady
			}
			get name() {
				return this._name
			}
			provideFallbacks(e, t) {}
			_setInitialTarget(e) {
				this._target = e, this._originalTargetIsNeutral = e === Xf.Neutral
			}
			_linkConnectionTypes(e, t, i = !1) {
				i ? this._inputs[t]._acceptedConnectionPointType = this._inputs[e] : this._inputs[e]._linkedConnectionSource = this._inputs[t], this._inputs[t]._linkedConnectionSource = this._inputs[e]
			}
			prepareDefines(e, t, i, s = !1, n) {}
			set name(e) {
				this.validateBlockName(e) && (this._name = e)
			}
			get buildId() {
				return this._buildId
			}
			_inputRename(e) {
				return e
			}
			getSiblingOutput(e) {
				const t = this._outputs.indexOf(e);
				return -1 === t || t >= this._outputs.length ? null : this._outputs[t + 1]
			}
			_dumpCodeForOutputConnections(e) {
				let t = "";
				if (-1 !== e.indexOf(this)) return t;
				e.push(this);
				for (const i of this.inputs) {
					if (!i.isConnected) continue;
					const s = i.connectedPoint,
						n = s.ownerBlock;
					t += n._dumpCodeForOutputConnections(e), t += `${n._codeVariableName}.${n._outputRename(s.name)}.connectTo(${this._codeVariableName}.${this._inputRename(i.name)});\n`
				}
				return t
			}
			initialize(e) {}
			bind(e, t, i, s) {}
			build(e, t) {
				if (this._buildId === e.sharedData.buildId) return !0;
				if (!this.isInput)
					for (const t of this._outputs) t.associatedVariableName || (t.associatedVariableName = e._getFreeVariableName(t.name));
				for (const i of this._inputs) {
					if (!i.connectedPoint) {
						i.isOptional || e.sharedData.checks.notConnectedNonOptionalInputs.push(i);
						continue
					}
					if (this.target !== Xf.Neutral) {
						if (!(i.target & this.target)) continue;
						if (!(i.target & e.target)) continue
					}
					const s = i.connectedPoint.ownerBlock;
					s && s !== this && this._processBuild(s, e, i, t)
				}
				if (this._customBuildStep(e, t), this._buildId === e.sharedData.buildId) return !0;
				if (e.sharedData.verbose && Qc.Log(`${e.target===Xf.Vertex?"Vertex shader":"Fragment shader"}: Building ${this.name} [${this.getClassName()}]`), this.isFinalMerger) switch (e.target) {
					case Xf.Vertex:
						e.sharedData.checks.emitVertex = !0;
						break;
					case Xf.Fragment:
						e.sharedData.checks.emitFragment = !0
				}!this.isInput && e.sharedData.emitComments && (e.compilationString += `\n//${this.name}\n`), this._buildBlock(e), this._buildId = e.sharedData.buildId, this._buildTarget = e.target;
				for (const i of this._outputs)
					if (i.target & e.target)
						for (const s of i.endpoints) {
							const i = s.ownerBlock;
							i && i.target & e.target && -1 !== t.indexOf(i) && this._processBuild(i, e, s, t)
						}
				return !1
			}
			initializeDefines(e, t, i, s = !1) {}
			_writeVariable(e) {
				return e.connectedPoint ? `${e.associatedVariableName}` : "0."
			}
			get isUnique() {
				return this._isUnique
			}
			get outputs() {
				return this._outputs
			}
			_customBuildStep(e, t) {}
			serialize() {
				const e = {};
				e.customType = "BABYLON." + this.getClassName(), e.id = this.ik, e.name = this.name, e.comments = this.comments, e.visibleInInspector = this.visibleInInspector, e.visibleOnFrame = this.visibleOnFrame, e.target = this.target, e.inputs = [], e.outputs = [];
				for (const t of this.inputs) e.inputs.push(t.serialize());
				for (const t of this.outputs) e.outputs.push(t.serialize(!1));
				return e
			}
			get inputs() {
				return this._inputs
			}
			getClassName() {
				return "NodeMaterialBlock"
			}
			isConnectedInFragmentShader() {
				return this.outputs.some((e => e.isConnectedInFragmentShader))
			}
			get isFinalMerger() {
				return this._isFinalMerger
			}
			_deserializePortDisplayNamesAndExposedOnFrame(e) {
				const t = e.inputs,
					i = e.outputs;
				t && t.forEach(((e, t) => {
					e.displayName && (this.inputs[t].displayName = e.displayName), e.isExposedOnFrame && (this.inputs[t].isExposedOnFrame = e.isExposedOnFrame, this.inputs[t].exposedPortPosition = e.exposedPortPosition)
				})), i && i.forEach(((e, t) => {
					e.displayName && (this.outputs[t].displayName = e.displayName), e.isExposedOnFrame && (this.outputs[t].isExposedOnFrame = e.isExposedOnFrame, this.outputs[t].exposedPortPosition = e.exposedPortPosition)
				}))
			}
			get target() {
				return this._target
			}
			_dumpCode(e, t) {
				t.push(this);
				const i = this.name.replace(/[^A-Za-z_]+/g, "");
				if (this._codeVariableName = i || `${this.getClassName()}_${this.ik}`, -1 !== e.indexOf(this._codeVariableName)) {
					let t = 0;
					do {
						t++, this._codeVariableName = i + t
					} while (-1 !== e.indexOf(this._codeVariableName))
				}
				e.push(this._codeVariableName);
				let s = `\n// ${this.getClassName()}\n`;
				this.comments && (s += `// ${this.comments}\n`), s += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");\n`, s += this._dumpPropertiesCode();
				for (const i of this.inputs) {
					if (!i.isConnected) continue;
					const n = i.connectedPoint.ownerBlock; - 1 === t.indexOf(n) && (s += n._dumpCode(e, t))
				}
				for (const i of this.outputs)
					if (i.hasEndpoints)
						for (const n of i.endpoints) {
							const i = n.ownerBlock;
							i && -1 === t.indexOf(i) && (s += i._dumpCode(e, t))
						}
				return s
			}
			getInputByName(e) {
				const t = this._inputs.filter((t => t.name === e));
				return t.length ? t[0] : null
			}
			_deserialize(e, t, i, s) {
				this.name = e.name, this.comments = e.comments, this.visibleInInspector = !!e.visibleInInspector, this.visibleOnFrame = !!e.visibleOnFrame, this._target = e.target ?? this.target, this._deserializePortDisplayNamesAndExposedOnFrame(e)
			}
			registerOutput(e, t, i, s) {
				return (s = s ?? new sp(e, this, 1)).type = t, i && (s.target = i), this._outputs.push(s), this
			}
			connectTo(e, t) {
				if (0 === this._outputs.length) return;
				let i = t && t.output ? this.getOutputByName(t.output) : this.getFirstAvailableOutput(e),
					s = !0;
				for (; s;) {
					const n = t && t.input ? e.getInputByName(t.input) : e.getFirstAvailableInput(i);
					if (i && n && i.canConnectTo(n)) i.connectTo(n), s = !1;
					else {
						if (!i) throw "Unable to find a compatible match";
						i = this.getSiblingOutput(i)
					}
				}
				return this
			}
			updateUniformsAndSamples(e, t, i, s) {}
			get isTeleportOut() {
				return this._isTeleportOut
			}
			replaceRepeatableContent(e, t, i, s) {}
			getFirstAvailableInput(e = null) {
				for (const t of this._inputs)
					if (!(t.connectedPoint || e && e.type !== t.type && t.type !== Wf.AutoDetect)) return t;
				return null
			}
			autoConfigure(e, t = () => !0) {}
			get willBeGeneratedIntoVertexShaderFromFragmentShader() {
				return !this.isInput && !this.isFinalMerger && (!this._outputs.some((e => e.isDirectlyConnectedToVertexOutput)) && (this.target !== Xf.Vertex && !(this.target !== Xf.VertexAndFragment && this.target !== Xf.Neutral || !this._outputs.some((e => e.isConnectedInVertexShader)))))
			}
			_outputRename(e) {
				return e
			}
			get isInput() {
				return this._isInput
			}
			_dumpPropertiesCode() {
				const e = this._codeVariableName;
				return `${e}.visibleInInspector = ${this.visibleInInspector};\n${e}.visibleOnFrame = ${this.visibleOnFrame};\n${e}.target = ${this.target};\n`
			}
			_processBuild(e, t, i, s) {
				e.build(t, s);
				const n = null != t._vertexState,
					a = e._buildTarget === Xf.Vertex && e.target !== Xf.VertexAndFragment;
				if (n && (!(e.target & e._buildTarget) || !(e.target & i.target) || this.target !== Xf.VertexAndFragment && a) && (!e.isInput && t.target !== e._buildTarget || e.isInput && e.isAttribute && !e._noContextSwitch)) {
					const e = i.connectedPoint;
					if (t._vertexState._emitVaryingFromString("v_" + e.declarationVariableName, e.type)) {
						const i = 1 === t.shaderLanguage ? "vertexOutputs." : "";
						t._vertexState.compilationString += `${i}${"v_"+e.declarationVariableName} = ${e.associatedVariableName};\n`
					}
					const s = 1 === t.shaderLanguage ? "fragmentInputs." : "";
					i.associatedVariableName = s + "v_" + e.declarationVariableName, i._enforceAssociatedVariableName = !0
				}
			}
			constructor(e, t = Xf.Vertex, i = !1) {
				this._isFinalMerger = !1, this._isInput = !1, this._isTeleportOut = !1, this._isTeleportIn = !1, this._name = "", this._isUnique = !1, this._codeIsReady = !0, this.onCodeIsReadyObservable = new kc, this.inputsAreExclusive = !1, this._codeVariableName = "", this._inputs = new Array, this._outputs = new Array, this.comments = "", this.visibleInInspector = !1, this.visibleOnFrame = !1, this._target = t, this._originalTargetIsNeutral = t === Xf.Neutral, this._isFinalMerger = i, this._isInput = "InputBlock" === this.getClassName(), this._isTeleportOut = "NodeMaterialTeleportOutBlock" === this.getClassName(), this._isTeleportIn = "NodeMaterialTeleportInBlock" === this.getClassName(), this._name = e, this.ik = np.UniqueId
			}
			getOutputByName(e) {
				const t = this._outputs.filter((t => t.name === e));
				return t.length ? t[0] : null
			}
			validateBlockName(e) {
				const t = ["position", "normal", "tangent", "particle_positionw", "uv", "uv2", "uv3", "uv4", "uv5", "uv6", "position2d", "particle_uv", "matricesIndices", "matricesWeights", "world0", "world1", "world2", "world3", "particle_color", "particle_texturemask"];
				for (const i of t)
					if (e === i) return !1;
				return !0
			}
			set buildId(e) {
				this._buildId = e
			}
			get isTeleportIn() {
				return this._isTeleportIn
			}
		},
		rp = class extends ap {
			get vector() {
				return this._inputs[0]
			}
			get xyz() {
				return this._outputs[1]
			}
			serialize() {
				const e = super.serialize();
				return e.complementZ = this.complementZ, e.complementW = this.complementW, e
			}
			_dumpPropertiesCode() {
				let e = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\n`;
				return e += `${this._codeVariableName}.complementW = ${this.complementW};\n`, e
			}
			_deserialize(e, t, i) {
				super._deserialize(e, t, i), this.complementZ = void 0 !== e.complementZ ? e.complementZ : 0, this.complementW = void 0 !== e.complementW ? e.complementW : 1
			}
			prepareDefines(e, t, i) {
				e.nonUniformScaling && i.setValue("NONUNIFORMSCALING", !0)
			}
			get transform() {
				return this._inputs[1]
			}
			constructor(e) {
				super(e, Xf.Neutral), this.complementW = 1, this.complementZ = 0, this.target = Xf.Vertex, this.registerInput("vector", Wf.AutoDetect), this.registerInput("transform", Wf.Matrix), this.registerOutput("output", Wf.Vector4), this.registerOutput("xyz", Wf.Vector3), this._inputs[0].onConnectionObservable.add((e => {
					if (e.ownerBlock.isInput) {
						const t = e.ownerBlock;
						"normal" !== t.name && "tangent" !== t.name || (this.complementW = 0)
					}
				}))
			}
			getClassName() {
				return "TransformBlock"
			}
			_buildBlock(e) {
				super._buildBlock(e);
				const t = this.vector,
					i = this.transform,
					s = e._getShaderType(Wf.Vector4),
					n = e._getShaderType(Wf.Vector3);
				if (t.connectedPoint) {
					if (0 === this.complementW) {
						const a = `//${this.name}`;
						e._emitFunctionFromInclude("helperFunctions", a), e.sharedData.blocksWithDefines.push(this);
						const r = e._getFreeVariableName(`${i.associatedVariableName}_NUS`);
						switch (1 === e.shaderLanguage ? e.compilationString += `var ${r}: mat3x3f = mat3x3f(${i.associatedVariableName}[0].xyz, ${i.associatedVariableName}[1].xyz, ${i.associatedVariableName}[2].xyz);\n` : e.compilationString += `mat3 ${r} = mat3(${i.associatedVariableName});\n`, e.compilationString += "#ifdef NONUNIFORMSCALING\n", e.compilationString += `${r} = transposeMat3(inverseMat3(${r}));\n`, e.compilationString += "#endif\n", t.connectedPoint.type) {
							case Wf.Vector2:
								e.compilationString += e._declareOutput(this.output) + ` = ${s}(${r} * ${n}(${t.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\n`;
								break;
							case Wf.Vector3:
							case Wf.Color3:
								e.compilationString += e._declareOutput(this.output) + ` = ${s}(${r} * ${t.associatedVariableName}, ${this._writeFloat(this.complementW)});\n`;
								break;
							default:
								e.compilationString += e._declareOutput(this.output) + ` = ${s}(${r} * ${t.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\n`
						}
					} else {
						const n = i.associatedVariableName;
						switch (t.connectedPoint.type) {
							case Wf.Vector2:
								e.compilationString += e._declareOutput(this.output) + ` = ${n} * ${s}(${t.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\n`;
								break;
							case Wf.Vector3:
							case Wf.Color3:
								e.compilationString += e._declareOutput(this.output) + ` = ${n} * ${s}(${t.associatedVariableName}, ${this._writeFloat(this.complementW)});\n`;
								break;
							default:
								e.compilationString += e._declareOutput(this.output) + ` = ${n} * ${t.associatedVariableName};\n`
						}
					}
					this.xyz.hasEndpoints && (e.compilationString += e._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;\n`)
				}
				return this
			}
			get output() {
				return this._outputs[0]
			}
		};
	cc("BABYLON.TransformBlock", rp);
	var op, lp, hp = class extends ap {
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this.vector,
				i = 1 === e.shaderLanguage;
			if (1 === e.shaderLanguage ? e.compilationString += `vertexOutputs.position = ${t.associatedVariableName};\n` : e.compilationString += `gl_Position = ${t.associatedVariableName};\n`, this._isLogarithmicDepthEnabled(e.sharedData.fragmentOutputNodes, e.sharedData.nodeMaterial.useLogarithmicDepth)) {
				e._emitUniformFromString("logarithmicDepthConstant", Wf.Float), e._emitVaryingFromString("vFragmentDepth", Wf.Float);
				const t = i ? "vertexOutputs.vFragmentDepth" : "vFragmentDepth",
					s = i ? "uniforms." : "",
					n = i ? "vertexOutputs.position" : "gl_Position";
				e.compilationString += `${t} = 1.0 + ${n}.w;\n`, e.compilationString += `${n}.z = log2(max(0.000001, ${t})) * ${s}logarithmicDepthConstant;\n`
			}
			return this
		}
		_isLogarithmicDepthEnabled(e, t) {
			if (t) return !0;
			for (const t of e)
				if (t.useLogarithmicDepth) return !0;
			return !1
		}
		constructor(e) {
			super(e, Xf.Vertex, !0), this.registerInput("vector", Wf.Vector4)
		}
		getClassName() {
			return "VertexOutputBlock"
		}
		get vector() {
			return this._inputs[0]
		}
	};

	function cp(e, t = 0, i = "PROPERTIES", s) {
		return (n, a) => {
			let r = n._propStore;
			r || (r = [], n._propStore = r), r.push({
				propertyName: a,
				displayName: e,
				type: t,
				groupName: i,
				options: s ?? {}
			})
		}
	}
	cc("BABYLON.VertexOutputBlock", hp), (lp = op || (op = {}))[lp.Boolean = 0] = "Boolean", lp[lp.Float = 1] = "Float", lp[lp.Int = 2] = "Int", lp[lp.Vector2 = 3] = "Vector2", lp[lp.List = 4] = "List";
	var up, mp, dp, fp, pp = class extends ap {
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this.rgba,
				i = this.rgb,
				s = this.a,
				n = 1 === e.shaderLanguage;
			e.sharedData.hints.needAlphaBlending = t.isConnected || s.isConnected, e.sharedData.blocksWithDefines.push(this), (this.useLogarithmicDepth || e.sharedData.nodeMaterial.useLogarithmicDepth) && (e._emitUniformFromString("logarithmicDepthConstant", Wf.Float), e._emitVaryingFromString("vFragmentDepth", Wf.Float), e.sharedData.bindableBlocks.push(this)), this._linearDefineName = e._getFreeDefineName("CONVERTTOLINEAR"), this._gammaDefineName = e._getFreeDefineName("CONVERTTOGAMMA");
			const a = `//${this.name}`;
			e._emitFunctionFromInclude("helperFunctions", a);
			let r = "gl_FragColor";
			1 === e.shaderLanguage && (e.compilationString += "var fragmentOutputsColor : vec4<f32>;\r\n", r = "fragmentOutputsColor");
			const o = e._getShaderType(Wf.Vector4);
			if (t.connectedPoint) s.isConnected ? e.compilationString += `${r} = ${o}(${t.associatedVariableName}.rgb, ${s.associatedVariableName});\n` : e.compilationString += `${r}  = ${t.associatedVariableName};\n`;
			else if (i.connectedPoint) {
				let t = "1.0";
				s.connectedPoint && (t = s.associatedVariableName), i.connectedPoint.type === Wf.Float ? e.compilationString += `${r}  = ${o}(${i.associatedVariableName}, ${i.associatedVariableName}, ${i.associatedVariableName}, ${t});\n` : e.compilationString += `${r}  = ${o}(${i.associatedVariableName}, ${t});\n`
			} else e.sharedData.checks.notConnectedNonOptionalInputs.push(t);
			if (e.compilationString += `#ifdef ${this._linearDefineName}\n`, e.compilationString += `${r}  = toLinearSpace(${r});\n`, e.compilationString += "#endif\n", e.compilationString += `#ifdef ${this._gammaDefineName}\n`, e.compilationString += `${r}  = toGammaSpace(${r});\n`, e.compilationString += "#endif\n", 1 === e.shaderLanguage && (e.compilationString += "#if !defined(PREPASS)\r\n", e.compilationString += "fragmentOutputs.color = fragmentOutputsColor;\r\n", e.compilationString += "#endif\r\n"), this.useLogarithmicDepth || e.sharedData.nodeMaterial.useLogarithmicDepth) {
				const t = n ? "input.vFragmentDepth" : "vFragmentDepth",
					i = n ? "uniforms." : "",
					s = n ? "fragmentOutputs.fragDepth" : "gl_FragDepthEXT";
				e.compilationString += `${s} = log2(${t}) * ${i}logarithmicDepthConstant * 0.5;\n`
			}
			return e.compilationString += "#if defined(PREPASS)\r\n", e.compilationString += `${n?"fragmentOutputs.fragData0":"gl_FragData[0]"} = ${r};\r\n`, e.compilationString += "#endif\r\n", this
		}
		get rgba() {
			return this._inputs[0]
		}
		initialize(e) {
			e._excludeVariableName("logarithmicDepthConstant"), e._excludeVariableName("vFragmentDepth")
		}
		get rgb() {
			return this._inputs[1]
		}
		bind(e, t, i) {
			(this.useLogarithmicDepth || t.useLogarithmicDepth) && i && sf(void 0, e, i.getScene())
		}
		prepareDefines(e, t, i) {
			i.setValue(this._linearDefineName, this.convertToLinearSpace, !0), i.setValue(this._gammaDefineName, this.convertToGammaSpace, !0)
		}
		get a() {
			return this._inputs[2]
		}
		constructor(e) {
			super(e, Xf.Fragment, !0), this.convertToGammaSpace = !1, this.convertToLinearSpace = !1, this.useLogarithmicDepth = !1, this.registerInput("rgba", Wf.Color4, !0), this.registerInput("rgb", Wf.AutoDetect, !0), this.registerInput("a", Wf.Float, !0), this.rgb.addExcludedConnectionPointFromAllowedTypes(Wf.Color3 | Wf.Vector3 | Wf.Float)
		}
		getClassName() {
			return "FragmentOutputBlock"
		}
		_dumpPropertiesCode() {
			let e = super._dumpPropertiesCode();
			return e += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\n`, e += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\n`, e += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\n`, e
		}
		serialize() {
			const e = super.serialize();
			return e.convertToGammaSpace = this.convertToGammaSpace, e.convertToLinearSpace = this.convertToLinearSpace, e.useLogarithmicDepth = this.useLogarithmicDepth, e
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.convertToGammaSpace = !!e.convertToGammaSpace, this.convertToLinearSpace = !!e.convertToLinearSpace, this.useLogarithmicDepth = e.useLogarithmicDepth ?? !1
		}
	};
	Gh([cp("Convert to gamma space", 0, "PROPERTIES", {
		notifiers: {
			update: !0
		}
	})], pp.prototype, "convertToGammaSpace", void 0), Gh([cp("Convert to linear space", 0, "PROPERTIES", {
		notifiers: {
			update: !0
		}
	})], pp.prototype, "convertToLinearSpace", void 0), Gh([cp("Use logarithmic depth", 0, "PROPERTIES")], pp.prototype, "useLogarithmicDepth", void 0), cc("BABYLON.FragmentOutputBlock", pp), (mp = up || (up = {}))[mp.World = 1] = "World", mp[mp.View = 2] = "View", mp[mp.Projection = 3] = "Projection", mp[mp.ViewProjection = 4] = "ViewProjection", mp[mp.WorldView = 5] = "WorldView", mp[mp.WorldViewProjection = 6] = "WorldViewProjection", mp[mp.CameraPosition = 7] = "CameraPosition", mp[mp.FogColor = 8] = "FogColor", mp[mp.DeltaTime = 9] = "DeltaTime", mp[mp.CameraParameters = 10] = "CameraParameters", mp[mp.MaterialAlpha = 11] = "MaterialAlpha", (fp = dp || (dp = {}))[fp.CW = 0] = "CW", fp[fp.CCW = 1] = "CCW";
	var _p, gp, vp = class e {
			static FromRadians(t) {
				return new e(t)
			}
			static BetweenTwoVectors(t, i) {
				let s = t.lengthSquared() * i.lengthSquared();
				if (0 === s) return new e(Math.PI / 2);
				s = Math.sqrt(s);
				let n = t.dot(i) / s;
				n = Ac.Clamp(n, -1, 1);
				const a = Math.acos(n);
				return new e(a)
			}
			degrees() {
				return 180 * this._radians / Math.PI
			}
			radians() {
				return this._radians
			}
			constructor(e) {
				this._radians = e, this._radians < 0 && (this._radians += 2 * Math.PI)
			}
			static BetweenTwoPoints(t, i) {
				const s = i.subtract(t),
					n = Math.atan2(s.y, s.x);
				return new e(n)
			}
			static FromDegrees(t) {
				return new e(t * Math.PI / 180)
			}
		},
		yp = class {
			constructor(e, t, i) {
				this.startPoint = e, this.midPoint = t, this.endPoint = i;
				const s = Math.pow(t.x, 2) + Math.pow(t.y, 2),
					n = (Math.pow(e.x, 2) + Math.pow(e.y, 2) - s) / 2,
					a = (s - Math.pow(i.x, 2) - Math.pow(i.y, 2)) / 2,
					r = (e.x - t.x) * (t.y - i.y) - (t.x - i.x) * (e.y - t.y);
				this.centerPoint = new Fc((n * (t.y - i.y) - a * (e.y - t.y)) / r, ((e.x - t.x) * a - (t.x - i.x) * n) / r), this.radius = this.centerPoint.subtract(this.startPoint).length(), this.startAngle = vp.BetweenTwoPoints(this.centerPoint, this.startPoint);
				const o = this.startAngle.degrees();
				let l = vp.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees(),
					h = vp.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
				l - o > 180 && (l -= 360), l - o < -180 && (l += 360), h - l > 180 && (h -= 360), h - l < -180 && (h += 360), this.orientation = l - o < 0 ? 0 : 1, this.angle = vp.FromDegrees(0 === this.orientation ? o - h : h - o)
			}
		},
		Sp = class e {
			constructor(e, t) {
				this._points = new Array, this._length = 0, this.closed = !1, this._points.push(new Fc(e, t))
			}
			length() {
				let e = this._length;
				if (this.closed) {
					const t = this._points[this._points.length - 1];
					e += this._points[0].subtract(t).length()
				}
				return e
			}
			addQuadraticCurveTo(e, t, i, s, n = 36) {
				if (this.closed) return this;
				const a = (e, t, i, s) => (1 - e) * (1 - e) * t + 2 * e * (1 - e) * i + e * e * s,
					r = this._points[this._points.length - 1];
				for (let o = 0; o <= n; o++) {
					const l = o / n,
						h = a(l, r.x, e, i),
						c = a(l, r.y, t, s);
					this.addLineTo(h, c)
				}
				return this
			}
			close() {
				return this.closed = !0, this
			}
			addArcTo(e, t, i, s, n = 36) {
				if (this.closed) return this;
				const a = this._points[this._points.length - 1],
					r = new Fc(e, t),
					o = new Fc(i, s),
					l = new yp(a, r, o);
				let h = l.angle.radians() / n;
				0 === l.orientation && (h *= -1);
				let c = l.startAngle.radians() + h;
				for (let e = 0; e < n; e++) {
					const e = Math.cos(c) * l.radius + l.centerPoint.x,
						t = Math.sin(c) * l.radius + l.centerPoint.y;
					this.addLineTo(e, t), c += h
				}
				return this
			}
			isPointInside(e) {
				let t = !1;
				const i = this._points.length;
				for (let s = i - 1, n = 0; n < i; s = n++) {
					let i = this._points[s],
						a = this._points[n],
						r = a.x - i.x,
						o = a.y - i.y;
					if (Math.abs(o) > Number.EPSILON) {
						if (o < 0 && (i = this._points[n], r = -r, a = this._points[s], o = -o), e.y < i.y || e.y > a.y) continue;
						if (e.y === i.y && e.x === i.x) return !0;
						{
							const s = o * (e.x - i.x) - r * (e.y - i.y);
							if (0 === s) return !0;
							if (s < 0) continue;
							t = !t
						}
					} else {
						if (e.y !== i.y) continue;
						if (a.x <= e.x && e.x <= i.x || i.x <= e.x && e.x <= a.x) return !0
					}
				}
				return t
			}
			addLineTo(e, t) {
				if (this.closed) return this;
				const i = new Fc(e, t),
					s = this._points[this._points.length - 1];
				return this._points.push(i), this._length += i.subtract(s).length(), this
			}
			area() {
				const e = this._points.length;
				let t = 0;
				for (let i = e - 1, s = 0; s < e; i = s++) t += this._points[i].x * this._points[s].y - this._points[s].x * this._points[i].y;
				return .5 * t
			}
			addBezierCurveTo(e, t, i, s, n, a, r = 36) {
				if (this.closed) return this;
				const o = (e, t, i, s, n) => (1 - e) * (1 - e) * (1 - e) * t + 3 * e * (1 - e) * (1 - e) * i + 3 * e * e * (1 - e) * s + e * e * e * n,
					l = this._points[this._points.length - 1];
				for (let h = 0; h <= r; h++) {
					const c = h / r,
						u = o(c, l.x, e, i, n),
						m = o(c, l.y, t, s, a);
					this.addLineTo(u, m)
				}
				return this
			}
			getPoints() {
				return this._points
			}
			static StartingAt(t, i) {
				return new e(t, i)
			}
			getPointAtLengthPosition(e) {
				if (e < 0 || e > 1) return Fc.Zero();
				const t = e * this.length();
				let i = 0;
				for (let e = 0; e < this._points.length; e++) {
					const s = (e + 1) % this._points.length,
						n = this._points[e],
						a = this._points[s].subtract(n),
						r = a.length() + i;
					if (t >= i && t <= r) {
						const e = a.normalize(),
							s = t - i;
						return new Fc(n.x + e.x * s, n.y + e.y * s)
					}
					i = r
				}
				return Fc.Zero()
			}
		},
		Ep = class e {
			_updatePointAtData(e, t = !1) {
				if (this._pointAtData.id === e) return this._pointAtData.interpolateReady || this._updateInterpolationMatrix(), this._pointAtData;
				this._pointAtData.id = e;
				const i = this.getPoints();
				if (e <= 0) return this._setPointAtData(0, 0, i[0], 0, t);
				if (e >= 1) return this._setPointAtData(1, 1, i[i.length - 1], i.length - 1, t);
				let s, n = i[0],
					a = 0;
				const r = e * this.length();
				for (let o = 1; o < i.length; o++) {
					s = i[o];
					const l = Lc.Distance(n, s);
					if (a += l, a === r) return this._setPointAtData(e, 1, s, o, t);
					if (a > r) {
						const i = (a - r) / l,
							h = n.subtract(s),
							c = s.add(h.scaleInPlace(i));
						return this._setPointAtData(e, 1 - i, c, o - 1, t)
					}
					n = s
				}
				return this._pointAtData
			}
			_getLastNonNullVector(e) {
				let t = 1,
					i = this._curve[e].subtract(this._curve[e - t]);
				for (; 0 === i.length() && e > t + 1;) t++, i = this._curve[e].subtract(this._curve[e - t]);
				return i
			}
			getSubPositionAt(e) {
				return this._updatePointAtData(e), this._pointAtData.subPosition
			}
			getCurve() {
				return this._curve
			}
			getTangentAt(e, t = !1) {
				return this._updatePointAtData(e, t), t ? Lc.TransformCoordinates(Lc.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex]
			}
			_updateInterpolationMatrix() {
				this._pointAtData.interpolationMatrix = Hc.Identity();
				const e = this._pointAtData.previousPointArrayIndex;
				if (e !== this._tangents.length - 1) {
					const t = e + 1,
						i = this._tangents[e].clone(),
						s = this._normals[e].clone(),
						n = this._binormals[e].clone(),
						a = this._tangents[t].clone(),
						r = this._normals[t].clone(),
						o = this._binormals[t].clone(),
						l = Gc.RotationQuaternionFromAxis(s, n, i),
						h = Gc.RotationQuaternionFromAxis(r, o, a);
					Gc.Slerp(l, h, this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)
				}
			}
			getClosestPositionTo(e) {
				let t = Number.MAX_VALUE,
					i = 0;
				for (let s = 0; s < this._curve.length - 1; s++) {
					const n = this._curve[s + 0],
						a = this._curve[s + 1].subtract(n).normalize(),
						r = this._distances[s + 1] - this._distances[s + 0],
						o = Math.min(Math.max(Lc.Dot(a, e.subtract(n).normalize()), 0) * Lc.Distance(n, e) / r, 1),
						l = Lc.Distance(n.add(a.scale(o * r)), e);
					l < t && (t = l, i = (this._distances[s + 0] + r * o) / this.length())
				}
				return i
			}
			slice(t = 0, i = 1) {
				if (t < 0 && (t = 1 - -1 * t % 1), i < 0 && (i = 1 - -1 * i % 1), t > i) {
					const e = t;
					t = i, i = e
				}
				const s = this.getCurve(),
					n = this.getPointAt(t);
				let a = this.getPreviousPointIndexAt(t);
				const r = this.getPointAt(i),
					o = this.getPreviousPointIndexAt(i) + 1,
					l = [];
				return 0 !== t && (a++, l.push(n)), l.push(...s.slice(a, o)), 1 === i && 1 !== t || l.push(r), new e(l, this.getNormalAt(t), this._raw, this._alignTangentsWithPath)
			}
			getNormals() {
				return this._normals
			}
			getTangents() {
				return this._tangents
			}
			length() {
				return this._distances[this._distances.length - 1]
			}
			getPointAt(e) {
				return this._updatePointAtData(e).point
			}
			getPoints() {
				return this._curve
			}
			getBinormals() {
				return this._binormals
			}
			update(e, t = null, i = !1) {
				for (let t = 0; t < e.length; t++) this._curve[t].x = e[t].x, this._curve[t].y = e[t].y, this._curve[t].z = e[t].z;
				return this._compute(t, i), this
			}
			_normalVector(e, t) {
				let i, s = e.length();
				if (0 === s && (s = 1), null == t) {
					let t;
					t = Ac.WithinEpsilon(Math.abs(e.y) / s, 1, pc) ? Ac.WithinEpsilon(Math.abs(e.x) / s, 1, pc) ? Ac.WithinEpsilon(Math.abs(e.z) / s, 1, pc) ? Lc.Zero() : new Lc(0, 0, 1) : new Lc(1, 0, 0) : new Lc(0, -1, 0), i = Lc.Cross(e, t)
				} else i = Lc.Cross(e, t), Lc.CrossToRef(i, e, i);
				return i.normalize(), i
			}
			constructor(e, t = null, i, s = !1) {
				this.path = e, this._curve = new Array, this._distances = new Array, this._tangents = new Array, this._normals = new Array, this._binormals = new Array, this._pointAtData = {
					id: 0,
					point: Lc.Zero(),
					previousPointArrayIndex: 0,
					position: 0,
					subPosition: 0,
					interpolateReady: !1,
					interpolationMatrix: Hc.Identity()
				};
				for (let t = 0; t < e.length; t++) this._curve[t] = e[t].clone();
				this._raw = i || !1, this._alignTangentsWithPath = s, this._compute(t, s)
			}
			getDistances() {
				return this._distances
			}
			_setPointAtData(e, t, i, s, n) {
				return this._pointAtData.point = i, this._pointAtData.position = e, this._pointAtData.subPosition = t, this._pointAtData.previousPointArrayIndex = s, this._pointAtData.interpolateReady = n, n && this._updateInterpolationMatrix(), this._pointAtData
			}
			getNormalAt(e, t = !1) {
				return this._updatePointAtData(e, t), t ? Lc.TransformCoordinates(Lc.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex]
			}
			_compute(e, t = !1) {
				const i = this._curve.length;
				if (i < 2) return;
				this._tangents[0] = this._getFirstNonNullVector(0), this._raw || this._tangents[0].normalize(), this._tangents[i - 1] = this._curve[i - 1].subtract(this._curve[i - 2]), this._raw || this._tangents[i - 1].normalize();
				const s = this._tangents[0],
					n = this._normalVector(s, e);
				let a, r, o, l, h;
				this._normals[0] = n, this._raw || this._normals[0].normalize(), this._binormals[0] = Lc.Cross(s, this._normals[0]), this._raw || this._binormals[0].normalize(), this._distances[0] = 0;
				for (let e = 1; e < i; e++) a = this._getLastNonNullVector(e), e < i - 1 && (r = this._getFirstNonNullVector(e), this._tangents[e] = t ? r : a.add(r), this._tangents[e].normalize()), this._distances[e] = this._distances[e - 1] + this._curve[e].subtract(this._curve[e - 1]).length(), o = this._tangents[e], h = this._binormals[e - 1], this._normals[e] = Lc.Cross(h, o), this._raw || (0 === this._normals[e].length() ? (l = this._normals[e - 1], this._normals[e] = l.clone()) : this._normals[e].normalize()), this._binormals[e] = Lc.Cross(o, this._normals[e]), this._raw || this._binormals[e].normalize();
				this._pointAtData.id = NaN
			}
			getDistanceAt(e) {
				return this.length() * e
			}
			getPreviousPointIndexAt(e) {
				return this._updatePointAtData(e), this._pointAtData.previousPointArrayIndex
			}
			getBinormalAt(e, t = !1) {
				return this._updatePointAtData(e, t), t ? Lc.TransformCoordinates(Lc.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex]
			}
			_getFirstNonNullVector(e) {
				let t = 1,
					i = this._curve[e + t].subtract(this._curve[e]);
				for (; 0 === i.length() && e + t + 1 < this._curve.length;) t++, i = this._curve[e + t].subtract(this._curve[e]);
				return i
			}
		},
		Ap = class e {
			toString() {
				return `{W: ${this.width}, H: ${this.height}}`
			}
			static Zero() {
				return new e(0, 0)
			}
			copyFromFloats(e, t) {
				return this.width = e, this.height = t, this
			}
			subtract(t) {
				return new e(this.width - t.width, this.height - t.height)
			}
			add(t) {
				return new e(this.width + t.width, this.height + t.height)
			}
			equals(e) {
				return !!e && (this.width === e.width && this.height === e.height)
			}
			get surface() {
				return this.width * this.height
			}
			constructor(e, t) {
				this.width = e, this.height = t
			}
			scale(t) {
				return new e(this.width * t, this.height * t)
			}
			clone() {
				return new e(this.width, this.height)
			}
			copyFrom(e) {
				this.width = e.width, this.height = e.height
			}
			multiplyByFloats(t, i) {
				return new e(this.width * t, this.height * i)
			}
			static Lerp(t, i, s) {
				const n = t.width + (i.width - t.width) * s,
					a = t.height + (i.height - t.height) * s;
				return new e(n, a)
			}
			getHashCode() {
				let e = 0 | this.width;
				return e = 397 * e ^ this.height, e
			}
			set(e, t) {
				return this.copyFromFloats(e, t)
			}
			getClassName() {
				return "Size"
			}
		};
	(gp = _p || (_p = {}))[gp.None = 0] = "None", gp[gp.Time = 1] = "Time", gp[gp.RealTime = 2] = "RealTime", gp[gp.MouseInfo = 3] = "MouseInfo";
	var bp = {
			position2d: "position",
			particle_uv: "vUV",
			particle_color: "vColor",
			particle_texturemask: "textureMask",
			particle_positionw: "vPositionW"
		},
		xp = {
			particle_uv: !0,
			particle_color: !0,
			particle_texturemask: !0,
			particle_positionw: !0
		},
		Mp = {
			particle_texturemask: !0
		},
		Cp = class extends ap {
			set valueCallback(e) {
				this._valueCallback = e, this._mode = 0
			}
			initialize() {
				this.associatedVariableName = ""
			}
			_emitConstant(e) {
				switch (this.type) {
					case Wf.Float:
						return `${e._emitFloat(this.value)}`;
					case Wf.Vector2:
						return `vec2(${this.value.x}, ${this.value.y})`;
					case Wf.Vector3:
						return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
					case Wf.Vector4:
						return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
					case Wf.Color3:
						return Rc.Color3[0].set(this.value.r, this.value.g, this.value.b), this.convertToGammaSpace && Rc.Color3[0].toGammaSpaceToRef(Rc.Color3[0], e.sharedData.scene.getEngine().useExactSrgbConversions), this.convertToLinearSpace && Rc.Color3[0].toLinearSpaceToRef(Rc.Color3[0], e.sharedData.scene.getEngine().useExactSrgbConversions), `vec3(${Rc.Color3[0].r}, ${Rc.Color3[0].g}, ${Rc.Color3[0].b})`;
					case Wf.Color4:
						return Rc.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a), this.convertToGammaSpace && Rc.Color4[0].toGammaSpaceToRef(Rc.Color4[0], e.sharedData.scene.getEngine().useExactSrgbConversions), this.convertToLinearSpace && Rc.Color4[0].toLinearSpaceToRef(Rc.Color4[0], e.sharedData.scene.getEngine().useExactSrgbConversions), `vec4(${Rc.Color4[0].r}, ${Rc.Color4[0].g}, ${Rc.Color4[0].b}, ${Rc.Color4[0].a})`
				}
				return ""
			}
			set systemValue(e) {
				this._mode = 0, this.associatedVariableName = "", this._systemValue = e
			}
			_transmitWorld(e, t, i, s) {
				if (!this._systemValue) return;
				const n = this._associatedVariableName;
				switch (this._systemValue) {
					case up.World:
						e.setMatrix(n, t);
						break;
					case up.WorldView:
						e.setMatrix(n, i);
						break;
					case up.WorldViewProjection:
						e.setMatrix(n, s)
				}
			}
			set isVarying(e) {
				this._mode = e ? 2 : 3, this.associatedVariableName = ""
			}
			get valueCallback() {
				return this._valueCallback
			}
			constructor(e, t = Xf.Vertex, i = Wf.AutoDetect) {
				super(e, t, !1), this._mode = 3, this._animationType = _p.None, this._prefix = "", this.min = 0, this.max = 0, this.isBoolean = !1, this.matrixMode = 0, this._systemValue = null, this.isConstant = !1, this.groupInInspector = "", this.onValueChangedObservable = new kc, this.convertToGammaSpace = !1, this.convertToLinearSpace = !1, this._type = i, this.setDefaultValue(), this.registerOutput("output", i)
			}
			get declarationVariableName() {
				return this._associatedVariableName
			}
			get animationType() {
				return this._animationType
			}
			animate(e) {
				switch (this._animationType) {
					case _p.Time:
						this.type === Wf.Float && (this.value += .01 * e.getAnimationRatio());
						break;
					case _p.RealTime:
						this.type === Wf.Float && (this.value = (Pu.Now - e.getEngine().startTime) / 1e3);
						break;
					case _p.MouseInfo:
						if (this.type === Wf.Vector4) {
							const t = e._inputManager._originMouseEvent;
							if (t) {
								const e = t.offsetX,
									i = t.offsetY,
									s = 1 & t.buttons ? 1 : 0,
									n = 2 & t.buttons ? 1 : 0;
								this.value = new Bc(e, i, s, n)
							} else this.value = new Bc(0, 0, 0, 0)
						}
				}
			}
			get isAttribute() {
				return 1 === this._mode
			}
			_emitDefine(e) {
				return "!" === e[0] ? `#ifndef ${e.substring(1)}\n` : `#ifdef ${e}\n`
			}
			set associatedVariableName(e) {
				this._associatedVariableName = e
			}
			_transmit(e, t, i) {
				if (this.isAttribute) return;
				const s = this._associatedVariableName;
				if (this._systemValue) {
					switch (this._systemValue) {
						case up.World:
						case up.WorldView:
						case up.WorldViewProjection:
							return;
						case up.View:
							e.setMatrix(s, t.getViewMatrix());
							break;
						case up.Projection:
							e.setMatrix(s, t.getProjectionMatrix());
							break;
						case up.ViewProjection:
							e.setMatrix(s, t.getTransformMatrix());
							break;
						case up.CameraPosition:
							t.bindEyePosition(e, s, !0);
							break;
						case up.FogColor:
							e.setColor3(s, t.fogColor);
							break;
						case up.DeltaTime:
							e.setFloat(s, t.deltaTime / 1e3);
							break;
						case up.CameraParameters:
							t.activeCamera && e.setFloat4(s, t.getEngine().hasOriginBottomLeft ? -1 : 1, t.activeCamera.minZ, t.activeCamera.maxZ, 1 / t.activeCamera.maxZ);
							break;
						case up.MaterialAlpha:
							e.setFloat(s, i.alpha)
					}
					return
				}
				const n = this._valueCallback ? this._valueCallback() : this._storedValue;
				if (null !== n) switch (this.type) {
					case Wf.Float:
						e.setFloat(s, n);
						break;
					case Wf.Int:
						e.setInt(s, n);
						break;
					case Wf.Color3:
						Rc.Color3[0].set(this.value.r, this.value.g, this.value.b), this.convertToGammaSpace && Rc.Color3[0].toGammaSpaceToRef(Rc.Color3[0], t.getEngine().useExactSrgbConversions), this.convertToLinearSpace && Rc.Color3[0].toLinearSpaceToRef(Rc.Color3[0], t.getEngine().useExactSrgbConversions), e.setColor3(s, Rc.Color3[0]);
						break;
					case Wf.Color4:
						Rc.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a), this.convertToGammaSpace && Rc.Color4[0].toGammaSpaceToRef(Rc.Color4[0], t.getEngine().useExactSrgbConversions), this.convertToLinearSpace && Rc.Color4[0].toLinearSpaceToRef(Rc.Color4[0], t.getEngine().useExactSrgbConversions), e.setDirectColor4(s, Rc.Color4[0]);
						break;
					case Wf.Vector2:
						e.setVector2(s, n);
						break;
					case Wf.Vector3:
						e.setVector3(s, n);
						break;
					case Wf.Vector4:
						e.setVector4(s, n);
						break;
					case Wf.Matrix:
						e.setMatrix(s, n)
				}
			}
			get type() {
				if (this._type === Wf.AutoDetect) {
					if (this.isUniform && null != this.value) {
						if (!isNaN(this.value)) return this._type = Wf.Float, this._type;
						switch (this.value.getClassName()) {
							case "Vector2":
								return this._type = Wf.Vector2, this._type;
							case "Vector3":
								return this._type = Wf.Vector3, this._type;
							case "Vector4":
								return this._type = Wf.Vector4, this._type;
							case "Color3":
								return this._type = Wf.Color3, this._type;
							case "Color4":
								return this._type = Wf.Color4, this._type;
							case "Matrix":
								return this._type = Wf.Matrix, this._type
						}
					}
					if (this.isAttribute) switch (this.name) {
						case "position":
						case "normal":
						case "particle_positionw":
							return this._type = Wf.Vector3, this._type;
						case "uv":
						case "uv2":
						case "uv3":
						case "uv4":
						case "uv5":
						case "uv6":
						case "position2d":
						case "particle_uv":
							return this._type = Wf.Vector2, this._type;
						case "matricesIndices":
						case "matricesWeights":
						case "matricesIndicesExtra":
						case "matricesWeightsExtra":
						case "world0":
						case "world1":
						case "world2":
						case "world3":
						case "tangent":
							return this._type = Wf.Vector4, this._type;
						case "color":
						case "instanceColor":
						case "particle_color":
						case "particle_texturemask":
							return this._type = Wf.Color4, this._type
					}
					if (this.isSystemValue) switch (this._systemValue) {
						case up.World:
						case up.WorldView:
						case up.WorldViewProjection:
						case up.View:
						case up.ViewProjection:
						case up.Projection:
							return this._type = Wf.Matrix, this._type;
						case up.CameraPosition:
							return this._type = Wf.Vector3, this._type;
						case up.FogColor:
							return this._type = Wf.Color3, this._type;
						case up.DeltaTime:
						case up.MaterialAlpha:
							return this._type = Wf.Float, this._type;
						case up.CameraParameters:
							return this._type = Wf.Vector4, this._type
					}
				}
				return this._type
			}
			get _noContextSwitch() {
				return xp[this.name]
			}
			set value(e) {
				this.type === Wf.Float && (this.isBoolean ? e = e ? 1 : 0 : this.min !== this.max && (e = Math.max(this.min, e), e = Math.min(this.max, e))), this._storedValue = e, this._mode = 0, this.onValueChangedObservable.notifyObservers(this)
			}
			set isAttribute(e) {
				this._mode = e ? 1 : 3, this.associatedVariableName = ""
			}
			get output() {
				return this._outputs[0]
			}
			getClassName() {
				return "InputBlock"
			}
			get isVarying() {
				return 2 === this._mode
			}
			get isUndefined() {
				return 3 === this._mode
			}
			_deserialize(e, t, i) {
				if (this._mode = e.mode, super._deserialize(e, t, i), this._type = e.type, this._systemValue = e.systemValue || e.wellKnownValue, this._animationType = e.animationType, this.min = e.min || 0, this.max = e.max || 0, this.isBoolean = !!e.isBoolean, this.matrixMode = e.matrixMode || 0, this.isConstant = !!e.isConstant, this.groupInInspector = e.groupInInspector || "", this.convertToGammaSpace = !!e.convertToGammaSpace, this.convertToLinearSpace = !!e.convertToLinearSpace, "tangent" === e.name && 1 === e.mode && e.type === Wf.Vector3 && (this._type = Wf.Vector4), e.valueType)
					if ("number" === e.valueType) this._storedValue = e.value;
					else {
						const t = uc(e.valueType);
						t && (this._storedValue = t.FromArray(e.value))
					}
			}
			setAsAttribute(e) {
				return this._mode = 1, e && (this.name = e), this
			}
			dispose() {
				this.onValueChangedObservable.clear(), super.dispose()
			}
			_buildBlock(e) {
				super._buildBlock(e), (this.isUniform || this.isSystemValue) && e.sharedData.inputBlocks.push(this), this._emit(e)
			}
			get isSystemValue() {
				return null != this._systemValue
			}
			set animationType(e) {
				this._animationType = e
			}
			_dumpPropertiesCode() {
				const e = this._codeVariableName;
				if (this.isAttribute) return super._dumpPropertiesCode() + `${e}.setAsAttribute("${this.name}");\n`;
				if (this.isSystemValue) return super._dumpPropertiesCode() + `${e}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${up[this._systemValue]});\n`;
				if (this.isUniform) {
					const t = [];
					let i = "";
					switch (this.type) {
						case Wf.Float:
							i = `${this.value}`;
							break;
						case Wf.Vector2:
							i = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
							break;
						case Wf.Vector3:
							i = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
							break;
						case Wf.Vector4:
							i = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
							break;
						case Wf.Color3:
							i = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`, this.convertToGammaSpace && (i += ".toGammaSpace()"), this.convertToLinearSpace && (i += ".toLinearSpace()");
							break;
						case Wf.Color4:
							i = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`, this.convertToGammaSpace && (i += ".toGammaSpace()"), this.convertToLinearSpace && (i += ".toLinearSpace()");
							break;
						case Wf.Matrix:
							i = `BABYLON.Matrix.FromArray([${this.value.m}])`
					}
					return t.push(`${e}.value = ${i}`), this.type === Wf.Float && t.push(`${e}.min = ${this.min}`, `${e}.max = ${this.max}`, `${e}.isBoolean = ${this.isBoolean}`, `${e}.matrixMode = ${this.matrixMode}`, `${e}.animationType = BABYLON.AnimatedInputBlockTypes.${_p[this.animationType]}`), t.push(`${e}.isConstant = ${this.isConstant}`), t.push(""), super._dumpPropertiesCode() + t.join(";\n")
				}
				return super._dumpPropertiesCode()
			}
			_emit(e, t) {
				if (this.isUniform) {
					if (this._associatedVariableName || (this._associatedVariableName = e._getFreeVariableName("u_" + this.name)), this.isConstant) {
						if (-1 !== e.constants.indexOf(this.associatedVariableName)) return;
						return e.constants.push(this.associatedVariableName), void(e._constantDeclaration += e._declareOutput(this.output, !0) + ` = ${this._emitConstant(e)};\n`)
					}
					if (-1 !== e.uniforms.indexOf(this.associatedVariableName)) return;
					e.uniforms.push(this.associatedVariableName), t && (e._uniformDeclaration += this._emitDefine(t));
					const i = e._getShaderType(this.type);
					1 === e.shaderLanguage ? (e._uniformDeclaration += `uniform ${this._associatedVariableName}: ${i};\n`, this._prefix = "uniforms.") : e._uniformDeclaration += `uniform ${i} ${this.associatedVariableName};\n`, t && (e._uniformDeclaration += "#endif\n");
					const s = e.sharedData.hints;
					if (null !== this._systemValue && void 0 !== this._systemValue) switch (this._systemValue) {
						case up.WorldView:
							s.needWorldViewMatrix = !0;
							break;
						case up.WorldViewProjection:
							s.needWorldViewProjectionMatrix = !0
					} else this._animationType !== _p.None && e.sharedData.animatedInputs.push(this)
				} else if (this.isAttribute) {
					if (this.associatedVariableName = bp[this.name] ?? this.name, this.target === Xf.Vertex && e._vertexState) return void(xp[this.name] ? Mp[this.name] ? (e._emitUniformFromString(this.declarationVariableName, this.type, t), 1 === e.shaderLanguage && (this._prefix = "vertexInputs.")) : e._emitVaryingFromString(this.declarationVariableName, this.type, t) : this._emit(e._vertexState, t));
					if (-1 !== e.attributes.indexOf(this.declarationVariableName)) return;
					e.attributes.push(this.declarationVariableName), xp[this.name] ? Mp[this.name] ? (e._emitUniformFromString(this.declarationVariableName, this.type, t), 1 === e.shaderLanguage && (this._prefix = "uniforms.")) : (e._emitVaryingFromString(this.declarationVariableName, this.type, t), 1 === e.shaderLanguage && (this._prefix = "fragmentInputs.")) : (t && (e._attributeDeclaration += this._emitDefine(t)), 1 === e.shaderLanguage ? (e._attributeDeclaration += `attribute ${this.declarationVariableName}: ${e._getShaderType(this.type)};\n`, this._prefix = "vertexInputs.") : e._attributeDeclaration += `attribute ${e._getShaderType(this.type)} ${this.declarationVariableName};\n`, t && (e._attributeDeclaration += "#endif\n"))
				}
			}
			get systemValue() {
				return this._systemValue
			}
			setDefaultValue() {
				switch (this.type) {
					case Wf.Float:
						this.value = 0;
						break;
					case Wf.Vector2:
						this.value = Fc.Zero();
						break;
					case Wf.Vector3:
						this.value = Lc.Zero();
						break;
					case Wf.Vector4:
						this.value = Bc.Zero();
						break;
					case Wf.Color3:
						this.value = Tc.White();
						break;
					case Wf.Color4:
						this.value = new wc(1, 1, 1, 1);
						break;
					case Wf.Matrix:
						this.value = Hc.Identity()
				}
			}
			setAsSystemValue(e) {
				return this.systemValue = e, this
			}
			serialize() {
				const e = super.serialize();
				return e.type = this.type, e.mode = this._mode, e.systemValue = this._systemValue, e.animationType = this._animationType, e.min = this.min, e.max = this.max, e.isBoolean = this.isBoolean, e.matrixMode = this.matrixMode, e.isConstant = this.isConstant, e.groupInInspector = this.groupInInspector, e.convertToGammaSpace = this.convertToGammaSpace, e.convertToLinearSpace = this.convertToLinearSpace, null != this._storedValue && 0 === this._mode && (this._storedValue.asArray ? (e.valueType = "BABYLON." + this._storedValue.getClassName(), e.value = this._storedValue.asArray()) : (e.valueType = "number", e.value = this._storedValue)), e
			}
			get isUniform() {
				return 0 === this._mode
			}
			get associatedVariableName() {
				return this._prefix + this._associatedVariableName
			}
			validateBlockName(e) {
				return !!this.isAttribute || super.validateBlockName(e)
			}
			get value() {
				return this._storedValue
			}
			set isUniform(e) {
				this._mode = e ? 0 : 3, this.associatedVariableName = ""
			}
		};
	cc("BABYLON.InputBlock", Cp);
	var Tp = class e {
			constructor(t) {
				this._wrapU = 1, this._wrapV = 1, this.wrapR = 1, this.anisotropicFilteringLevel = 4, this.delayLoadState = 0, this._texture = null, this._engine = null, this._cachedSize = Ap.Zero(), this._cachedBaseSize = Ap.Zero(), this._initialSamplingMode = 2, this._texture = e._IsRenderTargetWrapper(t) ? t.texture : t, this._texture && (this._engine = this._texture.getEngine())
			}
			static _IsRenderTargetWrapper(e) {
				return void 0 !== e?.shareDepth
			}
			updateSamplingMode(e) {
				this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture)
			}
			isReady() {
				return 4 === this.delayLoadState ? (this.delayLoad(), !1) : !!this._texture && this._texture.isReady
			}
			getInternalTexture() {
				return this._texture
			}
			delayLoad() {}
			get wrapU() {
				return this._wrapU
			}
			get is2DArray() {
				return !!this._texture && this._texture.is2DArray
			}
			set is3D(e) {
				this._texture && (this._texture.is3D = e)
			}
			set wrapU(e) {
				this._wrapU = e
			}
			getSize() {
				if (this._texture) {
					if (this._texture.width) return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize;
					if (this._texture._size) return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize
				}
				return this._cachedSize
			}
			getBaseSize() {
				return this.isReady() && this._texture ? this._texture._size ? (this._cachedBaseSize.width = this._texture._size, this._cachedBaseSize.height = this._texture._size, this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth, this._cachedBaseSize.height = this._texture.baseHeight, this._cachedBaseSize) : (this._cachedBaseSize.width = 0, this._cachedBaseSize.height = 0, this._cachedBaseSize)
			}
			set isCube(e) {
				this._texture && (this._texture.isCube = e)
			}
			get wrapV() {
				return this._wrapV
			}
			get coordinatesMode() {
				return 0
			}
			get samplingMode() {
				return this._texture ? this._texture.samplingMode : this._initialSamplingMode
			}
			get is3D() {
				return !!this._texture && this._texture.is3D
			}
			releaseInternalTexture() {
				this._texture && (this._texture.dispose(), this._texture = null)
			}
			dispose() {
				this._texture && (this.releaseInternalTexture(), this._engine = null)
			}
			getClassName() {
				return "ThinTexture"
			}
			get isCube() {
				return !!this._texture && this._texture.isCube
			}
			set wrapV(e) {
				this._wrapV = e
			}
			set is2DArray(e) {
				this._texture && (this._texture.is2DArray = e)
			}
		},
		wp = class e extends Tp {
			get isRGBD() {
				return null != this._texture && this._texture._isRGBD
			}
			set lodGenerationScale(e) {
				this._texture && (this._texture._lodGenerationScale = e)
			}
			get gammaSpace() {
				return this._texture ? (null === this._texture._gammaSpace && (this._texture._gammaSpace = this._gammaSpace), this._texture._gammaSpace && !this._texture._useSRGBBuffer) : this._gammaSpace
			}
			get lodGenerationScale() {
				return this._texture ? this._texture._lodGenerationScale : 0
			}
			getScene() {
				return this._scene
			}
			getTextureMatrix() {
				return Hc.IdentityReadOnly
			}
			toString() {
				return this.name
			}
			get is2DArray() {
				return !!this._texture && this._texture.is2DArray
			}
			_markAllSubMeshesAsTexturesDirty() {
				const e = this.getScene();
				e && e.markAllMaterialsAsDirty(1)
			}
			get _lodTextureLow() {
				return this._texture ? this._texture._lodTextureLow : null
			}
			_getFromCache(e, t, i, s, n, a) {
				const r = this._getEngine();
				if (!r) return null;
				const o = r._getUseSRGBBuffer(!!n, t),
					l = r.getLoadedTexturesCache();
				for (let r = 0; r < l.length; r++) {
					const h = l[r];
					if (!(void 0 !== n && o !== h._useSRGBBuffer || void 0 !== s && s !== h.invertY || h.url !== e || h.generateMipMaps !== !t || i && i !== h.samplingMode || void 0 !== a && a !== h.isCube)) return h.incrementReferences(), h
				}
				return null
			}
			get isBlocking() {
				return !0
			}
			set hasAlpha(e) {
				this._hasAlpha !== e && (this._hasAlpha = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
			}
			set linearSpecularLOD(e) {
				this._texture && (this._texture._linearSpecularLOD = e)
			}
			set irradianceTexture(e) {
				this._texture && (this._texture._irradianceTexture = e)
			}
			_rebuild(e = !1) {}
			clone() {
				return null
			}
			get noMipmap() {
				return !1
			}
			get is3D() {
				return !!this._texture && this._texture.is3D
			}
			get coordinatesMode() {
				return this._coordinatesMode
			}
			getClassName() {
				return "BaseTexture"
			}
			get irradianceTexture() {
				return this._texture ? this._texture._irradianceTexture : null
			}
			get linearSpecularLOD() {
				return !!this._texture && this._texture._linearSpecularLOD
			}
			get wrapV() {
				return this._wrapV
			}
			get textureFormat() {
				return this._texture && void 0 !== this._texture.format ? this._texture.format : 5
			}
			dispose() {
				if (this._scene) {
					this._scene.stopAnimation && this._scene.stopAnimation(this), this._scene.removePendingData(this);
					const e = this._scene.textures.indexOf(this);
					if (e >= 0 && this._scene.textures.splice(e, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), this._scene = null, this._parentContainer) {
						const e = this._parentContainer.textures.indexOf(this);
						e > -1 && this._parentContainer.textures.splice(e, 1), this._parentContainer = null
					}
				}
				this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null, super.dispose()
			}
			get hasAlpha() {
				return this._hasAlpha
			}
			set getAlphaFromRGB(e) {
				this._getAlphaFromRGB !== e && (this._getAlphaFromRGB = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
			}
			constructor(t, i = null) {
				super(null), this.metadata = null, this.reservedDataStore = null, this._hasAlpha = !1, this._getAlphaFromRGB = !1, this.level = 1, this._coordinatesIndex = 0, this.optimizeUVAllocation = !0, this._coordinatesMode = 0, this.wrapR = 1, this.anisotropicFilteringLevel = e.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, this._isCube = !1, this._gammaSpace = !0, this.invertZ = !1, this.lodLevelInAlpha = !1, this.isRenderTarget = !1, this._prefiltered = !1, this._forceSerialize = !1, this.animations = [], this.onDisposeObservable = new kc, this._onDisposeObserver = null, this._scene = null, this._uid = null, this._parentContainer = null, this._loadingError = !1, t ? e._IsScene(t) ? this._scene = t : this._engine = t : this._scene = Dc.LastCreatedScene, this._scene && (this.ik = this._scene.getUniqueId(), this._scene.addTexture(this), this._engine = this._scene.getEngine()), this._texture = i, this._uid = null
			}
			set is3D(e) {
				this._texture && (this._texture.is3D = e)
			}
			serialize(e = !1) {
				if (!this.name && !e) return null;
				const t = Xc.Serialize(this);
				return Xc.AppendSerializedAnimations(this, t), t
			}
			set coordinatesMode(e) {
				this._coordinatesMode !== e && (this._coordinatesMode = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
			}
			get textureType() {
				return this._texture && void 0 !== this._texture.type ? this._texture.type : 0
			}
			get canRescale() {
				return !1
			}
			set onDispose(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			}
			_getEngine() {
				return this._engine
			}
			get isCube() {
				return this._texture ? this._texture.isCube : this._isCube
			}
			set isRGBD(e) {
				e !== this.isRGBD && (this._texture && (this._texture._isRGBD = e), this.getScene()?.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
			}
			set gammaSpace(e) {
				if (this._texture) {
					if (this._texture._gammaSpace === e) return;
					this._texture._gammaSpace = e
				} else {
					if (this._gammaSpace === e) return;
					this._gammaSpace = e
				}
				this.getScene()?.markAllMaterialsAsDirty(1, (e => e.hasTexture(this)))
			}
			readPixels(e = 0, t = 0, i = null, s = !0, n = !1, a = 0, r = 0, o = Number.MAX_VALUE, l = Number.MAX_VALUE) {
				if (!this._texture) return null;
				const h = this._getEngine();
				if (!h) return null;
				const c = this.getSize();
				let u = c.width,
					m = c.height;
				0 !== t && (u /= Math.pow(2, t), m /= Math.pow(2, t), u = Math.round(u), m = Math.round(m)), o = Math.min(u, o), l = Math.min(m, l);
				try {
					return this._texture.isCube ? h._readTexturePixels(this._texture, o, l, e, t, i, s, n, a, r) : h._readTexturePixels(this._texture, o, l, -1, t, i, s, n, a, r)
				} catch (e) {
					return null
				}
			}
			scale(e) {}
			static _IsScene(e) {
				return "Scene" === e.getClassName()
			}
			get loadingError() {
				return this._loadingError
			}
			set is2DArray(e) {
				this._texture && (this._texture.is2DArray = e)
			}
			set wrapV(e) {
				this._wrapV = e
			}
			_readPixelsSync(e = 0, t = 0, i = null, s = !0, n = !1) {
				if (!this._texture) return null;
				const a = this.getSize();
				let r = a.width,
					o = a.height;
				const l = this._getEngine();
				if (!l) return null;
				0 != t && (r /= Math.pow(2, t), o /= Math.pow(2, t), r = Math.round(r), o = Math.round(o));
				try {
					return this._texture.isCube ? l._readTexturePixelsSync(this._texture, r, o, e, t, i, s, n) : l._readTexturePixelsSync(this._texture, r, o, -1, t, i, s, n)
				} catch (e) {
					return null
				}
			}
			get _lodTextureMid() {
				return this._texture ? this._texture._lodTextureMid : null
			}
			get _lodTextureHigh() {
				return this._texture ? this._texture._lodTextureHigh : null
			}
			get uid() {
				return this._uid || (this._uid = rd()), this._uid
			}
			static WhenAllReady(e, t) {
				let i = e.length;
				if (0 !== i)
					for (let s = 0; s < e.length; s++) {
						const n = e[s];
						if (n.isReady()) 0 == --i && t();
						else {
							const e = n.onLoadObservable;
							e ? e.addOnce((() => {
								0 == --i && t()
							})) : 0 == --i && t()
						}
					} else t()
			}
			isReadyOrNotBlocking() {
				return !this.isBlocking || this.isReady() || this.loadingError
			}
			get wrapU() {
				return this._wrapU
			}
			set coordinatesIndex(e) {
				this._coordinatesIndex !== e && (this._coordinatesIndex = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
			}
			set wrapU(e) {
				this._wrapU = e
			}
			getReflectionTextureMatrix() {
				return Hc.IdentityReadOnly
			}
			set isCube(e) {
				this._texture ? this._texture.isCube = e : this._isCube = e
			}
			getRefractionTextureMatrix() {
				return this.getReflectionTextureMatrix()
			}
			get getAlphaFromRGB() {
				return this._getAlphaFromRGB
			}
			get lodGenerationOffset() {
				return this._texture ? this._texture._lodGenerationOffset : 0
			}
			get coordinatesIndex() {
				return this._coordinatesIndex
			}
			get errorObject() {
				return this._errorObject
			}
			set lodGenerationOffset(e) {
				this._texture && (this._texture._lodGenerationOffset = e)
			}
		};

	function Rp(e, t, i = !1) {
		const s = t.width,
			n = t.height;
		if (e instanceof Float32Array) {
			let t = e.byteLength / e.BYTES_PER_ELEMENT;
			const i = new Uint8Array(t);
			for (; --t >= 0;) {
				let s = e[t];
				s < 0 ? s = 0 : s > 1 && (s = 1), i[t] = 255 * s
			}
			e = i
		}
		const a = document.createElement("canvas");
		a.width = s, a.height = n;
		const r = a.getContext("2d");
		if (!r) return null;
		const o = r.createImageData(s, n);
		if (o.data.set(e), r.putImageData(o, 0, 0), i) {
			const e = document.createElement("canvas");
			e.width = s, e.height = n;
			const t = e.getContext("2d");
			return t ? (t.translate(0, n), t.scale(1, -1), t.drawImage(a, 0, 0), e.toDataURL("image/png")) : null
		}
		return a.toDataURL("image/png")
	}
	wp.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4, Gh([Xh()], wp.prototype, "uniqueId", void 0), Gh([Xh()], wp.prototype, "name", void 0), Gh([Xh()], wp.prototype, "metadata", void 0), Gh([Xh("hasAlpha")], wp.prototype, "_hasAlpha", void 0), Gh([Xh("getAlphaFromRGB")], wp.prototype, "_getAlphaFromRGB", void 0), Gh([Xh()], wp.prototype, "level", void 0), Gh([Xh("coordinatesIndex")], wp.prototype, "_coordinatesIndex", void 0), Gh([Xh()], wp.prototype, "optimizeUVAllocation", void 0), Gh([Xh("coordinatesMode")], wp.prototype, "_coordinatesMode", void 0), Gh([Xh()], wp.prototype, "wrapU", null), Gh([Xh()], wp.prototype, "wrapV", null), Gh([Xh()], wp.prototype, "wrapR", void 0), Gh([Xh()], wp.prototype, "anisotropicFilteringLevel", void 0), Gh([Xh()], wp.prototype, "isCube", null), Gh([Xh()], wp.prototype, "is3D", null), Gh([Xh()], wp.prototype, "is2DArray", null), Gh([Xh()], wp.prototype, "gammaSpace", null), Gh([Xh()], wp.prototype, "invertZ", void 0), Gh([Xh()], wp.prototype, "lodLevelInAlpha", void 0), Gh([Xh()], wp.prototype, "lodGenerationOffset", null), Gh([Xh()], wp.prototype, "lodGenerationScale", null), Gh([Xh()], wp.prototype, "linearSpecularLOD", null), Gh([Yh()], wp.prototype, "irradianceTexture", null), Gh([Xh()], wp.prototype, "isRenderTarget", void 0);
	var Np = class e extends wp {
		static _CreateVideoTexture(t, i, s, n = !1, a = !1, r = e.TRILINEAR_SAMPLINGMODE, o = {}, l, h = 5) {
			throw ic("VideoTexture")
		}
		getTextureMatrix(e = 1) {
			if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * e === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) return this._cachedTextureMatrix;
			this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale * e, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedURotationCenter = this.uRotationCenter, this._cachedVRotationCenter = this.vRotationCenter, this._cachedWRotationCenter = this.wRotationCenter, this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform, this._cachedTextureMatrix && this._rowGenerationMatrix || (this._cachedTextureMatrix = Hc.Zero(), this._rowGenerationMatrix = new Hc, this._t0 = Lc.Zero(), this._t1 = Lc.Zero(), this._t2 = Lc.Zero()), Hc.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this.homogeneousRotationInUVTransform ? (Hc.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, Vc.Matrix[0]), Hc.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, Vc.Matrix[1]), Hc.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, Vc.Matrix[2]), Hc.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, Vc.Matrix[3]), Vc.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(Vc.Matrix[1], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(Vc.Matrix[2], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(Vc.Matrix[3], this._cachedTextureMatrix), this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), Hc.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix));
			const t = this.getScene();
			if (!t) return this._cachedTextureMatrix;
			const i = this._cachedIdentity3x2;
			return this._cachedIdentity3x2 = this._cachedTextureMatrix.isIdentityAs3x2(), this.optimizeUVAllocation && i !== this._cachedIdentity3x2 && t.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))), this._cachedTextureMatrix
		}
		constructor(t, i, s, n, a = e.TRILINEAR_SAMPLINGMODE, r = null, o = null, l = null, h = !1, c, u, m, d, f) {
			let p;
			super(i), this.url = null, this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.uRotationCenter = .5, this.vRotationCenter = .5, this.wRotationCenter = .5, this.homogeneousRotationInUVTransform = !1, this.inspectableCustomProperties = null, this._noMipmap = !1, this._invertY = !1, this._rowGenerationMatrix = null, this._cachedTextureMatrix = null, this._projectionModeMatrix = null, this._t0 = null, this._t1 = null, this._t2 = null, this._cachedUOffset = -1, this._cachedVOffset = -1, this._cachedUScale = 0, this._cachedVScale = 0, this._cachedUAng = -1, this._cachedVAng = -1, this._cachedWAng = -1, this._cachedReflectionProjectionMatrixId = -1, this._cachedURotationCenter = -1, this._cachedVRotationCenter = -1, this._cachedWRotationCenter = -1, this._cachedHomogeneousRotationInUVTransform = !1, this._cachedIdentity3x2 = !0, this._cachedReflectionTextureMatrix = null, this._cachedReflectionUOffset = -1, this._cachedReflectionVOffset = -1, this._cachedReflectionUScale = 0, this._cachedReflectionVScale = 0, this._cachedReflectionCoordinatesMode = -1, this._buffer = null, this._deleteBuffer = !1, this._format = null, this._delayedOnLoad = null, this._delayedOnError = null, this.onLoadObservable = new kc, this._isBlocking = !0, this.name = t || "", this.url = t;
			let _ = !1,
				g = null,
				v = !0;
			"object" == typeof s && null !== s ? (p = s.noMipmap ?? !1, n = s.invertY ?? !0, a = s.samplingMode ?? e.TRILINEAR_SAMPLINGMODE, r = s.onLoad ?? null, o = s.onError ?? null, l = s.buffer ?? null, h = s.deleteBuffer ?? !1, c = s.format, u = s.mimeType, m = s.loaderOptions, d = s.creationFlags, _ = s.useSRGBBuffer ?? !1, g = s.internalTexture ?? null, v = s.gammaSpace ?? v) : p = !!s, this._gammaSpace = v, this._noMipmap = p, this._invertY = void 0 === n || n, this._initialSamplingMode = a, this._buffer = l, this._deleteBuffer = h, this._mimeType = u, this._loaderOptions = m, this._creationFlags = d, this._useSRGBBuffer = _, this._forcedExtension = f, c && (this._format = c);
			const y = this.getScene(),
				S = this._getEngine();
			if (!S) return;
			S.onBeforeTextureInitObservable.notifyObservers(this);
			const E = () => {
					this._texture && (this._texture._invertVScale && (this.vScale *= -1, this.vOffset += 1), null !== this._texture._cachedWrapU && (this.wrapU = this._texture._cachedWrapU, this._texture._cachedWrapU = null), null !== this._texture._cachedWrapV && (this.wrapV = this._texture._cachedWrapV, this._texture._cachedWrapV = null), null !== this._texture._cachedWrapR && (this.wrapR = this._texture._cachedWrapR, this._texture._cachedWrapR = null)), this.onLoadObservable.hasObservers() && this.onLoadObservable.notifyObservers(this), r && r(), !this.isBlocking && y && y.resetCachedMaterial()
				},
				A = (t, i) => {
					this._loadingError = !0, this._errorObject = {
						message: t,
						exception: i
					}, o && o(t, i), e.OnTextureLoadErrorObservable.notifyObservers(this)
				};
			if (!this.url && !g) return this._delayedOnLoad = E, void(this._delayedOnError = A);
			if (this._texture = g ?? this._getFromCache(this.url, p, a, this._invertY, _, this.isCube), this._texture)
				if (this._texture.isReady) um.SetImmediate((() => E()));
				else {
					const e = this._texture.onLoadedObservable.add(E);
					this._texture.onErrorObservable.add((t => {
						A(t.message, t.exception), this._texture?.onLoadedObservable.remove(e)
					}))
				}
			else if (y && y.useDelayedTextureLoading) this.delayLoadState = 4, this._delayedOnLoad = E, this._delayedOnError = A;
			else {
				try {
					this._texture = S.createTexture(this.url, p, this._invertY, y, a, E, A, this._buffer, void 0, this._format, this._forcedExtension, u, m, d, _)
				} catch (e) {
					throw A("error loading", e), e
				}
				h && (this._buffer = null)
			}
		}
		get mimeType() {
			return this._mimeType
		}
		set isBlocking(e) {
			this._isBlocking = e
		}
		delayLoad() {
			if (4 !== this.delayLoadState) return;
			const e = this.getScene();
			e && (this.delayLoadState = 1, this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube), this._texture ? this._delayedOnLoad && (this._texture.isReady ? um.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer), this._deleteBuffer && (this._buffer = null)), this._delayedOnLoad = null, this._delayedOnError = null)
		}
		getReflectionTextureMatrix() {
			const t = this.getScene();
			if (!t) return this._cachedReflectionTextureMatrix;
			if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
				if (this.coordinatesMode !== e.PROJECTION_MODE) return this._cachedReflectionTextureMatrix;
				if (this._cachedReflectionProjectionMatrixId === t.getProjectionMatrix().updateFlag) return this._cachedReflectionTextureMatrix
			}
			this._cachedReflectionTextureMatrix || (this._cachedReflectionTextureMatrix = Hc.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = Hc.Zero());
			const i = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
			switch (this._cachedReflectionUOffset = this.uOffset, this._cachedReflectionVOffset = this.vOffset, this._cachedReflectionUScale = this.uScale, this._cachedReflectionVScale = this.vScale, this._cachedReflectionCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {
				case e.PLANAR_MODE:
					Hc.IdentityToRef(this._cachedReflectionTextureMatrix), this._cachedReflectionTextureMatrix[0] = this.uScale, this._cachedReflectionTextureMatrix[5] = this.vScale, this._cachedReflectionTextureMatrix[12] = this.uOffset, this._cachedReflectionTextureMatrix[13] = this.vOffset;
					break;
				case e.PROJECTION_MODE: {
					Hc.FromValuesToRef(.5, 0, 0, 0, 0, -.5, 0, 0, 0, 0, 0, 0, .5, .5, 1, 1, this._projectionModeMatrix);
					const e = t.getProjectionMatrix();
					this._cachedReflectionProjectionMatrixId = e.updateFlag, e.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
					break
				}
				default:
					Hc.IdentityToRef(this._cachedReflectionTextureMatrix)
			}
			return i && t.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))), this._cachedReflectionTextureMatrix
		}
		static Parse(t, i, s) {
			if (t.customType) {
				const e = ad.Instantiate(t.customType).Parse(t, i, s);
				return t.samplingMode && e.updateSamplingMode && e._samplingMode && e._samplingMode !== t.samplingMode && e.updateSamplingMode(t.samplingMode), e
			}
			if (t.isCube && !t.isRenderTarget) return e._CubeTextureParser(t, i, s);
			const n = void 0 !== t.internalTextureUniqueId;
			if (!t.name && !t.isRenderTarget && !n) return null;
			let a;
			if (n) {
				const e = i.getEngine().getLoadedTexturesCache();
				for (const i of e)
					if (i.ik === t.internalTextureUniqueId) {
						a = i;
						break
					}
			}
			const r = e => {
				if (e && e._texture && (e._texture._cachedWrapU = null, e._texture._cachedWrapV = null, e._texture._cachedWrapR = null), t.samplingMode) {
					const i = t.samplingMode;
					e && e.samplingMode !== i && e.updateSamplingMode(i)
				}
				if (e && t.animations)
					for (let i = 0; i < t.animations.length; i++) {
						const s = t.animations[i],
							n = uc("BABYLON.Animation");
						n && e.animations.push(n.Parse(s))
					}
				n && !a && e?._texture?._setUniqueId(t.internalTextureUniqueId)
			};
			return Xc.Parse((() => {
				let n = !0;
				if (t.noMipmap && (n = !1), t.mirrorPlane) {
					const s = e._CreateMirror(t.name, t.renderTargetSize, i, n);
					return s._waitingRenderList = t.Tk, s.mirrorPlane = vd.FromArray(t.mirrorPlane), r(s), s
				}
				if (t.isRenderTarget) {
					let s = null;
					if (t.isCube) {
						if (i.reflectionProbes)
							for (let e = 0; e < i.reflectionProbes.length; e++) {
								const s = i.reflectionProbes[e];
								if (s.name === t.name) return s.cubeTexture
							}
					} else s = e._CreateRenderTargetTexture(t.name, t.renderTargetSize, i, n, t._creationFlags ?? 0), s._waitingRenderList = t.Tk;
					return r(s), s
				}
				if (t.isVideo) {
					const a = e._CreateVideoTexture(s + (t.url || t.name), s + (t.src || t.url), i, n, t.invertY, t.samplingMode, t.settings || {});
					return r(a), a
				} {
					let o;
					if (t.base64String && !a) o = e.CreateFromBase64String(t.base64String, t.base64String, i, !n, t.invertY, t.samplingMode, (() => {
						r(o)
					}), t._creationFlags ?? 0, t._useSRGBBuffer ?? !1), o.name = t.name;
					else {
						let l;
						l = t.name && (t.name.indexOf("://") > 0 || t.name.startsWith("data:")) ? t.name : s + t.name, t.url && (t.url.startsWith("data:") || e.UseSerializedUrlIfAny) && (l = t.url);
						const h = {
							noMipmap: !n,
							invertY: t.invertY,
							samplingMode: t.samplingMode,
							onLoad: () => {
								r(o)
							},
							internalTexture: a
						};
						o = new e(l, i, h)
					}
					return o
				}
			}), t, i)
		}
		get isBlocking() {
			return this._isBlocking
		}
		clone() {
			const t = {
				noMipmap: this._noMipmap,
				invertY: this._invertY,
				samplingMode: this.samplingMode,
				onLoad: void 0,
				onError: void 0,
				buffer: this._texture ? this._texture._buffer : void 0,
				deleteBuffer: this._deleteBuffer,
				format: this.textureFormat,
				mimeType: this.mimeType,
				loaderOptions: this._loaderOptions,
				creationFlags: this._creationFlags,
				useSRGBBuffer: this._useSRGBBuffer
			};
			return Xc.Clone((() => new e(this._texture ? this._texture.url : null, this.getScene(), t)), this)
		}
		static CreateFromBase64String(t, i, s, n, a, r = e.TRILINEAR_SAMPLINGMODE, o = null, l = null, h = 5, c, u) {
			return new e("data:" + i, s, n, a, r, o, l, t, !1, h, void 0, void 0, c, u)
		}
		_prepareRowForTextureGeneration(e, t, i, s) {
			e *= this._cachedUScale, t *= this._cachedVScale, e -= this.uRotationCenter * this._cachedUScale, t -= this.vRotationCenter * this._cachedVScale, i -= this.wRotationCenter, Lc.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, s), s.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset, s.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset, s.z += this.wRotationCenter
		}
		get invertY() {
			return this._invertY
		}
		serialize() {
			const t = this.name;
			e.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""), this.name.startsWith("data:") && this.url === this.name && (this.url = "");
			const i = super.serialize(e._SerializeInternalTextureUniqueId);
			return i ? ((e.SerializeBuffers || e.ForceSerializeBuffers) && ("string" == typeof this._buffer && "data:" === this._buffer.substr(0, 5) ? (i.base64String = this._buffer, i.name = i.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? i.base64String = "data:image/png;base64," + Ou(this._buffer) : (e.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (i.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? function(e, t = 0, i = 0) {
				const s = e.getInternalTexture();
				if (!s) return null;
				const n = e._readPixelsSync(t, i);
				return n ? Rp(n, e.getSize(), s.invertY) : null
			}(this) : async function(e, t = 0, i = 0) {
				const s = e.getInternalTexture();
				if (!s) return null;
				const n = await e.readPixels(t, i);
				return n ? Rp(n, e.getSize(), s.invertY) : null
			}(this))), i.invertY = this._invertY, i.samplingMode = this.samplingMode, i._creationFlags = this._creationFlags, i._useSRGBBuffer = this._useSRGBBuffer, e._SerializeInternalTextureUniqueId && (i.internalTextureUniqueId = this._texture?.ik ?? void 0), i.noMipmap = this._noMipmap, this.name = t, i) : null
		}
		getClassName() {
			return "Texture"
		}
		updateURL(e, t = null, i, s) {
			this.url && (this.releaseInternalTexture(), this.getScene().markAllMaterialsAsDirty(1, (e => e.hasTexture(this)))), this.name && !this.name.startsWith("data:") || (this.name = e), this.url = e, this._buffer = t, this._forcedExtension = s, this.delayLoadState = 4, i && (this._delayedOnLoad = i), this.delayLoad()
		}
		get noMipmap() {
			return this._noMipmap
		}
		dispose() {
			super.dispose(), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null, this._buffer = null
		}
		static LoadFromDataString(t, i, s, n = !1, a, r = !0, o = e.TRILINEAR_SAMPLINGMODE, l = null, h = null, c = 5, u, m) {
			return "data:" !== t.substr(0, 5) && (t = "data:" + t), new e(t, s, a, r, o, l, h, i, n, c, void 0, void 0, u, m)
		}
	};
	Np.SerializeBuffers = !0, Np.ForceSerializeBuffers = !1, Np.OnTextureLoadErrorObservable = new kc, Np._SerializeInternalTextureUniqueId = !1, Np._CubeTextureParser = (e, t, i) => {
		throw ic("CubeTexture")
	}, Np._CreateMirror = (e, t, i, s) => {
		throw ic("MirrorTexture")
	}, Np._CreateRenderTargetTexture = (e, t, i, s, n) => {
		throw ic("RenderTargetTexture")
	}, Np.NEAREST_SAMPLINGMODE = 1, Np.NEAREST_NEAREST_MIPLINEAR = 8, Np.BILINEAR_SAMPLINGMODE = 2, Np.LINEAR_LINEAR_MIPNEAREST = 11, Np.TRILINEAR_SAMPLINGMODE = 3, Np.LINEAR_LINEAR_MIPLINEAR = 3, Np.NEAREST_NEAREST_MIPNEAREST = 4, Np.NEAREST_LINEAR_MIPNEAREST = 5, Np.NEAREST_LINEAR_MIPLINEAR = 6, Np.NEAREST_LINEAR = 7, Np.NEAREST_NEAREST = 1, Np.LINEAR_NEAREST_MIPNEAREST = 9, Np.LINEAR_NEAREST_MIPLINEAR = 10, Np.LINEAR_LINEAR = 2, Np.LINEAR_NEAREST = 12, Np.EXPLICIT_MODE = 0, Np.SPHERICAL_MODE = 1, Np.PLANAR_MODE = 2, Np.CUBIC_MODE = 3, Np.PROJECTION_MODE = 4, Np.SKYBOX_MODE = 5, Np.INVCUBIC_MODE = 6, Np.EQUIRECTANGULAR_MODE = 7, Np.FIXED_EQUIRECTANGULAR_MODE = 8, Np.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, Np.CLAMP_ADDRESSMODE = 0, Np.WRAP_ADDRESSMODE = 1, Np.MIRROR_ADDRESSMODE = 2, Np.UseSerializedUrlIfAny = !1, Gh([Xh()], Np.prototype, "url", void 0), Gh([Xh()], Np.prototype, "uOffset", void 0), Gh([Xh()], Np.prototype, "vOffset", void 0), Gh([Xh()], Np.prototype, "uScale", void 0), Gh([Xh()], Np.prototype, "vScale", void 0), Gh([Xh()], Np.prototype, "uAng", void 0), Gh([Xh()], Np.prototype, "vAng", void 0), Gh([Xh()], Np.prototype, "wAng", void 0), Gh([Xh()], Np.prototype, "uRotationCenter", void 0), Gh([Xh()], Np.prototype, "vRotationCenter", void 0), Gh([Xh()], Np.prototype, "wRotationCenter", void 0), Gh([Xh()], Np.prototype, "homogeneousRotationInUVTransform", void 0), Gh([Xh()], Np.prototype, "isBlocking", null), cc("BABYLON.Texture", Np), Xc._TextureParser = Np.Parse;
	var Ip = class extends ap {
		get b() {
			return this._outputs[4]
		}
		get rgb() {
			return this._outputs[1]
		}
		constructor(e) {
			super(e, Xf.VertexAndFragment), this._samplerName = "textureSampler", this.convertToGammaSpace = !1, this.convertToLinearSpace = !1, this._isUnique = !1, this.registerInput("uv", Wf.AutoDetect, !1, Xf.VertexAndFragment), this.registerOutput("rgba", Wf.Color4, Xf.Neutral), this.registerOutput("rgb", Wf.Color3, Xf.Neutral), this.registerOutput("r", Wf.Float, Xf.Neutral), this.registerOutput("g", Wf.Float, Xf.Neutral), this.registerOutput("b", Wf.Float, Xf.Neutral), this.registerOutput("a", Wf.Float, Xf.Neutral), this._inputs[0].addExcludedConnectionPointFromAllowedTypes(Wf.Vector2 | Wf.Vector3 | Wf.Vector4), this._inputs[0]._prioritizeVertex = !1
		}
		get r() {
			return this._outputs[2]
		}
		get rgba() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			if (super._buildBlock(e), this._tempTextureRead = e._getFreeVariableName("tempTextureRead"), e.sharedData.blockingBlocks.indexOf(this) < 0 && e.sharedData.blockingBlocks.push(this), e.sharedData.textureBlocks.indexOf(this) < 0 && e.sharedData.textureBlocks.push(this), e.sharedData.blocksWithDefines.indexOf(this) < 0 && e.sharedData.blocksWithDefines.push(this), e.target !== Xf.Fragment) return e._emit2DSampler(this._samplerName), void this._injectVertexCode(e);
			if (!this._outputs.some((e => e.isConnectedInFragmentShader))) return;
			e._emit2DSampler(this._samplerName), this._linearDefineName = e._getFreeDefineName("ISLINEAR"), this._gammaDefineName = e._getFreeDefineName("ISGAMMA");
			const t = `//${this.name}`;
			e._emitFunctionFromInclude("helperFunctions", t), this._writeTextureRead(e);
			for (const t of this._outputs) t.hasEndpoints && this._writeOutput(e, t, t.name);
			return this
		}
		serialize() {
			const e = super.serialize();
			return e.convertToGammaSpace = this.convertToGammaSpace, e.convertToLinearSpace = this.convertToLinearSpace, this.texture && !this.texture.isRenderTarget && (e.texture = this.texture.serialize()), e
		}
		get g() {
			return this._outputs[3]
		}
		prepareDefines(e, t, i) {
			i.setValue(this._linearDefineName, this.convertToGammaSpace, !0), i.setValue(this._gammaDefineName, this.convertToLinearSpace, !0)
		}
		get a() {
			return this._outputs[5]
		}
		_injectVertexCode(e) {
			const t = this.uv;
			if (t.connectedPoint.ownerBlock.isInput) {
				t.connectedPoint.ownerBlock.isAttribute || e._emitUniformFromString(t.associatedVariableName, Wf.Vector2)
			}
			if (this._mainUVName = "vMain" + t.associatedVariableName, e._emitVaryingFromString(this._mainUVName, Wf.Vector2), e.compilationString += `${this._mainUVName} = ${t.associatedVariableName}.xy;\n`, this._outputs.some((e => e.isConnectedInVertexShader))) {
				this._writeTextureRead(e, !0);
				for (const t of this._outputs) t.hasEndpoints && this._writeOutput(e, t, t.name, !0)
			}
		}
		isReady() {
			return !(this.texture && !this.texture.isReadyOrNotBlocking())
		}
		initialize(e) {
			e._excludeVariableName(this._samplerName)
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.convertToGammaSpace = e.convertToGammaSpace, this.convertToLinearSpace = !!e.convertToLinearSpace, e.texture && (i = 0 === e.texture.url.indexOf("data:") ? "" : i, this.texture = Np.Parse(e.texture, t, i))
		}
		get target() {
			return this.uv.isConnected ? this.uv.sourceBlock.isInput ? Xf.VertexAndFragment : Xf.Fragment : Xf.VertexAndFragment
		}
		_writeTextureRead(e, t = !1) {
			const i = this.uv;
			if (t) {
				if (e.target === Xf.Fragment) return;
				const t = 0 === e.shaderLanguage ? `texture2D(${this._samplerName},` : `textureSampleLevel(${this._samplerName}, ${this._samplerName+"Sampler"},`,
					s = 0 === e.shaderLanguage ? "" : ", 0";
				return void(e.compilationString += `${e._declareLocalVar(this._tempTextureRead,Wf.Vector4)} = ${t} ${i.associatedVariableName}${s});\n`)
			}
			const s = 0 === e.shaderLanguage ? `texture2D(${this._samplerName},` : `textureSample(${this._samplerName}, ${this._samplerName+"Sampler"},`;
			this.uv.ownerBlock.target !== Xf.Fragment ? e.compilationString += `${e._declareLocalVar(this._tempTextureRead,Wf.Vector4)} = ${s} ${this._mainUVName});\n` : e.compilationString += `${e._declareLocalVar(this._tempTextureRead,Wf.Vector4)} = ${s} ${i.associatedVariableName});\n`
		}
		getClassName() {
			return "CurrentScreenBlock"
		}
		_writeOutput(e, t, i, s = !1) {
			if (s) {
				if (e.target === Xf.Fragment) return;
				e.compilationString += `${e._declareOutput(t)} = ${this._tempTextureRead}.${i};\n`
			} else this.uv.ownerBlock.target !== Xf.Fragment ? (e.compilationString += `${e._declareOutput(t)} = ${this._tempTextureRead}.${i};\n`, e.compilationString += `#ifdef ${this._linearDefineName}\n`, e.compilationString += `${t.associatedVariableName} = toGammaSpace(${t.associatedVariableName});\n`, e.compilationString += "#endif\n", e.compilationString += `#ifdef ${this._gammaDefineName}\n`, e.compilationString += `${t.associatedVariableName} = toLinearSpace(${t.associatedVariableName});\n`, e.compilationString += "#endif\n") : e.compilationString += `${e._declareOutput(t)} = ${this._tempTextureRead}.${i};\n`
		}
		get uv() {
			return this._inputs[0]
		}
	};
	cc("BABYLON.CurrentScreenBlock", Ip);
	var Pp = class extends ap {
		serialize() {
			const e = super.serialize();
			return e.convertToGammaSpace = this.convertToGammaSpace, e.convertToLinearSpace = this.convertToLinearSpace, this.texture && !this.texture.isRenderTarget && (e.texture = this.texture.serialize()), e
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.convertToGammaSpace = e.convertToGammaSpace, this.convertToLinearSpace = !!e.convertToLinearSpace, e.texture && (i = 0 === e.texture.url.indexOf("data:") ? "" : i, this.texture = Np.Parse(e.texture, t, i))
		}
		get rgb() {
			return this._outputs[1]
		}
		prepareDefines(e, t, i) {
			i.setValue(this._linearDefineName, this.convertToGammaSpace, !0), i.setValue(this._gammaDefineName, this.convertToLinearSpace, !0)
		}
		get g() {
			return this._outputs[3]
		}
		get b() {
			return this._outputs[4]
		}
		getClassName() {
			return "ParticleTextureBlock"
		}
		get r() {
			return this._outputs[2]
		}
		_buildBlock(e) {
			if (super._buildBlock(e), e.target === Xf.Vertex) return;
			this._tempTextureRead = e._getFreeVariableName("tempTextureRead"), e._emit2DSampler(this._samplerName), e.sharedData.blockingBlocks.push(this), e.sharedData.textureBlocks.push(this), e.sharedData.blocksWithDefines.push(this), this._linearDefineName = e._getFreeDefineName("ISLINEAR"), this._gammaDefineName = e._getFreeDefineName("ISGAMMA");
			const t = `//${this.name}`;
			e._emitFunctionFromInclude("helperFunctions", t), e.compilationString += `${e._declareLocalVar(this._tempTextureRead,Wf.Vector4)} = ${e._generateTextureSample(this.uv.associatedVariableName,this._samplerName)};\n`;
			for (const t of this._outputs) t.hasEndpoints && this._writeOutput(e, t, t.name);
			return this
		}
		constructor(e) {
			super(e, Xf.Fragment), this._samplerName = "diffuseSampler", this.convertToGammaSpace = !1, this.convertToLinearSpace = !1, this._isUnique = !1, this.registerInput("uv", Wf.AutoDetect, !1, Xf.VertexAndFragment), this.registerOutput("rgba", Wf.Color4, Xf.Neutral), this.registerOutput("rgb", Wf.Color3, Xf.Neutral), this.registerOutput("r", Wf.Float, Xf.Neutral), this.registerOutput("g", Wf.Float, Xf.Neutral), this.registerOutput("b", Wf.Float, Xf.Neutral), this.registerOutput("a", Wf.Float, Xf.Neutral), this._inputs[0].addExcludedConnectionPointFromAllowedTypes(Wf.Vector2 | Wf.Vector3 | Wf.Vector4)
		}
		get rgba() {
			return this._outputs[0]
		}
		get a() {
			return this._outputs[5]
		}
		initialize(e) {
			e._excludeVariableName("diffuseSampler")
		}
		autoConfigure(e, t = () => !0) {
			if (!this.uv.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "particle_uv" === e.name && t(e)));
				i || (i = new Cp("uv"), i.setAsAttribute("particle_uv")), i.output.connectTo(this.uv)
			}
		}
		isReady() {
			return !(this.texture && !this.texture.isReadyOrNotBlocking())
		}
		_writeOutput(e, t, i) {
			e.compilationString += `${e._declareOutput(t)} = ${this._tempTextureRead}.${i};\n`, e.compilationString += `#ifdef ${this._linearDefineName}\n`, e.compilationString += `${t.associatedVariableName} = toGammaSpace(${t.associatedVariableName});\n`, e.compilationString += "#endif\n", e.compilationString += `#ifdef ${this._gammaDefineName}\n`, e.compilationString += `${t.associatedVariableName} = toLinearSpace(${t.associatedVariableName});\n`, e.compilationString += "#endif\n"
		}
		get uv() {
			return this._inputs[0]
		}
	};
	cc("BABYLON.ParticleTextureBlock", Pp);
	var kp = class extends ap {
		initialize(e) {
			e._excludeVariableName("remapRanges"), e._excludeVariableName("rampSampler"), e._excludeVariableName("baseColor"), e._excludeVariableName("alpha"), e._excludeVariableName("remappedColorIndex"), e._excludeVariableName("rampColor")
		}
		get rampColor() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			if (super._buildBlock(e), e.target !== Xf.Vertex) return e._emit2DSampler("rampSampler", "RAMPGRADIENT"), e._emitVaryingFromString("remapRanges", Wf.Vector4, "RAMPGRADIENT"), e.compilationString += `\n            #ifdef RAMPGRADIENT\n                ${e._declareLocalVar("baseColor",Wf.Vector4)} = ${this.color.associatedVariableName};\n                ${e._declareLocalVar("alpha",Wf.Float)} = ${this.color.associatedVariableName}.a;\n\n                ${e._declareLocalVar("remappedColorIndex",Wf.Float)} = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\n\n                ${e._declareLocalVar("rampColor",Wf.Vector4)} = ${e._generateTextureSample("vec2(1.0 - remappedColorIndex, 0.)","rampSampler")};\n\n                // Remapped alpha\n                ${e._declareOutput(this.rampColor)} = vec4${e.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0));\n            #else\n                ${e._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};\n            #endif\n        `, this
		}
		get color() {
			return this._inputs[0]
		}
		getClassName() {
			return "ParticleRampGradientBlock"
		}
		constructor(e) {
			super(e, Xf.Fragment), this._isUnique = !0, this.registerInput("color", Wf.Color4, !1, Xf.Fragment), this.registerOutput("rampColor", Wf.Color4, Xf.Fragment)
		}
	};
	cc("BABYLON.ParticleRampGradientBlock", kp);
	var Dp = class extends ap {
		get alphaTexture() {
			return this._inputs[1]
		}
		constructor(e) {
			super(e, Xf.Fragment), this._isUnique = !0, this.registerInput("color", Wf.Color4, !1, Xf.Fragment), this.registerInput("alphaTexture", Wf.Float, !1, Xf.Fragment), this.registerInput("alphaColor", Wf.Float, !1, Xf.Fragment), this.registerOutput("blendColor", Wf.Color4, Xf.Fragment)
		}
		getClassName() {
			return "ParticleBlendMultiplyBlock"
		}
		initialize(e) {
			e._excludeVariableName("sourceAlpha")
		}
		_buildBlock(e) {
			if (super._buildBlock(e), e.target !== Xf.Vertex) return e.compilationString += `\n            #ifdef BLENDMULTIPLYMODE\n                ${e._declareOutput(this.blendColor)};\n                ${e._declareLocalVar("sourceAlpha",Wf.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};\n                ${this.blendColor.associatedVariableName} = vec4${e.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);\n            #else\n                ${e._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};\n            #endif\n        `, this
		}
		get alphaColor() {
			return this._inputs[2]
		}
		get blendColor() {
			return this._outputs[0]
		}
		get color() {
			return this._inputs[0]
		}
	};
	cc("BABYLON.ParticleBlendMultiplyBlock", Dp);
	var Op = class {
		addCPUSkinningFallback(e, t) {
			this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e)
		}
		constructor() {
			this._defines = {}, this._currentRank = 32, this._maxRank = -1, this._mesh = null
		}
		get hasMoreFallbacks() {
			return this._currentRank <= this._maxRank
		}
		unBindMesh() {
			this._mesh = null
		}
		addFallback(e, t) {
			this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array), this._defines[e].push(t)
		}
		reduce(e, t) {
			if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
				this._mesh.computeBonesUsingShaders = !1, e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), t._bonesComputationForcedToCPU = !0;
				const i = this._mesh.getScene();
				for (let e = 0; e < i.meshes.length; e++) {
					const s = i.meshes[e];
					if (s.material) {
						if (s.computeBonesUsingShaders && 0 !== s.numBoneInfluencers)
							if (s.material.getEffect() === t) s.computeBonesUsingShaders = !1;
							else if (s.subMeshes)
							for (const e of s.subMeshes) {
								if (e.effect === t) {
									s.computeBonesUsingShaders = !1;
									break
								}
							}
					} else !this._mesh.material && s.computeBonesUsingShaders && s.numBoneInfluencers > 0 && (s.computeBonesUsingShaders = !1)
				}
			} else {
				const t = this._defines[this._currentRank];
				if (t)
					for (let i = 0; i < t.length; i++) e = e.replace("#define " + t[i], "");
				this._currentRank++
			}
			return e
		}
	};
	f();
	var Fp = class {
			get depth() {
				return this._size.depth || 0
			}
			get depthStencilTexture() {
				return this._depthStencilTexture
			}
			get samples() {
				return this._samples
			}
			get textures() {
				return this._textures
			}
			get is2DArray() {
				return this.layers > 0
			}
			get layerIndices() {
				return this._layerIndices
			}
			get is3D() {
				return this.depth > 0
			}
			get height() {
				return this._size.height || this._size
			}
			get depthStencilTextureWithStencil() {
				return this._depthStencilTextureWithStencil
			}
			get layers() {
				return this._size.layers || 0
			}
			dispose(e = !1) {
				e || (this._depthStencilTexture?.dispose(), this._depthStencilTexture = null, this.releaseTextures()), this._engine._releaseRenderTargetWrapper(this)
			}
			get width() {
				return this._size.width || this._size
			}
			constructor(e, t, i, s, n) {
				this._textures = null, this._faceIndices = null, this._layerIndices = null, this._samples = 1, this._attachments = null, this._generateStencilBuffer = !1, this._generateDepthBuffer = !1, this._depthStencilTextureWithStencil = !1, this._isMulti = e, this._isCube = t, this._size = i, this._engine = s, this._depthStencilTexture = null, this.label = n
			}
			setTextures(e) {
				Array.isArray(e) ? this._textures = e : this._textures = e ? [e] : null
			}
			setLayerAndFaceIndex(e = 0, t, i) {
				this._layerIndices || (this._layerIndices = []), this._faceIndices || (this._faceIndices = []), void 0 !== t && t >= 0 && (this._layerIndices[e] = t), void 0 !== i && i >= 0 && (this._faceIndices[e] = i)
			}
			get texture() {
				return this._textures?.[0] ?? null
			}
			setSamples(e, t = !0, i = !1) {
				if (this.samples === e && !i) return e;
				const s = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, e, t) : this._engine.updateRenderTargetTextureSampleCount(this, e);
				return this._samples = e, s
			}
			setLayerAndFaceIndices(e, t) {
				this._layerIndices = e, this._faceIndices = t
			}
			get isCube() {
				return this._isCube
			}
			_swapAndDie(e) {
				this.texture && this.texture._swapAndDie(e), this._textures = null, this.dispose(!0)
			}
			_swapRenderTargetWrapper(e) {
				if (this._textures && e._textures)
					for (let t = 0; t < this._textures.length; ++t) this._textures[t]._swapAndDie(e._textures[t], !1), e._textures[t].isReady = !0;
				this._depthStencilTexture && e._depthStencilTexture && (this._depthStencilTexture._swapAndDie(e._depthStencilTexture), e._depthStencilTexture.isReady = !0), this._textures = null, this._depthStencilTexture = null
			}
			createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, n = 14, a) {
				return this._depthStencilTexture?.dispose(), this._depthStencilTextureWithStencil = i, this._depthStencilTextureLabel = a, this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
					bilinearFiltering: t,
					comparisonFunction: e,
					generateStencil: i,
					isCube: this._isCube,
					samples: s,
					depthTextureFormat: n,
					label: a
				}, this), this._depthStencilTexture
			}
			_shareDepth(e) {
				this.shareDepth(e)
			}
			_cloneRenderTargetWrapper() {
				let e = null;
				if (this._isMulti) {
					const t = this.textures;
					if (t && t.length > 0) {
						let i = !1,
							s = t.length,
							n = -1;
						const a = t[t.length - 1]._source;
						14 !== a && 12 !== a || (i = !0, n = t[t.length - 1].format, s--);
						const r = [],
							o = [],
							l = [],
							h = [],
							c = [],
							u = [],
							m = [],
							d = {};
						for (let e = 0; e < s; ++e) {
							const i = t[e];
							r.push(i.samplingMode), o.push(i.type), l.push(i.format);
							void 0 !== d[i.ik] ? (h.push(-1), m.push(0)) : (d[i.ik] = e, i.is2DArray ? (h.push(35866), m.push(i.depth)) : i.isCube ? (h.push(34067), m.push(0)) : i.is3D ? (h.push(32879), m.push(i.depth)) : (h.push(3553), m.push(0))), this._faceIndices && c.push(this._faceIndices[e] ?? 0), this._layerIndices && u.push(this._layerIndices[e] ?? 0)
						}
						const f = {
								samplingModes: r,
								generateMipMaps: t[0].generateMipMaps,
								generateDepthBuffer: this._generateDepthBuffer,
								generateStencilBuffer: this._generateStencilBuffer,
								generateDepthTexture: i,
								depthTextureFormat: n,
								types: o,
								formats: l,
								textureCount: s,
								targetTypes: h,
								faceIndex: c,
								layerIndex: u,
								layerCounts: m,
								label: this.label
							},
							p = {
								width: this.width,
								height: this.height,
								depth: this.depth
							};
						e = this._engine.createMultipleRenderTarget(p, f);
						for (let i = 0; i < s; ++i) {
							if (-1 !== h[i]) continue;
							const s = d[t[i].ik];
							e.setTexture(e.textures[s], i)
						}
					}
				} else {
					const t = {};
					if (t.generateDepthBuffer = this._generateDepthBuffer, t.generateMipMaps = this.texture?.generateMipMaps ?? !1, t.generateStencilBuffer = this._generateStencilBuffer, t.samplingMode = this.texture?.samplingMode, t.type = this.texture?.type, t.format = this.texture?.format, t.noColorAttachment = !this._textures, t.label = this.label, this.isCube) e = this._engine.createRenderTargetCubeTexture(this.width, t);
					else {
						const i = {
							width: this.width,
							height: this.height,
							layers: this.is2DArray || this.is3D ? this.texture?.depth : void 0
						};
						e = this._engine.createRenderTargetTexture(i, t)
					}
					e.texture && (e.texture.isReady = !0)
				}
				return e
			}
			get faceIndices() {
				return this._faceIndices
			}
			setTexture(e, t = 0, i = !0) {
				this._textures || (this._textures = []), this._textures[t] !== e && (this._textures[t] && i && this._textures[t].dispose(), this._textures[t] = e)
			}
			shareDepth(e) {
				this._depthStencilTexture && (e._depthStencilTexture && e._depthStencilTexture.dispose(), e._depthStencilTexture = this._depthStencilTexture, e._depthStencilTextureWithStencil = this._depthStencilTextureWithStencil, this._depthStencilTexture.incrementReferences())
			}
			get isMulti() {
				return this._isMulti
			}
			_rebuild() {
				const e = this._cloneRenderTargetWrapper();
				if (e) {
					if (this._depthStencilTexture) {
						const t = this._depthStencilTexture.samplingMode,
							i = this._depthStencilTexture.format,
							s = 2 === t || 3 === t || 11 === t;
						e.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, s, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples, i, this._depthStencilTextureLabel)
					}
					this.samples > 1 && e.setSamples(this.samples), e._swapRenderTargetWrapper(this), e.dispose()
				}
			}
			releaseTextures() {
				if (this._textures)
					for (let e = 0; e < this._textures?.length; ++e) this._textures[e].dispose();
				this._textures = null
			}
			get size() {
				return this.width
			}
		},
		Lp = class extends Fp {
			setLayerAndFaceIndices(e, t) {
				if (super.setLayerAndFaceIndices(e, t), !this.textures || !this.layerIndices || !this.faceIndices) return;
				const i = this._attachments?.length ?? this.textures.length;
				for (let e = 0; e < i; e++) {
					const t = this.textures[e];
					t && (t.is2DArray || t.is3D ? this._bindTextureRenderTarget(t, e, this.layerIndices[e]) : t.isCube ? this._bindTextureRenderTarget(t, e, this.faceIndices[e]) : this._bindTextureRenderTarget(t, e))
				}
			}
			constructor(e, t, i, s, n) {
				super(e, t, i, s), this._framebuffer = null, this._depthStencilBuffer = null, this._MSAAFramebuffer = null, this._colorTextureArray = null, this._depthStencilTextureArray = null, this._disposeOnlyFramebuffers = !1, this._currentLOD = 0, this._context = n
			}
			dispose(e = this._disposeOnlyFramebuffers) {
				const t = this._context;
				e || (this._colorTextureArray && (this._context.deleteTexture(this._colorTextureArray), this._colorTextureArray = null), this._depthStencilTextureArray && (this._context.deleteTexture(this._depthStencilTextureArray), this._depthStencilTextureArray = null)), this._framebuffer && (t.deleteFramebuffer(this._framebuffer), this._framebuffer = null), this._depthStencilBuffer && (t.deleteRenderbuffer(this._depthStencilBuffer), this._depthStencilBuffer = null), this._MSAAFramebuffer && (t.deleteFramebuffer(this._MSAAFramebuffer), this._MSAAFramebuffer = null), super.dispose(e)
			}
			_bindTextureRenderTarget(e, t = 0, i, s = 0) {
				if (!e._hardwareTexture) return;
				const n = this._framebuffer,
					a = this._engine,
					r = a._currentFramebuffer;
				if (a._bindUnboundFramebuffer(n), a.webGLVersion > 1) {
					const n = this._context,
						a = n["COLOR_ATTACHMENT" + t];
					e.is2DArray || e.is3D ? (i = i ?? this.layerIndices?.[t] ?? 0, n.framebufferTextureLayer(n.FRAMEBUFFER, a, e._hardwareTexture.underlyingResource, s, i)) : e.isCube ? (i = i ?? this.faceIndices?.[t] ?? 0, n.framebufferTexture2D(n.FRAMEBUFFER, a, n.TEXTURE_CUBE_MAP_POSITIVE_X + i, e._hardwareTexture.underlyingResource, s)) : n.framebufferTexture2D(n.FRAMEBUFFER, a, n.TEXTURE_2D, e._hardwareTexture.underlyingResource, s)
				} else {
					const n = this._context,
						a = n["COLOR_ATTACHMENT" + t + "_WEBGL"],
						r = void 0 !== i ? n.TEXTURE_CUBE_MAP_POSITIVE_X + i : n.TEXTURE_2D;
					n.framebufferTexture2D(n.FRAMEBUFFER, a, r, e._hardwareTexture.underlyingResource, s)
				}
				a._bindUnboundFramebuffer(r)
			}
			setTexture(e, t = 0, i = !0) {
				super.setTexture(e, t, i), this._bindTextureRenderTarget(e, t)
			}
			_swapRenderTargetWrapper(e) {
				super._swapRenderTargetWrapper(e), e._framebuffer = this._framebuffer, e._depthStencilBuffer = this._depthStencilBuffer, e._MSAAFramebuffer = this._MSAAFramebuffer, e._colorTextureArray = this._colorTextureArray, e._depthStencilTextureArray = this._depthStencilTextureArray, this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null
			}
			createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, n = 14, a) {
				if (this._depthStencilBuffer) {
					const e = this._engine,
						t = e._currentFramebuffer,
						i = this._context;
					e._bindUnboundFramebuffer(this._framebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, null), e._bindUnboundFramebuffer(t), i.deleteRenderbuffer(this._depthStencilBuffer), this._depthStencilBuffer = null
				}
				return super.createDepthStencilTexture(e, t, i, s, n, a)
			}
			shareDepth(e) {
				super.shareDepth(e);
				const t = this._context,
					i = this._depthStencilBuffer,
					s = e._MSAAFramebuffer || e._framebuffer,
					n = this._engine;
				e._depthStencilBuffer && e._depthStencilBuffer !== i && t.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = i;
				const a = e._generateStencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
				n._bindUnboundFramebuffer(s), t.framebufferRenderbuffer(t.FRAMEBUFFER, a, t.RENDERBUFFER, i), n._bindUnboundFramebuffer(null)
			}
			_cloneRenderTargetWrapper() {
				let e = null;
				return this._colorTextureArray && this._depthStencilTextureArray ? (e = this._engine.createMultiviewRenderTargetTexture(this.width, this.height), e.texture.isReady = !0) : e = super._cloneRenderTargetWrapper(), e
			}
			setLayerAndFaceIndex(e = 0, t, i) {
				if (super.setLayerAndFaceIndex(e, t, i), !this.textures || !this.layerIndices || !this.faceIndices) return;
				const s = this.textures[e];
				s.is2DArray || s.is3D ? this._bindTextureRenderTarget(this.textures[e], e, this.layerIndices[e]) : s.isCube && this._bindTextureRenderTarget(this.textures[e], e, this.faceIndices[e])
			}
		};
	Nd.prototype._createHardwareRenderTargetWrapper = function(e, t, i) {
		const s = new Lp(e, t, i, this, this._gl);
		return this._renderTargetWrapperCache.push(s), s
	}, Nd.prototype.createRenderTargetTexture = function(e, t) {
		const i = this._createHardwareRenderTargetWrapper(!1, !1, e);
		let s, n, a = !0,
			r = !1,
			o = !1,
			l = 1;
		void 0 !== t && "object" == typeof t && (a = t.generateDepthBuffer ?? !0, r = !!t.generateStencilBuffer, o = !!t.noColorAttachment, s = t.colorAttachment, l = t.samples ?? 1, n = t.label);
		const h = s || (o ? null : this._createInternalTexture(e, t, !0, 5)),
			c = e.width || e,
			u = e.height || e,
			m = this._currentFramebuffer,
			d = this._gl,
			f = d.createFramebuffer();
		return this._bindUnboundFramebuffer(f), i._depthStencilBuffer = this._setupFramebufferDepthAttachments(r, a, c, u), !h || h.is2DArray || h.is3D || d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, h._hardwareTexture.underlyingResource, 0), this._bindUnboundFramebuffer(m), i.label = n ?? "RenderTargetWrapper", i._framebuffer = f, i._generateDepthBuffer = a, i._generateStencilBuffer = r, i.setTextures(h), this.updateRenderTargetTextureSampleCount(i, l), i
	}, Nd.prototype._createDepthStencilTexture = function(e, t) {
		const i = this._gl,
			s = e.layers || 0,
			n = e.depth || 0;
		let a = i.TEXTURE_2D;
		0 !== s ? a = i.TEXTURE_2D_ARRAY : 0 !== n && (a = i.TEXTURE_3D);
		const r = new Pm(this, 12);
		if (r.label = t.label, !this._caps.depthTextureExtension) return Qc.Error("Depth texture is not supported by your browser or hardware."), r;
		const o = {
			bilinearFiltering: !1,
			comparisonFunction: 0,
			generateStencil: !1,
			...t
		};
		if (this._bindTextureDirectly(a, r, !0), this._setupDepthStencilTexture(r, e, o.generateStencil, 0 !== o.comparisonFunction && o.bilinearFiltering, o.comparisonFunction, o.samples), void 0 !== o.depthTextureFormat) {
			if (15 !== o.depthTextureFormat && 16 !== o.depthTextureFormat && 17 !== o.depthTextureFormat && 13 !== o.depthTextureFormat && 14 !== o.depthTextureFormat && 18 !== o.depthTextureFormat) return Qc.Error("Depth texture format is not supported."), r;
			r.format = o.depthTextureFormat
		} else r.format = o.generateStencil ? 13 : 16;
		const l = 17 === r.format || 13 === r.format || 18 === r.format;
		let h = i.UNSIGNED_INT;
		15 === r.format ? h = i.UNSIGNED_SHORT : 17 === r.format || 13 === r.format ? h = i.UNSIGNED_INT_24_8 : 14 === r.format ? h = i.FLOAT : 18 === r.format && (h = i.FLOAT_32_UNSIGNED_INT_24_8_REV);
		const c = l ? i.DEPTH_STENCIL : i.DEPTH_COMPONENT;
		let u = c;
		return this.webGLVersion > 1 && (15 === r.format ? u = i.DEPTH_COMPONENT16 : 16 === r.format ? u = i.DEPTH_COMPONENT24 : 17 === r.format || 13 === r.format ? u = i.DEPTH24_STENCIL8 : 14 === r.format ? u = i.DEPTH_COMPONENT32F : 18 === r.format && (u = i.DEPTH32F_STENCIL8)), r.is2DArray ? i.texImage3D(a, 0, u, r.width, r.height, s, 0, c, h, null) : r.is3D ? i.texImage3D(a, 0, u, r.width, r.height, n, 0, c, h, null) : i.texImage2D(a, 0, u, r.width, r.height, 0, c, h, null), this._bindTextureDirectly(a, null), this._internalTexturesCache.push(r), r
	}, Nd.prototype.updateRenderTargetTextureSampleCount = function(e, t) {
		if (this.webGLVersion < 2 || !e || !e.texture) return 1;
		if (e.samples === t) return t;
		const i = this._gl;
		t = Math.min(t, this.getCaps().maxMSAASamples), e._depthStencilBuffer && (i.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = null), e._MSAAFramebuffer && (i.deleteFramebuffer(e._MSAAFramebuffer), e._MSAAFramebuffer = null);
		const s = e.texture._hardwareTexture;
		if (s.releaseMSAARenderBuffers(), t > 1 && "function" == typeof i.renderbufferStorageMultisample) {
			const n = i.createFramebuffer();
			if (!n) throw new Error("Unable to create multi sampled framebuffer");
			e._MSAAFramebuffer = n, this._bindUnboundFramebuffer(e._MSAAFramebuffer);
			const a = this._createRenderBuffer(e.texture.width, e.texture.height, t, -1, this._getRGBABufferInternalSizedFormat(e.texture.type, e.texture.format, e.texture._useSRGBBuffer), i.COLOR_ATTACHMENT0, !1);
			if (!a) throw new Error("Unable to create multi sampled framebuffer");
			s.addMSAARenderBuffer(a)
		} else this._bindUnboundFramebuffer(e._framebuffer);
		return e.texture.samples = t, e._samples = t, e._depthStencilBuffer = this._setupFramebufferDepthAttachments(e._generateStencilBuffer, e._generateDepthBuffer, e.texture.width, e.texture.height, t), this._bindUnboundFramebuffer(null), t
	}, Nd.prototype._setupDepthStencilTexture = function(e, t, i, s, n, a = 1) {
		const r = t.width || t,
			o = t.height || t,
			l = t.layers || 0,
			h = t.depth || 0;
		e.baseWidth = r, e.baseHeight = o, e.width = r, e.height = o, e.is2DArray = l > 0, e.depth = l || h, e.isReady = !0, e.samples = a, e.generateMipMaps = !1, e.samplingMode = s ? 2 : 1, e.type = 0, e._comparisonFunction = n;
		const c = this._gl,
			u = this._getTextureTarget(e),
			m = this._getSamplingParameters(e.samplingMode, !1);
		c.texParameteri(u, c.TEXTURE_MAG_FILTER, m.mag), c.texParameteri(u, c.TEXTURE_MIN_FILTER, m.min), c.texParameteri(u, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(u, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), this.webGLVersion > 1 && (0 === n ? (c.texParameteri(u, c.TEXTURE_COMPARE_FUNC, 515), c.texParameteri(u, c.TEXTURE_COMPARE_MODE, c.NONE)) : (c.texParameteri(u, c.TEXTURE_COMPARE_FUNC, n), c.texParameteri(u, c.TEXTURE_COMPARE_MODE, c.COMPARE_REF_TO_TEXTURE)))
	}, Dm.prototype.setTextureFromPostProcess = function(e, t, i) {
		let s = null;
		t && (t._forcedOutputTexture ? s = t._forcedOutputTexture : t._textures.data[t._currentRenderTextureInd] && (s = t._textures.data[t._currentRenderTextureInd])), this._bindTexture(e, s?.texture ?? null, i)
	}, Dm.prototype.setTextureFromPostProcessOutput = function(e, t, i) {
		this._bindTexture(e, t?._outputTexture?.texture ?? null, i)
	}, xm.prototype.setTextureFromPostProcess = function(e, t) {
		this._engine.setTextureFromPostProcess(this._samplers[e], t, e)
	}, xm.prototype.setTextureFromPostProcessOutput = function(e, t) {
		this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e)
	};
	var Bp = class e {
		clone() {
			const t = this.serialize();
			t._engine = this._engine, t.cameraId = null;
			const i = e.Parse(t, this._scene, "");
			return i ? (i.onActivateObservable = this.onActivateObservable.clone(), i.onSizeChangedObservable = this.onSizeChangedObservable.clone(), i.onApplyObservable = this.onApplyObservable.clone(), i.onBeforeRenderObservable = this.onBeforeRenderObservable.clone(), i.onAfterRenderObservable = this.onAfterRenderObservable.clone(), i._prePassEffectConfiguration = this._prePassEffectConfiguration, i) : null
		}
		markTextureDirty() {
			this.width = -1
		}
		resize(e, t, i = null, s = !1, n = !1) {
			this._textures.length > 0 && this._textures.reset(), this.width = e, this.height = t;
			let a = null;
			if (i)
				for (let e = 0; e < i._postProcesses.length; e++)
					if (null !== i._postProcesses[e]) {
						a = i._postProcesses[e];
						break
					} const r = {
					width: this.width,
					height: this.height
				},
				o = {
					generateMipMaps: s,
					generateDepthBuffer: n || a === this,
					generateStencilBuffer: (n || a === this) && this._engine.isStencilEnable,
					samplingMode: this.renderTargetSamplingMode,
					type: this._textureType,
					format: this._textureFormat,
					samples: this._samples,
					label: "PostProcessRTT-" + this.name
				};
			this._textures.push(this._createRenderTargetTexture(r, o, 0)), this._reusable && this._textures.push(this._createRenderTargetTexture(r, o, 1)), this._texelSize.copyFromFloats(1 / this.width, 1 / this.height), this.onSizeChangedObservable.notifyObservers(this)
		}
		isReady() {
			return !!this._shadersLoaded && (this._drawWrapper.effect?.isReady() ?? !1)
		}
		static RegisterShaderCodeProcessing(t, i) {
			i ? e._CustomShaderCodeProcessing[t ?? ""] = i : delete e._CustomShaderCodeProcessing[t ?? ""]
		}
		set onSizeChanged(e) {
			this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e)
		}
		dispose(e) {
			let t;
			if (e = e || this._camera, this._disposeTextures(), this._scene && (t = this._scene.postProcesses.indexOf(this), -1 !== t && this._scene.postProcesses.splice(t, 1)), this._parentContainer) {
				const e = this._parentContainer.postProcesses.indexOf(this);
				e > -1 && this._parentContainer.postProcesses.splice(e, 1), this._parentContainer = null
			}
			if (t = this._engine.postProcesses.indexOf(this), -1 !== t && this._engine.postProcesses.splice(t, 1), e) {
				if (e.detachPostProcess(this), t = e._postProcesses.indexOf(this), 0 === t && e._postProcesses.length > 0) {
					const e = this._camera._getFirstPostProcess();
					e && e.markTextureDirty()
				}
				this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear(), this.onEffectCreatedObservable.clear()
			}
		}
		shareOutputWith(e) {
			return this._disposeTextures(), this._shareOutputWithPostProcess = e, this
		}
		async _initShaderSourceAsync(e = !1) {
			e && this._webGPUReady ? await Promise.all([Promise.resolve().then((() => (y(), p)))]) : await Promise.all([Promise.resolve().then((() => (f(), c)))]), this._shadersLoaded = !0
		}
		get shaderLanguage() {
			return this._shaderLanguage
		}
		set onActivate(e) {
			this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), e && (this._onActivateObserver = this.onActivateObservable.add(e))
		}
		_getTarget() {
			let e;
			if (this._shareOutputWithPostProcess) e = this._shareOutputWithPostProcess.inputTexture;
			else if (this._forcedOutputTexture) e = this._forcedOutputTexture, this.width = this._forcedOutputTexture.width, this.height = this._forcedOutputTexture.height;
			else {
				let t;
				e = this.inputTexture;
				for (let i = 0; i < this._textureCache.length; i++)
					if (this._textureCache[i].texture === e) {
						t = this._textureCache[i];
						break
					} t && (t.lastUsedRenderId = this._renderId)
			}
			return e
		}
		_createRenderTargetTexture(e, t, i = 0) {
			for (let s = 0; s < this._textureCache.length; s++)
				if (this._textureCache[s].texture.width === e.width && this._textureCache[s].texture.height === e.height && this._textureCache[s].postProcessChannel === i && this._textureCache[s].texture._generateDepthBuffer === t.generateDepthBuffer && this._textureCache[s].texture.samples === t.samples) return this._textureCache[s].texture;
			const s = this._engine.createRenderTargetTexture(e, t);
			return this._textureCache.push({
				texture: s,
				postProcessChannel: i,
				lastUsedRenderId: -1
			}), s
		}
		set inputTexture(e) {
			this._forcedOutputTexture = e
		}
		get aspectRatio() {
			return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.aspectRatio : this._forcedOutputTexture ? this._forcedOutputTexture.width / this._forcedOutputTexture.height : this.width / this.height
		}
		getClassName() {
			return "PostProcess"
		}
		useOwnOutput() {
			0 == this._textures.length && (this._textures = new pd(2)), this._shareOutputWithPostProcess = null
		}
		_disposeTextures() {
			this._shareOutputWithPostProcess || this._forcedOutputTexture ? this._disposeTextureCache() : (this._disposeTextureCache(), this._textures.dispose())
		}
		static _GetShaderCodeProcessing(t) {
			return e._CustomShaderCodeProcessing[t] ?? e._CustomShaderCodeProcessing[""]
		}
		get samples() {
			return this._samples
		}
		isReusable() {
			return this._reusable
		}
		activate(e, t = null, i) {
			const s = (e = e || this._camera).getScene(),
				n = s.getEngine(),
				a = n.getCaps().maxTextureSize,
				r = (t ? t.width : this._engine.getRenderWidth(!0)) * this._options | 0,
				o = (t ? t.height : this._engine.getRenderHeight(!0)) * this._options | 0;
			let l = this._options.width || r,
				h = this._options.height || o;
			const c = 7 !== this.renderTargetSamplingMode && 1 !== this.renderTargetSamplingMode && 2 !== this.renderTargetSamplingMode;
			let u = null;
			if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
				if (this.adaptScaleToCurrentViewport) {
					const e = n.currentViewport;
					e && (l *= e.width, h *= e.height)
				}(c || this.alwaysForcePOT) && (this._options.width || (l = n.needPOTTextures ? md(l, a, this.scaleMode) : l), this._options.height || (h = n.needPOTTextures ? md(h, a, this.scaleMode) : h)), this.width === l && this.height === h && (u = this._getTarget()) || this.resize(l, h, e, c, i), this._textures.forEach((e => {
					e.samples !== this.samples && this._engine.updateRenderTargetTextureSampleCount(e, this.samples)
				})), this._flushTextureCache(), this._renderId++
			}
			return u || (u = this._getTarget()), this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(r / l, o / h), this._engine.bindFramebuffer(u, 0, r, o, this.forceFullscreenViewport)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(u, 0, void 0, void 0, this.forceFullscreenViewport)), this._engine._debugInsertMarker?.(`post process ${this.name} input`), this.onActivateObservable.notifyObservers(e), this.autoClear && (0 === this.alphaMode || this.forceAutoClearInAlphaMode) && this._engine.clear(this.clearColor ? this.clearColor : s.clearColor, s._allowPostProcessClearColor, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2), u
		}
		getEffectName() {
			return this._fragmentUrl
		}
		async _postConstructor(t, i = null, s) {
			const n = this.getEngine().isWebGPU && !e.ForceGLSL;
			await this._initShaderSourceAsync(n), s && await s(n), n && this._webGPUReady && (this._shaderLanguage = 1), this._onInitShadersDone ? this._onInitShadersDone() : (this._shadersLoaded = !0, t || this.updateEffect(i))
		}
		setPrePassRenderer(e) {
			return !!this._prePassEffectConfiguration && (this._prePassEffectConfiguration = e.addEffectConfiguration(this._prePassEffectConfiguration), this._prePassEffectConfiguration.enabled = !0, !0)
		}
		set onApply(e) {
			this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e)
		}
		set samples(e) {
			this._samples = Math.min(e, this._engine.getCaps().maxMSAASamples), this._textures.forEach((e => {
				e.setSamples(this._samples)
			}))
		}
		apply() {
			if (!this._drawWrapper.effect?.isReady()) return null;
			let t;
			return this._engine.enableEffect(this._drawWrapper), this._engine.setState(!1), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._engine.setAlphaMode(this.alphaMode), this.alphaConstants && this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a), t = this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? this._forcedOutputTexture : this.inputTexture, this.externalTextureSamplerBinding || this._drawWrapper.effect._bindTexture("textureSampler", t?.texture), this._drawWrapper.effect.setVector2("scale", this._scaleRatio), this.onApplyObservable.notifyObservers(this._drawWrapper.effect), e._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name, this._drawWrapper.effect), this._drawWrapper.effect
		}
		set onBeforeRender(e) {
			this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
		}
		getEffect() {
			return this._drawWrapper.effect
		}
		set onAfterRender(e) {
			this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
		}
		updateEffect(t = null, i = null, s = null, n, a, r, o, l) {
			if (!this._shadersLoaded) return void(this._onInitShadersDone = () => {
				this._shadersLoaded = !0, this._onInitShadersDone = null, this.updateEffect(t, i, s, n, a, r, o, l)
			});
			const h = e._GetShaderCodeProcessing(this.name);
			if (h?.defineCustomBindings) {
				const e = i?.slice() ?? [];
				e.push(...this._parameters);
				const n = s?.slice() ?? [];
				n.push(...this._samplers), t = h.defineCustomBindings(this.name, t, e, n), i = e, s = n
			}
			this._postProcessDefines = t, this._drawWrapper.effect = this._engine.createEffect({
				vertex: o ?? this._vertexUrl,
				fragment: l ?? this._fragmentUrl
			}, {
				attributes: ["position"],
				uniformsNames: i || this._parameters,
				uniformBuffersNames: this._uniformBuffers,
				samplers: s || this._samplers,
				defines: null !== t ? t : "",
				fallbacks: null,
				onCompiled: a ?? null,
				onError: r ?? null,
				indexParameters: n || this._indexParameters,
				processCodeAfterIncludes: h?.processCodeAfterIncludes ? (e, t) => h.processCodeAfterIncludes(this.name, e, t) : null,
				processFinalCode: h?.processFinalCode ? (e, t) => h.processFinalCode(this.name, e, t) : null,
				shaderLanguage: this._shaderLanguage
			}, this._engine), this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect)
		}
		getCamera() {
			return this._camera
		}
		get isSupported() {
			return !this._shadersLoaded || this._drawWrapper.effect.isSupported
		}
		_flushTextureCache() {
			const e = this._renderId;
			for (let t = this._textureCache.length - 1; t >= 0; t--)
				if (e - this._textureCache[t].lastUsedRenderId > 100) {
					let e = !1;
					for (let i = 0; i < this._textures.length; i++)
						if (this._textures.data[i] === this._textureCache[t].texture) {
							e = !0;
							break
						} e || (this._textureCache[t].texture.dispose(), this._textureCache.splice(t, 1))
				}
		}
		_disposeTextureCache() {
			for (let e = this._textureCache.length - 1; e >= 0; e--) this._textureCache[e].texture.dispose();
			this._textureCache.length = 0
		}
		constructor(e, t, i, s, n, a, r = 1, o, l, h = null, c = 0, u = "postprocess", m, d = !1, f = 5, p, _) {
			this._parentContainer = null, this.width = -1, this.height = -1, this.nodeMaterialSource = null, this._outputTexture = null, this.autoClear = !0, this.forceAutoClearInAlphaMode = !1, this.alphaMode = 0, this.animations = [], this.enablePixelPerfectMode = !1, this.forceFullscreenViewport = !0, this.scaleMode = 1, this.alwaysForcePOT = !1, this._samples = 1, this.adaptScaleToCurrentViewport = !1, this._shadersLoaded = !1, this._webGPUReady = !1, this._reusable = !1, this._renderId = 0, this.externalTextureSamplerBinding = !1, this._textures = new pd(2), this._textureCache = [], this._currentRenderTextureInd = 0, this._scaleRatio = new Fc(1, 1), this._texelSize = Fc.Zero(), this.onEffectCreatedObservable = new kc(void 0, !0), this.onActivateObservable = new kc, this.onSizeChangedObservable = new kc, this.onApplyObservable = new kc, this.onBeforeRenderObservable = new kc, this.onAfterRenderObservable = new kc, this._onInitShadersDone = null, this.name = e;
			let g = 1,
				v = null;
			if (i && !Array.isArray(i)) {
				const e = i;
				i = e.uniforms ?? null, s = e.samplers ?? null, g = e.size ?? 1, a = e.camera ?? null, r = e.samplingMode ?? 1, o = e.engine, l = e.reusable, h = e.defines ?? null, c = e.textureType ?? 0, u = e.vertexUrl ?? "postprocess", m = e.indexParameters, d = e.blockCompilation ?? !1, f = e.textureFormat ?? 5, p = e.shaderLanguage ?? 0, v = e.uniformBuffers ?? null
			} else n && (g = "number" == typeof n ? n : {
				width: n.width,
				height: n.height
			});
			null != a ? (this._camera = a, this._scene = a.getScene(), a.attachPostProcess(this), this._engine = this._scene.getEngine(), this._scene.postProcesses.push(this), this.ik = this._scene.getUniqueId()) : o && (this._engine = o, this._engine.postProcesses.push(this)), this._options = g, this.renderTargetSamplingMode = r || 1, this._reusable = l || !1, this._textureType = c, this._textureFormat = f, this._shaderLanguage = p || 0, this._samplers = s || [], this._samplers.push("textureSampler"), this._fragmentUrl = t, this._vertexUrl = u, this._parameters = i || [], this._parameters.push("scale"), this._uniformBuffers = v || [], this._indexParameters = m, this._drawWrapper = new Au(this._engine), this._webGPUReady = 1 === this._shaderLanguage, this._postConstructor(d, h, _)
		}
		get inputTexture() {
			return this._textures.data[this._currentRenderTextureInd]
		}
		restoreDefaultInputTexture() {
			this._forcedOutputTexture && (this._forcedOutputTexture = null, this.markTextureDirty())
		}
		static _Parse(t, i, s, n) {
			return Xc.Parse((() => new e(t.name, t.fragmentUrl, t.parameters, t.samplers, t.options, i, t.renderTargetSamplingMode, t._engine, t.reusable, t.defines, t.textureType, t.vertexUrl, t.indexParameters, !1, t.textureFormat)), t, s, n)
		}
		static Parse(e, t, i) {
			const s = uc(e.customType);
			if (!s || !s._Parse) return null;
			const n = t ? t.getCameraById(e.cameraId) : null;
			return s._Parse(e, n, t, i)
		}
		get texelSize() {
			return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.texelSize : (this._forcedOutputTexture && this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height), this._texelSize)
		}
		serialize() {
			const e = Xc.Serialize(this),
				t = this.getCamera() || this._scene && this._scene.activeCamera;
			return e.customType = "BABYLON." + this.getClassName(), e.cameraId = t ? t.id : null, e.reusable = this._reusable, e.textureType = this._textureType, e.fragmentUrl = this._fragmentUrl, e.parameters = this._parameters, e.samplers = this._samplers, e.options = this._options, e.defines = this._postProcessDefines, e.textureFormat = this._textureFormat, e.vertexUrl = this._vertexUrl, e.indexParameters = this._indexParameters, e
		}
		getEngine() {
			return this._engine
		}
	};
	Bp.ForceGLSL = !1, Bp._CustomShaderCodeProcessing = {}, Gh([Xh()], Bp.prototype, "uniqueId", void 0), Gh([Xh()], Bp.prototype, "name", void 0), Gh([Xh()], Bp.prototype, "width", void 0), Gh([Xh()], Bp.prototype, "height", void 0), Gh([Xh()], Bp.prototype, "renderTargetSamplingMode", void 0), Gh([Qh()], Bp.prototype, "clearColor", void 0), Gh([Xh()], Bp.prototype, "autoClear", void 0), Gh([Xh()], Bp.prototype, "forceAutoClearInAlphaMode", void 0), Gh([Xh()], Bp.prototype, "alphaMode", void 0), Gh([Xh()], Bp.prototype, "alphaConstants", void 0), Gh([Xh()], Bp.prototype, "enablePixelPerfectMode", void 0), Gh([Xh()], Bp.prototype, "forceFullscreenViewport", void 0), Gh([Xh()], Bp.prototype, "scaleMode", void 0), Gh([Xh()], Bp.prototype, "alwaysForcePOT", void 0), Gh([Xh("samples")], Bp.prototype, "_samples", void 0), Gh([Xh()], Bp.prototype, "adaptScaleToCurrentViewport", void 0), cc("BABYLON.PostProcess", Bp);
	var Gp = class extends ap {
		constructor(e) {
			super(e, Xf.Neutral), this.xSwizzle = "x", this.ySwizzle = "y", this.zSwizzle = "z", this.wSwizzle = "w", this.registerInput("xyzw ", Wf.Vector4, !0), this.registerInput("xyz ", Wf.Vector3, !0), this.registerInput("xy ", Wf.Vector2, !0), this.registerInput("zw ", Wf.Vector2, !0), this.registerInput("x", Wf.Float, !0), this.registerInput("y", Wf.Float, !0), this.registerInput("z", Wf.Float, !0), this.registerInput("w", Wf.Float, !0), this.registerOutput("xyzw", Wf.Vector4), this.registerOutput("xyz", Wf.Vector3), this.registerOutput("xy", Wf.Vector2), this.registerOutput("zw", Wf.Vector2)
		}
		get xyzIn() {
			return this._inputs[1]
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.xSwizzle = e.xSwizzle ?? "x", this.ySwizzle = e.ySwizzle ?? "y", this.zSwizzle = e.zSwizzle ?? "z", this.wSwizzle = e.wSwizzle ?? "w"
		}
		_buildSwizzle(e) {
			return "." + (this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle).substr(0, e)
		}
		get x() {
			return this._inputs[4]
		}
		get xyOut() {
			return this._outputs[2]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this.x,
				i = this.y,
				s = this.z,
				n = this.w,
				a = this.xyIn,
				r = this.zwIn,
				o = this.xyzIn,
				l = this.xyzwIn,
				h = this._outputs[0],
				c = this._outputs[1],
				u = this._outputs[2],
				m = this._outputs[3],
				d = e._getShaderType(Wf.Vector4),
				f = e._getShaderType(Wf.Vector3),
				p = e._getShaderType(Wf.Vector2);
			return l.isConnected ? (h.hasEndpoints && (e.compilationString += e._declareOutput(h) + ` = ${l.associatedVariableName}${this._buildSwizzle(4)};\n`), c.hasEndpoints && (e.compilationString += e._declareOutput(c) + ` = ${l.associatedVariableName}${this._buildSwizzle(3)};\n`), u.hasEndpoints && (e.compilationString += e._declareOutput(u) + ` = ${l.associatedVariableName}${this._buildSwizzle(2)};\n`)) : o.isConnected ? (h.hasEndpoints && (e.compilationString += e._declareOutput(h) + ` = ${d}(${o.associatedVariableName}, ${n.isConnected?this._writeVariable(n):"0.0"})${this._buildSwizzle(4)};\n`), c.hasEndpoints && (e.compilationString += e._declareOutput(c) + ` = ${o.associatedVariableName}${this._buildSwizzle(3)};\n`), u.hasEndpoints && (e.compilationString += e._declareOutput(u) + ` = ${o.associatedVariableName}${this._buildSwizzle(2)};\n`)) : a.isConnected ? (h.hasEndpoints && (r.isConnected ? e.compilationString += e._declareOutput(h) + ` = ${d}(${a.associatedVariableName}, ${r.associatedVariableName})${this._buildSwizzle(4)};\n` : e.compilationString += e._declareOutput(h) + ` = ${d}(${a.associatedVariableName}, ${s.isConnected?this._writeVariable(s):"0.0"}, ${n.isConnected?this._writeVariable(n):"0.0"})${this._buildSwizzle(4)};\n`), c.hasEndpoints && (e.compilationString += e._declareOutput(c) + ` = ${f}(${a.associatedVariableName}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(3)};\n`), u.hasEndpoints && (e.compilationString += e._declareOutput(u) + ` = ${a.associatedVariableName}${this._buildSwizzle(2)};\n`), m.hasEndpoints && (r.isConnected ? e.compilationString += e._declareOutput(m) + ` = ${r.associatedVariableName}${this._buildSwizzle(2)};\n` : e.compilationString += e._declareOutput(m) + ` = ${p}(${s.isConnected?this._writeVariable(s):"0.0"}, ${n.isConnected?this._writeVariable(n):"0.0"})${this._buildSwizzle(2)};\n`)) : (h.hasEndpoints && (r.isConnected ? e.compilationString += e._declareOutput(h) + ` = ${d}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${r.associatedVariableName})${this._buildSwizzle(4)};\n` : e.compilationString += e._declareOutput(h) + ` = ${d}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"}, ${n.isConnected?this._writeVariable(n):"0.0"})${this._buildSwizzle(4)};\n`), c.hasEndpoints && (e.compilationString += e._declareOutput(c) + ` = ${f}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(3)};\n`), u.hasEndpoints && (e.compilationString += e._declareOutput(u) + ` = ${p}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"})${this._buildSwizzle(2)};\n`), m.hasEndpoints && (r.isConnected ? e.compilationString += e._declareOutput(m) + ` = ${r.associatedVariableName}${this._buildSwizzle(2)};\n` : e.compilationString += e._declareOutput(m) + ` = ${p}(${s.isConnected?this._writeVariable(s):"0.0"}, ${n.isConnected?this._writeVariable(n):"0.0"})${this._buildSwizzle(2)};\n`)), this
		}
		get y() {
			return this._inputs[5]
		}
		get xyIn() {
			return this._inputs[2]
		}
		get zwIn() {
			return this._inputs[3]
		}
		get zwOut() {
			return this._outputs[3]
		}
		get xyzOut() {
			return this._outputs[1]
		}
		get xyzwIn() {
			return this._inputs[0]
		}
		get xy() {
			return this.xyOut
		}
		get xyzw() {
			return this._outputs[0]
		}
		get w() {
			return this._inputs[7]
		}
		_inputRename(e) {
			return "xyzw " === e ? "xyzwIn" : "xyz " === e ? "xyzIn" : "xy " === e ? "xyIn" : "zw " === e ? "zwIn" : e
		}
		getClassName() {
			return "VectorMergerBlock"
		}
		get z() {
			return this._inputs[6]
		}
		serialize() {
			const e = super.serialize();
			return e.xSwizzle = this.xSwizzle, e.ySwizzle = this.ySwizzle, e.zSwizzle = this.zSwizzle, e.wSwizzle = this.wSwizzle, e
		}
		_dumpPropertiesCode() {
			let e = super._dumpPropertiesCode();
			return e += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";\n`, e += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";\n`, e += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";\n`, e += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";\n`, e
		}
		get xyz() {
			return this.xyzOut
		}
	};
	cc("BABYLON.VectorMergerBlock", Gp);
	var Hp = class extends ap {
		serialize() {
			const e = super.serialize();
			return e.sourceRange = this.sourceRange.asArray(), e.targetRange = this.targetRange.asArray(), e
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.sourceRange = Fc.FromArray(e.sourceRange), this.targetRange = Fc.FromArray(e.targetRange)
		}
		get sourceMin() {
			return this._inputs[1]
		}
		_dumpPropertiesCode() {
			let e = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\n`;
			return e += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\n`, e
		}
		constructor(e) {
			super(e, Xf.Neutral), this.sourceRange = new Fc(-1, 1), this.targetRange = new Fc(0, 1), this.registerInput("input", Wf.AutoDetect), this.registerInput("sourceMin", Wf.Float, !0), this.registerInput("sourceMax", Wf.Float, !0), this.registerInput("targetMin", Wf.Float, !0), this.registerInput("targetMax", Wf.Float, !0), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0]
		}
		get targetMin() {
			return this._inputs[3]
		}
		get input() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0],
				i = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x),
				s = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y),
				n = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x),
				a = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
			return e.compilationString += e._declareOutput(t) + ` = ${n} + (${this._inputs[0].associatedVariableName} - ${i}) * (${a} - ${n}) / (${s} - ${i});\n`, this
		}
		get sourceMax() {
			return this._inputs[2]
		}
		get output() {
			return this._outputs[0]
		}
		get targetMax() {
			return this._inputs[4]
		}
		getClassName() {
			return "RemapBlock"
		}
	};
	Gh([cp("From", 3)], Hp.prototype, "sourceRange", void 0), Gh([cp("To", 3)], Hp.prototype, "targetRange", void 0), cc("BABYLON.RemapBlock", Hp);
	var Up, Vp, Wp = class extends ap {
			get output() {
				return this._outputs[0]
			}
			get left() {
				return this._inputs[0]
			}
			constructor(e) {
				super(e, Xf.Neutral), this.registerInput("left", Wf.AutoDetect), this.registerInput("right", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this.output._typeConnectionSource = this.left, this._linkConnectionTypes(0, 1, !0), this.left.acceptedConnectionPointTypes.push(Wf.Float), this.right.acceptedConnectionPointTypes.push(Wf.Float), this._connectionObservers = [this.left.onTypeChangedObservable.add((() => this._updateInputOutputTypes())), this.right.onTypeChangedObservable.add((() => this._updateInputOutputTypes()))]
			}
			_updateInputOutputTypes() {
				if (this.output._typeConnectionSource = this.left, this.left.isConnected && this.right.isConnected ? (this.left.type === Wf.Int || this.left.type === Wf.Float && this.right.type !== Wf.Int) && (this.output._typeConnectionSource = this.right) : this.left.isConnected !== this.right.isConnected && (this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right), this.left.isConnected || this.right.isConnected)
					for (const [e, t] of [
							[this.left, this.right],
							[this.right, this.left]
						]) e.acceptedConnectionPointTypes = [Wf.Int, Wf.Float], t.isConnected && (e.acceptedConnectionPointTypes.push(t.type), t.type !== Wf.Int && t.type !== Wf.Float || e.acceptedConnectionPointTypes.push(Wf.Vector2, Wf.Vector3, Wf.Vector4, Wf.Color3, Wf.Color4, Wf.Matrix))
			}
			dispose() {
				super.dispose(), this._connectionObservers.forEach((e => e.remove())), this._connectionObservers.length = 0
			}
			get right() {
				return this._inputs[1]
			}
		},
		zp = class extends Wp {
			getClassName() {
				return "MultiplyBlock"
			}
			_buildBlock(e) {
				super._buildBlock(e);
				const t = this._outputs[0];
				return e.compilationString += e._declareOutput(t) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\n`, this
			}
			constructor(e) {
				super(e)
			}
		};
	cc("BABYLON.MultiplyBlock", zp), (Vp = Up || (Up = {}))[Vp.Material = 0] = "Material", Vp[Vp.PostProcess = 1] = "PostProcess", Vp[Vp.Particle = 2] = "Particle", Vp[Vp.ProceduralTexture = 3] = "ProceduralTexture";
	var Xp = class extends ip {
			constructor() {
				super(), this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = 0, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.EXPOSURE = !1, this.SKIPFINALCOLORCLAMP = !1, this.rebuild()
			}
		},
		Yp = class e {
			_reset() {}
			getEmitRateGradients() {
				return this._emitRateGradients
			}
			getAngularSpeedGradients() {
				return this._angularSpeedGradients
			}
			_removeGradientAndTexture(e, t, i) {
				if (!t) return this;
				let s = 0;
				for (const i of t) {
					if (i.gradient === e) {
						t.splice(s, 1);
						break
					}
					s++
				}
				return i && i.dispose(), this
			}
			createBoxEmitter(e, t, i, s) {
				throw new Error("Method not implemented.")
			}
			get isBillboardBased() {
				return this._isBillboardBased
			}
			get maxEmitBox() {
				return this.particleEmitterType.maxEmitBox ? this.particleEmitterType.maxEmitBox : Lc.Zero()
			}
			createConeEmitter(e = 1, t = Math.PI / 4) {
				throw new Error("Method not implemented.")
			}
			set billboardMode(e) {
				this._billboardMode !== e && (this._billboardMode = e, this._reset())
			}
			set imageProcessingConfiguration(e) {
				this._attachImageProcessingConfiguration(e)
			}
			set isBillboardBased(e) {
				this._isBillboardBased !== e && (this._isBillboardBased = e, this._reset())
			}
			getStartSizeGradients() {
				return this._startSizeGradients
			}
			get minEmitBox() {
				return this.particleEmitterType.minEmitBox ? this.particleEmitterType.minEmitBox : Lc.Zero()
			}
			getAlphaRemapGradients() {
				return this._alphaRemapGradients
			}
			createPointEmitter(e, t) {
				throw new Error("Method not implemented.")
			}
			createCylinderEmitter(e = 1, t = 1, i = 1, s = 0) {
				throw new Error("Method not implemented.")
			}
			createDirectedConeEmitter(e = 1, t = Math.PI / 4, i = new Lc(0, 1, 0), s = new Lc(0, 1, 0)) {
				throw new Error("Method not implemented.")
			}
			get direction1() {
				return this.particleEmitterType.direction1 ? this.particleEmitterType.direction1 : Lc.Zero()
			}
			get isAnimationSheetEnabled() {
				return this._isAnimationSheetEnabled
			}
			constructor(t) {
				this.animations = [], this.Lk = 0, this.emitter = Lc.Zero(), this.emitRate = 10, this.manualEmitCount = -1, this.updateSpeed = .01, this.targetStopDuration = 0, this.disposeOnStop = !1, this.minEmitPower = 1, this.maxEmitPower = 1, this.minLifeTime = 1, this.maxLifeTime = 1, this.minSize = 1, this.maxSize = 1, this.minScaleX = 1, this.maxScaleX = 1, this.minScaleY = 1, this.maxScaleY = 1, this.minInitialRotation = 0, this.maxInitialRotation = 0, this.minAngularSpeed = 0, this.maxAngularSpeed = 0, this.layerMask = 268435455, this.customShader = null, this.preventAutoStart = !1, this.applyFog = !1, this._wasDispatched = !1, this._rootUrl = "", this.noiseStrength = new Lc(10, 10, 10), this.onAnimationEnd = null, this.blendMode = e.BLENDMODE_ONEONE, this.forceDepthWrite = !1, this.preWarmCycles = 0, this.preWarmStepOffset = 1, this.spriteCellChangeSpeed = 1, this.startSpriteCellID = 0, this.endSpriteCellID = 0, this.spriteCellWidth = 0, this.spriteCellHeight = 0, this.spriteCellLoop = !0, this.spriteRandomStartCell = !1, this.translationPivot = new Fc(0, 0), this.beginAnimationOnStart = !1, this.beginAnimationFrom = 0, this.beginAnimationTo = 60, this.beginAnimationLoop = !1, this.worldOffset = new Lc(0, 0, 0), this._useLogarithmicDepth = !1, this.gravity = Lc.Zero(), this._colorGradients = null, this._sizeGradients = null, this._lifeTimeGradients = null, this._angularSpeedGradients = null, this._velocityGradients = null, this._limitVelocityGradients = null, this._dragGradients = null, this._emitRateGradients = null, this._startSizeGradients = null, this._rampGradients = null, this._colorRemapGradients = null, this._alphaRemapGradients = null, this.startDelay = 0, this.limitVelocityDamping = .4, this.color1 = new wc(1, 1, 1, 1), this.color2 = new wc(1, 1, 1, 1), this.colorDead = new wc(0, 0, 0, 1), this.textureMask = new wc(1, 1, 1, 1), this._isSubEmitter = !1, this._billboardMode = 7, this._isBillboardBased = !0, this._imageProcessingConfigurationDefines = new Xp, this.id = t, this.name = t
			}
			set maxEmitBox(e) {
				this.particleEmitterType.maxEmitBox && (this.particleEmitterType.maxEmitBox = e)
			}
			_hasTargetStopDurationDependantGradient() {
				return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0
			}
			get useLogarithmicDepth() {
				return this._useLogarithmicDepth
			}
			createDirectedCylinderEmitter(e = 1, t = 1, i = 1, s = new Lc(0, 1, 0), n = new Lc(0, 1, 0)) {
				throw new Error("Method not implemented.")
			}
			getColorGradients() {
				return this._colorGradients
			}
			set direction2(e) {
				this.particleEmitterType.direction2 && (this.particleEmitterType.direction2 = e)
			}
			set useLogarithmicDepth(e) {
				this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported
			}
			get noiseTexture() {
				return this._noiseTexture
			}
			createDirectedSphereEmitter(e = 1, t = new Lc(0, 1, 0), i = new Lc(0, 1, 0)) {
				throw new Error("Method not implemented.")
			}
			set direction1(e) {
				this.particleEmitterType.direction1 && (this.particleEmitterType.direction1 = e)
			}
			getScene() {
				return this._scene
			}
			set isAnimationSheetEnabled(e) {
				this._isAnimationSheetEnabled != e && (this._isAnimationSheetEnabled = e, this._reset())
			}
			set minEmitBox(e) {
				this.particleEmitterType.minEmitBox && (this.particleEmitterType.minEmitBox = e)
			}
			_attachImageProcessingConfiguration(e) {
				e !== this._imageProcessingConfiguration && (!e && this._scene ? this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration : this._imageProcessingConfiguration = e)
			}
			getLimitVelocityGradients() {
				return this._limitVelocityGradients
			}
			get imageProcessingConfiguration() {
				return this._imageProcessingConfiguration
			}
			getLifeTimeGradients() {
				return this._lifeTimeGradients
			}
			getDragGradients() {
				return this._dragGradients
			}
			set noiseTexture(e) {
				this._noiseTexture !== e && (this._noiseTexture = e, this._reset())
			}
			get billboardMode() {
				return this._billboardMode
			}
			createHemisphericEmitter(e = 1, t = 1) {
				throw new Error("Method not implemented.")
			}
			getSizeGradients() {
				return this._sizeGradients
			}
			createSphereEmitter(e = 1, t = 1) {
				throw new Error("Method not implemented.")
			}
			getVelocityGradients() {
				return this._velocityGradients
			}
			getColorRemapGradients() {
				return this._colorRemapGradients
			}
			get direction2() {
				return this.particleEmitterType.direction2 ? this.particleEmitterType.direction2 : Lc.Zero()
			}
		};
	Yp.BLENDMODE_ONEONE = 0, Yp.BLENDMODE_STANDARD = 1, Yp.BLENDMODE_ADD = 2, Yp.BLENDMODE_MULTIPLY = 3, Yp.BLENDMODE_MULTIPLYADD = 4, cc("BABYLON.BaseParticleSystem", Yp);
	var jp = class extends ap {
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this.rgba.isConnected ? this.rgba : this.rgbIn;
			if (!t.isConnected) return;
			const i = this._outputs[0],
				s = this._outputs[1],
				n = this._outputs[2],
				a = this._outputs[3],
				r = this._outputs[4];
			return i.hasEndpoints && (e.compilationString += e._declareOutput(i) + ` = ${t.associatedVariableName}.rgb;\n`), s.hasEndpoints && (e.compilationString += e._declareOutput(s) + ` = ${t.associatedVariableName}.r;\n`), n.hasEndpoints && (e.compilationString += e._declareOutput(n) + ` = ${t.associatedVariableName}.g;\n`), a.hasEndpoints && (e.compilationString += e._declareOutput(a) + ` = ${t.associatedVariableName}.b;\n`), r.hasEndpoints && (e.compilationString += e._declareOutput(r) + ` = ${t.associatedVariableName}.a;\n`), this
		}
		get g() {
			return this._outputs[2]
		}
		get b() {
			return this._outputs[3]
		}
		get a() {
			return this._outputs[4]
		}
		get rgbOut() {
			return this._outputs[0]
		}
		_outputRename(e) {
			return "rgb" === e ? "rgbOut" : e
		}
		get r() {
			return this._outputs[1]
		}
		_inputRename(e) {
			return "rgb " === e ? "rgbIn" : e
		}
		get rgba() {
			return this._inputs[0]
		}
		getClassName() {
			return "ColorSplitterBlock"
		}
		get rgbIn() {
			return this._inputs[1]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("rgba", Wf.Color4, !0), this.registerInput("rgb ", Wf.Color3, !0), this.registerOutput("rgb", Wf.Color3), this.registerOutput("r", Wf.Float), this.registerOutput("g", Wf.Float), this.registerOutput("b", Wf.Float), this.registerOutput("a", Wf.Float), this.inputsAreExclusive = !0
		}
	};
	cc("BABYLON.ColorSplitterBlock", jp);
	var Kp = class {
			_rebuild() {
				const e = this._vertexBuffers[eu.PositionKind];
				e && (e._rebuild(), this._buildIndexBuffer())
			}
			constructor(e) {
				this._vertexBuffers = {}, this._scene = e
			}
			_prepareBuffers() {
				if (this._vertexBuffers[eu.PositionKind]) return;
				const e = [];
				e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[eu.PositionKind] = new eu(this._scene.getEngine(), e, eu.PositionKind, !1, !1, 2), this._buildIndexBuffer()
			}
			directRender(e, t = null, i = !1, s = 0, n = 0, a = !1) {
				const r = this._scene.getEngine();
				for (let o = 0; o < e.length; o++) {
					o < e.length - 1 ? e[o + 1].activate(this._scene.activeCamera, t?.texture) : (t ? r.bindFramebuffer(t, s, void 0, void 0, i, n) : a || r.restoreDefaultFramebuffer(), r._debugInsertMarker?.(`post process ${e[o].name} output`));
					const l = e[o],
						h = l.apply();
					h && (l.onBeforeRenderObservable.notifyObservers(h), this._prepareBuffers(), r.bindBuffers(this._vertexBuffers, this._indexBuffer, h), r.drawElementsType(0, 0, 6), l.onAfterRenderObservable.notifyObservers(h))
				}
				r.setDepthBuffer(!0), r.setDepthWrite(!0)
			}
			_buildIndexBuffer() {
				const e = [];
				e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e)
			}
			_prepareFrame(e = null, t = null) {
				const i = this._scene.activeCamera;
				return !!i && (!(!(t = t || i._postProcesses.filter((e => null != e))) || 0 === t.length || !this._scene.postProcessesEnabled) && (t[0].activate(i, e, null != t), !0))
			}
			_finalizeFrame(e, t, i, s, n = !1) {
				const a = this._scene.activeCamera;
				if (!a) return;
				if (0 === (s = s || a._postProcesses.filter((e => null != e))).length || !this._scene.postProcessesEnabled) return;
				const r = this._scene.getEngine();
				for (let o = 0, l = s.length; o < l; o++) {
					const h = s[o];
					if (o < l - 1 ? h._outputTexture = s[o + 1].activate(a, t?.texture) : (t ? (r.bindFramebuffer(t, i, void 0, void 0, n), h._outputTexture = t) : (r.restoreDefaultFramebuffer(), h._outputTexture = null), r._debugInsertMarker?.(`post process ${s[o].name} output`)), e) break;
					const c = h.apply();
					c && (h.onBeforeRenderObservable.notifyObservers(c), this._prepareBuffers(), r.bindBuffers(this._vertexBuffers, this._indexBuffer, c), r.drawElementsType(0, 0, 6), h.onAfterRenderObservable.notifyObservers(c))
				}
				r.setDepthBuffer(!0), r.setDepthWrite(!0), r.setAlphaMode(0)
			}
			dispose() {
				const e = this._vertexBuffers[eu.PositionKind];
				e && (e.dispose(), this._vertexBuffers[eu.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null)
			}
		},
		$p = class e {
			set alphaTestSortCompareFn(t) {
				this._alphaTestSortCompareFn = t || e.PainterSortCompare, this._renderAlphaTest = this._renderAlphaTestSorted
			}
			_renderOpaqueSorted(t) {
				e._RenderSorted(t, this._opaqueSortCompareFn, this._scene.activeCamera, !1)
			}
			dispatchParticles(e) {
				this._particleSystems.push(e), this._empty = !1
			}
			set transparentSortCompareFn(t) {
				this._transparentSortCompareFn = t || e.defaultTransparentSortCompare, this._renderTransparent = this._renderTransparentSorted
			}
			_renderTransparentSorted(t) {
				e._RenderSorted(t, this._transparentSortCompareFn, this._scene.activeCamera, !0)
			}
			static defaultTransparentSortCompare(t, i) {
				return t._alphaIndex > i._alphaIndex ? 1 : t._alphaIndex < i._alphaIndex ? -1 : e.backToFrontSortCompare(t, i)
			}
			prepareSprites() {
				this._spriteManagers.reset()
			}
			set opaqueSortCompareFn(t) {
				this._opaqueSortCompareFn = t || e.PainterSortCompare, this._renderOpaque = this._renderOpaqueSorted
			}
			render(e, t, i, s) {
				if (e) return void e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
				const n = this._scene.getEngine();
				0 !== this._depthOnlySubMeshes.length && (n.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), n.setColorWrite(!0)), 0 !== this._opaqueSubMeshes.length && this._renderOpaque(this._opaqueSubMeshes), 0 !== this._alphaTestSubMeshes.length && this._renderAlphaTest(this._alphaTestSubMeshes);
				const a = n.getStencilBuffer();
				if (n.setStencilBuffer(!1), t && this._renderSprites(), i && this._renderParticles(s), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), 0 !== this._transparentSubMeshes.length || this._scene.useOrderIndependentTransparency) {
					if (n.setStencilBuffer(a), this._scene.useOrderIndependentTransparency) {
						const e = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
						e.length && this._renderTransparent(e)
					} else this._renderTransparent(this._transparentSubMeshes);
					n.setAlphaMode(0)
				}
				if (n.setStencilBuffer(!1), this._edgesRenderers.length) {
					for (let e = 0; e < this._edgesRenderers.length; e++) this._edgesRenderers.data[e].render();
					n.setAlphaMode(0)
				}
				n.setStencilBuffer(a)
			}
			static PainterSortCompare(e, t) {
				const i = e.getMesh(),
					s = t.getMesh();
				return i.material && s.material ? i.material.ik - s.material.ik : i.ik - s.ik
			}
			dispatchSprites(e) {
				this._spriteManagers.push(e), this._empty = !1
			}
			prepare() {
				this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this.prepareSprites(), this._edgesRenderers.reset(), this._empty = !0
			}
			constructor(e, t, i = null, s = null, n = null) {
				this.index = e, this._opaqueSubMeshes = new pd(256), this._transparentSubMeshes = new pd(256), this._alphaTestSubMeshes = new pd(256), this._depthOnlySubMeshes = new pd(256), this._particleSystems = new pd(256), this._spriteManagers = new pd(256), this._empty = !0, this._edgesRenderers = new _d(16), this._scene = t, this.opaqueSortCompareFn = i, this.alphaTestSortCompareFn = s, this.transparentSortCompareFn = n
			}
			_renderParticles(e) {
				if (0 === this._particleSystems.length) return;
				const t = this._scene.activeCamera;
				this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
				for (let i = 0; i < this._particleSystems.length; i++) {
					const s = this._particleSystems.data[i];
					if (0 === (t && t.layerMask & s.layerMask)) continue;
					const n = s.emitter;
					n.position && e && -1 === e.indexOf(n) || this._scene._activeParticles.addCount(s.render(), !1)
				}
				this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)
			}
			_renderAlphaTestSorted(t) {
				e._RenderSorted(t, this._alphaTestSortCompareFn, this._scene.activeCamera, !1)
			}
			static frontToBackSortCompare(e, t) {
				return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0
			}
			dispatch(e, t, i) {
				void 0 === t && (t = e.getMesh()), void 0 === i && (i = e.getMaterial()), null != i && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._renderingGroup = this, t._edgesRenderer && t.isEnabled() && t.isVisible && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer), this._empty = !1)
			}
			dispose() {
				this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose()
			}
			static backToFrontSortCompare(e, t) {
				return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0
			}
			static _RenderSorted(t, i, s, n) {
				let a, r = 0;
				const o = s ? s.globalPosition : e._ZeroVector;
				if (n)
					for (; r < t.length; r++) a = t.data[r], a._alphaIndex = a.getMesh().alphaIndex, a._distanceToCamera = Lc.Distance(a.getBoundingInfo().boundingSphere.centerWorld, o);
				const l = t.length === t.data.length ? t.data : t.data.slice(0, t.length);
				i && l.sort(i);
				const h = l[0].getMesh().getScene();
				for (r = 0; r < l.length; r++)
					if (a = l[r], !h._activeMeshesFrozenButKeepClipping || a.isInFrustum(h._frustumPlanes)) {
						if (n) {
							const e = a.getMaterial();
							if (e && e.needDepthPrePass) {
								const t = e.getScene().getEngine();
								t.setColorWrite(!1), t.setAlphaMode(0), a.render(!1), t.setColorWrite(!0)
							}
						}
						a.render(n)
					}
			}
			_renderSprites() {
				if (!this._scene.spritesEnabled || 0 === this._spriteManagers.length) return;
				const e = this._scene.activeCamera;
				this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
				for (let t = 0; t < this._spriteManagers.length; t++) {
					const i = this._spriteManagers.data[t];
					0 !== (e && e.layerMask & i.layerMask) && i.render()
				}
				this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)
			}
		};
	$p._ZeroVector = Lc.Zero();
	var Jp = class {},
		qp = class e {
			render(t, i, s, n) {
				const a = this._renderingGroupInfo;
				if (a.scene = this._scene, a.camera = this._scene.activeCamera, this._scene.spriteManagers && n)
					for (let e = 0; e < this._scene.spriteManagers.length; e++) {
						const t = this._scene.spriteManagers[e];
						this.dispatchSprites(t)
					}
				for (let r = e.MIN_RENDERINGGROUPS; r < e.MAX_RENDERINGGROUPS; r++) {
					this._depthStencilBufferAlreadyCleaned = r === e.MIN_RENDERINGGROUPS;
					const o = this._renderingGroups[r];
					if (!o || o._empty) continue;
					const l = 1 << r;
					if (a.Lk = r, this._scene.onBeforeRenderingGroupObservable.notifyObservers(a, l), e.AUTOCLEAR) {
						const e = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(r) : this._autoClearDepthStencil[r];
						e && e.autoClear && this._clearDepthStencilBuffer(e.depth, e.stencil)
					}
					for (const e of this._scene._beforeRenderingGroupDrawStage) e.action(r);
					o.render(t, n, s, i);
					for (const e of this._scene._afterRenderingGroupDrawStage) e.action(r);
					this._scene.onAfterRenderingGroupObservable.notifyObservers(a, l)
				}
			}
			dispatchSprites(e) {
				this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.Lk).dispatchSprites(e))
			}
			getRenderingGroup(e) {
				const t = e || 0;
				return this._prepareRenderingGroup(t), this._renderingGroups[t]
			}
			reset() {
				if (!this.maintainStateBetweenFrames)
					for (let t = e.MIN_RENDERINGGROUPS; t < e.MAX_RENDERINGGROUPS; t++) {
						const e = this._renderingGroups[t];
						e && e.prepare()
					}
			}
			resetSprites() {
				if (!this.maintainStateBetweenFrames)
					for (let t = e.MIN_RENDERINGGROUPS; t < e.MAX_RENDERINGGROUPS; t++) {
						const e = this._renderingGroups[t];
						e && e.prepareSprites()
					}
			}
			restoreDispachedFlags() {
				for (const e of this._scene.meshes)
					if (e.subMeshes)
						for (const t of e.subMeshes) t._wasDispatched = !1;
				if (this._scene.spriteManagers)
					for (const e of this._scene.spriteManagers) e._wasDispatched = !1;
				for (const e of this._scene.particleSystems) e._wasDispatched = !1
			}
			_clearDepthStencilBuffer(e = !0, t = !0) {
				this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0)
			}
			setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
				this._autoClearDepthStencil[e] = {
					autoClear: t,
					depth: i,
					stencil: s
				}
			}
			set maintainStateBetweenFrames(e) {
				e !== this._maintainStateBetweenFrames && (this._maintainStateBetweenFrames = e, this._maintainStateBetweenFrames || this.restoreDispachedFlags())
			}
			dispose() {
				this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null
			}
			getAutoClearDepthStencilSetup(e) {
				return this._autoClearDepthStencil[e]
			}
			setRenderingOrder(e, t = null, i = null, s = null) {
				if (this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = s, this._renderingGroups[e]) {
					const t = this._renderingGroups[e];
					t.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], t.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], t.transparentSortCompareFn = this._customTransparentSortCompareFn[e]
				}
			}
			get maintainStateBetweenFrames() {
				return this._maintainStateBetweenFrames
			}
			dispatchParticles(e) {
				this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.Lk).dispatchParticles(e))
			}
			dispatch(e, t, i) {
				void 0 === t && (t = e.getMesh()), this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(t.Lk).dispatch(e, t, i))
			}
			constructor(t) {
				this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array, this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new Jp, this._maintainStateBetweenFrames = !1, this._scene = t;
				for (let t = e.MIN_RENDERINGGROUPS; t < e.MAX_RENDERINGGROUPS; t++) this._autoClearDepthStencil[t] = {
					autoClear: !0,
					depth: !0,
					stencil: !0
				}
			}
			_prepareRenderingGroup(e) {
				void 0 === this._renderingGroups[e] && (this._renderingGroups[e] = new $p(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e]))
			}
			freeRenderingGroups() {
				for (let t = e.MIN_RENDERINGGROUPS; t < e.MAX_RENDERINGGROUPS; t++) {
					const e = this._renderingGroups[t];
					e && e.dispose()
				}
			}
		};
	qp.MAX_RENDERINGGROUPS = 4, qp.MIN_RENDERINGGROUPS = 0, qp.AUTOCLEAR = !0, Nd.prototype.createRenderTargetCubeTexture = function(e, t) {
		const i = this._createHardwareRenderTargetWrapper(!1, !0, e),
			s = {
				generateMipMaps: !0,
				generateDepthBuffer: !0,
				generateStencilBuffer: !1,
				type: 0,
				samplingMode: 3,
				format: 5,
				...t
			};
		s.generateStencilBuffer = s.generateDepthBuffer && s.generateStencilBuffer, (1 !== s.type || this._caps.textureFloatLinearFiltering) && (2 !== s.type || this._caps.textureHalfFloatLinearFiltering) || (s.samplingMode = 1);
		const n = this._gl,
			a = new Pm(this, 5);
		this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, a, !0);
		const r = this._getSamplingParameters(s.samplingMode, s.generateMipMaps);
		1 !== s.type || this._caps.textureFloat || (s.type = 0, Qc.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, r.mag), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, r.min), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
		for (let t = 0; t < 6; t++) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, this._getRGBABufferInternalSizedFormat(s.type, s.format), e, e, 0, this._getInternalFormat(s.format), this._getWebGLTextureType(s.type), null);
		const o = n.createFramebuffer();
		return this._bindUnboundFramebuffer(o), i._depthStencilBuffer = this._setupFramebufferDepthAttachments(s.generateStencilBuffer, s.generateDepthBuffer, e, e), s.generateMipMaps && n.generateMipmap(n.TEXTURE_CUBE_MAP), this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, null), this._bindUnboundFramebuffer(null), i._framebuffer = o, i._generateDepthBuffer = s.generateDepthBuffer, i._generateStencilBuffer = s.generateStencilBuffer, a.width = e, a.height = e, a.isReady = !0, a.isCube = !0, a.samples = 1, a.generateMipMaps = s.generateMipMaps, a.samplingMode = s.samplingMode, a.type = s.type, a.format = s.format, this._internalTexturesCache.push(a), i.setTextures(a), i
	}, Nd.prototype.setDepthStencilTexture = function(e, t, i, s) {
		void 0 !== e && (t && (this._boundUniforms[e] = t), i && i.depthStencilTexture ? this._setTexture(e, i, !1, !0, s) : this._setTexture(e, null, void 0, void 0, s))
	}, f();
	var Qp, Zp = {
			positions: [1, 1, -1, 1, -1, -1, 1, -1],
			indices: [0, 1, 2, 0, 2, 3]
		},
		e_ = class {
			setViewport(e = this._fullscreenViewport) {
				this.engine.setViewport(e)
			}
			constructor(e, t = Zp) {
				this._fullscreenViewport = new gd(0, 0, 1, 1);
				const i = t.positions ?? Zp.positions,
					s = t.indices ?? Zp.indices;
				this.engine = e, this._vertexBuffers = {
					[eu.PositionKind]: new eu(e, i, eu.PositionKind, !1, !1, 2)
				}, this._indexBuffer = e.createIndexBuffer(s), this._onContextRestoredObserver = e.onContextRestoredObservable.add((() => {
					this._indexBuffer = e.createIndexBuffer(s);
					for (const e in this._vertexBuffers) {
						this._vertexBuffers[e]._rebuild()
					}
				}))
			}
			bindBuffers(e) {
				this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, e)
			}
			render(e, t = null) {
				if (!e.effect.isReady()) return;
				this.saveStates(), this.setViewport();
				const i = null === t ? null : this._isRenderTargetTexture(t) ? t.renderTarget : t;
				i && this.engine.bindFramebuffer(i), this.applyEffectWrapper(e), this.draw(), i && this.engine.unBindFramebuffer(i), this.restoreStates()
			}
			applyEffectWrapper(e) {
				this.engine.setState(!0), this.engine.depthCullingState.depthTest = !1, this.engine.stencilState.stencilTest = !1, this.engine.enableEffect(e._drawWrapper), this.bindBuffers(e.effect), e.onApplyObservable.notifyObservers({})
			}
			dispose() {
				const e = this._vertexBuffers[eu.PositionKind];
				e && (e.dispose(), delete this._vertexBuffers[eu.PositionKind]), this._indexBuffer && this.engine._releaseBuffer(this._indexBuffer), this._onContextRestoredObserver && (this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)
			}
			saveStates() {
				this._savedStateDepthTest = this.engine.depthCullingState.depthTest, this._savedStateStencilTest = this.engine.stencilState.stencilTest
			}
			restoreStates() {
				this.engine.depthCullingState.depthTest = this._savedStateDepthTest, this.engine.stencilState.stencilTest = this._savedStateStencilTest
			}
			_isRenderTargetTexture(e) {
				return void 0 !== e.renderTarget
			}
			draw() {
				this.engine.drawElementsType(0, 0, 6)
			}
		},
		t_ = class {
			get effect() {
				return this._drawWrapper.effect
			}
			dispose(e = !1) {
				this._onContextRestoredObserver && (this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null), this.effect.dispose()
			}
			set effect(e) {
				this._drawWrapper.effect = e
			}
			constructor(e) {
				let t;
				this.onApplyObservable = new kc;
				const i = e.uniformNames || [];
				e.vertexShader ? t = {
					fragmentSource: e.fragmentShader,
					vertexSource: e.vertexShader,
					spectorName: e.name || "effectWrapper"
				} : (i.push("scale"), t = {
					fragmentSource: e.fragmentShader,
					vertex: "postprocess",
					spectorName: e.name || "effectWrapper"
				}, this.onApplyObservable.add((() => {
					this.effect.setFloat2("scale", 1, 1)
				})));
				const s = e.defines ? e.defines.join("\n") : "";
				this._drawWrapper = new Au(e.engine), e.useShaderStore ? (t.fragment = t.fragmentSource, t.vertex || (t.vertex = t.vertexSource), delete t.fragmentSource, delete t.vertexSource, this.effect = e.engine.createEffect(t, e.attributeNames || ["position"], i, e.samplerNames, s, void 0, e.onCompiled, void 0, void 0, e.shaderLanguage)) : (this.effect = new xm(t, e.attributeNames || ["position"], i, e.samplerNames, e.engine, s, void 0, e.onCompiled, void 0, void 0, void 0, e.shaderLanguage), this._onContextRestoredObserver = e.engine.onContextRestoredObservable.add((() => {
					this.effect._pipelineContext = null, this.effect._prepareEffect()
				})))
			}
		};

	function i_() {
		if (!Qp) {
			let e, t = null;
			const i = {
				preserveDrawingBuffer: !0,
				depth: !1,
				stencil: !1,
				alpha: !0,
				premultipliedAlpha: !1,
				antialias: !1,
				failIfMajorPerformanceCaveat: !1
			};
			try {
				e = new OffscreenCanvas(100, 100), t = new Nd(e, !1, i)
			} catch (s) {
				e = document.createElement("canvas"), t = new Nd(e, !1, i)
			}
			Dc.Instances.pop(), Dc.OnEnginesDisposedObservable.add((e => {
				t && e !== t && !t.isDisposed && 0 === Dc.Instances.length && function() {
					Qp && (Qp.wrapper.dispose(), Qp.renderer.dispose(), Qp.engine.dispose());
					Qp = null
				}()
			})), t.getCaps().parallelShaderCompile = void 0;
			const s = new e_(t),
				n = new t_({
					engine: t,
					name: v.name,
					fragmentShader: v.shader,
					samplerNames: ["textureSampler"]
				});
			Qp = {
				canvas: e,
				engine: t,
				renderer: s,
				wrapper: n
			}
		}
		return Qp
	}
	async function s_(e, t, i, s, n = "image/png", a, r) {
		const o = await i.readPixels(0, 0, e, t);
		a_(e, t, new Uint8Array(o.buffer), s, n, a, !0, void 0, r)
	}

	function n_(e, t, i, s = "image/png", n, a = !1, r = !1, o) {
		return new Promise((l => {
			a_(e, t, i, (e => l(e)), s, n, a, r, o)
		}))
	}

	function a_(e, t, i, s, n = "image/png", a, r = !1, o = !1, l) {
		const h = i_();
		if (h.engine.setSize(e, t, !0), i instanceof Float32Array) {
			const e = new Uint8Array(i.length);
			let t = i.length;
			for (; t--;) {
				const s = i[t];
				e[t] = Math.round(255 * Ac.Clamp(s))
			}
			i = e
		}
		const c = h.engine.createRawTexture(i, e, t, 5, !1, !r, 1);
		h.renderer.setViewport(), h.renderer.applyEffectWrapper(h.wrapper), h.wrapper.effect._bindTexture("textureSampler", c), h.renderer.draw(), o ? dd.ToBlob(h.canvas, (e => {
			const t = new FileReader;
			t.onload = e => {
				const t = e.target.result;
				s && s(t)
			}, t.readAsArrayBuffer(e)
		}), n, l) : dd.EncodeScreenshotCanvasData(h.canvas, s, n, a, l), c.dispose()
	}
	x();
	dd.DumpData = a_, dd.DumpDataAsync = n_, dd.DumpFramebuffer = s_, xm.prototype.setDepthStencilTexture = function(e, t) {
		this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e)
	};
	var r_ = class e extends Np {
		get renderTarget() {
			return this._renderTarget
		}
		setRenderingAutoClearDepthStencil(e, t) {
			this._renderingManager.setRenderingAutoClearDepthStencil(e, t), this._renderingManager._useSceneAutoClearSetup = !1
		}
		_rebuild() {
			this.refreshRate === e.REFRESHRATE_RENDER_ONCE && (this.refreshRate = e.REFRESHRATE_RENDER_ONCE), this._postProcessManager && this._postProcessManager._rebuild()
		}
		isReadyForRendering() {
			return this._render(!1, !1, !0)
		}
		render(e = !1, t = !1) {
			this._render(e, t)
		}
		set samples(e) {
			this._renderTarget && (this._samples = this._renderTarget.setSamples(e))
		}
		addPostProcess(e) {
			if (!this._postProcessManager) {
				const e = this.getScene();
				if (!e) return;
				this._postProcessManager = new Kp(e), this._postProcesses = new Array
			}
			this._postProcesses.push(e), this._postProcesses[0].autoClear = !1
		}
		disableRescaling() {
			this._canRescale = !1
		}
		get _prePassEnabled() {
			return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled
		}
		_onRatioRescale() {
			this._sizeRatio && this.resize(this._initialSizeParameter)
		}
		get currentRefreshId() {
			return this._currentRefreshId
		}
		_shouldRender() {
			return -1 === this._currentRefreshId || this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1)
		}
		get boundingBoxSize() {
			return this._boundingBoxSize
		}
		setRenderingOrder(e, t = null, i = null, s = null) {
			this._renderingManager.setRenderingOrder(e, t, i, s)
		}
		scale(e) {
			const t = Math.max(1, this.getRenderSize() * e);
			this.resize(t)
		}
		get renderPassIds() {
			return this._renderPassIds
		}
		get postProcesses() {
			return this._postProcesses
		}
		get refreshRate() {
			return this._refreshRate
		}
		_prepareFrame(e, t, i, s) {
			this._postProcessManager ? this._prePassEnabled || this._postProcessManager._prepareFrame(this._texture, this._postProcesses) : s && e.postProcessManager._prepareFrame(this._texture) || this._bindFrameBuffer(t, i)
		}
		_render(e = !1, t = !1, i = !1) {
			const s = this.getScene();
			if (!s) return i;
			const n = s.getEngine();
			if (void 0 !== this.useCameraPostProcesses && (e = this.useCameraPostProcesses), this._waitingRenderList) {
				if (!this.renderListPredicate) {
					this.Tk = [];
					for (let e = 0; e < this._waitingRenderList.length; e++) {
						const t = this._waitingRenderList[e],
							i = s.getMeshById(t);
						i && this.Tk.push(i)
					}
				}
				this._waitingRenderList = void 0
			}
			if (this.renderListPredicate) {
				this.Tk ? this.Tk.length = 0 : this.Tk = [];
				const e = this.getScene();
				if (!e) return i;
				const t = e.meshes;
				for (let e = 0; e < t.length; e++) {
					const i = t[e];
					this.renderListPredicate(i) && this.Tk.push(i)
				}
			}
			const a = n.currentRenderPassId;
			this.onBeforeBindObservable.notifyObservers(this);
			const r = this.activeCamera ?? s.activeCamera,
				o = s.activeCamera;
			r && (r !== s.activeCamera && (s.setTransformMatrix(r.getViewMatrix(), r.getProjectionMatrix(!0)), s.activeCamera = r), n.setViewport(r.rigParent ? r.rigParent.viewport : r.viewport, this.getRenderWidth(), this.getRenderHeight())), this._defaultRenderListPrepared = !1;
			let l = i;
			if (i) {
				s.getViewMatrix() || s.updateTransformMatrix();
				const e = this.is2DArray || this.is3D ? this.getRenderLayers() : this.isCube ? 6 : 1;
				for (let t = 0; t < e && l; t++) {
					let e = null;
					const a = this.Tk ? this.Tk : s.getActiveMeshes().data,
						r = this.Tk ? this.Tk.length : s.getActiveMeshes().length;
					n.currentRenderPassId = this._renderPassIds[t], this.onBeforeRenderObservable.notifyObservers(t), this.getCustomRenderList && (e = this.getCustomRenderList(t, a, r)), e || (e = a), this._doNotChangeAspectRatio || s.updateTransformMatrix(!0);
					for (let t = 0; t < e.length && l; ++t) {
						const s = e[t];
						if (s.isEnabled() && !s.isBlocked && s.isVisible && s.subMeshes)
							if (this.customIsReadyFunction) {
								if (!this.customIsReadyFunction(s, this.refreshRate, i)) {
									l = !1;
									continue
								}
							} else if (!s.isReady(!0)) {
							l = !1;
							continue
						}
					}
					this.onAfterRenderObservable.notifyObservers(t), (this.is2DArray || this.is3D || this.isCube) && (s.incrementRenderId(), s.resetCachedMaterial())
				}
			} else if (!this.is2DArray && !this.is3D || this.isMulti)
				if (this.isCube && !this.isMulti)
					for (let i = 0; i < 6; i++) this._renderToTarget(i, e, t, void 0, r), s.incrementRenderId(), s.resetCachedMaterial();
				else this._renderToTarget(0, e, t, void 0, r);
			else
				for (let i = 0; i < this.getRenderLayers(); i++) this._renderToTarget(0, e, t, i, r), s.incrementRenderId(), s.resetCachedMaterial();
			return this.onAfterUnbindObservable.notifyObservers(this), n.currentRenderPassId = a, o && (s.activeCamera = o, this.activeCamera && this.activeCamera !== s.activeCamera && s.setTransformMatrix(s.activeCamera.getViewMatrix(), s.activeCamera.getProjectionMatrix(!0)), n.setViewport(s.activeCamera.viewport)), s.resetCachedMaterial(), l
		}
		_bestReflectionRenderTargetDimension(e, t) {
			const i = e * t,
				s = hd(i + 16384 / (128 + i));
			return Math.min(ud(e), s)
		}
		set refreshRate(e) {
			this._refreshRate = e, this.resetRefreshCounter()
		}
		_unbindFrameBuffer(e, t) {
			this._renderTarget && e.unBindFramebuffer(this._renderTarget, this.isCube, (() => {
				this.onAfterRenderObservable.notifyObservers(t)
			}))
		}
		dispose() {
			this.onResizeObservable.clear(), this.onClearObservable.clear(), this.onAfterRenderObservable.clear(), this.onAfterUnbindObservable.clear(), this.onBeforeBindObservable.clear(), this.onBeforeRenderObservable.clear(), this._postProcessManager && (this._postProcessManager.dispose(), this._postProcessManager = null), this._prePassRenderTarget && this._prePassRenderTarget.dispose(), this._releaseRenderPassId(), this.clearPostProcesses(!0), this._resizeObserver && (this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this.Tk = null;
			const e = this.getScene();
			if (!e) return;
			let t = e.customRenderTargets.indexOf(this);
			t >= 0 && e.customRenderTargets.splice(t, 1);
			for (const i of e.cameras) t = i.customRenderTargets.indexOf(this), t >= 0 && i.customRenderTargets.splice(t, 1);
			this._renderTarget?.dispose(), this._renderTarget = null, this._texture = null, super.dispose()
		}
		_renderToTarget(e, t, i, s = 0, n = null) {
			const a = this.getScene();
			if (!a) return;
			const r = a.getEngine();
			r._debugPushGroup?.(`render to face #${e} layer #${s}`, 1), this._prepareFrame(a, e, s, t), this.is2DArray || this.is3D ? (r.currentRenderPassId = this._renderPassIds[s], this.onBeforeRenderObservable.notifyObservers(s)) : (r.currentRenderPassId = this._renderPassIds[e], this.onBeforeRenderObservable.notifyObservers(e));
			if (r.snapshotRendering && 1 === r.snapshotRenderingMode) this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(r) : this.skipInitialClear || r.clear(this.clearColor || a.clearColor, !0, !0, !0);
			else {
				let o = null;
				const l = this.Tk ? this.Tk : a.getActiveMeshes().data,
					h = this.Tk ? this.Tk.length : a.getActiveMeshes().length;
				this.getCustomRenderList && (o = this.getCustomRenderList(this.is2DArray || this.is3D ? s : e, l, h)), o ? this._prepareRenderingManager(o, o.length, n, this.forceLayerMaskCheck) : (this._defaultRenderListPrepared || (this._prepareRenderingManager(l, h, n, !this.Tk || this.forceLayerMaskCheck), this._defaultRenderListPrepared = !0), o = l);
				for (const t of a._beforeRenderTargetClearStage) t.action(this, e, s);
				this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(r) : this.skipInitialClear || r.clear(this.clearColor || a.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || a.updateTransformMatrix(!0);
				for (const t of a._beforeRenderTargetDrawStage) t.action(this, e, s);
				this._renderingManager.render(this.customRenderFunction, o, this.renderParticles, this.renderSprites);
				for (const t of a._afterRenderTargetDrawStage) t.action(this, e, s);
				const c = this._texture?.generateMipMaps ?? !1;
				this._texture && (this._texture.generateMipMaps = !1), this._postProcessManager ? this._postProcessManager._finalizeFrame(!1, this._renderTarget ?? void 0, e, this._postProcesses, this.ignoreCameraViewport) : t && a.postProcessManager._finalizeFrame(!1, this._renderTarget ?? void 0, e);
				for (const t of a._afterRenderTargetPostProcessStage) t.action(this, e, s);
				this._texture && (this._texture.generateMipMaps = c), this._doNotChangeAspectRatio || a.updateTransformMatrix(!0), i && s_(this.getRenderWidth(), this.getRenderHeight(), r)
			}
			this._unbindFrameBuffer(r, e), this._texture && this.isCube && 5 === e && r.generateMipMapsForCubemap(this._texture, !0), r._debugPopGroup?.(1)
		}
		_releaseRenderPassId() {
			if (this._scene) {
				const e = this._scene.getEngine();
				for (let t = 0; t < this._renderPassIds.length; ++t) e.releaseRenderPassId(this._renderPassIds[t])
			}
			this._renderPassIds = []
		}
		freeRenderingGroups() {
			this._renderingManager && this._renderingManager.freeRenderingGroups()
		}
		getReflectionTextureMatrix() {
			return this.isCube ? this._textureMatrix : super.getReflectionTextureMatrix()
		}
		_prepareRenderingManager(e, t, i, s) {
			const n = this.getScene();
			if (!n) return;
			this._renderingManager.reset();
			const a = n.getRenderId();
			for (let r = 0; r < t; r++) {
				const t = e[r];
				if (t && !t.isBlocked) {
					if (this.customIsReadyFunction) {
						if (!this.customIsReadyFunction(t, this.refreshRate, !1)) {
							this.resetRefreshCounter();
							continue
						}
					} else if (!t.isReady(0 === this.refreshRate)) {
						this.resetRefreshCounter();
						continue
					}
					if (!t._internalAbstractMeshDataInfo._currentLODIsUpToDate && n.activeCamera && (t._internalAbstractMeshDataInfo._currentLOD = n.customLODSelector ? n.customLODSelector(t, this.activeCamera || n.activeCamera) : t.getLOD(this.activeCamera || n.activeCamera), t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0), !t._internalAbstractMeshDataInfo._currentLOD) continue;
					let e, r = t._internalAbstractMeshDataInfo._currentLOD;
					if (r._preActivateForIntermediateRendering(a), e = !(!s || !i) && !(t.layerMask & i.layerMask), t.isEnabled() && t.isVisible && t.subMeshes && !e) {
						if (r !== t && r._activate(a, !0), t._activate(a, !0) && t.subMeshes.length) {
							t.isAnInstance ? t._internalAbstractMeshDataInfo._actAsRegularMesh && (r = t) : r._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !1, r._internalAbstractMeshDataInfo._isActiveIntermediate = !0;
							for (let e = 0; e < r.subMeshes.length; e++) {
								const t = r.subMeshes[e];
								this._renderingManager.dispatch(t, r)
							}
						}
						t._postActivate()
					}
				}
			}
			for (let e = 0; e < n.particleSystems.length; e++) {
				const t = n.particleSystems[e],
					i = t.emitter;
				t.isStarted() && i && (!i.position || i.isEnabled()) && this._renderingManager.dispatchParticles(t)
			}
		}
		get Tk() {
			return this._renderList
		}
		_bindFrameBuffer(e = 0, t = 0) {
			const i = this.getScene();
			if (!i) return;
			const s = i.getEngine();
			this._renderTarget && s.bindFramebuffer(this._renderTarget, this.isCube ? e : void 0, void 0, void 0, this.ignoreCameraViewport, 0, t)
		}
		clone() {
			const t = this.getSize(),
				i = new e(this.name, t, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
			return i.hasAlpha = this.hasAlpha, i.level = this.level, i.coordinatesMode = this.coordinatesMode, this.Tk && (i.Tk = this.Tk.slice(0)), i
		}
		getViewCount() {
			return 1
		}
		get renderTargetOptions() {
			return this._renderTargetOptions
		}
		set onClear(e) {
			this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(e)
		}
		disposeFramebufferObjects() {
			this._renderTarget?.dispose(!0)
		}
		set onAfterUnbind(e) {
			this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(e)
		}
		get isMulti() {
			return this._renderTarget?.isMulti ?? !1
		}
		resetRefreshCounter() {
			this._currentRefreshId = -1
		}
		set onAfterRender(e) {
			this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
		}
		getRenderHeight() {
			return this._size.width ? this._size.height : this._size
		}
		clearPostProcesses(e = !1) {
			if (this._postProcesses) {
				if (e)
					for (const e of this._postProcesses) e.dispose();
				this._postProcesses = []
			}
		}
		serialize() {
			if (!this.name) return null;
			const e = super.serialize();
			if (e.renderTargetSize = this.getRenderSize(), e.Tk = [], this.Tk)
				for (let t = 0; t < this.Tk.length; t++) e.Tk.push(this.Tk[t].id);
			return e
		}
		getRenderSize() {
			return this.getRenderWidth()
		}
		constructor(e, t, i, s = !1, n = !0, a = 0, r = !1, o = Np.TRILINEAR_SAMPLINGMODE, l = !0, h = !1, c = !1, u = 5, m = !1, d, f, p = !1, _ = !1) {
			let g, v = !0;
			if ("object" == typeof s) {
				const e = s;
				s = !!e.generateMipMaps, n = e.doNotChangeAspectRatio ?? !0, a = e.type ?? 0, r = !!e.isCube, o = e.samplingMode ?? Np.TRILINEAR_SAMPLINGMODE, l = e.generateDepthBuffer ?? !0, h = !!e.generateStencilBuffer, c = !!e.isMulti, u = e.format ?? 5, m = !!e.delayAllocation, d = e.samples, f = e.creationFlags, p = !!e.noColorAttachment, _ = !!e.useSRGBBuffer, g = e.colorAttachment, v = e.gammaSpace ?? v
			}
			if (super(null, i, !s, void 0, o, void 0, void 0, void 0, void 0, u), this._unObserveRenderList = null, this._renderListHasChanged = (e, t) => {
					const i = this._renderList ? this._renderList.length : 0;
					(0 === t && i > 0 || 0 === i) && this.getScene()?.meshes.forEach((e => {
						e._markSubMeshesAsLightDirty()
					}))
				}, this.renderParticles = !0, this.renderSprites = !1, this.forceLayerMaskCheck = !1, this.ignoreCameraViewport = !1, this.onBeforeBindObservable = new kc, this.onAfterUnbindObservable = new kc, this.onBeforeRenderObservable = new kc, this.onAfterRenderObservable = new kc, this.onClearObservable = new kc, this.onResizeObservable = new kc, this._cleared = !1, this.skipInitialClear = !1, this._currentRefreshId = -1, this._refreshRate = 1, this._samples = 1, this._canRescale = !0, this._renderTarget = null, this.boundingBoxPosition = Lc.Zero(), !(i = this.getScene())) return;
			const y = this.getScene().getEngine();
			this._gammaSpace = v, this._coordinatesMode = Np.PROJECTION_MODE, this.Tk = [], this.name = e, this.isRenderTarget = !0, this._initialSizeParameter = t, this._renderPassIds = [], this._isCubeData = r, this._processSizeParameter(t), this.renderPassId = this._renderPassIds[0], this._resizeObserver = y.onResizeObservable.add((() => {})), this._generateMipMaps = !!s, this._doNotChangeAspectRatio = n, this._renderingManager = new qp(i), this._renderingManager._useSceneAutoClearSetup = !0, c || (this._renderTargetOptions = {
				generateMipMaps: s,
				type: a,
				format: this._format ?? void 0,
				samplingMode: this.samplingMode,
				generateDepthBuffer: l,
				generateStencilBuffer: h,
				samples: d,
				creationFlags: f,
				noColorAttachment: p,
				useSRGBBuffer: _,
				colorAttachment: g,
				label: this.name
			}, this.samplingMode === Np.NEAREST_SAMPLINGMODE && (this.wrapU = Np.CLAMP_ADDRESSMODE, this.wrapV = Np.CLAMP_ADDRESSMODE), m || (r ? (this._renderTarget = i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions), this.coordinatesMode = Np.INVCUBIC_MODE, this._textureMatrix = Hc.Identity()) : this._renderTarget = i.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, void 0 !== d && (this.samples = d)))
		}
		_processSizeParameter(e, t = !0) {
			if (e.ratio) {
				this._sizeRatio = e.ratio;
				const t = this._getEngine();
				this._size = {
					width: this._bestReflectionRenderTargetDimension(t.getRenderWidth(), this._sizeRatio),
					height: this._bestReflectionRenderTargetDimension(t.getRenderHeight(), this._sizeRatio)
				}
			} else this._size = e;
			t && this._createRenderPassId()
		}
		get depthStencilTexture() {
			return this._renderTarget?._depthStencilTexture ?? null
		}
		releaseInternalTexture() {
			this._renderTarget?.releaseTextures(), this._texture = null
		}
		_createRenderPassId() {
			this._releaseRenderPassId();
			const e = this._scene.getEngine(),
				t = this._isCubeData ? 6 : this.getRenderLayers() || 1;
			for (let i = 0; i < t; ++i) this._renderPassIds[i] = e.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`)
		}
		resize(e) {
			const t = this.isCube;
			this._renderTarget?.dispose(), this._renderTarget = null;
			const i = this.getScene();
			i && (this._processSizeParameter(e, !1), this._renderTarget = t ? i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions) : i.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, void 0 !== this._renderTargetOptions.samples && (this.samples = this._renderTargetOptions.samples), this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this))
		}
		getRenderWidth() {
			return this._size.width ? this._size.width : this._size
		}
		createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, n = 14, a) {
			this._renderTarget?.createDepthStencilTexture(e, t, i, s, n, a)
		}
		set Tk(e) {
			this._unObserveRenderList && (this._unObserveRenderList(), this._unObserveRenderList = null), e && (this._unObserveRenderList = lc(e, this._renderListHasChanged)), this._renderList = e
		}
		get samples() {
			return this._renderTarget?.samples ?? this._samples
		}
		set boundingBoxSize(e) {
			if (this._boundingBoxSize && this._boundingBoxSize.equals(e)) return;
			this._boundingBoxSize = e;
			const t = this.getScene();
			t && t.markAllMaterialsAsDirty(1)
		}
		setMaterialForRendering(e, t) {
			let i;
			i = Array.isArray(e) ? e : [e];
			for (let e = 0; e < i.length; ++e)
				for (let s = 0; s < this._renderPassIds.length; ++s) i[e].setMaterialForRenderPass(this._renderPassIds[s], void 0 !== t ? Array.isArray(t) ? t[s] : t : void 0)
		}
		removePostProcess(e) {
			if (!this._postProcesses) return;
			const t = this._postProcesses.indexOf(e); - 1 !== t && (this._postProcesses.splice(t, 1), this._postProcesses.length > 0 && (this._postProcesses[0].autoClear = !1))
		}
		get canRescale() {
			return this._canRescale
		}
		set onBeforeRender(e) {
			this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
		}
		getRenderLayers() {
			const e = this._size.layers;
			if (e) return e;
			const t = this._size.depth;
			return t || 0
		}
	};
	r_.REFRESHRATE_RENDER_ONCE = 0, r_.REFRESHRATE_RENDER_ONEVERYFRAME = 1, r_.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2, Np._CreateRenderTargetTexture = (e, t, i, s, n) => new r_(e, t, i, s);
	var o_ = class {
		register() {
			this.scene._beforeClearStage.registerStep(Df.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear)
		}
		constructor(e) {
			this.name = Df.NAME_PROCEDURALTEXTURE, this.scene = e, this.scene.proceduralTextures = []
		}
		dispose() {}
		_beforeClear() {
			if (this.scene.proceduralTexturesEnabled) {
				dd.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
				for (let e = 0; e < this.scene.proceduralTextures.length; e++) {
					const t = this.scene.proceduralTextures[e];
					t._shouldRender() && t.render()
				}
				dd.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0)
			}
		}
		rebuild() {}
	};
	h();
	e.ShadersStore.proceduralVertexShader = "attribute vec2 position;varying vec2 vPosition;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvPosition=position;vUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";
	var l_, h_, c_ = class e extends Np {
		resetRefreshCounter() {
			this._currentRefreshId = -1
		}
		setMatrix(e, t) {
			return this._checkUniform(e), this._matrices[e] = t, this
		}
		_setEffect(e) {
			this._drawWrapper.effect = e
		}
		_checkUniform(e) {
			-1 === this._uniforms.indexOf(e) && this._uniforms.push(e)
		}
		clone() {
			const t = this.getSize(),
				i = new e(this.name, t.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
			return i.hasAlpha = this.hasAlpha, i.level = this.level, i.coordinatesMode = this.coordinatesMode, i
		}
		setVector2(e, t) {
			return this._checkUniform(e), this._vectors2[e] = t, this
		}
		getEffect() {
			return this._drawWrapper.effect
		}
		_getDefines() {
			return ""
		}
		get refreshRate() {
			return this._refreshRate
		}
		setVector3(e, t) {
			return this._checkUniform(e), this._vectors3[e] = t, this
		}
		setColor3(e, t) {
			return this._checkUniform(e), this._colors3[e] = t, this
		}
		_rebuild() {
			const e = this._vertexBuffers[eu.PositionKind];
			e && e._rebuild(), this._createIndexBuffer(), this.refreshRate === r_.REFRESHRATE_RENDER_ONCE && (this.refreshRate = r_.REFRESHRATE_RENDER_ONCE)
		}
		isReady() {
			const e = this._fullEngine;
			if (this.nodeMaterialSource) return this._drawWrapper.effect.isReady();
			if (!this._fragment) return !1;
			if (this._fallbackTextureUsed) return !0;
			if (!this._texture) return !1;
			const t = this._getDefines();
			if (this._drawWrapper.effect && t === this._cachedDefines && this._drawWrapper.effect.isReady()) return !0;
			const i = {
				vertex: "procedural",
				fragmentElement: this._fragment.fragmentElement,
				fragmentSource: this._fragment.fragmentSource,
				fragment: "string" == typeof this._fragment ? this._fragment : void 0
			};
			return this._cachedDefines !== t && (this._cachedDefines = t, this._drawWrapper.effect = e.createEffect(i, [eu.PositionKind], this._uniforms, this._samplers, t, void 0, void 0, (() => {
				this._rtWrapper?.dispose(), this._rtWrapper = this._texture = null, this._fallbackTexture && (this._texture = this._fallbackTexture._texture, this._texture && this._texture.incrementReferences()), this._fallbackTextureUsed = !0
			}))), this._drawWrapper.effect.isReady()
		}
		constructor(e, t, i, s, n = null, a = !0, r = !1, o = 0) {
			super(null, s, !a), this.isEnabled = !0, this.autoClear = !0, this.onGeneratedObservable = new kc, this.onBeforeGenerationObservable = new kc, this.nodeMaterialSource = null, this._textures = {}, this._currentRefreshId = -1, this._frameId = -1, this._refreshRate = 1, this._vertexBuffers = {}, this._uniforms = new Array, this._samplers = new Array, this._floats = {}, this._ints = {}, this._floatsArrays = {}, this._colors3 = {}, this._colors4 = {}, this._vectors2 = {}, this._vectors3 = {}, this._vectors4 = {}, this._matrices = {}, this._fallbackTextureUsed = !1, this._cachedDefines = null, this._contentUpdateId = -1, this._rtWrapper = null, null === n || n instanceof Np ? (this._options = {}, this._fallbackTexture = n) : (this._options = n, this._fallbackTexture = n.fallbackTexture ?? null);
			let l = (s = this.getScene() || Dc.LastCreatedScene)._getComponent(Df.NAME_PROCEDURALTEXTURE);
			l || (l = new o_(s), s._addComponent(l)), s.proceduralTextures.push(this), this._fullEngine = s.getEngine(), this.name = e, this.isRenderTarget = !0, this._size = t, this._textureType = o, this._generateMipMaps = a, this._drawWrapper = new Au(this._fullEngine), this.setFragment(i);
			const h = this._createRtWrapper(r, t, a, o);
			this._texture = h.texture;
			const c = [];
			c.push(1, 1), c.push(-1, 1), c.push(-1, -1), c.push(1, -1), this._vertexBuffers[eu.PositionKind] = new eu(this._fullEngine, c, eu.PositionKind, !1, !1, 2), this._createIndexBuffer()
		}
		reset() {
			this._drawWrapper.effect?.dispose(), this._drawWrapper.effect = null, this._cachedDefines = null
		}
		getContent() {
			return this._contentData && this._frameId === this._contentUpdateId || (this._contentData ? this._contentData.then((e => {
				this._contentData = this.readPixels(0, 0, e), this._contentUpdateId = this._frameId
			})) : (this._contentData = this.readPixels(0, 0), this._contentUpdateId = this._frameId)), this._contentData
		}
		set refreshRate(e) {
			this._refreshRate = e, this.resetRefreshCounter()
		}
		setColor4(e, t) {
			return this._checkUniform(e), this._colors4[e] = t, this
		}
		setFloat(e, t) {
			return this._checkUniform(e), this._floats[e] = t, this
		}
		setVector4(e, t) {
			return this._checkUniform(e), this._vectors4[e] = t, this
		}
		getRenderSize() {
			return this._size
		}
		setFloats(e, t) {
			return this._checkUniform(e), this._floatsArrays[e] = t, this
		}
		_shouldRender() {
			return this.isEnabled && this.isReady() && this._texture ? !this._fallbackTextureUsed && (-1 === this._currentRefreshId || this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, this._frameId++, !0) : (this._currentRefreshId++, !1)) : (this._texture && (this._texture.isReady = !1), !1)
		}
		setTexture(e, t) {
			return -1 === this._samplers.indexOf(e) && this._samplers.push(e), this._textures[e] = t, this
		}
		dispose() {
			const e = this.getScene();
			if (!e) return;
			const t = e.proceduralTextures.indexOf(this);
			t >= 0 && e.proceduralTextures.splice(t, 1);
			const i = this._vertexBuffers[eu.PositionKind];
			i && (i.dispose(), this._vertexBuffers[eu.PositionKind] = null), this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer) && (this._indexBuffer = null), this.onGeneratedObservable.clear(), this.onBeforeGenerationObservable.clear(), super.dispose()
		}
		render(e) {
			const t = this.getScene();
			if (!t) return;
			const i = this._fullEngine;
			if (i.enableEffect(this._drawWrapper), this.onBeforeGenerationObservable.notifyObservers(this), i.setState(!1), !this.nodeMaterialSource) {
				for (const e in this._textures) this._drawWrapper.effect.setTexture(e, this._textures[e]);
				for (const e in this._ints) this._drawWrapper.effect.setInt(e, this._ints[e]);
				for (const e in this._floats) this._drawWrapper.effect.setFloat(e, this._floats[e]);
				for (const e in this._floatsArrays) this._drawWrapper.effect.setArray(e, this._floatsArrays[e]);
				for (const e in this._colors3) this._drawWrapper.effect.setColor3(e, this._colors3[e]);
				for (const e in this._colors4) {
					const t = this._colors4[e];
					this._drawWrapper.effect.setFloat4(e, t.r, t.g, t.b, t.a)
				}
				for (const e in this._vectors2) this._drawWrapper.effect.setVector2(e, this._vectors2[e]);
				for (const e in this._vectors3) this._drawWrapper.effect.setVector3(e, this._vectors3[e]);
				for (const e in this._vectors4) this._drawWrapper.effect.setVector4(e, this._vectors4[e]);
				for (const e in this._matrices) this._drawWrapper.effect.setMatrix(e, this._matrices[e])
			}
			if (!this._texture || !this._rtWrapper) return;
			i._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);
			const s = i.currentViewport;
			if (this.isCube)
				for (let e = 0; e < 6; e++) i.bindFramebuffer(this._rtWrapper, e, void 0, void 0, !0), i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect), this._drawWrapper.effect.setFloat("face", e), this.autoClear && i.clear(t.clearColor, !0, !1, !1), i.drawElementsType(Pf.TriangleFillMode, 0, 6);
			else {
				let e = 1;
				this._rtWrapper.is3D ? e = this._rtWrapper.depth : this._rtWrapper.is2DArray && (e = this._rtWrapper.layers);
				for (let s = 0; s < e; s++) i.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, !0, 0, s), (this._rtWrapper.is3D || this._rtWrapper.is2DArray) && this._drawWrapper.effect?.setFloat("layer", 1 !== e ? s / (e - 1) : 0), i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect), this.autoClear && i.clear(t.clearColor, !0, !1, !1), i.drawElementsType(Pf.TriangleFillMode, 0, 6)
			}
			i.unBindFramebuffer(this._rtWrapper, this.isCube), s && i.setViewport(s), this.isCube && i.generateMipMapsForCubemap(this._texture, !0), i._debugPopGroup?.(1), this.onGenerated && this.onGenerated(), this.onGeneratedObservable.notifyObservers(this)
		}
		setInt(e, t) {
			return this._checkUniform(e), this._ints[e] = t, this
		}
		resize(e, t) {
			if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) return;
			const i = this._texture.isCube;
			this._rtWrapper.dispose();
			const s = this._createRtWrapper(i, e, t, this._textureType);
			this._texture = s.texture, this._size = e, this._generateMipMaps = t
		}
		_createIndexBuffer() {
			const e = this._fullEngine,
				t = [];
			t.push(0), t.push(1), t.push(2), t.push(0), t.push(2), t.push(3), this._indexBuffer = e.createIndexBuffer(t)
		}
		_createRtWrapper(e, t, i, s) {
			return e ? (this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(t, {
				generateMipMaps: i,
				generateDepthBuffer: !1,
				generateStencilBuffer: !1,
				type: s,
				...this._options
			}), this.setFloat("face", 0)) : this._rtWrapper = this._fullEngine.createRenderTargetTexture(t, {
				generateMipMaps: i,
				generateDepthBuffer: !1,
				generateStencilBuffer: !1,
				type: s,
				...this._options
			}), this._rtWrapper
		}
		executeWhenReady(e) {
			if (this.isReady()) return void e(this);
			const t = this.getEffect();
			t && t.executeWhenCompiled((() => {
				e(this)
			}))
		}
		setFragment(e) {
			this._fragment = e
		}
	};
	Gh([Xh()], c_.prototype, "isEnabled", void 0), Gh([Xh()], c_.prototype, "autoClear", void 0), Gh([Xh()], c_.prototype, "_generateMipMaps", void 0), Gh([Xh()], c_.prototype, "_size", void 0), Gh([Xh()], c_.prototype, "refreshRate", null), cc("BABYLON.ProceduralTexture", c_), (h_ = l_ || (l_ = {}))[h_.Cos = 0] = "Cos", h_[h_.Sin = 1] = "Sin", h_[h_.Abs = 2] = "Abs", h_[h_.Exp = 3] = "Exp", h_[h_.Exp2 = 4] = "Exp2", h_[h_.Round = 5] = "Round", h_[h_.Floor = 6] = "Floor", h_[h_.Ceiling = 7] = "Ceiling", h_[h_.Sqrt = 8] = "Sqrt", h_[h_.Log = 9] = "Log", h_[h_.Tan = 10] = "Tan", h_[h_.ArcTan = 11] = "ArcTan", h_[h_.ArcCos = 12] = "ArcCos", h_[h_.ArcSin = 13] = "ArcSin", h_[h_.Fract = 14] = "Fract", h_[h_.Sign = 15] = "Sign", h_[h_.Radians = 16] = "Radians", h_[h_.Degrees = 17] = "Degrees", h_[h_.Set = 18] = "Set";
	var u_ = class extends ap {
		constructor(e) {
			super(e, Xf.Neutral), this.operation = l_.Cos, this.registerInput("input", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0]
		}
		getClassName() {
			return "TrigonometryBlock"
		}
		serialize() {
			const e = super.serialize();
			return e.operation = this.operation, e
		}
		get output() {
			return this._outputs[0]
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.operation = e.operation
		}
		get input() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			let i = "";
			switch (this.operation) {
				case l_.Cos:
					i = "cos";
					break;
				case l_.Sin:
					i = "sin";
					break;
				case l_.Abs:
					i = "abs";
					break;
				case l_.Exp:
					i = "exp";
					break;
				case l_.Exp2:
					i = "exp2";
					break;
				case l_.Round:
					i = "round";
					break;
				case l_.Floor:
					i = "floor";
					break;
				case l_.Ceiling:
					i = "ceil";
					break;
				case l_.Sqrt:
					i = "sqrt";
					break;
				case l_.Log:
					i = "log";
					break;
				case l_.Tan:
					i = "tan";
					break;
				case l_.ArcTan:
					i = "atan";
					break;
				case l_.ArcCos:
					i = "acos";
					break;
				case l_.ArcSin:
					i = "asin";
					break;
				case l_.Fract:
					i = "fract";
					break;
				case l_.Sign:
					i = "sign";
					break;
				case l_.Radians:
					i = "radians";
					break;
				case l_.Degrees:
					i = "degrees";
					break;
				case l_.Set:
					i = ""
			}
			return e.compilationString += e._declareOutput(t) + ` = ${i}(${this.input.associatedVariableName});\n`, this
		}
		_dumpPropertiesCode() {
			return super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${l_[this.operation]};\n`
		}
	};
	cc("BABYLON.TrigonometryBlock", u_);
	var m_ = {
			effect: null,
			subMesh: null
		},
		d_ = class extends ip {
			constructor() {
				super(), this.NORMAL = !1, this.TANGENT = !1, this.VERTEXCOLOR_NME = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.PREPASS = !1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = 0, this.CONTRAST = !1, this.EXPOSURE = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.BUMPDIRECTUV = 0, this.CAMERA_ORTHOGRAPHIC = !1, this.CAMERA_PERSPECTIVE = !1, this.rebuild()
			}
			setValue(e, t, i = !1) {
				void 0 === this[e] && this._keys.push(e), i && this[e] !== t && this.markAsUnprocessed(), this[e] = t
			}
		},
		f_ = class e extends $f {
			_createEffectForParticles(e, t, i, s, n, a, r, o = "") {
				let l = this.name + this._buildId + "_" + t;
				a || (a = new d_), r || (r = this.getScene().getMeshByName(this.name + "Particle")) || ((r = new Vf(this.name + "Particle", this.getScene())).reservedDataStore = {
					hidden: !0
				});
				let h = this._buildId;
				const c = [];
				let u = o;
				if (!n) {
					const o = this._processDefines(r, a);
					xm.RegisterShader(l, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage), e.fillDefines(c, t, !1), u = c.join("\n"), n = this.getScene().getEngine().createEffectForParticles(l, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, a.toString() + "\n" + u, o?.fallbacks, i, s, e, this.shaderLanguage), e.setCustomEffect(n, t)
				}
				n.onBindObservable.add((n => {
					h !== this._buildId && (delete xm.ShadersStore[l + "PixelShader"], l = this.name + this._buildId + "_" + t, a.markAllAsDirty(), h = this._buildId), c.length = 0, e.fillDefines(c, t, !1);
					const m = c.join("\n");
					m !== u && (a.markAllAsDirty(), u = m);
					const d = this._processDefines(r, a);
					if (d) return xm.RegisterShader(l, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage), n = this.getScene().getEngine().createEffectForParticles(l, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, a.toString() + "\n" + u, d?.fallbacks, i, s, e), e.setCustomEffect(n, t), void this._createEffectForParticles(e, t, i, s, n, a, r, o);
					this._checkInternals(n)
				}))
			}
			getActiveTextures() {
				const e = super.getActiveTextures();
				return this._sharedData && e.push(...this._sharedData.textureBlocks.filter((e => e.texture)).map((e => e.texture))), e
			}
			unregisterOptimizer(e) {
				const t = this._optimizers.indexOf(e);
				if (-1 !== t) return this._optimizers.splice(t, 1), this
			}
			_addVertexOutputNode(e) {
				if (-1 === this._vertexOutputNodes.indexOf(e)) return e.target = Xf.Vertex, this._vertexOutputNodes.push(e), this
			}
			removeOutputNode(e) {
				return null === e.target || (e.target & Xf.Vertex && this._removeVertexOutputNode(e), e.target & Xf.Fragment && this._removeFragmentOutputNode(e)), this
			}
			getBlockByName(e) {
				let t = null;
				for (const i of this.attachedBlocks)
					if (i.name === e) {
						if (t) return dd.Warn("More than one block was found with the name `" + e + "`"), t;
						t = i
					} return t
			}
			setToDefaultPostProcess() {
				this.clear(), this.editorData = null;
				const e = new Cp("Position");
				e.setAsAttribute("position2d");
				const t = new Cp("Constant1");
				t.isConstant = !0, t.value = 1;
				const i = new Gp("Position3D");
				e.connectTo(i), t.connectTo(i, {
					input: "w"
				});
				const s = new hp("VertexOutput");
				i.connectTo(s);
				const n = new Cp("Scale");
				n.visibleInInspector = !0, n.value = new Fc(1, 1);
				const a = new Hp("uv0");
				e.connectTo(a);
				const r = new zp("UV scale");
				a.connectTo(r), n.connectTo(r);
				const o = new Ip("CurrentScreen");
				r.connectTo(o), o.texture = new Np("https://assets.babylonjs.com/nme/currentScreenPostProcess.png", this.getScene());
				const l = new pp("FragmentOutput");
				o.connectTo(l, {
					output: "rgba"
				}), this.addOutputNode(s), this.addOutputNode(l), this._mode = Up.PostProcess
			}
			createProceduralTexture(e, t) {
				if (this.mode !== Up.ProceduralTexture) return Qc.Log("Incompatible material mode"), null;
				let i = this.name + this._buildId;
				const s = new c_(i, e, null, t),
					n = new Vf(i + "Procedural", this.getScene());
				n.reservedDataStore = {
					hidden: !0
				};
				const a = new d_,
					r = this._processDefines(n, a);
				xm.RegisterShader(i, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
				let o = this.getScene().getEngine().createEffect({
					vertexElement: i,
					fragmentElement: i
				}, [eu.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, a.toString(), r?.fallbacks, void 0, void 0, void 0, this.shaderLanguage);
				s.nodeMaterialSource = this, s._setEffect(o);
				let l = this._buildId;
				const h = () => {
					l !== this._buildId && (delete xm.ShadersStore[i + "VertexShader"], delete xm.ShadersStore[i + "PixelShader"], i = this.name + this._buildId, a.markAllAsDirty(), l = this._buildId);
					const e = this._processDefines(n, a);
					e && (xm.RegisterShader(i, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage), um.SetImmediate((() => {
						o = this.getScene().getEngine().createEffect({
							vertexElement: i,
							fragmentElement: i
						}, [eu.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, a.toString(), e?.fallbacks, void 0), s._setEffect(o)
					}))), this._checkInternals(o)
				};
				return s.onBeforeGenerationObservable.add((() => {
					h()
				})), this.onBuildObservable.add((() => {
					h()
				})), s
			}
			hasTexture(e) {
				if (super.hasTexture(e)) return !0;
				if (!this._sharedData) return !1;
				for (const t of this._sharedData.textureBlocks)
					if (t.texture === e) return !0;
				return !1
			}
			get prePassTextureOutputs() {
				const e = this.getBlockByPredicate((e => "PrePassOutputBlock" === e.getClassName())),
					t = [4];
				return e ? (this.prePassTextureInputs.length || (e.viewDepth.isConnected && t.push(5), e.viewNormal.isConnected && t.push(6), e.worldPosition.isConnected && t.push(1)), t) : t
			}
			getBlockByPredicate(e) {
				for (const t of this.attachedBlocks)
					if (e(t)) return t;
				return null
			}
			clone(t, i = !1) {
				const s = this.serialize(),
					n = Xc.Clone((() => new e(t, this.getScene(), this.options)), this);
				return n.id = t, n.name = t, n.parseSerializedObject(s), n._buildId = this._buildId, n.build(!1, !i), n
			}
			setToDefault() {
				this.clear(), this.editorData = null;
				const e = new Cp("Position");
				e.setAsAttribute("position");
				const t = new Cp("World");
				t.setAsSystemValue(up.World);
				const i = new rp("WorldPos");
				e.connectTo(i), t.connectTo(i);
				const s = new Cp("ViewProjection");
				s.setAsSystemValue(up.ViewProjection);
				const n = new rp("WorldPos * ViewProjectionTransform");
				i.connectTo(n), s.connectTo(n);
				const a = new hp("VertexOutput");
				n.connectTo(a);
				const r = new Cp("color");
				r.value = new wc(.8, .8, .8, 1);
				const o = new pp("FragmentOutput");
				r.connectTo(o), this.addOutputNode(a), this.addOutputNode(o), this._mode = Up.Material
			}
			isReadyForSubMesh(e, t, i = !1) {
				if (!this._buildWasSuccessful) return !1;
				const s = this.getScene();
				if (this._sharedData.animatedInputs) {
					const e = s.getFrameId();
					if (this._animationFrame !== e) {
						for (const e of this._sharedData.animatedInputs) e.animate(s);
						this._animationFrame = e
					}
				}
				const n = t._drawWrapper;
				if (n.effect && this.isFrozen && n._wasPreviouslyReady && n._wasPreviouslyUsingInstances === i) return !0;
				t.materialDefines || (t.materialDefines = new d_);
				const a = t.materialDefines;
				if (this._isReadyForSubMesh(t)) return !0;
				const r = s.getEngine();
				if (this._prepareDefinesForAttributes(e, a), this._sharedData.blockingBlocks.some((t => !t.isReady(e, this, a, i)))) return !1;
				const o = this._processDefines(e, a, i, t);
				if (o) {
					const e = t.effect,
						i = a.toString();
					let n = r.createEffect({
						vertex: "nodeMaterial" + this._buildId,
						fragment: "nodeMaterial" + this._buildId,
						vertexSource: this._vertexCompilationState.compilationString,
						fragmentSource: this._fragmentCompilationState.compilationString
					}, {
						attributes: this._vertexCompilationState.attributes,
						uniformsNames: o.mergedUniforms,
						uniformBuffersNames: o.uniformBuffers,
						samplers: o.mergedSamplers,
						defines: i,
						fallbacks: o.fallbacks,
						onCompiled: this.onCompiled,
						onError: this.onError,
						multiTarget: a.PREPASS,
						indexParameters: {
							maxSimultaneousLights: this.maxSimultaneousLights,
							maxSimultaneousMorphTargets: a.NUM_MORPH_INFLUENCERS
						},
						shaderLanguage: this.shaderLanguage
					}, r);
					if (n)
						if (this._onEffectCreatedObservable && (m_.effect = n, m_.subMesh = t, this._onEffectCreatedObservable.notifyObservers(m_)), this.allowShaderHotSwapping && e && !n.isReady()) {
							if (n = e, a.markAsUnprocessed(), o.lightDisposed) return a._areLightsDisposed = !0, !1
						} else s.resetCachedMaterial(), t.setEffect(n, a, this._materialContext)
				}
				return !(!t.effect || !t.effect.isReady()) && (a._renderId = s.getRenderId(), n._wasPreviouslyReady = !0, n._wasPreviouslyUsingInstances = i, this._checkScenePerformancePriority(), !0)
			}
			_addFragmentOutputNode(e) {
				if (-1 === this._fragmentOutputNodes.indexOf(e)) return e.target = Xf.Fragment, this._fragmentOutputNodes.push(e), this
			}
			optimize() {
				for (const e of this._optimizers) e.optimize(this._vertexOutputNodes, this._fragmentOutputNodes)
			}
			_removeFragmentOutputNode(e) {
				const t = this._fragmentOutputNodes.indexOf(e);
				if (-1 !== t) return this._fragmentOutputNodes.splice(t, 1), this
			}
			needAlphaBlending() {
				return !this.ignoreAlpha && (this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending)
			}
			static _BlockIsTextureBlock(e) {
				return "TextureBlock" === e.getClassName() || "ReflectionTextureBaseBlock" === e.getClassName() || "ReflectionTextureBlock" === e.getClassName() || "ReflectionBlock" === e.getClassName() || "RefractionBlock" === e.getClassName() || "CurrentScreenBlock" === e.getClassName() || "ParticleTextureBlock" === e.getClassName() || "ImageSourceBlock" === e.getClassName() || "TriPlanarBlock" === e.getClassName() || "BiPlanarBlock" === e.getClassName() || "PrePassTextureBlock" === e.getClassName()
			}
			createAsShadowDepthWrapper(e) {
				this.mode === Up.Material ? e.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene()) : Qc.Log("Incompatible material mode")
			}
			async loadAsync(t, i = "") {
				return e.ParseFromFileAsync("", t, this.getScene(), i, !0, this)
			}
			get imageProcessingConfiguration() {
				return this._imageProcessingConfiguration
			}
			clear() {
				this._vertexOutputNodes.length = 0, this._fragmentOutputNodes.length = 0, this.attachedBlocks.length = 0
			}
			edit(t) {
				return new Promise((i => {
					if (this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor(), void 0 === this.BJSNODEMATERIALEDITOR) {
						const s = t && t.editorURL ? t.editorURL : e.EditorURL;
						dd.LoadBabylonScript(s, (() => {
							this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor(), this._createNodeEditor(t?.nodeEditorConfig), i()
						}))
					} else this._createNodeEditor(t?.nodeEditorConfig), i()
				}))
			}
			_getGlobalNodeMaterialEditor() {
				return "undefined" != typeof NODEEDITOR ? NODEEDITOR : "undefined" != typeof BABYLON && void 0 !== BABYLON.NodeEditor ? BABYLON : void 0
			}
			get isPrePassCapable() {
				return !0
			}
			createEffectForPostProcess(e) {
				this._createEffectForPostProcess(e)
			}
			_attachImageProcessingConfiguration(e) {
				e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add((() => {
					this._markAllSubMeshesAsImageProcessingDirty()
				}))))
			}
			getInputBlocks() {
				const e = [];
				for (const t of this.attachedBlocks) t.isInput && e.push(t);
				return e
			}
			_resetDualBlocks(e, t) {
				e.target === Xf.VertexAndFragment && (e.buildId = t);
				for (const i of e.inputs) {
					const s = i.connectedPoint;
					if (s) {
						const i = s.ownerBlock;
						i !== e && this._resetDualBlocks(i, t)
					}
				}
				if (e.isTeleportOut) {
					const i = e;
					i.entryPoint && this._resetDualBlocks(i.entryPoint, t)
				}
			}
			dispose(e, t, i) {
				if (t)
					for (const e of this.getTextureBlocks().filter((e => e.texture)).map((e => e.texture))) e.dispose();
				for (const e of this.attachedBlocks) e.dispose();
				this.attachedBlocks.length = 0, this._sharedData = null, this._vertexCompilationState = null, this._fragmentCompilationState = null, this.onBuildObservable.clear(), this._imageProcessingObserver && (this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingObserver = null), super.dispose(e, t, i)
			}
			bindForSubMesh(e, t, i) {
				const s = this.getScene(),
					n = i.effect;
				if (!n) return;
				this._activeEffect = n, this.bindOnlyWorldMatrix(e);
				const a = this._mustRebind(s, n, i, t.visibility),
					r = this._sharedData;
				if (a) {
					for (const e of r.bindableBlocks) e.bind(n, this, t, i);
					for (const e of r.forcedBindableBlocks) e.bind(n, this, t, i);
					for (const e of r.inputBlocks) e._transmit(n, s, this)
				} else if (!this.isFrozen)
					for (const e of r.forcedBindableBlocks) e.bind(n, this, t, i);
				this._afterBind(t, this._activeEffect, i)
			}
			_createNodeEditor(e) {
				const t = {
					nodeMaterial: this,
					...e
				};
				this.BJSNODEMATERIALEDITOR.NodeEditor.Show(t)
			}
			bindOnlyWorldMatrix(e) {
				const t = this.getScene();
				if (!this._activeEffect) return;
				const i = this._sharedData.hints;
				i.needWorldViewMatrix && e.multiplyToRef(t.getViewMatrix(), this._cachedWorldViewMatrix), i.needWorldViewProjectionMatrix && e.multiplyToRef(t.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
				for (const t of this._sharedData.inputBlocks) t._transmitWorld(this._activeEffect, e, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix)
			}
			removeBlock(e) {
				const t = this.attachedBlocks.indexOf(e);
				t > -1 && this.attachedBlocks.splice(t, 1), e.isFinalMerger && this.removeOutputNode(e)
			}
			static async ParseFromFileAsync(t, i, s, n = "", a = !1, r, o) {
				const l = r ?? new e(t, s),
					h = await s._loadFileAsync(i),
					c = JSON.parse(h);
				return l.parseSerializedObject(c, n, void 0, o), a || l.build(), l
			}
			get buildId() {
				return this._buildId
			}
			addOutputNode(e) {
				if (null === e.target) throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
				return e.target & Xf.Vertex && this._addVertexOutputNode(e), e.target & Xf.Fragment && this._addFragmentOutputNode(e), this
			}
			get options() {
				return this._options
			}
			_processDefines(e, t, i = !1, s) {
				let n = null;
				if (Rf(this.getScene(), t) && t.markAsMiscDirty(), this._sharedData.blocksWithDefines.forEach((s => {
						s.initializeDefines(e, this, t, i)
					})), this._sharedData.blocksWithDefines.forEach((n => {
						n.prepareDefines(e, this, t, i, s)
					})), t.isDirty) {
					const i = t._areLightsDisposed;
					t.markAsProcessed(), this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString, this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString, this._sharedData.repeatableContentBlocks.forEach((i => {
						i.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, e, t)
					}));
					const s = [];
					this._sharedData.dynamicUniformBlocks.forEach((e => {
						e.updateUniformsAndSamples(this._vertexCompilationState, this, t, s)
					}));
					const a = this._vertexCompilationState.uniforms;
					this._fragmentCompilationState.uniforms.forEach((e => {
						-1 === a.indexOf(e) && a.push(e)
					}));
					const r = this._vertexCompilationState.samplers;
					this._fragmentCompilationState.samplers.forEach((e => {
						-1 === r.indexOf(e) && r.push(e)
					}));
					const o = new Op;
					this._sharedData.blocksWithFallbacks.forEach((t => {
						t.provideFallbacks(e, o)
					})), n = {
						lightDisposed: i,
						uniformBuffers: s,
						mergedUniforms: a,
						mergedSamplers: r,
						fallbacks: o
					}
				}
				return n
			}
			getClassName() {
				return "NodeMaterial"
			}
			setToDefaultParticle() {
				this.clear(), this.editorData = null;
				const e = new Cp("uv");
				e.setAsAttribute("particle_uv");
				const t = new Pp("ParticleTexture");
				e.connectTo(t);
				const i = new Cp("Color");
				i.setAsAttribute("particle_color");
				const s = new zp("Texture * Color");
				t.connectTo(s), i.connectTo(s);
				const n = new kp("ParticleRampGradient");
				s.connectTo(n);
				const a = new jp("ColorSplitter");
				i.connectTo(a);
				const r = new Dp("ParticleBlendMultiply");
				n.connectTo(r), t.connectTo(r, {
					output: "a"
				}), a.connectTo(r, {
					output: "a"
				});
				const o = new pp("FragmentOutput");
				r.connectTo(o), this.addOutputNode(o), this._mode = Up.Particle
			}
			_restoreConnections(e, t, i) {
				for (const s of e.outputs)
					for (const n of t.blocks) {
						const a = i[n.id];
						if (a)
							for (const r of n.inputs)
								if (i[r.targetBlockId] !== e || r.targetConnectionName !== s.name);
								else {
									const e = a.getInputByName(r.inputName);
									if (!e || e.isConnected) continue;
									s.connectTo(e, !0), this._restoreConnections(a, t, i)
								}
					}
			}
			get compiledShaders() {
				return `// Vertex shader\n${this._vertexCompilationState.compilationString}\n\n// Fragment shader\n${this._fragmentCompilationState.compilationString}`
			}
			_processInitializeOnLink(e, t, i, s = !0) {
				(e.target === Xf.VertexAndFragment || t.target === Xf.Fragment && e.target === Xf.Vertex && e._preparationId !== this._buildId) && i.push(e), this._initializeBlock(e, t, i, s)
			}
			get prePassTextureInputs() {
				const e = this.getAllTextureBlocks().filter((e => "PrePassTextureBlock" === e.getClassName())),
					t = [];
				for (const i of e) i.position.isConnected && !t.includes(1) && t.push(1), i.depth.isConnected && !t.includes(5) && t.push(5), i.normal.isConnected && !t.includes(6) && t.push(6);
				return t
			}
			_createEffectForPostProcess(e, t, i = 1, s = 1, n, a, r = 0, o = 5) {
				let l = this.name + this._buildId;
				const h = new d_,
					c = new Vf(l + "PostProcess", this.getScene());
				let u = this._buildId;
				return this._processDefines(c, h), xm.RegisterShader(l, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage), e ? e.updateEffect(h.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {
					maxSimultaneousLights: this.maxSimultaneousLights
				}, void 0, void 0, l, l) : e = new Bp(this.name + "PostProcess", l, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, i, t, s, n, a, h.toString(), r, l, {
					maxSimultaneousLights: this.maxSimultaneousLights
				}, !1, o, this.shaderLanguage), e.nodeMaterialSource = this, e.onApplyObservable.add((t => {
					u !== this._buildId && (delete xm.ShadersStore[l + "VertexShader"], delete xm.ShadersStore[l + "PixelShader"], l = this.name + this._buildId, h.markAllAsDirty(), u = this._buildId);
					this._processDefines(c, h) && (xm.RegisterShader(l, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString), um.SetImmediate((() => e.updateEffect(h.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {
						maxSimultaneousLights: this.maxSimultaneousLights
					}, void 0, void 0, l, l)))), this._checkInternals(t)
				})), e
			}
			get shaderLanguage() {
				return this._options.shaderLanguage
			}
			set imageProcessingConfiguration(e) {
				this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty()
			}
			set options(e) {
				this._options = e
			}
			_removeVertexOutputNode(e) {
				const t = this._vertexOutputNodes.indexOf(e);
				if (-1 !== t) return this._vertexOutputNodes.splice(t, 1), this
			}
			createPostProcess(e, t = 1, i = 1, s, n, a = 0, r = 5) {
				return this.mode !== Up.PostProcess ? (Qc.Log("Incompatible material mode"), null) : this._createEffectForPostProcess(null, e, t, i, s, n, a, r)
			}
			loadFromSerialization(e, t = "", i = !1) {
				this.parseSerializedObject(e, t, i)
			}
			setPrePassRenderer(e) {
				const t = this.prePassTextureInputs.concat(this.prePassTextureOutputs);
				if (e && t.length > 1) {
					let i = e.getEffectConfiguration("nodeMaterial");
					i || (i = e.addEffectConfiguration({
						enabled: !0,
						needsImageProcessing: !1,
						name: "nodeMaterial",
						texturesRequired: []
					}));
					for (const e of t) i.texturesRequired.includes(e) || i.texturesRequired.push(e);
					i.enabled = !0
				}
				return t.length > 1
			}
			generateCode() {
				let e = [];
				const t = [],
					i = ["const", "var", "let"];
				for (const e of this._vertexOutputNodes) this._gatherBlocks(e, t);
				const s = [];
				for (const e of this._fragmentOutputNodes) this._gatherBlocks(e, s);
				let n = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name||"node material"}");\n`;
				n += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${Up[this.mode]};\n`;
				for (const s of t) s.isInput && -1 === e.indexOf(s) && (n += s._dumpCode(i, e));
				for (const t of s) t.isInput && -1 === e.indexOf(t) && (n += t._dumpCode(i, e));
				e = [], n += "\n// Connections\n";
				for (const t of this._vertexOutputNodes) n += t._dumpCodeForOutputConnections(e);
				for (const t of this._fragmentOutputNodes) n += t._dumpCodeForOutputConnections(e);
				n += "\n// Output nodes\n";
				for (const e of this._vertexOutputNodes) n += `nodeMaterial.addOutputNode(${e._codeVariableName});\n`;
				for (const e of this._fragmentOutputNodes) n += `nodeMaterial.addOutputNode(${e._codeVariableName});\n`;
				return n += "nodeMaterial.build();\n", n
			}
			serialize(e) {
				const t = e ? {} : Xc.Serialize(this);
				t.editorData = JSON.parse(JSON.stringify(this.editorData));
				let i = [];
				if (e) i = e;
				else {
					t.customType = "BABYLON.NodeMaterial", t.outputNodes = [];
					for (const e of this._vertexOutputNodes) this._gatherBlocks(e, i), t.outputNodes.push(e.ik);
					for (const e of this._fragmentOutputNodes) this._gatherBlocks(e, i), -1 === t.outputNodes.indexOf(e.ik) && t.outputNodes.push(e.ik)
				}
				t.blocks = [];
				for (const e of i) t.blocks.push(e.serialize());
				if (!e)
					for (const e of this.attachedBlocks) - 1 === i.indexOf(e) && t.blocks.push(e.serialize());
				return t.ik = this.ik, t
			}
			getInputBlockByPredicate(e) {
				for (const t of this.attachedBlocks)
					if (t.isInput && e(t)) return t;
				return null
			}
			parseSerializedObject(e, t = "", i = !1, s) {
				i || this.clear();
				const n = {};
				for (const i of e.blocks) {
					const e = uc(i.customType);
					if (e) {
						const a = new e;
						a._deserialize(i, this.getScene(), t, s), n[i.id] = a, this.attachedBlocks.push(a)
					}
				}
				for (const e of this.attachedBlocks)
					if (e.isTeleportOut) {
						const t = e,
							i = t._tempEntryPointUniqueId;
						if (i) {
							n[i].attachToEndpoint(t)
						}
					} for (let t = 0; t < e.blocks.length; t++) {
					const s = n[e.blocks[t].id];
					s && (s.inputs.length && !i || this._restoreConnections(s, e, n))
				}
				if (e.outputNodes)
					for (const t of e.outputNodes) this.addOutputNode(n[t]);
				if (e.locations || e.editorData && e.editorData.locations) {
					const t = e.locations || e.editorData.locations;
					for (const e of t) n[e.blockId] && (e.blockId = n[e.blockId].ik);
					i && this.editorData && this.editorData.locations && t.concat(this.editorData.locations), e.locations ? this.editorData = {
						locations: t
					} : (this.editorData = e.editorData, this.editorData.locations = t);
					const s = [];
					for (const e in n) s[e] = n[e].ik;
					this.editorData.map = s
				}
				this.comment = e.comment, void 0 !== e.forceAlphaBlending && (this.forceAlphaBlending = e.forceAlphaBlending), void 0 !== e.alphaMode && (this.alphaMode = e.alphaMode), i || (this._mode = e.mode ?? Up.Material)
			}
			needAlphaTesting() {
				return this._sharedData && this._sharedData.hints.needAlphaTesting
			}
			_initializeBlock(e, t, i, s = !0) {
				if (e.initialize(t), s && e.autoConfigure(this), e._preparationId = this._buildId, -1 === this.attachedBlocks.indexOf(e)) {
					if (e.isUnique) {
						const t = e.getClassName();
						for (const e of this.attachedBlocks)
							if (e.getClassName() === t) throw `Cannot have multiple blocks of type ${t} in the same NodeMaterial`
					}
					this.attachedBlocks.push(e)
				}
				for (const n of e.inputs) {
					n.associatedVariableName = "";
					const a = n.connectedPoint;
					if (a) {
						const n = a.ownerBlock;
						n !== e && this._processInitializeOnLink(n, t, i, s)
					}
				}
				if (e.isTeleportOut) {
					const n = e;
					n.entryPoint && this._processInitializeOnLink(n.entryPoint, t, i, s)
				}
				for (const t of e.outputs) t.associatedVariableName = ""
			}
			static CreateDefault(t, i) {
				const s = new e(t, i);
				return s.setToDefault(), s.build(), s
			}
			build(e = !1, t = !0, i = !1) {
				if (this._buildIsInProgress) return void Qc.Warn("Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.");
				this._buildIsInProgress = !0, this._vertexCompilationState || i || (i = !0), this._buildWasSuccessful = !1;
				const s = this.getScene().getEngine(),
					n = this._mode === Up.Particle;
				if (0 === this._vertexOutputNodes.length && !n) throw "You must define at least one vertexOutputNode";
				if (0 === this._fragmentOutputNodes.length) throw "You must define at least one fragmentOutputNode";
				this._vertexCompilationState = new ep, this._vertexCompilationState.supportUniformBuffers = s.supportsUniformBuffers, this._vertexCompilationState.target = Xf.Vertex, this._fragmentCompilationState = new ep, this._fragmentCompilationState.supportUniformBuffers = s.supportsUniformBuffers, this._fragmentCompilationState.target = Xf.Fragment, this._sharedData = new tp, this._sharedData.nodeMaterial = this, this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes, this._vertexCompilationState.sharedData = this._sharedData, this._fragmentCompilationState.sharedData = this._sharedData, this._sharedData.buildId = this._buildId, this._sharedData.emitComments = this._options.emitComments, this._sharedData.verbose = e, this._sharedData.scene = this.getScene(), this._sharedData.allowEmptyVertexProgram = n;
				const a = [],
					r = [];
				for (const e of this._vertexOutputNodes) a.push(e), this._initializeBlock(e, this._vertexCompilationState, r, i);
				for (const e of this._fragmentOutputNodes) r.push(e), this._initializeBlock(e, this._fragmentCompilationState, a, i);
				let o = 0;
				for (const i of this.attachedBlocks) i.codeIsReady || (o++, i.onCodeIsReadyObservable.addOnce((() => {
					o--, 0 === o && this._finishBuildProcess(e, t, a, r)
				})));
				0 === o && this._finishBuildProcess(e, t, a, r)
			}
			_finishBuildProcess(t = !1, i = !0, s, n) {
				this.optimize();
				for (const e of s) e.build(this._vertexCompilationState, s);
				this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0), this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration, this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration, this._fragmentCompilationState._vertexState = this._vertexCompilationState;
				for (const e of n) this._resetDualBlocks(e, this._buildId - 1);
				for (const e of n) e.build(this._fragmentCompilationState, n);
				this._vertexCompilationState.finalize(this._vertexCompilationState), this._fragmentCompilationState.finalize(this._fragmentCompilationState), i && (this._buildId = e._BuildIdGenerator++), this._sharedData.emitErrors(), t && (Qc.Log("Vertex shader:"), Qc.Log(this._vertexCompilationState.compilationString), Qc.Log("Fragment shader:"), Qc.Log(this._fragmentCompilationState.compilationString)), this._buildIsInProgress = !1, this._buildWasSuccessful = !0, this.onBuildObservable.notifyObservers(this);
				const a = this.getScene().meshes;
				for (const e of a)
					if (e.subMeshes)
						for (const t of e.subMeshes) {
							if (t.getMaterial() !== this) continue;
							if (!t.materialDefines) continue;
							const e = t.materialDefines;
							e.markAllAsDirty(), e.reset()
						}
				this.prePassTextureInputs.length && this.getScene().enablePrePassRenderer();
				const r = this.getScene().prePassRenderer;
				r && r.markAsDirty()
			}
			_gatherBlocks(e, t) {
				if (-1 === t.indexOf(e)) {
					t.push(e);
					for (const i of e.inputs) {
						const s = i.connectedPoint;
						if (s) {
							const i = s.ownerBlock;
							i !== e && this._gatherBlocks(i, t)
						}
					}
					if (e.isTeleportOut) {
						const i = e;
						i.entryPoint && this._gatherBlocks(i.entryPoint, t)
					}
				}
			}
			set mode(e) {
				this._mode = e
			}
			_checkInternals(e) {
				if (this._sharedData.animatedInputs) {
					const e = this.getScene(),
						t = e.getFrameId();
					if (this._animationFrame !== t) {
						for (const t of this._sharedData.animatedInputs) t.animate(e);
						this._animationFrame = t
					}
				}
				for (const t of this._sharedData.bindableBlocks) t.bind(e, this);
				for (const t of this._sharedData.inputBlocks) t._transmit(e, this.getScene(), this)
			}
			whenTexturesReadyAsync() {
				const e = [];
				return this.getActiveTextures().forEach((t => {
					const i = t.getInternalTexture();
					i && !i.isReady && e.push(new Promise(((e, t) => {
						i.onLoadedObservable.addOnce((() => {
							e()
						})), i.onErrorObservable.addOnce((e => {
							t(e)
						}))
					})))
				})), Promise.all(e)
			}
			getTextureBlocks() {
				return this._sharedData ? this._sharedData.textureBlocks : []
			}
			static Parse(t, i, s = "", n = 0) {
				const a = Xc.Parse((() => new e(t.name, i, {
					shaderLanguage: n
				})), t, i, s);
				return a.parseSerializedObject(t, s), a.build(), a
			}
			get mode() {
				return this._mode
			}
			registerOptimizer(e) {
				if (!(this._optimizers.indexOf(e) > -1)) return this._optimizers.push(e), this
			}
			set buildId(e) {
				this._buildId = e
			}
			setToDefaultProceduralTexture() {
				this.clear(), this.editorData = null;
				const e = new Cp("Position");
				e.setAsAttribute("position2d");
				const t = new Cp("Constant1");
				t.isConstant = !0, t.value = 1;
				const i = new Gp("Position3D");
				e.connectTo(i), t.connectTo(i, {
					input: "w"
				});
				const s = new hp("VertexOutput");
				i.connectTo(s);
				const n = new Cp("Time");
				n.value = 0, n.min = 0, n.max = 0, n.isBoolean = !1, n.matrixMode = 0, n.animationType = _p.Time, n.isConstant = !1;
				const a = new Cp("Color3");
				a.value = new Tc(1, 1, 1), a.isConstant = !1;
				const r = new pp("FragmentOutput"),
					o = new Gp("VectorMerger");
				o.visibleInInspector = !1;
				const l = new u_("Cos");
				l.operation = l_.Cos, e.connectTo(o), n.output.connectTo(l.input), l.output.connectTo(o.z), o.xyzOut.connectTo(r.rgb), this.addOutputNode(s), this.addOutputNode(r), this._mode = Up.ProceduralTexture
			}
			_prepareDefinesForAttributes(e, t) {
				const i = t.NORMAL,
					s = t.TANGENT,
					n = t.VERTEXCOLOR_NME;
				t.NORMAL = e.isVerticesDataPresent(eu.NormalKind), t.TANGENT = e.isVerticesDataPresent(eu.TangentKind);
				const a = e.useVertexColors && e.isVerticesDataPresent(eu.ColorKind);
				t.VERTEXCOLOR_NME = a;
				let r = !1;
				for (let i = 1; i <= 6; ++i) {
					const s = t["UV" + i];
					t["UV" + i] = e.isVerticesDataPresent(`uv${1===i?"":i}`), r = r || t["UV" + i] !== s
				}
				const o = this.needAlphaBlendingForMesh(e) && this.getScene().useOrderIndependentTransparency;
				wf(this.getScene(), t, !o), (i !== t.NORMAL || s !== t.TANGENT || n !== t.VERTEXCOLOR_NME || r) && t.markAsAttributesDirty()
			}
			static ParseFromSnippetAsync(t, i = Dc.LastCreatedScene, s = "", n, a = !1, r = !1, o) {
				return "_BLANK" === t ? Promise.resolve(e.CreateDefault("blank", i)) : new Promise(((l, h) => {
					const c = new ku;
					c.addEventListener("readystatechange", (() => {
						if (4 == c.readyState)
							if (200 == c.status) {
								const u = JSON.parse(JSON.parse(c.responseText).jsonPayload),
									m = JSON.parse(u.nodeMaterial);
								n || ((n = Xc.Parse((() => new e(t, i)), m, i, s)).ik = i.getUniqueId()), n.parseSerializedObject(m, void 0, void 0, o), n.snippetId = t, n.sideOrientation = null;
								try {
									a || n.build()
								} catch (e) {
									h(e)
								}
								r ? n.whenTexturesReadyAsync().then((() => {
									l(n)
								})).catch((e => {
									h(e)
								})) : l(n)
							} else h("Unable to load the snippet " + t)
					})), c.open("GET", this.SnippetUrl + "/" + t.replace(/#/g, "/")), c.send()
				}))
			}
			createEffectForParticles(e, t, i) {
				this.mode === Up.Particle ? (this._createEffectForParticles(e, Yp.BLENDMODE_ONEONE, t, i), this._createEffectForParticles(e, Yp.BLENDMODE_MULTIPLY, t, i)) : Qc.Log("Incompatible material mode")
			}
			set shaderLanguage(e) {
				this._options.shaderLanguage = e
			}
			getAllTextureBlocks() {
				const t = [];
				for (const i of this.attachedBlocks) e._BlockIsTextureBlock(i) && t.push(i);
				return t
			}
			constructor(t, i, s = {}) {
				if (super(t, i || Dc.LastCreatedScene), this._buildId = e._BuildIdGenerator++, this._buildWasSuccessful = !1, this._cachedWorldViewMatrix = new Hc, this._cachedWorldViewProjectionMatrix = new Hc, this._optimizers = new Array, this._animationFrame = -1, this._buildIsInProgress = !1, this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor(), this.editorData = null, this.ignoreAlpha = !1, this.maxSimultaneousLights = 4, this.onBuildObservable = new kc, this._vertexOutputNodes = new Array, this._fragmentOutputNodes = new Array, this.attachedBlocks = [], this._mode = Up.Material, this.forceAlphaBlending = !1, s && 1 === s.shaderLanguage && !this.getScene().getEngine().isWebGPU) throw new Error("WebGPU shader language is only supported with WebGPU engine");
				this._options = {
					emitComments: !1,
					shaderLanguage: e.DefaultShaderLanguage,
					...s
				}, this._attachImageProcessingConfiguration(null)
			}
		};
	f_._BuildIdGenerator = 0, f_.EditorURL = `${dd._DefaultCdnUrl}/v${Dm.Version}/nodeEditor/babylon.nodeEditor.js`, f_.SnippetUrl = "https://snippet.babylonjs.com", f_.IgnoreTexturesAtLoadTime = !1, f_.DefaultShaderLanguage = 0, Gh([Xh()], f_.prototype, "ignoreAlpha", void 0), Gh([Xh()], f_.prototype, "maxSimultaneousLights", void 0), Gh([Xh("mode")], f_.prototype, "_mode", void 0), Gh([Xh("comment")], f_.prototype, "comment", void 0), Gh([Xh()], f_.prototype, "forceAlphaBlending", void 0), cc("BABYLON.NodeMaterial", f_);
	var p_ = class extends ap {
		get output() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = e.sharedData.scene.getEngine();
			e.sharedData.blocksWithDefines.push(this);
			const i = this._outputs[0],
				s = this._outputs[1],
				n = this.world0,
				a = this.world1,
				r = this.world2,
				o = this.world3;
			let l = "mat4",
				h = "gl_InstanceID",
				c = "float";
			return 1 === e.shaderLanguage && (l = "mat4x4f", h = "vertexInputs.instanceIndex", c = "f32"), e.compilationString += "#ifdef INSTANCES\n", e.compilationString += e._declareOutput(i) + ` = ${l}(${n.associatedVariableName}, ${a.associatedVariableName}, ${r.associatedVariableName}, ${o.associatedVariableName});\n`, e.compilationString += "#ifdef THIN_INSTANCES\n", e.compilationString += `${i.associatedVariableName} = ${this.world.associatedVariableName} * ${i.associatedVariableName};\n`, e.compilationString += "#endif\n", t._caps.canUseGLInstanceID ? e.compilationString += e._declareOutput(s) + ` = ${c}(${h});\n` : e.compilationString += e._declareOutput(s) + " = 0.0;\n", e.compilationString += "#else\n", e.compilationString += e._declareOutput(i) + ` = ${this.world.associatedVariableName};\n`, e.compilationString += e._declareOutput(s) + " = 0.0;\n", e.compilationString += "#endif\n", this
		}
		get world2() {
			return this._inputs[2]
		}
		constructor(e) {
			super(e, Xf.Vertex), this.registerInput("world0", Wf.Vector4), this.registerInput("world1", Wf.Vector4), this.registerInput("world2", Wf.Vector4), this.registerInput("world3", Wf.Vector4), this.registerInput("world", Wf.Matrix, !0), this.registerOutput("output", Wf.Matrix), this.registerOutput("instanceID", Wf.Float)
		}
		get world() {
			return this._inputs[4]
		}
		getClassName() {
			return "InstancesBlock"
		}
		get instanceID() {
			return this._outputs[1]
		}
		prepareDefines(e, t, i, s = !1, n) {
			let a = !1;
			i.INSTANCES !== s && (i.setValue("INSTANCES", s), a = !0), n && i.THIN_INSTANCES !== !!n?.getRenderingMesh().hasThinInstances && (i.setValue("THIN_INSTANCES", !!n?.getRenderingMesh().hasThinInstances), a = !0), a && i.markAsUnprocessed()
		}
		get world0() {
			return this._inputs[0]
		}
		autoConfigure(e, t = () => !0) {
			if (!this.world0.connectedPoint) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "world0" === e.name && t(e)));
				i || (i = new Cp("world0"), i.setAsAttribute("world0")), i.output.connectTo(this.world0)
			}
			if (!this.world1.connectedPoint) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "world1" === e.name && t(e)));
				i || (i = new Cp("world1"), i.setAsAttribute("world1")), i.output.connectTo(this.world1)
			}
			if (!this.world2.connectedPoint) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "world2" === e.name && t(e)));
				i || (i = new Cp("world2"), i.setAsAttribute("world2")), i.output.connectTo(this.world2)
			}
			if (!this.world3.connectedPoint) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "world3" === e.name && t(e)));
				i || (i = new Cp("world3"), i.setAsAttribute("world3")), i.output.connectTo(this.world3)
			}
			if (!this.world.connectedPoint) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "world" === e.name && t(e)));
				i || (i = new Cp("world"), i.setAsSystemValue(up.World)), i.output.connectTo(this.world)
			}
			this.world.define = "!INSTANCES || THIN_INSTANCES"
		}
		get world1() {
			return this._inputs[1]
		}
		get world3() {
			return this._inputs[3]
		}
	};
	cc("BABYLON.InstancesBlock", p_);
	var __ = class extends Wp {
		constructor(e) {
			super(e)
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = ${this.left.associatedVariableName} + ${this.right.associatedVariableName};\n`, this
		}
		getClassName() {
			return "AddBlock"
		}
	};
	cc("BABYLON.AddBlock", __);
	cc("BABYLON.DivideBlock", class extends Wp {
		constructor(e) {
			super(e)
		}
		getClassName() {
			return "DivideBlock"
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = ${this.left.associatedVariableName} / ${this.right.associatedVariableName};\n`, this
		}
	});
	cc("BABYLON.SubtractBlock", class extends Wp {
		constructor(e) {
			super(e)
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = ${this.left.associatedVariableName} - ${this.right.associatedVariableName};\n`, this
		}
		getClassName() {
			return "SubtractBlock"
		}
	});
	var g_ = class extends ap {
		serialize() {
			const e = super.serialize();
			return e.minimum = this.minimum, e.maximum = this.maximum, e
		}
		getClassName() {
			return "ClampBlock"
		}
		constructor(e) {
			super(e, Xf.Neutral), this.minimum = 0, this.maximum = 1, this.registerInput("value", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0]
		}
		_dumpPropertiesCode() {
			let e = super._dumpPropertiesCode() + `${this._codeVariableName}.minimum = ${this.minimum};\n`;
			return e += `${this._codeVariableName}.maximum = ${this.maximum};\n`, e
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.minimum = e.minimum, this.maximum = e.maximum
		}
		get output() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0],
				i = 1 === e.shaderLanguage ? e._getShaderType(this.value.type) : "";
			return e.compilationString += e._declareOutput(t) + ` = clamp(${this.value.associatedVariableName}, ${i}(${this._writeFloat(this.minimum)}), ${i}(${this._writeFloat(this.maximum)}));\n`, this
		}
		get value() {
			return this._inputs[0]
		}
	};
	Gh([cp("Minimum", 1)], g_.prototype, "minimum", void 0), Gh([cp("Maximum", 1)], g_.prototype, "maximum", void 0), cc("BABYLON.ClampBlock", g_);
	cc("BABYLON.VectorSplitterBlock", class extends ap {
		_outputRename(e) {
			switch (e) {
				case "xy":
					return "xyOut";
				case "xyz":
					return "xyzOut";
				default:
					return e
			}
		}
		get xyOut() {
			return this._outputs[1]
		}
		get xyzOut() {
			return this._outputs[0]
		}
		get xyIn() {
			return this._inputs[2]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("xyzw", Wf.Vector4, !0), this.registerInput("xyz ", Wf.Vector3, !0), this.registerInput("xy ", Wf.Vector2, !0), this.registerOutput("xyz", Wf.Vector3), this.registerOutput("xy", Wf.Vector2), this.registerOutput("zw", Wf.Vector2), this.registerOutput("x", Wf.Float), this.registerOutput("y", Wf.Float), this.registerOutput("z", Wf.Float), this.registerOutput("w", Wf.Float), this.inputsAreExclusive = !0
		}
		_inputRename(e) {
			switch (e) {
				case "xy ":
					return "xyIn";
				case "xyz ":
					return "xyzIn";
				default:
					return e
			}
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this.xyzw.isConnected ? this.xyzw : this.xyzIn.isConnected ? this.xyzIn : this.xyIn,
				i = this._outputs[0],
				s = this._outputs[1],
				n = this._outputs[2],
				a = this._outputs[3],
				r = this._outputs[4],
				o = this._outputs[5],
				l = this._outputs[6],
				h = e._getShaderType(Wf.Vector3);
			return i.hasEndpoints && (t === this.xyIn ? e.compilationString += e._declareOutput(i) + ` = ${h}(${t.associatedVariableName}, 0.0);\n` : e.compilationString += e._declareOutput(i) + ` = ${t.associatedVariableName}.xyz;\n`), n.hasEndpoints && this.xyzw.isConnected && (e.compilationString += e._declareOutput(n) + ` = ${this.xyzw.associatedVariableName}.zw;\n`), s.hasEndpoints && (e.compilationString += e._declareOutput(s) + ` = ${t.associatedVariableName}.xy;\n`), a.hasEndpoints && (e.compilationString += e._declareOutput(a) + ` = ${t.associatedVariableName}.x;\n`), r.hasEndpoints && (e.compilationString += e._declareOutput(r) + ` = ${t.associatedVariableName}.y;\n`), o.hasEndpoints && (e.compilationString += e._declareOutput(o) + ` = ${t.associatedVariableName}.z;\n`), l.hasEndpoints && (e.compilationString += e._declareOutput(l) + ` = ${t.associatedVariableName}.w;\n`), this
		}
		get xyzIn() {
			return this._inputs[1]
		}
		get zw() {
			return this._outputs[2]
		}
		get w() {
			return this._outputs[6]
		}
		get y() {
			return this._outputs[4]
		}
		get xyzw() {
			return this._inputs[0]
		}
		getClassName() {
			return "VectorSplitterBlock"
		}
		get x() {
			return this._outputs[3]
		}
		get z() {
			return this._outputs[5]
		}
	});
	var v_ = class extends ap {
		provideFallbacks(e, t) {
			e && e.useBones && e.computeBonesUsingShaders && e.skeleton && t.addCPUSkinningFallback(0, e)
		}
		get matricesWeights() {
			return this._inputs[1]
		}
		get matricesWeightsExtra() {
			return this._inputs[3]
		}
		async _initShaderSourceAsync(e) {
			this._codeIsReady = !1, 1 === e ? await Promise.all([Promise.resolve().then((() => (R(), M))), Promise.resolve().then((() => (D(), N)))]) : await Promise.all([Promise.resolve().then((() => (G(), O))), Promise.resolve().then((() => (z(), H)))]), this._codeIsReady = !0, this.onCodeIsReadyObservable.notifyObservers(this)
		}
		constructor(e) {
			super(e, Xf.Vertex), this.registerInput("matricesIndices", Wf.Vector4), this.registerInput("matricesWeights", Wf.Vector4), this.registerInput("matricesIndicesExtra", Wf.Vector4, !0), this.registerInput("matricesWeightsExtra", Wf.Vector4, !0), this.registerInput("world", Wf.Matrix), this.registerOutput("output", Wf.Matrix)
		}
		bind(e, t, i) {
			df(i, e)
		}
		get world() {
			return this._inputs[4]
		}
		_buildBlock(e) {
			super._buildBlock(e), e.sharedData.blocksWithFallbacks.push(this), e.sharedData.forcedBindableBlocks.push(this), e.sharedData.blocksWithDefines.push(this), e.uniforms.push("boneTextureWidth"), e.uniforms.push("mBones"), e.samplers.push("boneSampler");
			const t = `//${this.name}`;
			e._emitFunctionFromInclude("bonesDeclaration", t, {
				removeAttributes: !0,
				removeUniforms: !1,
				removeVaryings: !0,
				removeIfDef: !1
			});
			const i = e._getFreeVariableName("influence");
			e.compilationString += e._emitCodeFromInclude("bonesVertex", t, {
				replaceStrings: [{
					search: /finalWorld=finalWorld\*influence;/,
					replace: ""
				}, {
					search: /influence/gm,
					replace: i
				}]
			});
			const s = this._outputs[0],
				n = this.world;
			return e.compilationString += "#if NUM_BONE_INFLUENCERS>0\n", e.compilationString += e._declareOutput(s) + ` = ${n.associatedVariableName} * ${i};\n`, e.compilationString += "#else\n", e.compilationString += e._declareOutput(s) + ` = ${n.associatedVariableName};\n`, e.compilationString += "#endif\n", this
		}
		getClassName() {
			return "BonesBlock"
		}
		initialize(e) {
			e._excludeVariableName("boneSampler"), e._excludeVariableName("boneTextureWidth"), e._excludeVariableName("mBones"), e._excludeVariableName("BonesPerMesh"), this._initShaderSourceAsync(e.shaderLanguage)
		}
		autoConfigure(e, t = () => !0) {
			if (!this.matricesIndices.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "matricesIndices" === e.name && t(e)));
				i || (i = new Cp("matricesIndices"), i.setAsAttribute("matricesIndices")), i.output.connectTo(this.matricesIndices)
			}
			if (!this.matricesWeights.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.isAttribute && "matricesWeights" === e.name && t(e)));
				i || (i = new Cp("matricesWeights"), i.setAsAttribute("matricesWeights")), i.output.connectTo(this.matricesWeights)
			}
			if (!this.world.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.systemValue === up.World && t(e)));
				i || (i = new Cp("world"), i.setAsSystemValue(up.World)), i.output.connectTo(this.world)
			}
		}
		prepareDefines(e, t, i) {
			i._areAttributesDirty && xf(e, i)
		}
		get matricesIndices() {
			return this._inputs[0]
		}
		get matricesIndicesExtra() {
			return this._inputs[2]
		}
		get output() {
			return this._outputs[0]
		}
	};
	cc("BABYLON.BonesBlock", v_);
	var y_ = class extends ap {
		bind(e, t, i) {
			if (!i) return;
			const s = i.getScene();
			this.light ? ff(this.light, this._lightId, s, e, !0) : pf(s, i, e, !0, t.maxSimultaneousLights)
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = 1 === e.shaderLanguage,
				i = t ? "f" : "",
				s = `//${this.name}`;
			if (e.target !== Xf.Fragment) return void this._injectVertexCode(e);
			this.generateOnlyFragmentCode && e.sharedData.dynamicUniformBlocks.push(this);
			const n = 1 === e.shaderLanguage ? "fragmentInputs." : "";
			e.sharedData.forcedBindableBlocks.push(this), e.sharedData.blocksWithDefines.push(this);
			const a = this.worldPosition;
			let r = a.associatedVariableName;
			this.generateOnlyFragmentCode ? (r = e._getFreeVariableName("globalWorldPos"), e._emitFunction("light_globalworldpos", `${e._declareLocalVar(r,Wf.Vector3)};\n`, s), e.compilationString += `${r} = ${a.associatedVariableName}.xyz;\n`, e.compilationString += e._emitCodeFromInclude("shadowsVertex", s, {
				repeatKey: "maxSimultaneousLights",
				substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${a.associatedVariableName}` : void 0
			})) : r = n + "v_" + r + ".xyz", e._emitFunctionFromInclude("helperFunctions", s), e._emitFunctionFromInclude("lightsFragmentFunctions", s, {
				replaceStrings: [{
					search: /vPositionW/g,
					replace: r
				}]
			}), e._emitFunctionFromInclude("shadowsFragmentFunctions", s, {
				replaceStrings: [{
					search: /vPositionW/g,
					replace: r
				}]
			}), this._injectUBODeclaration(e), 0 === this._lightId && (e._registerTempVariable("viewDirectionW") && (e.compilationString += `${e._declareLocalVar("viewDirectionW",Wf.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${r});\n`), e.compilationString += t ? "var info: lightingInfo;\n" : "lightingInfo info;\n", e.compilationString += `${e._declareLocalVar("shadow",Wf.Float)} = 1.;\n`, e.compilationString += `${e._declareLocalVar("aggShadow",Wf.Float)} = 0.;\n`, e.compilationString += `${e._declareLocalVar("numLights",Wf.Float)} = 0.;\n`, e.compilationString += `${e._declareLocalVar("glossiness",Wf.Float)} = ${this.glossiness.isConnected?this.glossiness.associatedVariableName:"1.0"} * ${this.glossPower.isConnected?this.glossPower.associatedVariableName:"1024.0"};\n`, e.compilationString += `${e._declareLocalVar("diffuseBase",Wf.Vector3)} = vec3${i}(0., 0., 0.);\n`, e.compilationString += `${e._declareLocalVar("specularBase",Wf.Vector3)}  = vec3${i}(0., 0., 0.);\n`, e.compilationString += `${e._declareLocalVar("normalW",Wf.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;\n`), this.light ? e.compilationString += e._emitCodeFromInclude("lightFragment", s, {
				replaceStrings: [{
					search: /{X}/g,
					replace: this._lightId.toString()
				}, {
					search: /vPositionW/g,
					replace: r + ".xyz"
				}]
			}) : e.compilationString += e._emitCodeFromInclude("lightFragment", s, {
				repeatKey: "maxSimultaneousLights",
				substitutionVars: `vPositionW,${r}.xyz`
			}), 0 === this._lightId && (e.compilationString += "aggShadow = aggShadow / numLights;\n");
			const o = this.diffuseOutput,
				l = this.specularOutput;
			return e.compilationString += e._declareOutput(o) + ` = diffuseBase${this.diffuseColor.isConnected?" * "+this.diffuseColor.associatedVariableName:""};\n`, l.hasEndpoints && (e.compilationString += e._declareOutput(l) + ` = specularBase${this.specularColor.isConnected?" * "+this.specularColor.associatedVariableName:""};\n`), this.shadow.hasEndpoints && (e.compilationString += e._declareOutput(this.shadow) + " = aggShadow;\n"), this
		}
		get specularOutput() {
			return this._outputs[1]
		}
		_injectVertexCode(e) {
			const t = this.worldPosition,
				i = `//${this.name}`;
			this.light ? (this._lightId = (void 0 !== e.counters.lightCounter ? e.counters.lightCounter : -1) + 1, e.counters.lightCounter = this._lightId, e._emitFunctionFromInclude(e.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", i, {
				replaceStrings: [{
					search: /{X}/g,
					replace: this._lightId.toString()
				}]
			}, this._lightId.toString())) : (e._emitFunctionFromInclude(e.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", i, {
				repeatKey: "maxSimultaneousLights"
			}), this._lightId = 0, e.sharedData.dynamicUniformBlocks.push(this));
			const s = "v_" + t.associatedVariableName;
			e._emitVaryingFromString(s, Wf.Vector4) && (e.compilationString += (1 === e.shaderLanguage ? "vertexOutputs." : "") + `${s} = ${t.associatedVariableName};\n`), this.light ? e.compilationString += e._emitCodeFromInclude("shadowsVertex", i, {
				replaceStrings: [{
					search: /{X}/g,
					replace: this._lightId.toString()
				}, {
					search: /worldPos/g,
					replace: t.associatedVariableName
				}]
			}) : (e.compilationString += `${e._declareLocalVar("worldPos",Wf.Vector4)} = ${t.associatedVariableName};\n`, this.view.isConnected && (e.compilationString += `${e._declareLocalVar("view",Wf.Matrix)} = ${this.view.associatedVariableName};\n`), e.compilationString += e._emitCodeFromInclude("shadowsVertex", i, {
				repeatKey: "maxSimultaneousLights"
			}))
		}
		get view() {
			return this._inputs[7]
		}
		serialize() {
			const e = super.serialize();
			return e.generateOnlyFragmentCode = this.generateOnlyFragmentCode, this.light && (e.lightId = this.light.id), e
		}
		get worldNormal() {
			return this._inputs[1]
		}
		get shadow() {
			return this._outputs[2]
		}
		get diffuseColor() {
			return this._inputs[5]
		}
		getClassName() {
			return "LightBlock"
		}
		get diffuseOutput() {
			return this._outputs[0]
		}
		autoConfigure(e, t = () => !0) {
			if (!this.cameraPosition.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.systemValue === up.CameraPosition && t(e)));
				i || (i = new Cp("cameraPosition"), i.setAsSystemValue(up.CameraPosition)), i.output.connectTo(this.cameraPosition)
			}
		}
		get glossiness() {
			return this._inputs[3]
		}
		constructor(e) {
			super(e, Xf.VertexAndFragment), this._lightId = 0, this.generateOnlyFragmentCode = !1, this._isUnique = !0, this.registerInput("worldPosition", Wf.Vector4, !1, Xf.Vertex), this.registerInput("worldNormal", Wf.Vector4, !1, Xf.Fragment), this.registerInput("cameraPosition", Wf.Vector3, !1, Xf.Fragment), this.registerInput("glossiness", Wf.Float, !0, Xf.Fragment), this.registerInput("glossPower", Wf.Float, !0, Xf.Fragment), this.registerInput("diffuseColor", Wf.Color3, !0, Xf.Fragment), this.registerInput("specularColor", Wf.Color3, !0, Xf.Fragment), this.registerInput("view", Wf.Matrix, !0), this.registerOutput("diffuseOutput", Wf.Color3, Xf.Fragment), this.registerOutput("specularOutput", Wf.Color3, Xf.Fragment), this.registerOutput("shadow", Wf.Float, Xf.Fragment)
		}
		initialize(e) {
			this._initShaderSourceAsync(e.shaderLanguage)
		}
		get specularColor() {
			return this._inputs[6]
		}
		_setTarget() {
			this._setInitialTarget(this.generateOnlyFragmentCode ? Xf.Fragment : Xf.VertexAndFragment), this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? Xf.Fragment : Xf.Vertex
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), e.lightId && (this.light = t.getLightById(e.lightId)), this.generateOnlyFragmentCode = e.generateOnlyFragmentCode, this._setTarget()
		}
		updateUniformsAndSamples(e, t, i, s) {
			for (let n = 0; n < t.maxSimultaneousLights && i["LIGHT" + n]; n++) {
				const t = e.uniforms.indexOf("vLightData" + n) >= 0;
				Nf(n, e.uniforms, e.samplers, i["PROJECTEDLIGHTTEXTURE" + n], s, t)
			}
		}
		async _initShaderSourceAsync(e) {
			this._codeIsReady = !1, 1 === e ? await Promise.all([Promise.resolve().then((() => ($(), X))), Promise.resolve().then((() => (ee(), J))), Promise.resolve().then((() => (ae(), te))), Promise.resolve().then((() => (ce(), re))), Promise.resolve().then((() => (pe(), ue))), Promise.resolve().then((() => (Se(), _e))), Promise.resolve().then((() => (Me(), Ee)))]) : await Promise.all([Promise.resolve().then((() => (Ne(), Ce))), Promise.resolve().then((() => (Oe(), Ie))), Promise.resolve().then((() => (He(), Fe))), Promise.resolve().then((() => (Xe(), Ue))), Promise.resolve().then((() => (Je(), Ye))), Promise.resolve().then((() => (tt(), qe))), Promise.resolve().then((() => (rt(), it))), Promise.resolve().then((() => (ut(), ot))), Promise.resolve().then((() => (_t(), mt)))]), this._codeIsReady = !0, this.onCodeIsReadyObservable.notifyObservers(this)
		}
		get cameraPosition() {
			return this._inputs[2]
		}
		_injectUBODeclaration(e) {
			const t = `//${this.name}`;
			this.light ? e._emitFunctionFromInclude(e.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", t, {
				replaceStrings: [{
					search: /{X}/g,
					replace: this._lightId.toString()
				}]
			}, this._lightId.toString()) : e._emitFunctionFromInclude(e.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", t, {
				repeatKey: "maxSimultaneousLights",
				substitutionVars: this.generateOnlyFragmentCode ? "varying," : void 0
			})
		}
		prepareDefines(e, t, i) {
			if (!i._areLightsDirty) return;
			const s = e.getScene();
			if (this.light) {
				const t = {
					needNormals: !1,
					needRebuild: !1,
					lightmapMode: !1,
					shadowEnabled: !1,
					specularEnabled: !1
				};
				Af(s, e, this.light, this._lightId, i, !0, t), t.needRebuild && i.rebuild()
			} else Ef(s, e, i, !0, t.maxSimultaneousLights)
		}
		get worldPosition() {
			return this._inputs[0]
		}
		get glossPower() {
			return this._inputs[4]
		}
		static _OnGenerateOnlyFragmentCodeChanged(e, t) {
			const i = e;
			return i.worldPosition.isConnected ? (i.generateOnlyFragmentCode = !i.generateOnlyFragmentCode, Qc.Error("The worldPosition input must not be connected to be able to switch!"), !1) : (i._setTarget(), !0)
		}
	};
	Gh([cp("Generate only fragment code", 0, "ADVANCED", {
		notifiers: {
			rebuild: !0,
			update: !0,
			onValidation: y_._OnGenerateOnlyFragmentCodeChanged
		}
	})], y_.prototype, "generateOnlyFragmentCode", void 0), cc("BABYLON.LightBlock", y_);
	var S_ = class extends ap {
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("value", Wf.AutoDetect), this.registerInput("power", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0], this._linkConnectionTypes(0, 1)
		}
		get output() {
			return this._outputs[0]
		}
		getClassName() {
			return "PowBlock"
		}
		get power() {
			return this._inputs[1]
		}
		get value() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = pow(${this.value.associatedVariableName}, ${this.power.associatedVariableName});\n`, this
		}
	};
	cc("BABYLON.PowBlock", S_);
	var E_ = class e extends sp {
			createCustomInputBlock() {
				return [new this._blockType(this._blockName), this.name]
			}
			checkCompatibilityState(t) {
				return t instanceof e && t._blockName === this._blockName ? 0 : 1
			}
			constructor(e, t, i, s, n) {
				super(e, t, i), this._blockType = s, this._blockName = n, this.needDualDirectionValidation = !0
			}
		},
		A_ = class e extends ap {
			isReady() {
				return !(this.texture && !this.texture.isReadyOrNotBlocking())
			}
			get samplerName() {
				return this._samplerName
			}
			_dumpPropertiesCode() {
				let e = super._dumpPropertiesCode();
				return this.texture ? (e += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\n`, e += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\n`, e += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\n`, e += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\n`, e += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\n`, e += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\n`, e += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\n`, e += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\n`, e += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\n`, e += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\n`, e += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\n`, e) : e
			}
			_deserialize(e, t, i, s) {
				super._deserialize(e, t, i, s), e.texture && !f_.IgnoreTexturesAtLoadTime && void 0 !== e.texture.url && (0 === e.texture.url.indexOf("data:") ? i = "" : s && (e.texture.url = s(e.texture.url), e.texture.name = e.texture.url), this.texture = Np.Parse(e.texture, t, i))
			}
			bind(e) {
				this.texture && e.setTexture(this._samplerName, this.texture)
			}
			serialize() {
				const e = super.serialize();
				return this.texture && !this.texture.isRenderTarget && "VideoTexture" !== this.texture.getClassName() && (e.texture = this.texture.serialize()), e
			}
			constructor(t) {
				super(t, Xf.VertexAndFragment), this.registerOutput("source", Wf.Object, Xf.VertexAndFragment, new E_("source", this, 1, e, "ImageSourceBlock"))
			}
			get source() {
				return this._outputs[0]
			}
			get texture() {
				return this._texture
			}
			set texture(e) {
				if (this._texture === e) return;
				const t = e?.getScene() ?? Dc.LastCreatedScene;
				!e && t && t.markAllMaterialsAsDirty(1, (e => e.hasTexture(this._texture))), this._texture = e, e && t && t.markAllMaterialsAsDirty(1, (t => t.hasTexture(e)))
			}
			getClassName() {
				return "ImageSourceBlock"
			}
			_buildBlock(e) {
				return super._buildBlock(e), e.target === Xf.Vertex && (this._samplerName = e._getFreeVariableName(this.name + "Texture"), e.sharedData.blockingBlocks.push(this), e.sharedData.textureBlocks.push(this), e.sharedData.bindableBlocks.push(this)), e._emit2DSampler(this._samplerName), this
			}
		};
	cc("BABYLON.ImageSourceBlock", A_);
	var b_ = class extends ap {
		get options() {
			return this._options
		}
		_dumpPropertiesCode() {
			let e = super._dumpPropertiesCode();
			return e += `${this._codeVariableName}.options = ${JSON.stringify(this._options)};\n`, e
		}
		_buildBlock(e) {
			super._buildBlock(e);
			let t = this._code,
				i = this._options.functionName;
			this._inputs.forEach((s => {
				const n = new RegExp("\\{TYPE_" + s.name + "\\}", "gm"),
					a = e._getGLType(s.type);
				t = t.replace(n, a), i = i.replace(n, a)
			})), this._outputs.forEach((s => {
				const n = new RegExp("\\{TYPE_" + s.name + "\\}", "gm"),
					a = e._getGLType(s.type);
				t = t.replace(n, a), i = i.replace(n, a)
			})), e._emitFunction(i, t, ""), this._outputs.forEach((t => {
				e.compilationString += e._declareOutput(t) + ";\n"
			})), e.compilationString += i + "(";
			let s = !1;
			return this._inputs.forEach(((t, i) => {
				i > 0 && (e.compilationString += ", "), this._inputSamplers && -1 !== this._inputSamplers.indexOf(t.name) ? e.compilationString += t.connectedPoint?.ownerBlock?.samplerName ?? t.associatedVariableName : e.compilationString += t.associatedVariableName, s = !0
			})), this._outputs.forEach(((t, i) => {
				(i > 0 || s) && (e.compilationString += ", "), e.compilationString += t.associatedVariableName
			})), e.compilationString += ");\n", this
		}
		_deserializeOptions(e) {
			this._options = e, this._code = e.code.join("\n") + "\n", this.name = this.name || e.name, this.target = Xf[e.target], e.inParameters?.forEach(((e, t) => {
				const i = Wf[e.type];
				"sampler2D" === e.type || "samplerCube" === e.type ? (this._inputSamplers = this._inputSamplers || [], this._inputSamplers.push(e.name), this.registerInput(e.name, Wf.Object, !0, Xf.VertexAndFragment, new E_(e.name, this, 0, A_, "ImageSourceBlock"))) : this.registerInput(e.name, i), Object.defineProperty(this, e.name, {
					get: function() {
						return this._inputs[t]
					},
					enumerable: !0,
					configurable: !0
				})
			})), e.outParameters?.forEach(((e, t) => {
				this.registerOutput(e.name, Wf[e.type]), Object.defineProperty(this, e.name, {
					get: function() {
						return this._outputs[t]
					},
					enumerable: !0,
					configurable: !0
				}), "BasedOnInput" === e.type && (this._outputs[t]._typeConnectionSource = this._findInputByName(e.typeFromInput)[0])
			})), e.inLinkedConnectionTypes?.forEach((e => {
				this._linkConnectionTypes(this._findInputByName(e.input1)[1], this._findInputByName(e.input2)[1])
			}))
		}
		_findInputByName(e) {
			if (!e) return null;
			for (let t = 0; t < this._inputs.length; t++)
				if (this._inputs[t].name === e) return [this._inputs[t], t];
			return null
		}
		_deserialize(e, t, i) {
			this._deserializeOptions(e.options), super._deserialize(e, t, i)
		}
		set options(e) {
			this._deserializeOptions(e)
		}
		getClassName() {
			return "CustomBlock"
		}
		serialize() {
			const e = super.serialize();
			return e.options = this._options, e
		}
		constructor(e) {
			super(e)
		}
	};
	cc("BABYLON.CustomBlock", b_);
	var x_ = class extends ap {
		get input() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = ${this.input.associatedVariableName} * ${this.factor.associatedVariableName};\n`, this
		}
		getClassName() {
			return "ScaleBlock"
		}
		get output() {
			return this._outputs[0]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("input", Wf.AutoDetect), this.registerInput("factor", Wf.Float), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0]
		}
		get factor() {
			return this._inputs[1]
		}
	};
	cc("BABYLON.ScaleBlock", x_);
	var M_ = class extends ap {
		getClassName() {
			return "LerpBlock"
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("left", Wf.AutoDetect), this.registerInput("right", Wf.AutoDetect), this.registerInput("gradient", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0], this._linkConnectionTypes(0, 1), this._linkConnectionTypes(1, 2, !0), this._inputs[2].acceptedConnectionPointTypes.push(Wf.Float)
		}
		get output() {
			return this._outputs[0]
		}
		get right() {
			return this._inputs[1]
		}
		get gradient() {
			return this._inputs[2]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName});\n`, this
		}
		get left() {
			return this._inputs[0]
		}
	};
	cc("BABYLON.LerpBlock", M_);
	var C_ = class extends ap {
		getClassName() {
			return "StepBlock"
		}
		get output() {
			return this._outputs[0]
		}
		get value() {
			return this._inputs[0]
		}
		get edge() {
			return this._inputs[1]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("value", Wf.Float), this.registerInput("edge", Wf.Float), this.registerOutput("output", Wf.Float)
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = step(${this.edge.associatedVariableName}, ${this.value.associatedVariableName});\n`, this
		}
	};
	cc("BABYLON.StepBlock", C_);
	var T_ = class extends ap {
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("worldPosition", Wf.Vector4), this.registerInput("cameraPosition", Wf.Vector3), this.registerOutput("output", Wf.Vector3)
		}
		get cameraPosition() {
			return this._inputs[1]
		}
		getClassName() {
			return "ViewDirectionBlock"
		}
		autoConfigure(e, t = () => !0) {
			if (!this.cameraPosition.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.systemValue === up.CameraPosition && t(e)));
				i || (i = new Cp("cameraPosition"), i.setAsSystemValue(up.CameraPosition)), i.output.connectTo(this.cameraPosition)
			}
		}
		get output() {
			return this._outputs[0]
		}
		get worldPosition() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);\n`, this
		}
	};
	cc("BABYLON.ViewDirectionBlock", T_);
	var w_, R_, N_ = class extends ap {
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("left", Wf.AutoDetect), this.registerInput("right", Wf.AutoDetect), this.registerOutput("output", Wf.Float), this._linkConnectionTypes(0, 1), this._inputs[0].excludedConnectionPointTypes.push(Wf.Float), this._inputs[0].excludedConnectionPointTypes.push(Wf.Matrix), this._inputs[1].excludedConnectionPointTypes.push(Wf.Float), this._inputs[1].excludedConnectionPointTypes.push(Wf.Matrix)
		}
		get left() {
			return this._inputs[0]
		}
		get right() {
			return this._inputs[1]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = dot(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\n`, this
		}
		get output() {
			return this._outputs[0]
		}
		getClassName() {
			return "DotBlock"
		}
	};
	cc("BABYLON.DotBlock", N_), (R_ = w_ || (w_ = {}))[R_.Equal = 0] = "Equal", R_[R_.NotEqual = 1] = "NotEqual", R_[R_.LessThan = 2] = "LessThan", R_[R_.GreaterThan = 3] = "GreaterThan", R_[R_.LessOrEqual = 4] = "LessOrEqual", R_[R_.GreaterOrEqual = 5] = "GreaterOrEqual", R_[R_.Xor = 6] = "Xor", R_[R_.Or = 7] = "Or", R_[R_.And = 8] = "And";
	cc("BABYLON.ConditionalBlock", class extends ap {
		serialize() {
			const e = super.serialize();
			return e.condition = this.condition, e
		}
		get false() {
			return this._inputs[3]
		}
		get a() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0],
				i = this.true.isConnected ? this.true.associatedVariableName : "1.0",
				s = this.false.isConnected ? this.false.associatedVariableName : "0.0";
			switch (this.condition) {
				case w_.Equal:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} == ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.NotEqual:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} != ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.LessThan:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} < ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.LessOrEqual:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} <= ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.GreaterThan:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} > ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.GreaterOrEqual:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`${this.a.associatedVariableName} >= ${this.b.associatedVariableName}`)};\n`;
					break;
				case w_.Xor:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`(((${this.a.associatedVariableName} + ${this.b.associatedVariableName}) % 2.0) > 0.0)`)};\n`;
					break;
				case w_.Or:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`(min(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 1.0) > 0.0)`)};\n`;
					break;
				case w_.And:
					e.compilationString += e._declareOutput(t) + ` = ${e._generateTernary(i,s,`(${this.a.associatedVariableName} * ${this.b.associatedVariableName} > 0.0)`)};\n`
			}
			return this
		}
		get output() {
			return this._outputs[0]
		}
		_deserialize(e, t, i) {
			super._deserialize(e, t, i), this.condition = e.condition
		}
		getClassName() {
			return "ConditionalBlock"
		}
		get b() {
			return this._inputs[1]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.condition = w_.LessThan, this.registerInput("a", Wf.Float), this.registerInput("b", Wf.Float), this.registerInput("true", Wf.AutoDetect, !0), this.registerInput("false", Wf.AutoDetect, !0), this.registerOutput("output", Wf.BasedOnInput), this._linkConnectionTypes(2, 3), this._outputs[0]._typeConnectionSource = this._inputs[2], this._outputs[0]._defaultConnectionPointType = Wf.Float
		}
		get true() {
			return this._inputs[2]
		}
		_dumpPropertiesCode() {
			return super._dumpPropertiesCode() + `${this._codeVariableName}.condition = BABYLON.ConditionalBlockConditions.${w_[this.condition]};\n`
		}
	});
	var I_ = class extends ap {
		get input() {
			return this._inputs[0]
		}
		get output() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = 1. - ${this.input.associatedVariableName};\n`, this
		}
		getClassName() {
			return "OneMinusBlock"
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("input", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0], this._outputs[0].excludedConnectionPointTypes.push(Wf.Matrix)
		}
	};
	cc("BABYLON.OneMinusBlock", I_), cc("BABYLON.OppositeBlock", I_);
	cc("BABYLON.MaxBlock", class extends ap {
		get left() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = max(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\n`, this
		}
		getClassName() {
			return "MaxBlock"
		}
		get right() {
			return this._inputs[1]
		}
		get output() {
			return this._outputs[0]
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("left", Wf.AutoDetect), this.registerInput("right", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0], this._linkConnectionTypes(0, 1)
		}
	});
	cc("BABYLON.DistanceBlock", class extends ap {
		get left() {
			return this._inputs[0]
		}
		get output() {
			return this._outputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = length(${this.left.associatedVariableName} - ${this.right.associatedVariableName});\n`, this
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("left", Wf.AutoDetect), this.registerInput("right", Wf.AutoDetect), this.registerOutput("output", Wf.Float), this._linkConnectionTypes(0, 1), this._inputs[0].excludedConnectionPointTypes.push(Wf.Float), this._inputs[0].excludedConnectionPointTypes.push(Wf.Matrix), this._inputs[1].excludedConnectionPointTypes.push(Wf.Float), this._inputs[1].excludedConnectionPointTypes.push(Wf.Matrix)
		}
		getClassName() {
			return "DistanceBlock"
		}
		get right() {
			return this._inputs[1]
		}
	});
	var P_ = class extends ap {
		autoConfigure(e, t = () => !0) {
			if (!this.view.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.systemValue === up.View && t(e)));
				i || (i = new Cp("view"), i.setAsSystemValue(up.View)), i.output.connectTo(this.view)
			}
			if (!this.fogColor.isConnected) {
				let i = e.getInputBlockByPredicate((e => e.systemValue === up.FogColor && t(e)));
				i || (i = new Cp("fogColor", void 0, Wf.Color3), i.setAsSystemValue(up.FogColor)), i.output.connectTo(this.fogColor)
			}
		}
		get fogColor() {
			return this._inputs[3]
		}
		bind(e, t, i) {
			if (!i) return;
			const s = i.getScene();
			e.setFloat4(this._fogParameters, s.fogMode, s.fogStart, s.fogEnd, s.fogDensity)
		}
		get worldPosition() {
			return this._inputs[0]
		}
		constructor(e) {
			super(e, Xf.VertexAndFragment, !1), this.registerInput("worldPosition", Wf.Vector4, !1, Xf.Vertex), this.registerInput("view", Wf.Matrix, !1, Xf.Vertex), this.registerInput("input", Wf.AutoDetect, !1, Xf.Fragment), this.registerInput("fogColor", Wf.AutoDetect, !1, Xf.Fragment), this.registerOutput("output", Wf.Color3, Xf.Fragment), this.input.addExcludedConnectionPointFromAllowedTypes(Wf.Color3 | Wf.Vector3 | Wf.Color4), this.fogColor.addExcludedConnectionPointFromAllowedTypes(Wf.Color3 | Wf.Vector3 | Wf.Color4)
		}
		getClassName() {
			return "FogBlock"
		}
		initialize(e) {
			this._initShaderSourceAsync(e.shaderLanguage)
		}
		prepareDefines(e, t, i) {
			const s = e.getScene();
			i.setValue("FOG", t.fogEnabled && yf(e, s))
		}
		get output() {
			return this._outputs[0]
		}
		async _initShaderSourceAsync(e) {
			this._codeIsReady = !1, 1 === e ? await Promise.resolve().then((() => (Et(), gt))) : await Promise.resolve().then((() => (Ct(), At))), this._codeIsReady = !0, this.onCodeIsReadyObservable.notifyObservers(this)
		}
		get input() {
			return this._inputs[2]
		}
		get view() {
			return this._inputs[1]
		}
		_buildBlock(e) {
			if (super._buildBlock(e), e.target === Xf.Fragment) {
				e.sharedData.blocksWithDefines.push(this), e.sharedData.bindableBlocks.push(this);
				let t = [],
					i = "",
					s = "";
				1 === e.shaderLanguage ? (t = [{
					search: /fn CalcFogFactor\(\)/,
					replace: "fn CalcFogFactor(vFogDistance: vec3f, vFogInfos: vec4f)"
				}, {
					search: /uniforms.vFogInfos/g,
					replace: "vFogInfos"
				}, {
					search: /fragmentInputs.vFogDistance/g,
					replace: "vFogDistance"
				}], i = "fragmentInputs.", s = "uniforms.") : t = [{
					search: /float CalcFogFactor\(\)/,
					replace: "float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)"
				}], e._emitFunctionFromInclude("fogFragmentDeclaration", `//${this.name}`, {
					removeUniforms: !0,
					removeVaryings: !0,
					removeIfDef: !1,
					replaceStrings: t
				});
				const n = e._getFreeVariableName("fog"),
					a = this.input,
					r = this.fogColor;
				this._fogParameters = e._getFreeVariableName("fogParameters");
				const o = this._outputs[0];
				e._emitUniformFromString(this._fogParameters, Wf.Vector4), e.compilationString += "#ifdef FOG\n", e.compilationString += `${e._declareLocalVar(n,Wf.Float)} = CalcFogFactor(${i}${this._fogDistanceName}, ${s}${this._fogParameters});\n`, e.compilationString += e._declareOutput(o) + ` = ${n} * ${a.associatedVariableName}.rgb + (1.0 - ${n}) * ${r.associatedVariableName}.rgb;\n`, e.compilationString += `#else\n${e._declareOutput(o)} =  ${a.associatedVariableName}.rgb;\n`, e.compilationString += "#endif\n"
			} else {
				const t = this.worldPosition,
					i = this.view;
				this._fogDistanceName = e._getFreeVariableName("vFogDistance"), e._emitVaryingFromString(this._fogDistanceName, Wf.Vector3);
				const s = 1 === e.shaderLanguage ? "vertexOutputs." : "";
				e.compilationString += `${s}${this._fogDistanceName} = (${i.associatedVariableName} * ${t.associatedVariableName}).xyz;\n`
			}
			return this
		}
	};
	cc("BABYLON.FogBlock", P_);
	cc("BABYLON.NegateBlock", class extends ap {
		get output() {
			return this._outputs[0]
		}
		getClassName() {
			return "NegateBlock"
		}
		get value() {
			return this._inputs[0]
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = this._outputs[0];
			return e.compilationString += e._declareOutput(t) + ` = -1.0 * ${this.value.associatedVariableName};\n`, this
		}
		constructor(e) {
			super(e, Xf.Neutral), this.registerInput("value", Wf.AutoDetect), this.registerOutput("output", Wf.BasedOnInput), this._outputs[0]._typeConnectionSource = this._inputs[0]
		}
	});
	cc("BABYLON.ShadowMapBlock", class extends ap {
		get worldNormal() {
			return this._inputs[2]
		}
		get depth() {
			return this._outputs[0]
		}
		async _initShaderSourceAsync(e) {
			this._codeIsReady = !1, 1 === e ? await Promise.all([Promise.resolve().then((() => (It(), Tt))), Promise.resolve().then((() => (Ft(), Pt))), Promise.resolve().then((() => (Ut(), Lt)))]) : await Promise.all([Promise.resolve().then((() => (Yt(), Vt))), Promise.resolve().then((() => (qt(), jt))), Promise.resolve().then((() => (ii(), Qt)))]), this._codeIsReady = !0, this.onCodeIsReadyObservable.notifyObservers(this)
		}
		_buildBlock(e) {
			super._buildBlock(e);
			const t = `//${this.name}`,
				i = 1 === e.shaderLanguage;
			e._emitUniformFromString("biasAndScaleSM", Wf.Vector3), e._emitUniformFromString("lightDataSM", Wf.Vector3), e._emitUniformFromString("depthValuesSM", Wf.Vector2), e._emitFunctionFromInclude("packingFunctions", t), e.compilationString += `${e._declareLocalVar("worldPos",Wf.Vector4)} = ${this.worldPosition.associatedVariableName};\n`, e.compilationString += `${e._declareLocalVar("vPositionWSM",Wf.Vector3)};\n`, e.compilationString += `${e._declareLocalVar("vDepthMetricSM",Wf.Float)} = 0.0;\n`, e.compilationString += `${e._declareLocalVar("zSM",Wf.Float)};\n`, this.worldNormal.isConnected && (e.compilationString += `${e._declareLocalVar("vNormalW",Wf.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;\n`, e.compilationString += e._emitCodeFromInclude("shadowMapVertexNormalBias", t)), e.compilationString += `${e._declareLocalVar("clipPos",Wf.Vector4)} = ${this.viewProjection.associatedVariableName} * worldPos;\n`, e.compilationString += e._emitCodeFromInclude("shadowMapVertexMetric", t, {
				replaceStrings: [{
					search: /gl_Position/g,
					replace: "clipPos"
				}, {
					search: /vertexOutputs.position/g,
					replace: "clipPos"
				}]
			}), e.compilationString += e._emitCodeFromInclude("shadowMapFragment", t, {
				replaceStrings: [{
					search: /return;/g,
					replace: ""
				}]
			});
			const s = i ? "fragmentOutputs.fragDepth" : "gl_FragDepth";
			return e.compilationString += `\n            #if SM_DEPTHTEXTURE == 1\n                #ifdef IS_NDC_HALF_ZRANGE\n                    ${s} = (clipPos.z / clipPos.w);\n                #else\n                    ${s} = (clipPos.z / clipPos.w) * 0.5 + 0.5;\n                #endif\n            #endif\n        `, e.compilationString += `${e._declareOutput(this.depth)} = vec3${e.fSuffix}(depthSM, 1., 1.);\n`, this
		}
		getClassName() {
			return "ShadowMapBlock"
		}
		constructor(e) {
			super(e, Xf.Fragment), this.registerInput("worldPosition", Wf.Vector4, !1), this.registerInput("viewProjection", Wf.Matrix, !1), this.registerInput("worldNormal", Wf.AutoDetect, !0), this.registerOutput("depth", Wf.Vector3), this.worldNormal.addExcludedConnectionPointFromAllowedTypes(Wf.Color3 | Wf.Vector3 | Wf.Vector4)
		}
		initialize(e) {
			e._excludeVariableName("vPositionWSM"), e._excludeVariableName("lightDataSM"), e._excludeVariableName("biasAndScaleSM"), e._excludeVariableName("depthValuesSM"), e._excludeVariableName("clipPos"), e._excludeVariableName("worldPos"), e._excludeVariableName("zSM"), this._initShaderSourceAsync(e.shaderLanguage)
		}
		get worldPosition() {
			return this._inputs[0]
		}
		get viewProjection() {
			return this._inputs[1]
		}
	});
	var k_ = {
			standard: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new v_("Bones");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1;
				var r = new Cp("matricesIndices");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.setAsAttribute("matricesIndices");
				var o = new Cp("matricesWeights");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsAttribute("matricesWeights");
				var l = new Cp("World");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1, l.setAsSystemValue(up.World);
				var h = new rp("Transform");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 1, h.complementZ = 0, h.complementW = 0;
				var c = new Cp("normal");
				c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 1, c.setAsAttribute("normal");
				var u = new y_("Lights");
				u.visibleInInspector = !1, u.visibleOnFrame = !1, u.target = 3;
				var m = new Cp("cameraPosition");
				m.visibleInInspector = !1, m.visibleOnFrame = !1, m.target = 1, m.setAsSystemValue(up.CameraPosition);
				var d = new zp("Multiply");
				d.visibleInInspector = !1, d.visibleOnFrame = !1, d.target = 4;
				var f = new S_("Pow");
				f.visibleInInspector = !1, f.visibleOnFrame = !1, f.target = 4;
				var p = new jp("ColorSplitter");
				p.visibleInInspector = !1, p.visibleOnFrame = !1, p.target = 4;
				var _ = new Cp("color");
				_.visibleInInspector = !1, _.visibleOnFrame = !1, _.target = 1, _.setAsAttribute("color");
				var g = new Gp("VectorMerger");
				g.visibleInInspector = !1, g.visibleOnFrame = !1, g.target = 4, g.xSwizzle = "x", g.ySwizzle = "y", g.zSwizzle = "z", g.wSwizzle = "w";
				var v = new Cp("Float");
				v.visibleInInspector = !1, v.visibleOnFrame = !1, v.target = 1, v.value = .5, v.min = 0, v.max = 0, v.isBoolean = !1, v.matrixMode = 0, v.animationType = _p.None, v.isConstant = !1;
				var y = new __("Add");
				y.visibleInInspector = !1, y.visibleOnFrame = !1, y.target = 4;
				var S = new Cp("emissiveColor");
				S.visibleInInspector = !1, S.visibleOnFrame = !1, S.target = 1, S.value = new Tc(0, 0, 0), S.isConstant = !1;
				var E = new pp("FragmentOutput");
				E.visibleInInspector = !1, E.visibleOnFrame = !1, E.target = 2, E.convertToGammaSpace = !1, E.convertToLinearSpace = !1, E.useLogarithmicDepth = !1;
				var A = new rp("WorldPos * ViewProjectionTransform");
				A.visibleInInspector = !1, A.visibleOnFrame = !1, A.target = 1, A.complementZ = 0, A.complementW = 1;
				var b = new Cp("ViewProjection");
				b.visibleInInspector = !1, b.visibleOnFrame = !1, b.target = 1, b.setAsSystemValue(up.ViewProjection);
				var x = new hp("VertexOutput");
				return x.visibleInInspector = !1, x.visibleOnFrame = !1, x.target = 1, s.output.connectTo(n.vector), r.output.connectTo(a.matricesIndices), o.output.connectTo(a.matricesWeights), l.output.connectTo(a.world), a.output.connectTo(n.transform), n.output.connectTo(A.vector), b.output.connectTo(A.transform), A.output.connectTo(x.vector), S.output.connectTo(y.left), n.output.connectTo(u.worldPosition), c.output.connectTo(h.vector), a.output.connectTo(h.transform), h.output.connectTo(u.worldNormal), m.output.connectTo(u.cameraPosition), u.diffuseOutput.connectTo(d.left), _.output.connectTo(p.rgba), p.rgbOut.connectTo(f.value), v.output.connectTo(g.x), v.output.connectTo(g.y), v.output.connectTo(g.z), g.xyz.connectTo(f.power), f.output.connectTo(d.right), d.output.connectTo(y.right), y.output.connectTo(E.rgb), i.addOutputNode(x), i.addOutputNode(E), i.build(), i
			},
			shell: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new v_("Bones");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1;
				var r = new Cp("matricesIndices");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.setAsAttribute("matricesIndices");
				var o = new Cp("matricesWeights");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsAttribute("matricesWeights");
				var l = new Cp("World");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1, l.setAsSystemValue(up.World);
				var h = new rp("Transform");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 1, h.complementZ = 0, h.complementW = 0;
				var c = new Cp("normal");
				c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 1, c.setAsAttribute("normal");
				var u = new b_("StampNormal");
				u.visibleInInspector = !1, u.visibleOnFrame = !1, u.target = 1, u.options = {
					name: "StampNormal",
					comments: "Calculate stamp normal",
					target: "Vertex",
					inParameters: [{
						name: "vPosition",
						type: "Vector3"
					}, {
						name: "vNormal",
						type: "Vector3"
					}, {
						name: "stampPosition",
						type: "Vector2"
					}],
					outParameters: [{
						name: "vUV",
						type: "Vector2"
					}, {
						name: "stampNormal",
						type: "Vector3"
					}],
					functionName: "eggStampNormal",
					code: ["mat4 rotationMatrix(vec3 axis, float angle) {", "axis = normalize(axis);", "float s = sin(angle);", "float c = cos(angle);", "float oc = 1.0 - c;", "return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "0.0,                                0.0,                                0.0,                                1.0);", "}", "void eggStampNormal(vec3 vPosition, vec3 vNormal, vec2 stampPosition, out vec2 vUV, out vec3 stampNormal) {", "mat4 rotY = rotationMatrix(vec3(0., 1., 0.), stampPosition.x * 0.01745329 * 2.5); // stampPosition is a value from -1 to 1, multiply that with max angle", "mat4 rotX = rotationMatrix(vec3(1., 0., 0.), stampPosition.y * 0.01745329 * 2.5);", "vec4 pos = rotX * rotY * vec4(vPosition, 1.);", "// Project the stamp", "vUV = pos.xy * 0.236; // base scale", "vUV = vUV + vec2(0.0625, 0.0625) / 2.; // half stamp offset", "vUV.x = 0.0625 - vUV.x; // flip axis", "vUV.y = vUV.y + 0.00125; // position correction", "//vUV = vUV - stampPosition / 100.;", "stampNormal = (rotX * rotY * vec4(vNormal, 1.)).xyz;", "}"]
				};
				var m = new Cp("stampPosition");
				m.visibleInInspector = !1, m.visibleOnFrame = !1, m.target = 1, m.value = new Fc(.003, .001), m.isConstant = !1;
				var d = new b_("EggStamp");
				d.visibleInInspector = !1, d.visibleOnFrame = !1, d.target = 2, d.options = {
					name: "EggStamp",
					comments: "Sample selected stamp",
					target: "Fragment",
					inParameters: [{
						name: "source",
						type: "sampler2D"
					}, {
						name: "color",
						type: "Color3"
					}, {
						name: "vUV",
						type: "Vector2"
					}, {
						name: "stampOffset",
						type: "Vector2"
					}, {
						name: "stampNormal",
						type: "Vector3"
					}],
					outParameters: [{
						name: "rgb",
						type: "Color3"
					}],
					functionName: "eggStamp",
					code: ["void eggStamp(sampler2D source, vec3 color, vec2 vUV, vec2 stampOffset, vec3 stampNormal, out vec3 rgb) {", "float d = dot(stampNormal, vec3(0.0, 0.0, 1.0));", "vec2 uv = clamp(vUV, vec2(0., 0.), vec2(0.0625, 0.0625));", "uv += stampOffset - vec2(0., 0.0625);", "vec4 stampColor = texture2D(source, uv);", "if (d > -0.1) {", "stampColor.a = 0.;", "}", "rgb = mix(color.rgb, stampColor.rgb, stampColor.a);", "}"]
				};
				var f = new A_("ImageSource");
				f.visibleInInspector = !1, f.visibleOnFrame = !1, f.target = 3;
				var p = new zp("Multiply");
				p.visibleInInspector = !1, p.visibleOnFrame = !1, p.target = 4;
				var _ = new Cp("customColor");
				_.visibleInInspector = !0, _.visibleOnFrame = !1, _.target = 1, _.value = new Tc(1, 1, 1), _.isConstant = !1;
				var g = new S_("Pow");
				g.visibleInInspector = !1, g.visibleOnFrame = !1, g.target = 4;
				var v = new g_("Clamp");
				v.visibleInInspector = !1, v.visibleOnFrame = !1, v.target = 2, v.minimum = 0, v.maximum = 1;
				var y = new x_("Scale");
				y.visibleInInspector = !1, y.visibleOnFrame = !1, y.target = 1;
				var S = new __("Add");
				S.visibleInInspector = !1, S.visibleOnFrame = !1, S.target = 1;
				var E = new jp("ColorSplitter");
				E.visibleInInspector = !1, E.visibleOnFrame = !1, E.target = 4;
				var A = new Cp("color");
				A.visibleInInspector = !1, A.visibleOnFrame = !1, A.target = 1, A.setAsAttribute("color");
				var b = new x_("Scale");
				b.visibleInInspector = !1, b.visibleOnFrame = !1, b.target = 1;
				var x = new Cp("Color3");
				x.visibleInInspector = !1, x.visibleOnFrame = !1, x.target = 1, x.value = new Tc(.16470588235294117, .16470588235294117, .16470588235294117), x.isConstant = !0;
				var M = new Cp("hp");
				M.visibleInInspector = !0, M.visibleOnFrame = !1, M.target = 1, M.value = 0, M.min = 0, M.max = 1, M.isBoolean = !1, M.matrixMode = 0, M.animationType = _p.None, M.isConstant = !1;
				var C = new Cp("Float");
				C.visibleInInspector = !1, C.visibleOnFrame = !1, C.target = 1, C.value = 6, C.min = 0, C.max = 0, C.isBoolean = !1, C.matrixMode = 0, C.animationType = _p.None, C.isConstant = !0;
				var T = new Gp("VectorMerger");
				T.visibleInInspector = !1, T.visibleOnFrame = !1, T.target = 4, T.xSwizzle = "x", T.ySwizzle = "y", T.zSwizzle = "z", T.wSwizzle = "w";
				var w = new Cp("Float");
				w.visibleInInspector = !1, w.visibleOnFrame = !1, w.target = 1, w.value = .5, w.min = 0, w.max = 0, w.isBoolean = !1, w.matrixMode = 0, w.animationType = _p.None, w.isConstant = !1;
				var R = new Cp("stampOffset");
				R.visibleInInspector = !1, R.visibleOnFrame = !1, R.target = 1, R.value = new Fc(.003, .001), R.isConstant = !1;
				var N = new zp("Multiply");
				N.visibleInInspector = !1, N.visibleOnFrame = !1, N.target = 4;
				var I = new y_("Lights");
				I.visibleInInspector = !1, I.visibleOnFrame = !1, I.target = 3;
				var P = new Cp("cameraPosition");
				P.visibleInInspector = !1, P.visibleOnFrame = !1, P.target = 1, P.setAsSystemValue(up.CameraPosition);
				var k = new M_("Lerp");
				k.visibleInInspector = !1, k.visibleOnFrame = !1, k.target = 2;
				var D = new jp("ColorSplitter");
				D.visibleInInspector = !1, D.visibleOnFrame = !1, D.target = 1;
				var O = new Cp("teamColor");
				O.visibleInInspector = !0, O.visibleOnFrame = !1, O.target = 1, O.value = new wc(1, 0, 0, .3137254901960784), O.isConstant = !1;
				var F = new C_("Step");
				F.visibleInInspector = !1, F.visibleOnFrame = !1, F.target = 4;
				var L = new N_("Dot");
				L.visibleInInspector = !1, L.visibleOnFrame = !1, L.target = 1;
				var B = new T_("View direction");
				B.visibleInInspector = !1, B.visibleOnFrame = !1, B.target = 1;
				var G = new Cp("cameraPosition");
				G.visibleInInspector = !1, G.visibleOnFrame = !1, G.target = 1, G.setAsSystemValue(up.CameraPosition);
				var H = new pp("FragmentOutput");
				H.visibleInInspector = !1, H.visibleOnFrame = !1, H.target = 2, H.convertToGammaSpace = !1, H.convertToLinearSpace = !1, H.useLogarithmicDepth = !1;
				var U = new rp("WorldPos * ViewProjectionTransform");
				U.visibleInInspector = !1, U.visibleOnFrame = !1, U.target = 1, U.complementZ = 0, U.complementW = 1;
				var V = new Cp("ViewProjection");
				V.visibleInInspector = !1, V.visibleOnFrame = !1, V.target = 1, V.setAsSystemValue(up.ViewProjection);
				var W = new hp("VertexOutput");
				return W.visibleInInspector = !1, W.visibleOnFrame = !1, W.target = 1, s.output.connectTo(n.vector), r.output.connectTo(a.matricesIndices), o.output.connectTo(a.matricesWeights), l.output.connectTo(a.world), a.output.connectTo(n.transform), n.output.connectTo(U.vector), V.output.connectTo(U.transform), U.output.connectTo(W.vector), O.output.connectTo(D.rgba), D.rgbOut.connectTo(k.left), n.output.connectTo(I.worldPosition), c.output.connectTo(h.vector), a.output.connectTo(h.transform), h.output.connectTo(I.worldNormal), P.output.connectTo(I.cameraPosition), I.diffuseOutput.connectTo(N.left), f.source.connectTo(d.source), _.output.connectTo(p.left), A.output.connectTo(E.rgba), E.rgbOut.connectTo(S.left), x.output.connectTo(b.input), M.output.connectTo(b.factor), b.output.connectTo(S.right), S.output.connectTo(y.input), C.output.connectTo(y.factor), y.output.connectTo(v.value), v.output.connectTo(g.value), w.output.connectTo(T.x), w.output.connectTo(T.y), w.output.connectTo(T.z), T.xyz.connectTo(g.power), g.output.connectTo(p.right), p.output.connectTo(d.color), s.output.connectTo(u.vPosition), c.output.connectTo(u.vNormal), m.output.connectTo(u.stampPosition), u.vUV.connectTo(d.vUV), R.output.connectTo(d.stampOffset), u.stampNormal.connectTo(d.stampNormal), d.rgb.connectTo(N.right), N.output.connectTo(k.right), n.output.connectTo(B.worldPosition), G.output.connectTo(B.cameraPosition), B.output.connectTo(L.left), h.xyz.connectTo(L.right), L.output.connectTo(F.value), D.a.connectTo(F.edge), F.output.connectTo(k.gradient), k.output.connectTo(H.rgb), i.addOutputNode(W), i.addOutputNode(H), i.build(), i
			},
			instanced: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new p_("Instances");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1;
				var r = new Cp("world0");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.setAsAttribute("world0");
				var o = new Cp("world1");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsAttribute("world1");
				var l = new Cp("world2");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1, l.setAsAttribute("world2");
				var h = new Cp("world3");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 1, h.setAsAttribute("world3");
				var c = new Cp("world");
				c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 1, c.setAsSystemValue(up.World);
				var u = new rp("Transform");
				u.visibleInInspector = !1, u.visibleOnFrame = !1, u.target = 1, u.complementZ = 0, u.complementW = 0;
				var m = new Cp("normal");
				m.visibleInInspector = !1, m.visibleOnFrame = !1, m.target = 1, m.setAsAttribute("normal");
				var d = new y_("Lights");
				d.visibleInInspector = !1, d.visibleOnFrame = !1, d.target = 3;
				var f = new Cp("cameraPosition");
				f.visibleInInspector = !1, f.visibleOnFrame = !1, f.target = 1, f.setAsSystemValue(up.CameraPosition);
				var p = new zp("Multiply");
				p.visibleInInspector = !1, p.visibleOnFrame = !1, p.target = 4;
				var _ = new S_("Pow");
				_.visibleInInspector = !1, _.visibleOnFrame = !1, _.target = 4;
				var g = new jp("ColorSplitter");
				g.visibleInInspector = !1, g.visibleOnFrame = !1, g.target = 4;
				var v = new Cp("color");
				v.visibleInInspector = !1, v.visibleOnFrame = !1, v.target = 1, v.setAsAttribute("color");
				var y = new Gp("VectorMerger");
				y.visibleInInspector = !1, y.visibleOnFrame = !1, y.target = 4, y.xSwizzle = "x", y.ySwizzle = "y", y.zSwizzle = "z", y.wSwizzle = "w";
				var S = new Cp("Float");
				S.visibleInInspector = !1, S.visibleOnFrame = !1, S.target = 1, S.value = .5, S.min = 0, S.max = 0, S.isBoolean = !1, S.matrixMode = 0, S.animationType = _p.None, S.isConstant = !1;
				var E = new pp("FragmentOutput");
				E.visibleInInspector = !1, E.visibleOnFrame = !1, E.target = 2, E.convertToGammaSpace = !1, E.convertToLinearSpace = !1, E.useLogarithmicDepth = !1;
				var A = new rp("WorldPos * ViewProjectionTransform");
				A.visibleInInspector = !1, A.visibleOnFrame = !1, A.target = 1, A.complementZ = 0, A.complementW = 1;
				var b = new Cp("ViewProjection");
				b.visibleInInspector = !1, b.visibleOnFrame = !1, b.target = 1, b.setAsSystemValue(up.ViewProjection);
				var x = new hp("VertexOutput");
				return x.visibleInInspector = !1, x.visibleOnFrame = !1, x.target = 1, s.output.connectTo(n.vector), r.output.connectTo(a.world0), o.output.connectTo(a.world1), l.output.connectTo(a.world2), h.output.connectTo(a.world3), c.output.connectTo(a.world), a.output.connectTo(n.transform), n.output.connectTo(A.vector), b.output.connectTo(A.transform), A.output.connectTo(x.vector), n.output.connectTo(d.worldPosition), m.output.connectTo(u.vector), a.output.connectTo(u.transform), u.output.connectTo(d.worldNormal), f.output.connectTo(d.cameraPosition), d.diffuseOutput.connectTo(p.left), v.output.connectTo(g.rgba), g.rgbOut.connectTo(_.value), S.output.connectTo(y.x), S.output.connectTo(y.y), S.output.connectTo(y.z), y.xyz.connectTo(_.power), _.output.connectTo(p.right), p.output.connectTo(E.rgb), i.addOutputNode(x), i.addOutputNode(E), i.build(), i
			},
			bullet: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new p_("Instances");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1;
				var r = new Cp("world0");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.setAsAttribute("world0");
				var o = new Cp("world1");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsAttribute("world1");
				var l = new Cp("world2");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1, l.setAsAttribute("world2");
				var h = new Cp("world3");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 1, h.setAsAttribute("world3");
				var c = new Cp("world");
				c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 1, c.setAsSystemValue(up.World);
				var u = new rp("WorldPos * ViewProjectionTransform");
				u.visibleInInspector = !1, u.visibleOnFrame = !1, u.target = 1, u.complementZ = 0, u.complementW = 1;
				var m = new Cp("ViewProjection");
				m.visibleInInspector = !1, m.visibleOnFrame = !1, m.target = 1, m.setAsSystemValue(up.ViewProjection);
				var d = new hp("VertexOutput");
				d.visibleInInspector = !1, d.visibleOnFrame = !1, d.target = 1;
				var f = new Cp("color");
				f.visibleInInspector = !1, f.visibleOnFrame = !1, f.target = 1, f.setAsAttribute("color");
				var p = new pp("FragmentOutput");
				return p.visibleInInspector = !1, p.visibleOnFrame = !1, p.target = 2, p.convertToGammaSpace = !1, p.convertToLinearSpace = !1, p.useLogarithmicDepth = !1, s.output.connectTo(n.vector), r.output.connectTo(a.world0), o.output.connectTo(a.world1), l.output.connectTo(a.world2), h.output.connectTo(a.world3), c.output.connectTo(a.world), a.output.connectTo(n.transform), n.output.connectTo(u.vector), m.output.connectTo(u.transform), u.output.connectTo(d.vector), f.output.connectTo(p.rgba), i.addOutputNode(d), i.addOutputNode(p), i.build(), i
			},
			map: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new Cp("World");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1, a.setAsSystemValue(up.World);
				var r = new rp("WorldPos * ViewProjectionTransform");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.complementZ = 0, r.complementW = 1;
				var o = new Cp("ViewProjection");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsSystemValue(up.ViewProjection);
				var l = new hp("VertexOutput");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1;
				var h = new P_("Fog");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 3;
				var c = new Cp("view");
				c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 1, c.setAsSystemValue(up.View);
				var u = new zp("Multiply");
				u.visibleInInspector = !1, u.visibleOnFrame = !1, u.target = 4;
				var m = new S_("Pow");
				m.visibleInInspector = !1, m.visibleOnFrame = !1, m.target = 4;
				var d = new jp("ColorSplitter");
				d.visibleInInspector = !1, d.visibleOnFrame = !1, d.target = 4;
				var f = new Cp("color");
				f.visibleInInspector = !1, f.visibleOnFrame = !1, f.target = 1, f.setAsAttribute("color");
				var p = new Cp("Vector3");
				p.visibleInInspector = !1, p.visibleOnFrame = !1, p.target = 1, p.value = new Lc(.5, .5, .5), p.isConstant = !1;
				var _ = new b_("Shadow");
				_.visibleInInspector = !1, _.visibleOnFrame = !1, _.target = 2, _.options = {
					name: "Shadow",
					comments: "Custom shadow shit",
					target: "Fragment",
					inParameters: [{
						name: "posFromLight",
						type: "Vector4"
					}, {
						name: "shadowSampler",
						type: "sampler2D"
					}],
					outParameters: [{
						name: "output",
						type: "Float"
					}],
					functionName: "computeShadow",
					code: ["void computeShadow(vec4 posFromLight, sampler2D shadowSampler, out float result) {", "vec3 depth = posFromLight.xyz / posFromLight.w;", "depth = 0.5 * depth + vec3(0.5);", "vec2 uv = depth.xy;", "float s = texture2D(shadowSampler, uv).x;", "if (s < 1.) {", "float d = depth.z;", "s = 1. - (s - d) * 80. - 1.;", "if (s < 0.) s = 1.;", "s = clamp(s, 0., 1.);", "}", "else {", "s = 1.;", "}", "result = s;", "}"]
				};
				var g = new rp("Transform");
				g.visibleInInspector = !1, g.visibleOnFrame = !1, g.target = 1, g.complementZ = 0, g.complementW = 1;
				var v = new Cp("shadowLightMatrix ");
				v.visibleInInspector = !1, v.visibleOnFrame = !1, v.target = 1, v.value = Hc.FromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), v.isConstant = !1;
				var y = new A_("shadowSampler");
				y.visibleInInspector = !1, y.visibleOnFrame = !1, y.target = 3;
				var S = new Cp("fogColor");
				S.visibleInInspector = !1, S.visibleOnFrame = !1, S.target = 1, S.setAsSystemValue(up.FogColor);
				var E = new pp("FragmentOutput");
				return E.visibleInInspector = !1, E.visibleOnFrame = !1, E.target = 2, E.convertToGammaSpace = !1, E.convertToLinearSpace = !1, E.useLogarithmicDepth = !1, s.output.connectTo(n.vector), a.output.connectTo(n.transform), n.output.connectTo(r.vector), o.output.connectTo(r.transform), r.output.connectTo(l.vector), n.output.connectTo(h.worldPosition), c.output.connectTo(h.view), f.output.connectTo(d.rgba), d.rgbOut.connectTo(m.value), p.output.connectTo(m.power), m.output.connectTo(u.left), n.output.connectTo(g.vector), v.output.connectTo(g.transform), g.output.connectTo(_.posFromLight), y.source.connectTo(_.shadowSampler), _.output.connectTo(u.right), u.output.connectTo(h.input), S.output.connectTo(h.fogColor), h.output.connectTo(E.rgb), i.addOutputNode(l), i.addOutputNode(E), i.build(), i
			},
			colorized: function(e, t) {
				var i = new f_(e, t);
				i.mode = Up.Material;
				var s = new Cp("position");
				s.visibleInInspector = !1, s.visibleOnFrame = !1, s.target = 1, s.setAsAttribute("position");
				var n = new rp("WorldPos");
				n.visibleInInspector = !1, n.visibleOnFrame = !1, n.target = 1, n.complementZ = 0, n.complementW = 1;
				var a = new Cp("World");
				a.visibleInInspector = !1, a.visibleOnFrame = !1, a.target = 1, a.setAsSystemValue(up.World);
				var r = new rp("WorldPos * ViewProjectionTransform");
				r.visibleInInspector = !1, r.visibleOnFrame = !1, r.target = 1, r.complementZ = 0, r.complementW = 1;
				var o = new Cp("ViewProjection");
				o.visibleInInspector = !1, o.visibleOnFrame = !1, o.target = 1, o.setAsSystemValue(up.ViewProjection);
				var l = new hp("VertexOutput");
				l.visibleInInspector = !1, l.visibleOnFrame = !1, l.target = 1;
				var h = new Cp("color");
				h.visibleInInspector = !1, h.visibleOnFrame = !1, h.target = 1, h.value = new Tc(0, 0, 0), h.isConstant = !1;
				var c = new pp("FragmentOutput");
				return c.visibleInInspector = !1, c.visibleOnFrame = !1, c.target = 2, c.convertToGammaSpace = !1, c.convertToLinearSpace = !1, c.useLogarithmicDepth = !1, s.output.connectTo(n.vector), a.output.connectTo(n.transform), n.output.connectTo(r.vector), o.output.connectTo(r.transform), r.output.connectTo(l.vector), h.output.connectTo(c.rgb), i.addOutputNode(l), i.addOutputNode(c), i.build(), i
			}
		},
		D_ = class {
			getOrAddWithFactory(e, t) {
				let i = this.get(e);
				return void 0 !== i || (i = t(e), i && this.add(e, i)), i
			}
			copyFrom(e) {
				this.clear(), e.forEach(((e, t) => this.add(e, t)))
			}
			get(e) {
				const t = this._data[e];
				if (void 0 !== t) return t
			}
			getOrAdd(e, t) {
				const i = this.get(e);
				return void 0 !== i ? i : (this.add(e, t), t)
			}
			get count() {
				return this._count
			}
			remove(e) {
				return !!this.contains(e) && (delete this._data[e], --this._count, !0)
			}
			first(e) {
				for (const t in this._data) {
					const i = e(t, this._data[t]);
					if (i) return i
				}
				return null
			}
			clear() {
				this._data = {}, this._count = 0
			}
			add(e, t) {
				return void 0 === this._data[e] && (this._data[e] = t, ++this._count, !0)
			}
			getAndRemove(e) {
				const t = this.get(e);
				return void 0 !== t ? (delete this._data[e], --this._count, t) : null
			}
			contains(e) {
				return void 0 !== this._data[e]
			}
			forEach(e) {
				for (const t in this._data) {
					e(t, this._data[t])
				}
			}
			constructor() {
				this._count = 0, this._data = {}
			}
			set(e, t) {
				return void 0 !== this._data[e] && (this._data[e] = t, !0)
			}
		},
		O_ = class {
			static AddIndividualParser(e, t) {
				this._IndividualBabylonFileParsers[e] = t
			}
			static GetParser(e) {
				return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null
			}
			constructor() {
				this.rootNodes = [], this.cameras = [], this.lights = [], this.meshes = [], this.skeletons = [], this.particleSystems = [], this.animations = [], this.animationGroups = [], this.multiMaterials = [], this.materials = [], this.morphTargetManagers = [], this.geometries = [], this.transformNodes = [], this.actionManagers = [], this.textures = [], this._environmentTexture = null, this.postProcesses = []
			}
			static AddParser(e, t) {
				this._BabylonFileParsers[e] = t
			}
			static Parse(e, t, i, s) {
				for (const n in this._BabylonFileParsers) Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, n) && this._BabylonFileParsers[n](e, t, i, s)
			}
			set environmentTexture(e) {
				this._environmentTexture = e
			}
			get environmentTexture() {
				return this._environmentTexture
			}
			static GetIndividualParser(e) {
				return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null
			}
			getNodes() {
				let e = [];
				return e = e.concat(this.meshes), e = e.concat(this.lights), e = e.concat(this.cameras), e = e.concat(this.transformNodes), this.skeletons.forEach((t => e = e.concat(t.bones))), e
			}
		};

	function F_(e) {
		e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative")
	}
	O_._BabylonFileParsers = {}, O_._IndividualBabylonFileParsers = {}, cc("BABYLON.AbstractScene", O_);
	var L_ = class e {
		getClassName() {
			return "ColorCurves"
		}
		set midtonesHue(e) {
			this._midtonesHue = e, this._dirty = !0
		}
		get shadowsDensity() {
			return this._shadowsDensity
		}
		set globalExposure(e) {
			this._globalExposure = e, this._dirty = !0
		}
		_getColorGradingDataToRef(t, i, s, n, a) {
			null != t && (t = e._Clamp(t, 0, 360), i = e._Clamp(i, -100, 100), s = e._Clamp(s, -100, 100), n = e._Clamp(n, -100, 100), i = e._ApplyColorGradingSliderNonlinear(i), i *= .5, n = e._ApplyColorGradingSliderNonlinear(n), i < 0 && (i *= -1, t = (t + 180) % 360), e._FromHSBToRef(t, i, 50 + .25 * n, a), a.scaleToRef(2, a), a.a = 1 + .01 * s)
		}
		get highlightsExposure() {
			return this._highlightsExposure
		}
		static Bind(e, t, i = "vCameraColorCurvePositive", s = "vCameraColorCurveNeutral", n = "vCameraColorCurveNegative") {
			e._dirty && (e._dirty = !1, e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(s, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(n, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a))
		}
		get highlightsDensity() {
			return this._highlightsDensity
		}
		set highlightsSaturation(e) {
			this._highlightsSaturation = e, this._dirty = !0
		}
		constructor() {
			this._dirty = !0, this._tempColor = new wc(0, 0, 0, 0), this._globalCurve = new wc(0, 0, 0, 0), this._highlightsCurve = new wc(0, 0, 0, 0), this._midtonesCurve = new wc(0, 0, 0, 0), this._shadowsCurve = new wc(0, 0, 0, 0), this._positiveCurve = new wc(0, 0, 0, 0), this._negativeCurve = new wc(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0
		}
		static Parse(t) {
			return Xc.Parse((() => new e), t, null, null)
		}
		set midtonesDensity(e) {
			this._midtonesDensity = e, this._dirty = !0
		}
		set highlightsExposure(e) {
			this._highlightsExposure = e, this._dirty = !0
		}
		get midtonesExposure() {
			return this._midtonesExposure
		}
		set shadowsSaturation(e) {
			this._shadowsSaturation = e, this._dirty = !0
		}
		clone() {
			return Xc.Clone((() => new e), this)
		}
		set shadowsExposure(e) {
			this._shadowsExposure = e, this._dirty = !0
		}
		get shadowsExposure() {
			return this._shadowsExposure
		}
		set shadowsHue(e) {
			this._shadowsHue = e, this._dirty = !0
		}
		get midtonesSaturation() {
			return this._midtonesSaturation
		}
		get globalSaturation() {
			return this._globalSaturation
		}
		set highlightsHue(e) {
			this._highlightsHue = e, this._dirty = !0
		}
		set globalSaturation(e) {
			this._globalSaturation = e, this._dirty = !0
		}
		serialize() {
			return Xc.Serialize(this)
		}
		static _ApplyColorGradingSliderNonlinear(e) {
			e /= 100;
			let t = Math.abs(e);
			return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100, t
		}
		set midtonesExposure(e) {
			this._midtonesExposure = e, this._dirty = !0
		}
		set midtonesSaturation(e) {
			this._midtonesSaturation = e, this._dirty = !0
		}
		get highlightsSaturation() {
			return this._highlightsSaturation
		}
		get highlightsHue() {
			return this._highlightsHue
		}
		get shadowsSaturation() {
			return this._shadowsSaturation
		}
		get midtonesHue() {
			return this._midtonesHue
		}
		static _FromHSBToRef(t, i, s, n) {
			let a = e._Clamp(t, 0, 360);
			const r = e._Clamp(i / 100, 0, 1),
				o = e._Clamp(s / 100, 0, 1);
			if (0 === r) n.r = o, n.g = o, n.b = o;
			else {
				a /= 60;
				const e = Math.floor(a),
					t = a - e,
					i = o * (1 - r),
					s = o * (1 - r * t),
					l = o * (1 - r * (1 - t));
				switch (e) {
					case 0:
						n.r = o, n.g = l, n.b = i;
						break;
					case 1:
						n.r = s, n.g = o, n.b = i;
						break;
					case 2:
						n.r = i, n.g = o, n.b = l;
						break;
					case 3:
						n.r = i, n.g = s, n.b = o;
						break;
					case 4:
						n.r = l, n.g = i, n.b = o;
						break;
					default:
						n.r = o, n.g = i, n.b = s
				}
			}
			n.a = 1
		}
		get shadowsHue() {
			return this._shadowsHue
		}
		get midtonesDensity() {
			return this._midtonesDensity
		}
		set globalDensity(e) {
			this._globalDensity = e, this._dirty = !0
		}
		get globalHue() {
			return this._globalHue
		}
		get globalExposure() {
			return this._globalExposure
		}
		set highlightsDensity(e) {
			this._highlightsDensity = e, this._dirty = !0
		}
		get globalDensity() {
			return this._globalDensity
		}
		static _Clamp(e, t, i) {
			return Math.min(Math.max(e, t), i)
		}
		set globalHue(e) {
			this._globalHue = e, this._dirty = !0
		}
		set shadowsDensity(e) {
			this._shadowsDensity = e, this._dirty = !0
		}
	};
	L_.PrepareUniforms = F_, Gh([Xh()], L_.prototype, "_globalHue", void 0), Gh([Xh()], L_.prototype, "_globalDensity", void 0), Gh([Xh()], L_.prototype, "_globalSaturation", void 0), Gh([Xh()], L_.prototype, "_globalExposure", void 0), Gh([Xh()], L_.prototype, "_highlightsHue", void 0), Gh([Xh()], L_.prototype, "_highlightsDensity", void 0), Gh([Xh()], L_.prototype, "_highlightsSaturation", void 0), Gh([Xh()], L_.prototype, "_highlightsExposure", void 0), Gh([Xh()], L_.prototype, "_midtonesHue", void 0), Gh([Xh()], L_.prototype, "_midtonesDensity", void 0), Gh([Xh()], L_.prototype, "_midtonesSaturation", void 0), Gh([Xh()], L_.prototype, "_midtonesExposure", void 0), Xc._ColorCurvesParser = L_.Parse;
	var B_ = class e {
		set contrast(e) {
			this._contrast !== e && (this._contrast = e, this._updateParameters())
		}
		getClassName() {
			return "ImageProcessingConfiguration"
		}
		set vignetteCentreX(e) {
			this.vignetteCenterX = e
		}
		get applyByPostProcess() {
			return this._applyByPostProcess
		}
		set exposure(e) {
			this._exposure !== e && (this._exposure = e, this._updateParameters())
		}
		static get VIGNETTEMODE_MULTIPLY() {
			return this._VIGNETTEMODE_MULTIPLY
		}
		set colorCurvesEnabled(e) {
			this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters())
		}
		set vignetteCentreY(e) {
			this.vignetteCenterY = e
		}
		get contrast() {
			return this._contrast
		}
		_updateParameters() {
			this.onUpdateParameters.notifyObservers(this)
		}
		prepareDefines(t, i = !1) {
			if (i !== this.applyByPostProcess || !this._isEnabled) return t.VIGNETTE = !1, t.TONEMAPPING = 0, t.CONTRAST = !1, t.EXPOSURE = !1, t.COLORCURVES = !1, t.COLORGRADING = !1, t.COLORGRADING3D = !1, t.DITHER = !1, t.IMAGEPROCESSING = !1, t.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, void(t.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled);
			if (t.VIGNETTE = this.vignetteEnabled, t.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === e._VIGNETTEMODE_MULTIPLY, t.VIGNETTEBLENDMODEOPAQUE = !t.VIGNETTEBLENDMODEMULTIPLY, this._toneMappingEnabled) switch (this._toneMappingType) {
				case e.TONEMAPPING_KHR_PBR_NEUTRAL:
					t.TONEMAPPING = 3;
					break;
				case e.TONEMAPPING_ACES:
					t.TONEMAPPING = 2;
					break;
				default:
					t.TONEMAPPING = 1
			} else t.TONEMAPPING = 0;
			t.CONTRAST = 1 !== this.contrast, t.EXPOSURE = 1 !== this.exposure, t.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, t.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, t.COLORGRADING ? t.COLORGRADING3D = this.colorGradingTexture.is3D : t.COLORGRADING3D = !1, t.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, t.SAMPLER3DBGRMAP = this.colorGradingBGR, t.DITHER = this._ditheringEnabled, t.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, t.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, t.IMAGEPROCESSING = t.VIGNETTE || !!t.TONEMAPPING || t.CONTRAST || t.EXPOSURE || t.COLORCURVES || t.COLORGRADING || t.DITHER
		}
		set vignetteEnabled(e) {
			this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters())
		}
		get colorGradingEnabled() {
			return this._colorGradingEnabled
		}
		get colorCurvesEnabled() {
			return this._colorCurvesEnabled
		}
		static get VIGNETTEMODE_OPAQUE() {
			return this._VIGNETTEMODE_OPAQUE
		}
		set toneMappingEnabled(e) {
			this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters())
		}
		get exposure() {
			return this._exposure
		}
		get colorGradingBGR() {
			return this._colorGradingBGR
		}
		bind(e, t) {
			if (this._colorCurvesEnabled && this.colorCurves && L_.Bind(this.colorCurves, e), this._vignetteEnabled || this._ditheringEnabled) {
				const i = 1 / e.getEngine().getRenderWidth(),
					s = 1 / e.getEngine().getRenderHeight();
				if (e.setFloat2("vInverseScreenSize", i, s), this._ditheringEnabled && e.setFloat("ditherIntensity", .5 * this._ditheringIntensity), this._vignetteEnabled) {
					const n = null != t ? t : s / i;
					let a = Math.tan(.5 * this.vignetteCameraFov),
						r = a * n;
					const o = Math.sqrt(r * a);
					r = ld(r, o, this.vignetteStretch), a = ld(a, o, this.vignetteStretch), e.setFloat4("vignetteSettings1", r, a, -r * this.vignetteCenterX, -a * this.vignetteCenterY);
					const l = -2 * this.vignetteWeight;
					e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, l)
				}
			}
			if (e.setFloat("exposureLinear", this.exposure), e.setFloat("contrast", this.contrast), this.colorGradingTexture) {
				e.setTexture("txColorTransform", this.colorGradingTexture);
				const t = this.colorGradingTexture.getSize().height;
				e.setFloat4("colorTransformSettings", (t - 1) / t, .5 / t, t, this.colorGradingTexture.level)
			}
		}
		get colorGradingTexture() {
			return this._colorGradingTexture
		}
		get ditheringEnabled() {
			return this._ditheringEnabled
		}
		set colorGradingWithGreenDepth(e) {
			this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters())
		}
		set applyByPostProcess(e) {
			this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters())
		}
		get isEnabled() {
			return this._isEnabled
		}
		constructor() {
			this.colorCurves = new L_, this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = e.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCenterX = 0, this.vignetteCenterY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new wc(0, 0, 0, 0), this.vignetteCameraFov = .5, this._vignetteBlendMode = e.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._ditheringEnabled = !1, this._ditheringIntensity = 1 / 255, this._skipFinalColorClamp = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new kc
		}
		set isEnabled(e) {
			this._isEnabled !== e && (this._isEnabled = e, this._updateParameters())
		}
		set toneMappingType(e) {
			this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters())
		}
		static Parse(t) {
			const i = Xc.Parse((() => new e), t, null, null);
			return void 0 !== t.vignetteCentreX && (i.vignetteCenterX = t.vignetteCentreX), void 0 !== t.vignetteCentreY && (i.vignetteCenterY = t.vignetteCentreY), i
		}
		set ditheringIntensity(e) {
			this._ditheringIntensity !== e && (this._ditheringIntensity = e, this._updateParameters())
		}
		get toneMappingType() {
			return this._toneMappingType
		}
		set ditheringEnabled(e) {
			this._ditheringEnabled !== e && (this._ditheringEnabled = e, this._updateParameters())
		}
		get skipFinalColorClamp() {
			return this._skipFinalColorClamp
		}
		set colorGradingTexture(e) {
			this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters())
		}
		set colorGradingEnabled(e) {
			this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters())
		}
		clone() {
			return Xc.Clone((() => new e), this)
		}
		get ditheringIntensity() {
			return this._ditheringIntensity
		}
		set vignetteBlendMode(e) {
			this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters())
		}
		set skipFinalColorClamp(e) {
			this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e, this._updateParameters())
		}
		get vignetteCentreY() {
			return this.vignetteCenterY
		}
		get colorGradingWithGreenDepth() {
			return this._colorGradingWithGreenDepth
		}
		get vignetteCentreX() {
			return this.vignetteCenterX
		}
		set colorGradingBGR(e) {
			this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters())
		}
		get vignetteEnabled() {
			return this._vignetteEnabled
		}
		isReady() {
			return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady()
		}
		get toneMappingEnabled() {
			return this._toneMappingEnabled
		}
		serialize() {
			return Xc.Serialize(this)
		}
		get vignetteBlendMode() {
			return this._vignetteBlendMode
		}
	};
	B_.TONEMAPPING_STANDARD = 0, B_.TONEMAPPING_ACES = 1, B_.TONEMAPPING_KHR_PBR_NEUTRAL = 2, B_.PrepareUniforms = function(e, t) {
		t.EXPOSURE && e.push("exposureLinear"), t.CONTRAST && e.push("contrast"), t.COLORGRADING && e.push("colorTransformSettings"), (t.VIGNETTE || t.DITHER) && e.push("vInverseScreenSize"), t.VIGNETTE && (e.push("vignetteSettings1"), e.push("vignetteSettings2")), t.COLORCURVES && F_(e), t.DITHER && e.push("ditherIntensity")
	}, B_.PrepareSamplers = function(e, t) {
		t.COLORGRADING && e.push("txColorTransform")
	}, B_._VIGNETTEMODE_MULTIPLY = 0, B_._VIGNETTEMODE_OPAQUE = 1, Gh([function(e) {
		return Wh(7, e)
	}()], B_.prototype, "colorCurves", void 0), Gh([Xh()], B_.prototype, "_colorCurvesEnabled", void 0), Gh([Yh("colorGradingTexture")], B_.prototype, "_colorGradingTexture", void 0), Gh([Xh()], B_.prototype, "_colorGradingEnabled", void 0), Gh([Xh()], B_.prototype, "_colorGradingWithGreenDepth", void 0), Gh([Xh()], B_.prototype, "_colorGradingBGR", void 0), Gh([Xh()], B_.prototype, "_exposure", void 0), Gh([Xh()], B_.prototype, "_toneMappingEnabled", void 0), Gh([Xh()], B_.prototype, "_toneMappingType", void 0), Gh([Xh()], B_.prototype, "_contrast", void 0), Gh([Xh()], B_.prototype, "vignetteStretch", void 0), Gh([Xh()], B_.prototype, "vignetteCenterX", void 0), Gh([Xh()], B_.prototype, "vignetteCenterY", void 0), Gh([Xh()], B_.prototype, "vignetteWeight", void 0), Gh([Qh()], B_.prototype, "vignetteColor", void 0), Gh([Xh()], B_.prototype, "vignetteCameraFov", void 0), Gh([Xh()], B_.prototype, "_vignetteBlendMode", void 0), Gh([Xh()], B_.prototype, "_vignetteEnabled", void 0), Gh([Xh()], B_.prototype, "_ditheringEnabled", void 0), Gh([Xh()], B_.prototype, "_ditheringIntensity", void 0), Gh([Xh()], B_.prototype, "_skipFinalColorClamp", void 0), Gh([Xh()], B_.prototype, "_applyByPostProcess", void 0), Gh([Xh()], B_.prototype, "_isEnabled", void 0), Xc._ImageProcessingConfigurationParser = B_.Parse, cc("BABYLON.ImageProcessingConfiguration", B_);
	var G_ = class e {
			static CreateNewFromPrimitive(t, i, s, n) {
				return new e(t, i.x, i.y, null, s, n)
			}
			static CreateNewFromScene(t, i) {
				return new e(null, t.pointerX, t.pointerY, t.meshUnderPointer, i)
			}
			static CreateNewFromSprite(t, i, s, n) {
				return new e(t, i.pointerX, i.pointerY, i.meshUnderPointer, s, n)
			}
			constructor(e, t, i, s, n, a) {
				this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = s, this.sourceEvent = n, this.additionalData = a
			}
			static CreateNew(t, i, s) {
				const n = t.getScene();
				return new e(t, n.pointerX, n.pointerY, n.meshUnderPointer || t, i, s)
			}
		},
		H_ = class {};
	H_.POINTERDOWN = 1, H_.POINTERUP = 2, H_.POINTERMOVE = 4, H_.POINTERWHEEL = 8, H_.POINTERPICK = 16, H_.POINTERTAP = 32, H_.POINTERDOUBLETAP = 64;
	var U_ = class {
			constructor(e, t) {
				this.type = e, this.event = t
			}
		},
		V_ = class extends U_ {
			constructor(e, t, i, s) {
				super(e, t), this.ray = null, this.originalPickingInfo = null, this.skipOnPointerObservable = !1, this.localPosition = new Fc(i, s)
			}
		},
		W_ = class extends U_ {
			_generatePickInfo() {
				this._inputManager && (this._pickInfo = this._inputManager._pickMove(this.event), this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event), this._inputManager = null)
			}
			get pickInfo() {
				return this._pickInfo || this._generatePickInfo(), this._pickInfo
			}
			constructor(e, t, i, s = null) {
				super(e, t), this._pickInfo = i, this._inputManager = s
			}
		},
		z_ = class e {
			static get HasPickTriggers() {
				for (const t in e.Triggers)
					if (Object.prototype.hasOwnProperty.call(e.Triggers, t)) {
						const e = parseInt(t);
						if (e >= 1 && e <= 7) return !0
					} return !1
			}
			static HasSpecificTrigger(t) {
				for (const i in e.Triggers)
					if (Object.prototype.hasOwnProperty.call(e.Triggers, i)) {
						if (parseInt(i) === t) return !0
					} return !1
			}
			constructor() {
				this.hoverCursor = "", this.actions = [], this.isRecursive = !1, this.disposeWhenUnowned = !0
			}
			static get HasTriggers() {
				for (const t in e.Triggers)
					if (Object.prototype.hasOwnProperty.call(e.Triggers, t)) return !0;
				return !1
			}
		};
	z_.Triggers = {};
	var X_ = class {};
	X_.KEYDOWN = 1, X_.KEYUP = 2;
	var Y_, j_, K_, $_, J_, q_, Q_, Z_, eg, tg, ig, sg, ng, ag, rg, og, lg = class {
			constructor(e, t) {
				this.type = e, this.event = t
			}
		},
		hg = class extends lg {
			get skipOnPointerObservable() {
				return this.skipOnKeyboardObservable
			}
			set skipOnPointerObservable(e) {
				this.skipOnKeyboardObservable = e
			}
			constructor(e, t) {
				super(e, t), this.type = e, this.event = t, this.skipOnKeyboardObservable = !1
			}
		};
	(j_ = Y_ || (Y_ = {}))[j_.Generic = 0] = "Generic", j_[j_.Keyboard = 1] = "Keyboard", j_[j_.Mouse = 2] = "Mouse", j_[j_.Touch = 3] = "Touch", j_[j_.DualShock = 4] = "DualShock", j_[j_.Xbox = 5] = "Xbox", j_[j_.Switch = 6] = "Switch", j_[j_.DualSense = 7] = "DualSense", ($_ = K_ || (K_ = {}))[$_.Horizontal = 0] = "Horizontal", $_[$_.Vertical = 1] = "Vertical", $_[$_.LeftClick = 2] = "LeftClick", $_[$_.MiddleClick = 3] = "MiddleClick", $_[$_.RightClick = 4] = "RightClick", $_[$_.BrowserBack = 5] = "BrowserBack", $_[$_.BrowserForward = 6] = "BrowserForward", $_[$_.MouseWheelX = 7] = "MouseWheelX", $_[$_.MouseWheelY = 8] = "MouseWheelY", $_[$_.MouseWheelZ = 9] = "MouseWheelZ", $_[$_.Move = 12] = "Move", (q_ = J_ || (J_ = {}))[q_.Horizontal = 0] = "Horizontal", q_[q_.Vertical = 1] = "Vertical", q_[q_.LeftClick = 2] = "LeftClick", q_[q_.MiddleClick = 3] = "MiddleClick", q_[q_.RightClick = 4] = "RightClick", q_[q_.BrowserBack = 5] = "BrowserBack", q_[q_.BrowserForward = 6] = "BrowserForward", q_[q_.MouseWheelX = 7] = "MouseWheelX", q_[q_.MouseWheelY = 8] = "MouseWheelY", q_[q_.MouseWheelZ = 9] = "MouseWheelZ", q_[q_.DeltaHorizontal = 10] = "DeltaHorizontal", q_[q_.DeltaVertical = 11] = "DeltaVertical", (Z_ = Q_ || (Q_ = {}))[Z_.Cross = 0] = "Cross", Z_[Z_.Circle = 1] = "Circle", Z_[Z_.Square = 2] = "Square", Z_[Z_.Triangle = 3] = "Triangle", Z_[Z_.L1 = 4] = "L1", Z_[Z_.R1 = 5] = "R1", Z_[Z_.L2 = 6] = "L2", Z_[Z_.R2 = 7] = "R2", Z_[Z_.Share = 8] = "Share", Z_[Z_.Options = 9] = "Options", Z_[Z_.L3 = 10] = "L3", Z_[Z_.R3 = 11] = "R3", Z_[Z_.DPadUp = 12] = "DPadUp", Z_[Z_.DPadDown = 13] = "DPadDown", Z_[Z_.DPadLeft = 14] = "DPadLeft", Z_[Z_.DPadRight = 15] = "DPadRight", Z_[Z_.Home = 16] = "Home", Z_[Z_.TouchPad = 17] = "TouchPad", Z_[Z_.LStickXAxis = 18] = "LStickXAxis", Z_[Z_.LStickYAxis = 19] = "LStickYAxis", Z_[Z_.RStickXAxis = 20] = "RStickXAxis", Z_[Z_.RStickYAxis = 21] = "RStickYAxis", (tg = eg || (eg = {}))[tg.Cross = 0] = "Cross", tg[tg.Circle = 1] = "Circle", tg[tg.Square = 2] = "Square", tg[tg.Triangle = 3] = "Triangle", tg[tg.L1 = 4] = "L1", tg[tg.R1 = 5] = "R1", tg[tg.L2 = 6] = "L2", tg[tg.R2 = 7] = "R2", tg[tg.Create = 8] = "Create", tg[tg.Options = 9] = "Options", tg[tg.L3 = 10] = "L3", tg[tg.R3 = 11] = "R3", tg[tg.DPadUp = 12] = "DPadUp", tg[tg.DPadDown = 13] = "DPadDown", tg[tg.DPadLeft = 14] = "DPadLeft", tg[tg.DPadRight = 15] = "DPadRight", tg[tg.Home = 16] = "Home", tg[tg.TouchPad = 17] = "TouchPad", tg[tg.LStickXAxis = 18] = "LStickXAxis", tg[tg.LStickYAxis = 19] = "LStickYAxis", tg[tg.RStickXAxis = 20] = "RStickXAxis", tg[tg.RStickYAxis = 21] = "RStickYAxis", (sg = ig || (ig = {}))[sg.A = 0] = "A", sg[sg.B = 1] = "B", sg[sg.X = 2] = "X", sg[sg.Y = 3] = "Y", sg[sg.LB = 4] = "LB", sg[sg.RB = 5] = "RB", sg[sg.LT = 6] = "LT", sg[sg.RT = 7] = "RT", sg[sg.Back = 8] = "Back", sg[sg.Start = 9] = "Start", sg[sg.LS = 10] = "LS", sg[sg.RS = 11] = "RS", sg[sg.DPadUp = 12] = "DPadUp", sg[sg.DPadDown = 13] = "DPadDown", sg[sg.DPadLeft = 14] = "DPadLeft", sg[sg.DPadRight = 15] = "DPadRight", sg[sg.Home = 16] = "Home", sg[sg.LStickXAxis = 17] = "LStickXAxis", sg[sg.LStickYAxis = 18] = "LStickYAxis", sg[sg.RStickXAxis = 19] = "RStickXAxis", sg[sg.RStickYAxis = 20] = "RStickYAxis", (ag = ng || (ng = {}))[ag.B = 0] = "B", ag[ag.A = 1] = "A", ag[ag.Y = 2] = "Y", ag[ag.X = 3] = "X", ag[ag.L = 4] = "L", ag[ag.R = 5] = "R", ag[ag.ZL = 6] = "ZL", ag[ag.ZR = 7] = "ZR", ag[ag.Minus = 8] = "Minus", ag[ag.Plus = 9] = "Plus", ag[ag.LS = 10] = "LS", ag[ag.RS = 11] = "RS", ag[ag.DPadUp = 12] = "DPadUp", ag[ag.DPadDown = 13] = "DPadDown", ag[ag.DPadLeft = 14] = "DPadLeft", ag[ag.DPadRight = 15] = "DPadRight", ag[ag.Home = 16] = "Home", ag[ag.Capture = 17] = "Capture", ag[ag.LStickXAxis = 18] = "LStickXAxis", ag[ag.LStickYAxis = 19] = "LStickYAxis", ag[ag.RStickXAxis = 20] = "RStickXAxis", ag[ag.RStickYAxis = 21] = "RStickYAxis", (og = rg || (rg = {}))[og.PointerMove = 0] = "PointerMove", og[og.PointerDown = 1] = "PointerDown", og[og.PointerUp = 2] = "PointerUp";
	var cg = class {};
	cg.DOM_DELTA_PIXEL = 0, cg.DOM_DELTA_LINE = 1, cg.DOM_DELTA_PAGE = 2;
	var ug = class {
			static _CreateEvent(e) {
				const t = {
					preventDefault: () => {}
				};
				return t.target = e, t
			}
			static CreateDeviceEvent(e, t, i, s, n, a, r) {
				switch (e) {
					case Y_.Keyboard:
						return this._CreateKeyboardEvent(i, s, n, a);
					case Y_.Mouse:
						if (i === K_.MouseWheelX || i === K_.MouseWheelY || i === K_.MouseWheelZ) return this._CreateWheelEvent(e, t, i, s, n, a);
					case Y_.Touch:
						return this._CreatePointerEvent(e, t, i, s, n, a, r);
					default:
						throw `Unable to generate event for device ${Y_[e]}`
				}
			}
			static _CreateWheelEvent(e, t, i, s, n, a) {
				const r = this._CreateMouseEvent(e, t, i, s, n, a);
				switch (r.pointerId = 1, r.type = "wheel", r.deltaMode = cg.DOM_DELTA_PIXEL, r.deltaX = 0, r.deltaY = 0, r.deltaZ = 0, i) {
					case K_.MouseWheelX:
						r.deltaX = s;
						break;
					case K_.MouseWheelY:
						r.deltaY = s;
						break;
					case K_.MouseWheelZ:
						r.deltaZ = s
				}
				return r
			}
			static _CheckNonCharacterKeys(e, t) {
				const i = t.isDeviceAvailable(Y_.Keyboard),
					s = i && 1 === t.pollInput(Y_.Keyboard, 0, 18),
					n = i && 1 === t.pollInput(Y_.Keyboard, 0, 17),
					a = i && (1 === t.pollInput(Y_.Keyboard, 0, 91) || 1 === t.pollInput(Y_.Keyboard, 0, 92) || 1 === t.pollInput(Y_.Keyboard, 0, 93)),
					r = i && 1 === t.pollInput(Y_.Keyboard, 0, 16);
				e.altKey = s, e.ctrlKey = n, e.metaKey = a, e.shiftKey = r
			}
			static _CreatePointerEvent(e, t, i, s, n, a, r) {
				const o = this._CreateMouseEvent(e, t, i, s, n, a);
				e === Y_.Mouse ? (o.deviceType = Y_.Mouse, o.pointerId = 1, o.pointerType = "mouse") : (o.deviceType = Y_.Touch, o.pointerId = r ?? t, o.pointerType = "touch");
				let l = 0;
				return l += n.pollInput(e, t, K_.LeftClick), l += 2 * n.pollInput(e, t, K_.RightClick), l += 4 * n.pollInput(e, t, K_.MiddleClick), o.buttons = l, i === K_.Move ? o.type = "pointermove" : i >= K_.LeftClick && i <= K_.RightClick && (o.type = 1 === s ? "pointerdown" : "pointerup", o.button = i - 2), o
			}
			static _CreateKeyboardEvent(e, t, i, s) {
				const n = this._CreateEvent(s);
				return this._CheckNonCharacterKeys(n, i), n.deviceType = Y_.Keyboard, n.deviceSlot = 0, n.inputIndex = e, n.type = 1 === t ? "keydown" : "keyup", n.key = String.fromCharCode(e), n.keyCode = e, n
			}
			static _CreateMouseEvent(e, t, i, s, n, a) {
				const r = this._CreateEvent(a),
					o = n.pollInput(e, t, K_.Horizontal),
					l = n.pollInput(e, t, K_.Vertical);
				return a ? (r.movementX = 0, r.movementY = 0, r.offsetX = r.movementX - a.getBoundingClientRect().x, r.offsetY = r.movementY - a.getBoundingClientRect().y) : (r.movementX = n.pollInput(e, t, 10), r.movementY = n.pollInput(e, t, 11), r.offsetX = 0, r.offsetY = 0), this._CheckNonCharacterKeys(r, n), r.clientX = o, r.clientY = l, r.x = o, r.y = l, r.deviceType = e, r.deviceSlot = t, r.inputIndex = i, r
			}
		},
		mg = class {
			isDeviceAvailable(e) {
				return e === Y_.Mouse || e === Y_.Touch
			}
			dispose() {
				this._nativeInput.dispose()
			}
			pollInput(e, t, i) {
				return this._nativeInput.pollInput(e, t, i)
			}
			constructor(e, t, i) {
				this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e, t, ((e, t, s, n) => {
					const a = ug.CreateDeviceEvent(e, t, s, n, this);
					i(e, t, a)
				})) : this._createDummyNativeInput()
			}
			_createDummyNativeInput() {
				return {
					pollInput: () => 0,
					isDeviceAvailable: () => !1,
					dispose: () => {}
				}
			}
		},
		dg = Object.keys(K_).length / 2,
		fg = class {
			_handleGamepadActions() {
				this._gamepadConnectedEvent = e => {
					this._addGamePad(e.gamepad)
				}, this._gamepadDisconnectedEvent = e => {
					if (this._gamepads) {
						const t = this._getGamepadDeviceType(e.gamepad.id),
							i = e.gamepad.index;
						this._unregisterDevice(t, i), delete this._gamepads[i]
					}
				}, window.addEventListener("gamepadconnected", this._gamepadConnectedEvent), window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)
			}
			_addPointerDevice(e, t, i, s) {
				this._pointerActive || (this._pointerActive = !0), this._registerDevice(e, t, dg);
				const n = this._inputs[e][t];
				n[0] = i, n[1] = s
			}
			_handleKeyActions() {
				this._keyboardDownEvent = e => {
					this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(Y_.Keyboard, 0, 255));
					const t = this._inputs[Y_.Keyboard][0];
					if (t) {
						t[e.keyCode] = 1;
						const i = e;
						i.inputIndex = e.keyCode, this._usingMacOS && e.metaKey && "Meta" !== e.key && (this._metaKeys.includes(e.keyCode) || this._metaKeys.push(e.keyCode)), this._onInputChanged(Y_.Keyboard, 0, i)
					}
				}, this._keyboardUpEvent = e => {
					this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(Y_.Keyboard, 0, 255));
					const t = this._inputs[Y_.Keyboard][0];
					if (t) {
						t[e.keyCode] = 0;
						const i = e;
						if (i.inputIndex = e.keyCode, this._usingMacOS && "Meta" === e.key && this._metaKeys.length > 0) {
							for (const e of this._metaKeys) {
								const i = ug.CreateDeviceEvent(Y_.Keyboard, 0, e, 0, this, this._elementToAttachTo);
								t[e] = 0, this._onInputChanged(Y_.Keyboard, 0, i)
							}
							this._metaKeys.splice(0, this._metaKeys.length)
						}
						this._onInputChanged(Y_.Keyboard, 0, i)
					}
				}, this._keyboardBlurEvent = () => {
					if (this._keyboardActive) {
						const e = this._inputs[Y_.Keyboard][0];
						for (let t = 0; t < e.length; t++)
							if (0 !== e[t]) {
								e[t] = 0;
								const i = ug.CreateDeviceEvent(Y_.Keyboard, 0, t, 0, this, this._elementToAttachTo);
								this._onInputChanged(Y_.Keyboard, 0, i)
							} this._usingMacOS && this._metaKeys.splice(0, this._metaKeys.length)
					}
				}, this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent)
			}
			_getGamepadDeviceType(e) {
				return -1 !== e.indexOf("054c") ? -1 !== e.indexOf("0ce6") ? Y_.DualSense : Y_.DualShock : -1 !== e.indexOf("Xbox One") || -1 !== e.search("Xbox 360") || -1 !== e.search("xinput") ? Y_.Xbox : -1 !== e.indexOf("057e") ? Y_.Switch : Y_.Generic
			}
			dispose() {
				this._onDeviceConnected = () => {}, this._onDeviceDisconnected = () => {}, this._onInputChanged = () => {}, delete this._engine._onEngineViewChanged, this._elementToAttachTo && this._disableEvents()
			}
			_unregisterDevice(e, t) {
				this._inputs[e][t] && (delete this._inputs[e][t], this._onDeviceDisconnected(e, t))
			}
			isDeviceAvailable(e) {
				return void 0 !== this._inputs[e]
			}
			_handlePointerActions() {
				this._maxTouchPoints = Tu() && navigator.maxTouchPoints || 2, this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints));
				for (let e = 0; e < this._maxTouchPoints; e++) this._activeTouchIds[e] = -1;
				this._pointerMoveEvent = e => {
					const t = this._getPointerType(e);
					let i = t === Y_.Mouse ? 0 : this._activeTouchIds.indexOf(e.pointerId);
					if (t === Y_.Touch && -1 === i) {
						const s = this._activeTouchIds.indexOf(-1);
						if (!(s >= 0)) return void dd.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
						i = s, this._activeTouchIds[s] = e.pointerId, this._onDeviceConnected(t, i)
					}
					this._inputs[t] || (this._inputs[t] = {}), this._inputs[t][i] || this._addPointerDevice(t, i, e.clientX, e.clientY);
					const s = this._inputs[t][i];
					if (s) {
						const n = e;
						n.inputIndex = K_.Move, s[K_.Horizontal] = e.clientX, s[K_.Vertical] = e.clientY, t === Y_.Touch && 0 === s[K_.LeftClick] && (s[K_.LeftClick] = 1), void 0 === e.pointerId && (e.pointerId = this._mouseId), this._onInputChanged(t, i, n), this._usingSafari || -1 === e.button || (n.inputIndex = e.button + 2, s[e.button + 2] = s[e.button + 2] ? 0 : 1, this._onInputChanged(t, i, n))
					}
				}, this._pointerDownEvent = e => {
					const t = this._getPointerType(e);
					let i = t === Y_.Mouse ? 0 : e.pointerId;
					if (t === Y_.Touch) {
						let t = this._activeTouchIds.indexOf(e.pointerId);
						if (-1 === t && (t = this._activeTouchIds.indexOf(-1)), !(t >= 0)) return void dd.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
						i = t, this._activeTouchIds[t] = e.pointerId
					}
					this._inputs[t] || (this._inputs[t] = {}), this._inputs[t][i] ? t === Y_.Touch && this._onDeviceConnected(t, i) : this._addPointerDevice(t, i, e.clientX, e.clientY);
					const s = this._inputs[t][i];
					if (s) {
						const n = s[K_.Horizontal],
							a = s[K_.Vertical];
						if (t === Y_.Mouse) {
							if (void 0 === e.pointerId && (e.pointerId = this._mouseId), !document.pointerLockElement) try {
								this._elementToAttachTo.setPointerCapture(this._mouseId)
							} catch (e) {}
						} else if (e.pointerId && !document.pointerLockElement) try {
							this._elementToAttachTo.setPointerCapture(e.pointerId)
						} catch (e) {}
						s[K_.Horizontal] = e.clientX, s[K_.Vertical] = e.clientY, s[e.button + 2] = 1;
						const r = e;
						r.inputIndex = e.button + 2, this._onInputChanged(t, i, r), n === e.clientX && a === e.clientY || (r.inputIndex = K_.Move, this._onInputChanged(t, i, r))
					}
				}, this._pointerUpEvent = e => {
					const t = this._getPointerType(e),
						i = t === Y_.Mouse ? 0 : this._activeTouchIds.indexOf(e.pointerId);
					if (t === Y_.Touch) {
						if (-1 === i) return;
						this._activeTouchIds[i] = -1
					}
					const s = this._inputs[t]?.[i];
					if (s && 0 !== s[e.button + 2]) {
						const n = s[K_.Horizontal],
							a = s[K_.Vertical];
						s[K_.Horizontal] = e.clientX, s[K_.Vertical] = e.clientY, s[e.button + 2] = 0;
						const r = e;
						void 0 === e.pointerId && (e.pointerId = this._mouseId), n === e.clientX && a === e.clientY || (r.inputIndex = K_.Move, this._onInputChanged(t, i, r)), r.inputIndex = e.button + 2, t === Y_.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) ? this._elementToAttachTo.releasePointerCapture(this._mouseId) : e.pointerId && this._elementToAttachTo.hasPointerCapture?.(e.pointerId) && this._elementToAttachTo.releasePointerCapture(e.pointerId), this._onInputChanged(t, i, r), t === Y_.Touch && this._onDeviceDisconnected(t, i)
					}
				}, this._pointerCancelEvent = e => {
					if ("mouse" === e.pointerType) {
						const e = this._inputs[Y_.Mouse][0];
						this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
						for (let t = K_.LeftClick; t <= K_.BrowserForward; t++)
							if (1 === e[t]) {
								e[t] = 0;
								const i = ug.CreateDeviceEvent(Y_.Mouse, 0, t, 0, this, this._elementToAttachTo);
								this._onInputChanged(Y_.Mouse, 0, i)
							}
					} else {
						const t = this._activeTouchIds.indexOf(e.pointerId);
						if (-1 === t) return;
						this._elementToAttachTo.hasPointerCapture?.(e.pointerId) && this._elementToAttachTo.releasePointerCapture(e.pointerId), this._inputs[Y_.Touch][t][K_.LeftClick] = 0;
						const i = ug.CreateDeviceEvent(Y_.Touch, t, K_.LeftClick, 0, this, this._elementToAttachTo, e.pointerId);
						this._onInputChanged(Y_.Touch, t, i), this._activeTouchIds[t] = -1, this._onDeviceDisconnected(Y_.Touch, t)
					}
				}, this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll";
				let e = !1;
				const t = function() {};
				try {
					const i = Object.defineProperty({}, "passive", {
						get: function() {
							e = !0
						}
					});
					this._elementToAttachTo.addEventListener("test", t, i), this._elementToAttachTo.removeEventListener("test", t, i)
				} catch (e) {}
				this._pointerBlurEvent = () => {
					if (this.isDeviceAvailable(Y_.Mouse)) {
						const e = this._inputs[Y_.Mouse][0];
						this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
						for (let t = K_.LeftClick; t <= K_.BrowserForward; t++)
							if (1 === e[t]) {
								e[t] = 0;
								const i = ug.CreateDeviceEvent(Y_.Mouse, 0, t, 0, this, this._elementToAttachTo);
								this._onInputChanged(Y_.Mouse, 0, i)
							}
					}
					if (this.isDeviceAvailable(Y_.Touch)) {
						const e = this._inputs[Y_.Touch];
						for (let t = 0; t < this._activeTouchIds.length; t++) {
							const i = this._activeTouchIds[t];
							if (this._elementToAttachTo.hasPointerCapture?.(i) && this._elementToAttachTo.releasePointerCapture(i), -1 !== i && 1 === e[t]?.[K_.LeftClick]) {
								e[t][K_.LeftClick] = 0;
								const s = ug.CreateDeviceEvent(Y_.Touch, t, K_.LeftClick, 0, this, this._elementToAttachTo, i);
								this._onInputChanged(Y_.Touch, t, s), this._activeTouchIds[t] = -1, this._onDeviceDisconnected(Y_.Touch, t)
							}
						}
					}
				}, this._pointerWheelEvent = e => {
					const t = Y_.Mouse;
					this._inputs[t] || (this._inputs[t] = []), this._inputs[t][0] || (this._pointerActive = !0, this._registerDevice(t, 0, dg));
					const i = this._inputs[t][0];
					if (i) {
						i[K_.MouseWheelX] = e.deltaX || 0, i[K_.MouseWheelY] = e.deltaY || e.wheelDelta || 0, i[K_.MouseWheelZ] = e.deltaZ || 0;
						const s = e;
						void 0 === e.pointerId && (e.pointerId = this._mouseId), 0 !== i[K_.MouseWheelX] && (s.inputIndex = K_.MouseWheelX, this._onInputChanged(t, 0, s)), 0 !== i[K_.MouseWheelY] && (s.inputIndex = K_.MouseWheelY, this._onInputChanged(t, 0, s)), 0 !== i[K_.MouseWheelZ] && (s.inputIndex = K_.MouseWheelZ, this._onInputChanged(t, 0, s))
					}
				}, this._usingMacOS && this._isUsingChromium && (this._pointerMacOSChromeOutEvent = e => {
					e.buttons > 1 && this._pointerCancelEvent(e)
				}, this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent)), this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, !!e && {
					passive: !1
				}), this._pointerInputClearObserver = this._engine.onEndFrameObservable.add((() => {
					if (this.isDeviceAvailable(Y_.Mouse)) {
						const e = this._inputs[Y_.Mouse][0];
						e[K_.MouseWheelX] = 0, e[K_.MouseWheelY] = 0, e[K_.MouseWheelZ] = 0
					}
				}))
			}
			constructor(e, t, i, s) {
				this._inputs = [], this._keyboardActive = !1, this._pointerActive = !1, this._usingSafari = dd.IsSafari(), this._usingMacOS = Tu() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform), this._keyboardDownEvent = e => {}, this._keyboardUpEvent = e => {}, this._keyboardBlurEvent = e => {}, this._pointerMoveEvent = e => {}, this._pointerDownEvent = e => {}, this._pointerUpEvent = e => {}, this._pointerCancelEvent = e => {}, this._pointerWheelEvent = e => {}, this._pointerBlurEvent = e => {}, this._pointerMacOSChromeOutEvent = e => {}, this._eventsAttached = !1, this._mouseId = -1, this._isUsingFirefox = Tu() && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Firefox"), this._isUsingChromium = Tu() && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Chrome"), this._maxTouchPoints = 0, this._pointerInputClearObserver = null, this._gamepadConnectedEvent = e => {}, this._gamepadDisconnectedEvent = e => {}, this._eventPrefix = dd.GetPointerPrefix(e), this._engine = e, this._onDeviceConnected = t, this._onDeviceDisconnected = i, this._onInputChanged = s, this._mouseId = this._isUsingFirefox ? 0 : 1, this._enableEvents(), this._usingMacOS && (this._metaKeys = []), this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = () => {
					this._enableEvents()
				})
			}
			_addGamePad(e) {
				const t = this._getGamepadDeviceType(e.id),
					i = e.index;
				this._gamepads = this._gamepads || new Array(e.index + 1), this._registerDevice(t, i, e.buttons.length + e.axes.length), this._gamepads[i] = t
			}
			_disableEvents() {
				this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent), this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent), this._usingMacOS && this._isUsingChromium && this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent), window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent), window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)), this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver), this._eventsAttached = !1
			}
			_enableEvents() {
				const e = this?._engine.getInputElement();
				if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) {
					if (this._disableEvents(), this._inputs)
						for (const e of this._inputs)
							if (e)
								for (const t in e) {
									const i = e[+t];
									if (i)
										for (let e = 0; e < i.length; e++) i[e] = 0
								}
					this._elementToAttachTo = e, this._elementToAttachTo.tabIndex = -1 !== this._elementToAttachTo.tabIndex ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex, this._handleKeyActions(), this._handlePointerActions(), this._handleGamepadActions(), this._eventsAttached = !0, this._checkForConnectedDevices()
				}
			}
			_registerDevice(e, t, i) {
				if (void 0 === t) throw `Unable to register device ${Y_[e]} to undefined slot.`;
				if (this._inputs[e] || (this._inputs[e] = {}), !this._inputs[e][t]) {
					const s = new Array(i);
					s.fill(0), this._inputs[e][t] = s, this._onDeviceConnected(e, t)
				}
			}
			pollInput(e, t, i) {
				const s = this._inputs[e][t];
				if (!s) throw `Unable to find device ${Y_[e]}`;
				e >= Y_.DualShock && e <= Y_.DualSense && this._updateDevice(e, t, i);
				const n = s[i];
				if (void 0 === n) throw `Unable to find input ${i} for device ${Y_[e]} in slot ${t}`;
				return i === K_.Move && dd.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."), n
			}
			_getPointerType(e) {
				let t = Y_.Mouse;
				return ("touch" === e.pointerType || "pen" === e.pointerType || e.touches) && (t = Y_.Touch), t
			}
			_checkForConnectedDevices() {
				if (navigator.getGamepads) {
					const e = navigator.getGamepads();
					for (const t of e) t && this._addGamePad(t)
				}
				"function" == typeof matchMedia && matchMedia("(pointer:fine)").matches && this._addPointerDevice(Y_.Mouse, 0, 0, 0)
			}
			_updateDevice(e, t, i) {
				const s = navigator.getGamepads()[t];
				if (s && e === this._gamepads[t]) {
					const n = this._inputs[e][t];
					i >= s.buttons.length ? n[i] = s.axes[i - s.buttons.length].valueOf() : n[i] = s.buttons[i].value
				}
			}
		},
		pg = class {
			constructor(e, t, i = 0) {
				this.deviceType = t, this.deviceSlot = i, this.onInputChangedObservable = new kc, this._deviceInputSystem = e
			}
			getInput(e) {
				return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e)
			}
		},
		_g = class {
			dispose() {
				this._deviceInputSystem.dispose()
			}
			constructor(e) {
				this._registeredManagers = new Array, this._refCount = 0, this.registerManager = e => {
					for (let t = 0; t < this._devices.length; t++) {
						const i = this._devices[t];
						for (const s in i) {
							const i = +s;
							e._addDevice(new pg(this._deviceInputSystem, t, i))
						}
					}
					this._registeredManagers.push(e)
				}, this.unregisterManager = e => {
					const t = this._registeredManagers.indexOf(e);
					t > -1 && this._registeredManagers.splice(t, 1)
				};
				const t = Object.keys(Y_).length / 2;
				this._devices = new Array(t);
				const i = (e, t) => {
						this._devices[e] || (this._devices[e] = new Array), this._devices[e][t] || (this._devices[e][t] = t);
						for (const i of this._registeredManagers) {
							const s = new pg(this._deviceInputSystem, e, t);
							i._addDevice(s)
						}
					},
					s = (e, t) => {
						this._devices[e]?.[t] && delete this._devices[e][t];
						for (const i of this._registeredManagers) i._removeDevice(e, t)
					},
					n = (e, t, i) => {
						if (i)
							for (const s of this._registeredManagers) s._onInputChanged(e, t, i)
					};
				"undefined" != typeof _native ? this._deviceInputSystem = new mg(i, s, n) : this._deviceInputSystem = new fg(e, i, s, n)
			}
		},
		gg = class {
			_addDevice(e) {
				this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array), this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e, this._updateFirstDevices(e.deviceType)), this.onDeviceConnectedObservable.notifyObservers(e)
			}
			constructor(e) {
				const t = Object.keys(Y_).length / 2;
				this._devices = new Array(t), this._firstDevice = new Array(t), this._engine = e, this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new _g(e)), this._engine._deviceSourceManager._refCount++, this.onDeviceConnectedObservable = new kc((e => {
					for (const t of this._devices)
						if (t)
							for (const i of t) i && this.onDeviceConnectedObservable.notifyObserver(e, i)
				})), this.onDeviceDisconnectedObservable = new kc, this._engine._deviceSourceManager.registerManager(this), this._onDisposeObserver = e.onDisposeObservable.add((() => {
					this.dispose()
				}))
			}
			dispose() {
				this.onDeviceConnectedObservable.clear(), this.onDeviceDisconnectedObservable.clear(), this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this), --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(), delete this._engine._deviceSourceManager)), this._engine.onDisposeObservable.remove(this._onDisposeObserver)
			}
			_removeDevice(e, t) {
				const i = this._devices[e]?.[t];
				this.onDeviceDisconnectedObservable.notifyObservers(i), this._devices[e]?.[t] && delete this._devices[e][t], this._updateFirstDevices(e)
			}
			getDeviceSource(e, t) {
				if (void 0 === t) {
					if (void 0 === this._firstDevice[e]) return null;
					t = this._firstDevice[e]
				}
				return this._devices[e] && void 0 !== this._devices[e][t] ? this._devices[e][t] : null
			}
			_updateFirstDevices(e) {
				switch (e) {
					case Y_.Keyboard:
					case Y_.Mouse:
						this._firstDevice[e] = 0;
						break;
					case Y_.Touch:
					case Y_.DualSense:
					case Y_.DualShock:
					case Y_.Xbox:
					case Y_.Switch:
					case Y_.Generic: {
						delete this._firstDevice[e];
						const t = this._devices[e];
						if (t)
							for (let i = 0; i < t.length; i++)
								if (t[i]) {
									this._firstDevice[e] = i;
									break
								} break
					}
				}
			}
			getDeviceSources(e) {
				return this._devices[e] ? this._devices[e].filter((e => !!e)) : []
			}
			_onInputChanged(e, t, i) {
				this._devices[e]?.[t]?.onInputChangedObservable.notifyObservers(i)
			}
		},
		vg = class {
			constructor() {
				this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1
			}
			set ignore(e) {
				this._ignore = e
			}
			get singleClick() {
				return this._singleClick
			}
			set hasSwiped(e) {
				this._hasSwiped = e
			}
			get ignore() {
				return this._ignore
			}
			set doubleClick(e) {
				this._doubleClick = e
			}
			set singleClick(e) {
				this._singleClick = e
			}
			get doubleClick() {
				return this._doubleClick
			}
			get hasSwiped() {
				return this._hasSwiped
			}
		},
		yg = class e {
			simulatePointerDown(e, t) {
				const i = new PointerEvent("pointerdown", t);
				i.inputIndex = i.button + 2, this._checkPrePointerObservable(e, i, H_.POINTERDOWN) || this._processPointerDown(e, i)
			}
			_setCursorAndPointerOverMesh(e, t, i) {
				const s = i.getEngine().getInputElement();
				if (e?.pickedMesh) {
					if (this.setPointerOverMesh(e.pickedMesh, t.pointerId, e, t), !i.doNotHandleCursors && s && this._pointerOverMesh) {
						const e = this._pointerOverMesh._getActionManagerForTrigger();
						e && e.hasPointerTriggers && (s.style.cursor = e.hoverCursor || i.hoverCursor)
					}
				} else this.setPointerOverMesh(null, t.pointerId, e, t)
			}
			_pickMove(e) {
				const t = this._scene,
					i = t.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, t.pointerMovePredicate, t.pointerMoveFastCheck, t.cameraToUseForPointers, t.pointerMoveTrianglePredicate);
				return this._setCursorAndPointerOverMesh(i, e, t), i
			}
			_checkForPicking() {
				return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick)
			}
			attachControl(t = !0, i = !0, s = !0, n = null) {
				const a = this._scene,
					r = a.getEngine();
				n || (n = r.getInputElement()), this._alreadyAttached && this.detachControl(), n && (this._alreadyAttachedTo = n), this._deviceSourceManager = new gg(r), this._initActionManager = e => {
					if (!this._meshPickProceed) {
						const t = a.skipPointerUpPicking || 0 === a._registeredActions && !this._checkForPicking() && !a.onPointerUp ? null : a.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, a.pointerUpPredicate, a.pointerUpFastCheck, a.cameraToUseForPointers, a.pointerUpTrianglePredicate);
						this._currentPickResult = t, t && (e = t.hit && t.pickedMesh ? t.pickedMesh._getActionManagerForTrigger() : null), this._meshPickProceed = !0
					}
					return e
				}, this._delayedSimpleClick = (t, i, s) => {
					if ((Date.now() - this._previousStartingPointerTime > e.DoubleClickDelay && !this._doubleClickOccured || t !== this._previousButtonPressed) && (this._doubleClickOccured = !1, i.singleClick = !0, i.ignore = !1, this._delayedClicks[t])) {
						const e = this._delayedClicks[t].evt,
							i = H_.POINTERTAP,
							s = new W_(i, e, this._currentPickResult);
						a.onPointerObservable.hasObservers() && a.onPointerObservable.hasSpecificMask(i) && a.onPointerObservable.notifyObservers(s, i), this._delayedClicks[t] = null
					}
				}, this._initClickEvent = (t, i, s, n) => {
					const a = new vg;
					this._currentPickResult = null;
					let r = null,
						o = t.hasSpecificMask(H_.POINTERPICK) || i.hasSpecificMask(H_.POINTERPICK) || t.hasSpecificMask(H_.POINTERTAP) || i.hasSpecificMask(H_.POINTERTAP) || t.hasSpecificMask(H_.POINTERDOUBLETAP) || i.hasSpecificMask(H_.POINTERDOUBLETAP);
					!o && z_ && (r = this._initActionManager(r, a), r && (o = r.hasPickTriggers));
					let l = !1;
					if (o) {
						const o = s.button;
						if (a.hasSwiped = this._isPointerSwiping(), !a.hasSwiped) {
							let h = !e.ExclusiveDoubleClickMode;
							if (h || (h = !t.hasSpecificMask(H_.POINTERDOUBLETAP) && !i.hasSpecificMask(H_.POINTERDOUBLETAP), h && !z_.HasSpecificTrigger(6) && (r = this._initActionManager(r, a), r && (h = !r.hasSpecificTrigger(6)))), h)(Date.now() - this._previousStartingPointerTime > e.DoubleClickDelay || o !== this._previousButtonPressed) && (a.singleClick = !0, n(a, this._currentPickResult), l = !0);
							else {
								const t = {
									evt: s,
									clickInfo: a,
									timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, o, a, n), e.DoubleClickDelay)
								};
								this._delayedClicks[o] = t
							}
							let c = t.hasSpecificMask(H_.POINTERDOUBLETAP) || i.hasSpecificMask(H_.POINTERDOUBLETAP);
							!c && z_.HasSpecificTrigger(6) && (r = this._initActionManager(r, a), r && (c = r.hasSpecificTrigger(6))), c && (o === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < e.DoubleClickDelay && !this._doubleClickOccured ? (a.hasSwiped || this._isPointerSwiping() ? (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = o, e.ExclusiveDoubleClickMode ? (this._delayedClicks[o] && (clearTimeout(this._delayedClicks[o]?.timeoutId), this._delayedClicks[o] = null), n(a, this._previousPickResult)) : n(a, this._currentPickResult)) : (this._previousStartingPointerTime = 0, this._doubleClickOccured = !0, a.doubleClick = !0, a.ignore = !1, e.ExclusiveDoubleClickMode && this._delayedClicks[o] && (clearTimeout(this._delayedClicks[o]?.timeoutId), this._delayedClicks[o] = null), n(a, this._currentPickResult)), l = !0) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = o))
						}
					}
					l || n(a, this._currentPickResult)
				}, this._onPointerMove = t => {
					if (this._updatePointerPosition(t), this._isSwiping || -1 === this._swipeButtonPressed || (this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > e.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > e.DragMovementThreshold), r.isPointerLock && r._verifyPointerLock(), this._checkPrePointerObservable(null, t, t.inputIndex >= K_.MouseWheelX && t.inputIndex <= K_.MouseWheelZ ? H_.POINTERWHEEL : H_.POINTERMOVE)) return;
					if (!a.cameraToUseForPointers && !a.activeCamera) return;
					if (a.skipPointerMovePicking) return void this._processPointerMove(new Ld, t);
					a.pointerMovePredicate || (a.pointerMovePredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (e.enablePointerMoveEvents || a.constantlyUpdateMeshUnderPointer || null !== e._getActionManagerForTrigger()) && (!a.cameraToUseForPointers || !!(a.cameraToUseForPointers.layerMask & e.layerMask)));
					const i = a._registeredActions > 0 || a.constantlyUpdateMeshUnderPointer ? this._pickMove(t) : null;
					this._processPointerMove(i, t)
				}, this._onPointerDown = t => {
					if (this._totalPointersPressed++, this._pickedDownMesh = null, this._meshPickProceed = !1, e.ExclusiveDoubleClickMode)
						for (let e = 0; e < this._delayedClicks.length; e++)
							if (this._delayedClicks[e])
								if (t.button === e) clearTimeout(this._delayedClicks[e]?.timeoutId);
								else {
									const t = this._delayedClicks[e].clickInfo;
									this._doubleClickOccured = !1, t.singleClick = !0, t.ignore = !1;
									const i = this._delayedClicks[e].evt,
										s = H_.POINTERTAP,
										n = new W_(s, i, this._currentPickResult);
									a.onPointerObservable.hasObservers() && a.onPointerObservable.hasSpecificMask(s) && a.onPointerObservable.notifyObservers(n, s), this._delayedClicks[e] = null
								} if (this._updatePointerPosition(t), -1 === this._swipeButtonPressed && (this._swipeButtonPressed = t.button), a.preventDefaultOnPointerDown && n && (t.preventDefault(), n.focus()), this._startingPointerPosition.x = this._pointerX, this._startingPointerPosition.y = this._pointerY, this._startingPointerTime = Date.now(), this._checkPrePointerObservable(null, t, H_.POINTERDOWN)) return;
					if (!a.cameraToUseForPointers && !a.activeCamera) return;
					let i;
					this._pointerCaptures[t.pointerId] = !0, a.pointerDownPredicate || (a.pointerDownPredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (!a.cameraToUseForPointers || !!(a.cameraToUseForPointers.layerMask & e.layerMask))), this._pickedDownMesh = null, i = a.skipPointerDownPicking || 0 === a._registeredActions && !this._checkForPicking() && !a.onPointerDown ? new Ld : a.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, a.pointerDownPredicate, a.pointerDownFastCheck, a.cameraToUseForPointers, a.pointerDownTrianglePredicate), this._processPointerDown(i, t)
				}, this._onPointerUp = e => {
					0 !== this._totalPointersPressed && (this._totalPointersPressed--, this._pickedUpMesh = null, this._meshPickProceed = !1, this._updatePointerPosition(e), a.preventDefaultOnPointerUp && n && (e.preventDefault(), n.focus()), this._initClickEvent(a.onPrePointerObservable, a.onPointerObservable, e, ((t, i) => {
						if (a.onPrePointerObservable.hasObservers() && (this._skipPointerTap = !1, !t.ignore)) {
							if (this._checkPrePointerObservable(null, e, H_.POINTERUP)) return this._swipeButtonPressed === e.button && (this._isSwiping = !1, this._swipeButtonPressed = -1), void(0 === e.buttons && (this._pointerCaptures[e.pointerId] = !1));
							t.hasSwiped || (t.singleClick && a.onPrePointerObservable.hasSpecificMask(H_.POINTERTAP) && this._checkPrePointerObservable(null, e, H_.POINTERTAP) && (this._skipPointerTap = !0), t.doubleClick && a.onPrePointerObservable.hasSpecificMask(H_.POINTERDOUBLETAP) && this._checkPrePointerObservable(null, e, H_.POINTERDOUBLETAP) && (this._skipPointerTap = !0))
						}
						this._pointerCaptures[e.pointerId] ? (0 === e.buttons && (this._pointerCaptures[e.pointerId] = !1), (a.cameraToUseForPointers || a.activeCamera) && (a.pointerUpPredicate || (a.pointerUpPredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (!a.cameraToUseForPointers || !!(a.cameraToUseForPointers.layerMask & e.layerMask))), !this._meshPickProceed && (z_ && z_.HasTriggers || this._checkForPicking() || a.onPointerUp) && this._initActionManager(null, t), i || (i = this._currentPickResult), this._processPointerUp(i, e, t), this._previousPickResult = this._currentPickResult, this._swipeButtonPressed === e.button && (this._isSwiping = !1, this._swipeButtonPressed = -1))) : this._swipeButtonPressed === e.button && (this._isSwiping = !1, this._swipeButtonPressed = -1)
					})))
				}, this._onKeyDown = e => {
					const t = X_.KEYDOWN;
					if (a.onPreKeyboardObservable.hasObservers()) {
						const i = new hg(t, e);
						if (a.onPreKeyboardObservable.notifyObservers(i, t), i.skipOnKeyboardObservable) return
					}
					if (a.onKeyboardObservable.hasObservers()) {
						const i = new lg(t, e);
						a.onKeyboardObservable.notifyObservers(i, t)
					}
					a.actionManager && a.actionManager.processTrigger(14, G_.CreateNewFromScene(a, e))
				}, this._onKeyUp = e => {
					const t = X_.KEYUP;
					if (a.onPreKeyboardObservable.hasObservers()) {
						const i = new hg(t, e);
						if (a.onPreKeyboardObservable.notifyObservers(i, t), i.skipOnKeyboardObservable) return
					}
					if (a.onKeyboardObservable.hasObservers()) {
						const i = new lg(t, e);
						a.onKeyboardObservable.notifyObservers(i, t)
					}
					a.actionManager && a.actionManager.processTrigger(15, G_.CreateNewFromScene(a, e))
				}, this._deviceSourceManager.onDeviceConnectedObservable.add((e => {
					e.deviceType === Y_.Mouse ? e.onInputChangedObservable.add((n => {
						this._originMouseEvent = n, n.inputIndex === K_.LeftClick || n.inputIndex === K_.MiddleClick || n.inputIndex === K_.RightClick || n.inputIndex === K_.BrowserBack || n.inputIndex === K_.BrowserForward ? i && 1 === e.getInput(n.inputIndex) ? this._onPointerDown(n) : t && 0 === e.getInput(n.inputIndex) && this._onPointerUp(n) : s && (n.inputIndex === K_.Move ? this._onPointerMove(n) : n.inputIndex !== K_.MouseWheelX && n.inputIndex !== K_.MouseWheelY && n.inputIndex !== K_.MouseWheelZ || this._onPointerMove(n))
					})) : e.deviceType === Y_.Touch ? e.onInputChangedObservable.add((n => {
						n.inputIndex === K_.LeftClick && (i && 1 === e.getInput(n.inputIndex) ? (this._onPointerDown(n), this._totalPointersPressed > 1 && (this._isMultiTouchGesture = !0)) : t && 0 === e.getInput(n.inputIndex) && (this._onPointerUp(n), 0 === this._totalPointersPressed && (this._isMultiTouchGesture = !1))), s && n.inputIndex === K_.Move && this._onPointerMove(n)
					})) : e.deviceType === Y_.Keyboard && e.onInputChangedObservable.add((e => {
						"keydown" === e.type ? this._onKeyDown(e) : "keyup" === e.type && this._onKeyUp(e)
					}))
				})), this._alreadyAttached = !0
			}
			_processPointerUp(e, t, i) {
				const s = this._scene;
				if (e?.pickedMesh) {
					if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (s.onPointerPick && s.onPointerPick(t, e), i.singleClick && !i.ignore && s.onPointerObservable.observers.length > this._cameraObserverCount)) {
						const i = H_.POINTERPICK,
							n = new W_(i, t, e);
						this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(n, i)
					}
					const n = e.pickedMesh._getActionManagerForTrigger();
					if (n && !i.ignore) {
						n.processTrigger(7, G_.CreateNew(e.pickedMesh, t, e)), !i.hasSwiped && i.singleClick && n.processTrigger(1, G_.CreateNew(e.pickedMesh, t, e));
						const s = e.pickedMesh._getActionManagerForTrigger(6);
						i.doubleClick && s && s.processTrigger(6, G_.CreateNew(e.pickedMesh, t, e))
					}
				} else if (!i.ignore)
					for (const n of s._pointerUpStage) e = n.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, i.doubleClick);
				if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
					const e = this._pickedDownMesh._getActionManagerForTrigger(16);
					e && e.processTrigger(16, G_.CreateNew(this._pickedDownMesh, t))
				}
				if (!i.ignore) {
					const n = new W_(H_.POINTERUP, t, e);
					if (this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(n, H_.POINTERUP), s.onPointerUp && s.onPointerUp(t, e, H_.POINTERUP), !i.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
						let n = 0;
						if (i.singleClick ? n = H_.POINTERTAP : i.doubleClick && (n = H_.POINTERDOUBLETAP), n) {
							const i = new W_(n, t, e);
							s.onPointerObservable.hasObservers() && s.onPointerObservable.hasSpecificMask(n) && s.onPointerObservable.notifyObservers(i, n)
						}
					}
				}
			}
			_setRayOnPointerInfo(e, t) {
				const i = this._scene;
				e && i._pickingAvailable && (e.ray || (e.ray = i.createPickingRay(t.offsetX, t.offsetY, Hc.Identity(), i.activeCamera)))
			}
			_checkPrePointerObservable(e, t, i) {
				const s = this._scene,
					n = new V_(i, t, this._unTranslatedPointerX, this._unTranslatedPointerY);
				return e && (n.originalPickingInfo = e, n.ray = e.ray, "xr-near" === t.pointerType && e.originMesh && (n.nearInteractionPickingInfo = e)), s.onPrePointerObservable.notifyObservers(n, i), !!n.skipOnPointerObservable
			}
			_removeCameraPointerObserver(e) {
				return this._cameraObserverCount--, this._scene.onPointerObservable.remove(e)
			}
			isPointerCaptured(e = 0) {
				return this._pointerCaptures[e]
			}
			constructor(e) {
				this._alreadyAttached = !1, this._meshPickProceed = !1, this._currentPickResult = null, this._previousPickResult = null, this._totalPointersPressed = 0, this._doubleClickOccured = !1, this._isSwiping = !1, this._swipeButtonPressed = -1, this._skipPointerTap = !1, this._isMultiTouchGesture = !1, this._pointerX = 0, this._pointerY = 0, this._startingPointerPosition = new Fc(0, 0), this._previousStartingPointerPosition = new Fc(0, 0), this._startingPointerTime = 0, this._previousStartingPointerTime = 0, this._pointerCaptures = {}, this._meshUnderPointerId = {}, this._movePointerInfo = null, this._cameraObserverCount = 0, this._delayedClicks = [null, null, null, null, null], this._deviceSourceManager = null, this._scene = e || Dc.LastCreatedScene, this._scene
			}
			set pointerX(e) {
				this._pointerX = e
			}
			getPointerOverMesh() {
				return this.meshUnderPointer
			}
			setPointerOverMesh(e, t = 0, i, s) {
				if (!(this._meshUnderPointerId[t] !== e || e && e._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) return;
				const n = this._meshUnderPointerId[t];
				let a;
				n && (a = n._getActionManagerForTrigger(10), a && a.processTrigger(10, G_.CreateNew(n, s, {
					pointerId: t
				}))), e ? (this._meshUnderPointerId[t] = e, this._pointerOverMesh = e, a = e._getActionManagerForTrigger(9), a && a.processTrigger(9, G_.CreateNew(e, s, {
					pointerId: t,
					pickResult: i
				}))) : (delete this._meshUnderPointerId[t], this._pointerOverMesh = null)
			}
			get pointerY() {
				return this._pointerY
			}
			_isPointerSwiping() {
				return this._isSwiping
			}
			simulatePointerUp(e, t, i) {
				const s = new PointerEvent("pointerup", t);
				s.inputIndex = K_.Move;
				const n = new vg;
				i ? n.doubleClick = !0 : n.singleClick = !0, this._checkPrePointerObservable(e, s, H_.POINTERUP) || this._processPointerUp(e, s, n)
			}
			get meshUnderPointer() {
				return this._movePointerInfo && (this._movePointerInfo._generatePickInfo(), this._movePointerInfo = null), this._pointerOverMesh
			}
			_addCameraPointerObserver(e, t) {
				return this._cameraObserverCount++, this._scene.onPointerObservable.add(e, t)
			}
			detachControl() {
				this._alreadyAttached && (this._deviceSourceManager.dispose(), this._deviceSourceManager = null, this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor), this._alreadyAttached = !1, this._alreadyAttachedTo = null)
			}
			getMeshUnderPointerByPointerId(e) {
				return this._meshUnderPointerId[e] || null
			}
			set pointerY(e) {
				this._pointerY = e
			}
			get unTranslatedPointer() {
				return new Fc(this._unTranslatedPointerX, this._unTranslatedPointerY)
			}
			_updatePointerPosition(e) {
				const t = this._scene.getEngine().getInputElementClientRect();
				t && (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY)
			}
			get pointerX() {
				return this._pointerX
			}
			_processPointerMove(e, t) {
				const i = this._scene,
					s = i.getEngine(),
					n = s.getInputElement();
				n && (n.tabIndex = s.canvasTabIndex, i.doNotHandleCursors || (n.style.cursor = i.defaultCursor)), this._setCursorAndPointerOverMesh(e, t, i);
				for (const s of i._pointerMoveStage) {
					e = e || this._pickMove(t);
					const i = !!e?.pickedMesh;
					e = s.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, i, n)
				}
				const a = t.inputIndex >= K_.MouseWheelX && t.inputIndex <= K_.MouseWheelZ ? H_.POINTERWHEEL : H_.POINTERMOVE;
				let r;
				i.onPointerMove && (e = e || this._pickMove(t), i.onPointerMove(t, e, a)), e ? (r = new W_(a, t, e), this._setRayOnPointerInfo(e, t)) : (r = new W_(a, t, null, this), this._movePointerInfo = r), i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(r, a)
			}
			simulatePointerMove(e, t) {
				const i = new PointerEvent("pointermove", t);
				i.inputIndex = K_.Move, this._checkPrePointerObservable(e, i, H_.POINTERMOVE) || this._processPointerMove(e, i)
			}
			_invalidateMesh(e) {
				this._pointerOverMesh === e && (this._pointerOverMesh = null), this._pickedDownMesh === e && (this._pickedDownMesh = null), this._pickedUpMesh === e && (this._pickedUpMesh = null);
				for (const t in this._meshUnderPointerId) this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t]
			}
			_processPointerDown(t, i) {
				const s = this._scene;
				if (t?.pickedMesh) {
					this._pickedDownMesh = t.pickedMesh;
					const n = t.pickedMesh._getActionManagerForTrigger();
					if (n) {
						if (n.hasPickTriggers) switch (n.processTrigger(5, G_.CreateNew(t.pickedMesh, i, t)), i.button) {
							case 0:
								n.processTrigger(2, G_.CreateNew(t.pickedMesh, i, t));
								break;
							case 1:
								n.processTrigger(4, G_.CreateNew(t.pickedMesh, i, t));
								break;
							case 2:
								n.processTrigger(3, G_.CreateNew(t.pickedMesh, i, t))
						}
						n.hasSpecificTrigger(8) && window.setTimeout((() => {
							const t = s.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (e => e.isPickable && e.isVisible && e.isReady() && e.actionManager && e.actionManager.hasSpecificTrigger(8) && e === this._pickedDownMesh), !1, s.cameraToUseForPointers);
							t?.pickedMesh && n && 0 !== this._totalPointersPressed && Date.now() - this._startingPointerTime > e.LongPressDelay && !this._isPointerSwiping() && (this._startingPointerTime = 0, n.processTrigger(8, G_.CreateNew(t.pickedMesh, i)))
						}), e.LongPressDelay)
					}
				} else
					for (const e of s._pointerDownStage) t = e.action(this._unTranslatedPointerX, this._unTranslatedPointerY, t, i, !1);
				let n;
				const a = H_.POINTERDOWN;
				t ? (s.onPointerDown && s.onPointerDown(i, t, a), n = new W_(a, i, t), this._setRayOnPointerInfo(t, i)) : n = new W_(a, i, null, this), s.onPointerObservable.hasObservers() && s.onPointerObservable.notifyObservers(n, a)
			}
		};
	yg.DragMovementThreshold = 10, yg.LongPressDelay = 500, yg.DoubleClickDelay = 300, yg.ExclusiveDoubleClickMode = !1;
	var Sg, Eg, Ag = class {
		constructor() {
			this.pointerDownFastCheck = !1, this.pointerUpFastCheck = !1, this.pointerMoveFastCheck = !1, this.skipPointerMovePicking = !1, this.skipPointerDownPicking = !1, this.skipPointerUpPicking = !1
		}
	};
	(Eg = Sg || (Sg = {}))[Eg.BackwardCompatible = 0] = "BackwardCompatible", Eg[Eg.Intermediate = 1] = "Intermediate", Eg[Eg.Aggressive = 2] = "Aggressive";
	var bg = class e extends O_ {
		static CollisionCoordinatorFactory() {
			throw ic("DefaultCollisionCoordinator")
		}
		removeAnimationGroup(e) {
			const t = this.animationGroups.indexOf(e);
			return -1 !== t && this.animationGroups.splice(t, 1), t
		}
		getPointerOverMesh() {
			return this._inputManager.getPointerOverMesh()
		}
		removeMaterial(e) {
			const t = e._indexInSceneMaterialArray;
			if (-1 !== t && t < this.materials.length) {
				if (t !== this.materials.length - 1) {
					const e = this.materials[this.materials.length - 1];
					this.materials[t] = e, e._indexInSceneMaterialArray = t
				}
				e._indexInSceneMaterialArray = -1, this.materials.pop()
			}
			return this.onMaterialRemovedObservable.notifyObservers(e), t
		}
		getNodeById(e) {
			const t = this.getMeshById(e);
			if (t) return t;
			const i = this.getTransformNodeById(e);
			if (i) return i;
			const s = this.getLightById(e);
			if (s) return s;
			const n = this.getCameraById(e);
			if (n) return n;
			const a = this.getBoneById(e);
			return a || null
		}
		getCameraByUniqueID(e) {
			return this.getCameraByUniqueId(e)
		}
		set animationPropertiesOverride(e) {
			this._animationPropertiesOverride = e
		}
		cleanCachedTextureBuffer() {
			for (const e of this.textures) {
				e._buffer && (e._buffer = null)
			}
		}
		animate() {
			if (this._engine.isDeterministicLockStep()) {
				let t = Math.max(e.MinDeltaTime, Math.min(this._engine.getDeltaTime(), e.MaxDeltaTime)) + this._timeAccumulator;
				const i = this._engine.getTimeStep(),
					s = 1e3 / i / 1e3;
				let n = 0;
				const a = this._engine.getLockstepMaxSteps();
				let r = Math.floor(t / i);
				for (r = Math.min(r, a); t > 0 && n < r;) this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = i * s, this._animate(i), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(i), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, n++, t -= i;
				this._timeAccumulator = t < 0 ? 0 : t
			} else {
				const t = this.useConstantAnimationDeltaTime ? 16 : Math.max(e.MinDeltaTime, Math.min(this._engine.getDeltaTime(), e.MaxDeltaTime));
				this._animationRatio = .06 * t, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(t)
			}
		}
		getLastTransformNodeById(e) {
			for (let t = this.transformNodes.length - 1; t >= 0; t--)
				if (this.transformNodes[t].id === e) return this.transformNodes[t];
			return null
		}
		setActiveCameraByID(e) {
			return this.setActiveCameraById(e)
		}
		get skipPointerDownPicking() {
			return this._pointerPickingConfiguration.skipPointerDownPicking
		}
		getOrAddExternalDataWithFactory(e, t) {
			return this._externalData || (this._externalData = new D_), this._externalData.getOrAddWithFactory(e, t)
		}
		get defaultMaterial() {
			return this._defaultMaterial || (this._defaultMaterial = e.DefaultMaterialFactory(this)), this._defaultMaterial
		}
		getLightByID(e) {
			return this.getLightById(e)
		}
		set beforeCameraRender(e) {
			this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e)
		}
		get pointerY() {
			return this._inputManager.pointerY
		}
		getMeshByID(e) {
			return this.getMeshById(e)
		}
		freeActiveMeshes() {
			if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras))
				for (let e = 0; e < this.activeCameras.length; e++) {
					const t = this.activeCameras[e];
					t && t._activeMeshes && t._activeMeshes.dispose()
				}
		}
		static DefaultMaterialFactory(e) {
			throw ic("StandardMaterial")
		}
		getSkeletonById(e) {
			for (let t = 0; t < this.skeletons.length; t++)
				if (this.skeletons[t].id === e) return this.skeletons[t];
			return null
		}
		set skipPointerMovePicking(e) {
			this._pointerPickingConfiguration.skipPointerMovePicking = e
		}
		get activeParticlesPerfCounter() {
			return this._activeParticles
		}
		_loadFile(e, t, i, s, n, a, r) {
			const o = Wm(e, t, i, s ? this.offlineProvider : void 0, n, a, r);
			return this._activeRequests.push(o), o.onCompleteObservable.add((e => {
				this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
			})), o
		}
		setActiveCameraById(e) {
			const t = this.getCameraById(e);
			return t ? (this.activeCamera = t, t) : null
		}
		addSkeleton(e) {
			this._blockEntityCollection || (this.skeletons.push(e), this.onNewSkeletonAddedObservable.notifyObservers(e))
		}
		getProjectionMatrix() {
			return this._projectionMatrix
		}
		set pointerMoveFastCheck(e) {
			this._pointerPickingConfiguration.pointerMoveFastCheck = e
		}
		getMaterialByID(e) {
			return this.getMaterialById(e)
		}
		getTextureByUniqueId(e) {
			for (let t = 0; t < this.textures.length; t++)
				if (this.textures[t].ik === e) return this.textures[t];
			return null
		}
		set pointerDownPredicate(e) {
			this._pointerPickingConfiguration.pointerDownPredicate = e
		}
		removeActionManager(e) {
			const t = this.actionManagers.indexOf(e);
			return -1 !== t && this.actionManagers.splice(t, 1), t
		}
		getSkeletonByName(e) {
			for (let t = 0; t < this.skeletons.length; t++)
				if (this.skeletons[t].name === e) return this.skeletons[t];
			return null
		}
		get blockMaterialDirtyMechanism() {
			return this._blockMaterialDirtyMechanism
		}
		addAnimationGroup(e) {
			this._blockEntityCollection || this.animationGroups.push(e)
		}
		set texturesEnabled(e) {
			this._texturesEnabled !== e && (this._texturesEnabled = e, this.markAllMaterialsAsDirty(1))
		}
		getActiveIndices() {
			return this._activeIndices.current
		}
		getLastMeshById(e) {
			for (let t = this.meshes.length - 1; t >= 0; t--)
				if (this.meshes[t].id === e) return this.meshes[t];
			return null
		}
		set environmentTexture(e) {
			this._environmentTexture !== e && (this._environmentTexture = e, this.markAllMaterialsAsDirty(1))
		}
		get performancePriority() {
			return this._performancePriority
		}
		getMorphTargetByName(e) {
			for (let t = 0; t < this.morphTargetManagers.length; ++t) {
				const i = this.morphTargetManagers[t];
				for (let t = 0; t < i.numTargets; ++t) {
					const s = i.getTarget(t);
					if (s.name === e) return s
				}
			}
			return null
		}
		set pointerUpPredicate(e) {
			this._pointerPickingConfiguration.pointerUpPredicate = e
		}
		_readFile(e, t, i, s, n) {
			const a = Vm(e, t, i, s, n);
			return this._activeRequests.push(a), a.onCompleteObservable.add((e => {
				this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
			})), a
		}
		_disposeList(e, t) {
			const i = e.slice(0);
			t = t ?? (e => e.dispose());
			for (const e of i) t(e);
			e.length = 0
		}
		addGeometry(e) {
			this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[e.ik] = this.geometries.length), this.geometries.push(e))
		}
		switchActiveCamera(e, t = !0) {
			this._engine.getInputElement() && (this.activeCamera && this.activeCamera.detachControl(), this.activeCamera = e, t && e.attachControl())
		}
		getTransformNodesByID(e) {
			return this.getTransformNodesById(e)
		}
		set pointerX(e) {
			this._inputManager.pointerX = e
		}
		getTransformNodeById(e) {
			for (let t = 0; t < this.transformNodes.length; t++)
				if (this.transformNodes[t].id === e) return this.transformNodes[t];
			return null
		}
		_rebuildTextures() {
			for (const e of this.textures) e._rebuild(!0);
			this.markAllMaterialsAsDirty(1)
		}
		get texturesEnabled() {
			return this._texturesEnabled
		}
		registerAfterRender(e) {
			this.onAfterRenderObservable.add(e)
		}
		removeMultiMaterial(e) {
			const t = this.multiMaterials.indexOf(e);
			return -1 !== t && this.multiMaterials.splice(t, 1), this.onMultiMaterialRemovedObservable.notifyObservers(e), t
		}
		set pointerY(e) {
			this._inputManager.pointerY = e
		}
		set useRightHandedSystem(e) {
			this._useRightHandedSystem !== e && (this._useRightHandedSystem = e, this.markAllMaterialsAsDirty(16))
		}
		_checkIsReady(e = !1) {
			return this._registerTransientComponents(), this.isReady(e) ? (this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), void(this._executeWhenReadyTimeoutId = null)) : this._isDisposed ? (this.onReadyObservable.clear(), void(this._executeWhenReadyTimeoutId = null)) : void(this._executeWhenReadyTimeoutId = setTimeout((() => {
				this.incrementRenderId(), this._checkIsReady(e)
			}), 100))
		}
		registerBeforeRender(e) {
			this.onBeforeRenderObservable.add(e)
		}
		getLightByUniqueID(e) {
			return this.getLightByUniqueId(e)
		}
		updateTransformMatrix(e) {
			const t = this.activeCamera;
			if (t)
				if (t._renderingMultiview) {
					const i = t._rigCameras[0],
						s = t._rigCameras[1];
					this.setTransformMatrix(i.getViewMatrix(), i.getProjectionMatrix(e), s.getViewMatrix(), s.getProjectionMatrix(e))
				} else this.setTransformMatrix(t.getViewMatrix(), t.getProjectionMatrix(e))
		}
		_advancePhysicsEngineStep(e) {}
		simulatePointerUp(e, t, i) {
			return this._inputManager.simulatePointerUp(e, t, i), this
		}
		getInternalStep() {
			return this._currentInternalStep
		}
		getGeometryByID(e) {
			return this.getGeometryById(e)
		}
		_registerTransientComponents() {
			if (this._transientComponents.length > 0) {
				for (const e of this._transientComponents) e.register();
				this._transientComponents.length = 0
			}
		}
		get skipPointerMovePicking() {
			return this._pointerPickingConfiguration.skipPointerMovePicking
		}
		set defaultMaterial(e) {
			this._defaultMaterial = e
		}
		addParticleSystem(e) {
			this._blockEntityCollection || this.particleSystems.push(e)
		}
		getViewMatrix() {
			return this._viewMatrix
		}
		getTotalVertices() {
			return this._totalVertices.current
		}
		getCameraById(e) {
			for (let t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].id === e) return this.cameras[t];
			return null
		}
		unfreezeActiveMeshes() {
			for (let e = 0; e < this.meshes.length; e++) {
				const t = this.meshes[e];
				t._internalAbstractMeshDataInfo && (t._internalAbstractMeshDataInfo._isActive = !1)
			}
			for (let e = 0; e < this._activeMeshes.length; e++) this._activeMeshes.data[e]._unFreeze();
			return this._activeMeshesFrozen = !1, this
		}
		get imageProcessingConfiguration() {
			return this._imageProcessingConfiguration
		}
		getTransformNodeByID(e) {
			return this.getTransformNodeById(e)
		}
		removeLight(e) {
			const t = this.lights.indexOf(e);
			if (-1 !== t) {
				for (const t of this.meshes) t._removeLightSource(e, !1);
				this.lights.splice(t, 1), this.sortLightsByPriority(), e.parent || e._removeFromSceneRootNodes()
			}
			return this.onLightRemovedObservable.notifyObservers(e), t
		}
		setDefaultCandidateProviders() {
			this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates(), this.getActiveSubMeshCandidates = e => this._getDefaultSubMeshCandidates(e), this.getIntersectingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e), this.getCollidingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e)
		}
		_evaluateActiveMeshes() {
			if (this._engine.snapshotRendering && 1 === this._engine.snapshotRenderingMode) return void(this._activeMeshes.length > 0 && (this.activeCamera?._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset()));
			if (this._activeMeshesFrozen && this._activeMeshes.length) {
				if (!this._skipEvaluateActiveMeshesCompletely) {
					const e = this._activeMeshes.length;
					for (let t = 0; t < e; t++) {
						this._activeMeshes.data[t].computeWorldMatrix()
					}
				}
				if (this._activeParticleSystems) {
					const e = this._activeParticleSystems.length;
					for (let t = 0; t < e; t++) this._activeParticleSystems.data[t].animate()
				}
				return void this._renderingManager.resetSprites()
			}
			if (!this.activeCamera) return;
			this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._materialsRenderTargets.reset();
			for (const e of this._beforeEvaluateActiveMeshStage) e.action();
			const e = this.getActiveMeshCandidates(),
				t = e.length;
			for (let i = 0; i < t; i++) {
				const t = e.data[i];
				if (t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1, t.isBlocked) continue;
				if (this._totalVertices.addCount(t.getTotalVertices(), !1), !t.isReady() || !t.isEnabled() || t.scaling.hasAZeroComponent) continue;
				t.computeWorldMatrix(), t.actionManager && t.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(t);
				let s = this.customLODSelector ? this.customLODSelector(t, this.activeCamera) : t.getLOD(this.activeCamera);
				if (t._internalAbstractMeshDataInfo._currentLOD = s, t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0, null != s && (s !== t && 0 !== s.billboardMode && s.computeWorldMatrix(), t._preActivate(), t.isVisible && t.visibility > 0 && t.layerMask & this.activeCamera.layerMask && (this._skipFrustumClipping || t.alwaysSelectAsActiveMesh || t.isInFrustum(this._frustumPlanes)))) {
					this._activeMeshes.push(t), this.activeCamera._activeMeshes.push(t), s !== t && s._activate(this._renderId, !1);
					for (const e of this._preActiveMeshStage) e.action(t);
					t._activate(this._renderId, !1) && (t.isAnInstance ? t._internalAbstractMeshDataInfo._actAsRegularMesh && (s = t) : s._internalAbstractMeshDataInfo._onlyForInstances = !1, s._internalAbstractMeshDataInfo._isActive = !0, this._activeMesh(t, s)), t._postActivate()
				}
			}
			if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this), this.particlesEnabled) {
				this.onBeforeParticlesRenderingObservable.notifyObservers(this);
				for (let e = 0; e < this.particleSystems.length; e++) {
					const t = this.particleSystems[e];
					if (!t.isStarted() || !t.emitter) continue;
					const i = t.emitter;
					i.position && !i.isEnabled() || (this._activeParticleSystems.push(t), t.animate(), this._renderingManager.dispatchParticles(t))
				}
				this.onAfterParticlesRenderingObservable.notifyObservers(this)
			}
		}
		static get LongPressDelay() {
			return yg.LongPressDelay
		}
		get unTranslatedPointer() {
			return this._inputManager.unTranslatedPointer
		}
		getCachedVisibility() {
			return this._cachedVisibility
		}
		dispose() {
			if (this.isDisposed) return;
			this.beforeRender = null, this.afterRender = null, this.metadata = null, this.skeletons.length = 0, this.morphTargetManagers.length = 0, this._transientComponents.length = 0, this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._preActiveMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderTargetDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderTargetDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear(), this.importedMeshesFiles = [], this.stopAllAnimations && (this._activeAnimatables.forEach((e => {
				e.onAnimationEndObservable.clear(), e.onAnimationEnd = null
			})), this.stopAllAnimations()), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this.activeCameras = null, this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._materialsRenderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed.length = 0;
			const e = this._activeRequests.slice();
			for (const t of e) t.abort();
			this._activeRequests.length = 0;
			try {
				this.onDisposeObservable.notifyObservers(this)
			} catch (e) {
				Qc.Error("An error occurred while calling onDisposeObservable!", e)
			}
			this.detachControl();
			if (this._engine.getInputElement())
				for (let e = 0; e < this.cameras.length; e++) this.cameras[e].detachControl();
			this._disposeList(this.animationGroups), this._disposeList(this.lights), this._disposeList(this.meshes, (e => e.dispose(!0))), this._disposeList(this.transformNodes, (e => e.dispose(!0)));
			const t = this.cameras;
			this._disposeList(t), this._defaultMaterial && this._defaultMaterial.dispose(), this._disposeList(this.multiMaterials), this._disposeList(this.materials), this._disposeList(this.particleSystems), this._disposeList(this.postProcesses), this._disposeList(this.textures), this._disposeList(this.morphTargetManagers), this._sceneUbo.dispose(), this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(), this.postProcessManager.dispose(), this._disposeList(this._components);
			let i = this._engine.scenes.indexOf(this);
			i > -1 && this._engine.scenes.splice(i, 1), Dc._LastCreatedScene === this && (this._engine.scenes.length > 0 ? Dc._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : Dc._LastCreatedScene = null), i = this._engine._virtualScenes.indexOf(this), i > -1 && this._engine._virtualScenes.splice(i, 1), this._engine.wipeCaches(!0), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onAfterRenderCameraObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewSkeletonAddedObservable.clear(), this.onSkeletonRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onNewMultiMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onMultiMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.onActiveCameraChanged.clear(), this.onScenePerformancePriorityChangedObservable.clear(), this._isDisposed = !0
		}
		get forceWireframe() {
			return this._forceWireframe
		}
		isActiveMesh(e) {
			return -1 !== this._activeMeshes.indexOf(e)
		}
		set pointerMovePredicate(e) {
			this._pointerPickingConfiguration.pointerMovePredicate = e
		}
		addPendingData(e) {
			this._pendingData.push(e)
		}
		_getDefaultMeshCandidates() {
			return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates
		}
		multiPickWithRay(e, t, i) {
			throw ic("Ray")
		}
		addCamera(e) {
			this._blockEntityCollection || (this.cameras.push(e), this.onNewCameraAddedObservable.notifyObservers(e), e.parent || e._addToSceneRootNodes())
		}
		setPointerOverMesh(e, t, i) {
			this._inputManager.setPointerOverMesh(e, t, i)
		}
		set forceWireframe(e) {
			this._forceWireframe !== e && (this._forceWireframe = e, this.markAllMaterialsAsDirty(16))
		}
		getMorphTargetById(e) {
			for (let t = 0; t < this.morphTargetManagers.length; ++t) {
				const i = this.morphTargetManagers[t];
				for (let t = 0; t < i.numTargets; ++t) {
					const s = i.getTarget(t);
					if (s.id === e) return s
				}
			}
			return null
		}
		sortLightsByPriority() {
			this.requireLightSorting && this.lights.sort($d.CompareLightsPriority)
		}
		_clearFrameBuffer(e) {
			if (e && e._multiviewTexture);
			else if (e && e.outputRenderTarget && !e._renderingMultiview) {
				const t = e.outputRenderTarget;
				t.onClearObservable.hasObservers() ? t.onClearObservable.notifyObservers(this._engine) : t.skipInitialClear || e.isRightCamera || (this.autoClear && this._engine.clear(t.clearColor || this.clearColor, !t._cleared, !0, !0), t._cleared = !0)
			} else this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0, this._clear())
		}
		getCameraByName(e) {
			for (let t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].name === e) return this.cameras[t];
			return null
		}
		getLightById(e) {
			for (let t = 0; t < this.lights.length; t++)
				if (this.lights[t].id === e) return this.lights[t];
			return null
		}
		_clear() {
			(this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil)
		}
		get forcePointsCloud() {
			return this._forcePointsCloud
		}
		removeSkeleton(e) {
			const t = this.skeletons.indexOf(e);
			return -1 !== t && (this.skeletons.splice(t, 1), this.onSkeletonRemovedObservable.notifyObservers(e), this._executeActiveContainerCleanup(this._activeSkeletons)), t
		}
		getLightsByTags(e, t) {
			return this._getByTags(this.lights, e, t)
		}
		freeRenderingGroups() {
			if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures))
				for (let e = 0; e < this.textures.length; e++) {
					const t = this.textures[e];
					t && t.Tk && t.freeRenderingGroups()
				}
		}
		addMultiMaterial(e) {
			this._blockEntityCollection || (this.multiMaterials.push(e), this.onNewMultiMaterialAddedObservable.notifyObservers(e))
		}
		getLightByUniqueId(e) {
			for (let t = 0; t < this.lights.length; t++)
				if (this.lights[t].ik === e) return this.lights[t];
			return null
		}
		_processSubCameras(e, t = !0) {
			if (0 === e.cameraRigMode || e._renderingMultiview) return e._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(), this._renderForCamera(e, void 0, t), void this.onAfterRenderCameraObservable.notifyObservers(e);
			if (e._useMultiviewToSingleView) this._renderMultiviewToSingleView(e);
			else {
				this.onBeforeCameraRenderObservable.notifyObservers(e);
				for (let t = 0; t < e._rigCameras.length; t++) this._renderForCamera(e._rigCameras[t], e)
			}
			this._activeCamera = e, this.updateTransformMatrix(), this.onAfterRenderCameraObservable.notifyObservers(e)
		}
		removeParticleSystem(e) {
			const t = this.particleSystems.indexOf(e);
			return -1 !== t && (this.particleSystems.splice(t, 1), this._executeActiveContainerCleanup(this._activeParticleSystems)), t
		}
		getBoneByName(e) {
			for (let t = 0; t < this.skeletons.length; t++) {
				const i = this.skeletons[t];
				for (let t = 0; t < i.bones.length; t++)
					if (i.bones[t].name === e) return i.bones[t]
			}
			return null
		}
		incrementRenderId() {
			this._renderId++
		}
		unregisterAfterRender(e) {
			this.onAfterRenderObservable.removeCallback(e)
		}
		set blockMaterialDirtyMechanism(e) {
			this._blockMaterialDirtyMechanism !== e && (this._blockMaterialDirtyMechanism = e, e || this.markAllMaterialsAsDirty(63))
		}
		removeTexture(e) {
			const t = this.textures.indexOf(e);
			return -1 !== t && this.textures.splice(t, 1), this.onTextureRemovedObservable.notifyObservers(e), t
		}
		getAnimationGroupByName(e) {
			for (let t = 0; t < this.animationGroups.length; t++)
				if (this.animationGroups[t].name === e) return this.animationGroups[t];
			return null
		}
		resetCachedMaterial() {
			this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null
		}
		_bindFrameBuffer(e, t = !0) {
			e && e._multiviewTexture ? e._multiviewTexture._bindFrameBuffer() : e && e.outputRenderTarget ? e.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(), t && this._clearFrameBuffer(e)
		}
		getSceneUniformBuffer() {
			return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo
		}
		get meshUnderPointer() {
			return this._inputManager.meshUnderPointer
		}
		static set DragMovementThreshold(e) {
			yg.DragMovementThreshold = e
		}
		getTransformNodeByUniqueID(e) {
			return this.getTransformNodeByUniqueId(e)
		}
		get prePass() {
			return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled
		}
		get fogEnabled() {
			return this._fogEnabled
		}
		set skipPointerDownPicking(e) {
			this._pointerPickingConfiguration.skipPointerDownPicking = e
		}
		addMesh(e, t = !1) {
			this._blockEntityCollection || (this.meshes.push(e), e._resyncLightSources(), e.parent || e._addToSceneRootNodes(), this.onNewMeshAddedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((e => {
				this.addMesh(e)
			})))
		}
		getWorldExtends(e) {
			const t = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
				i = new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			return e = e || (() => !0), this.meshes.filter(e).forEach((e => {
				if (e.computeWorldMatrix(!0), !e.subMeshes || 0 === e.subMeshes.length || e.infiniteDistance) return;
				const s = e.getBoundingInfo(),
					n = s.boundingBox.minimumWorld,
					a = s.boundingBox.maximumWorld;
				Lc.CheckExtends(n, t, i), Lc.CheckExtends(a, t, i)
			})), {
				min: t,
				max: i
			}
		}
		_getByTags(e, t, i) {
			if (void 0 === t) return e;
			const s = [];
			for (const n in e) {
				const a = e[n];
				nc && nc.MatchesQuery(a, t) && (!i || i(a)) && s.push(a)
			}
			return s
		}
		static set LongPressDelay(e) {
			yg.LongPressDelay = e
		}
		getGeometries() {
			return this.geometries
		}
		static get ExclusiveDoubleClickMode() {
			return yg.ExclusiveDoubleClickMode
		}
		getCachedMaterial() {
			return this._cachedMaterial
		}
		get shadowsEnabled() {
			return this._shadowsEnabled
		}
		resetLastAnimationTimeFrame() {
			this._animationTimeLast = Pu.Now
		}
		removeGeometry(e) {
			let t;
			if (this._geometriesByUniqueId) {
				if (t = this._geometriesByUniqueId[e.ik], void 0 === t) return !1
			} else if (t = this.geometries.indexOf(e), t < 0) return !1;
			if (t !== this.geometries.length - 1) {
				const e = this.geometries[this.geometries.length - 1];
				e && (this.geometries[t] = e, this._geometriesByUniqueId && (this._geometriesByUniqueId[e.ik] = t))
			}
			return this._geometriesByUniqueId && (this._geometriesByUniqueId[e.ik] = void 0), this.geometries.pop(), this.onGeometryRemovedObservable.notifyObservers(e), !0
		}
		_addComponent(e) {
			this._components.push(e), this._transientComponents.push(e);
			const t = e;
			t.addFromContainer && t.serialize && this._serializableComponents.push(t)
		}
		createPickingRayInCameraSpaceToRef(e, t, i, s) {
			throw ic("Ray")
		}
		get activeCamera() {
			return this._activeCamera
		}
		getActiveParticles() {
			return this._activeParticles.current
		}
		stopAnimation(e, t, i) {}
		set activeCameras(e) {
			this._unObserveActiveCameras && (this._unObserveActiveCameras(), this._unObserveActiveCameras = null), e && (this._unObserveActiveCameras = lc(e, (() => {
				this.onActiveCamerasChanged.notifyObservers(this)
			}))), this._activeCameras = e
		}
		get renderingManager() {
			return this._renderingManager
		}
		getMeshById(e) {
			for (let t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].id === e) return this.meshes[t];
			return null
		}
		_evaluateSubMesh(e, t, i, s) {
			if (s || e.isInFrustum(this._frustumPlanes)) {
				for (const i of this._evaluateSubMeshStage) i.action(t, e);
				const i = e.getMaterial();
				null != i && (i.hasRenderTargetTextures && null != i.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(i) && (this._processedMaterials.push(i), this._materialsRenderTargets.concatWithNoDuplicate(i.getRenderTargetTextures())), this._renderingManager.dispatch(e, t, i))
			}
		}
		_renderForCamera(e, t, i = !0) {
			if (e && e._skipRendering) return;
			const s = this._engine;
			if (this._activeCamera = e, !this.activeCamera) throw new Error("Active camera not set");
			if (s.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, !this.prePass && i) {
				let t = !0;
				e._renderingMultiview && e.outputRenderTarget && (t = e.outputRenderTarget.skipInitialClear, this.autoClear && (this._defaultFrameBufferCleared = !1, e.outputRenderTarget.skipInitialClear = !1)), this._bindFrameBuffer(this._activeCamera), e._renderingMultiview && e.outputRenderTarget && (e.outputRenderTarget.skipInitialClear = t)
			}
			this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes();
			for (let e = 0; e < this._softwareSkinnedMeshes.length; e++) {
				const t = this._softwareSkinnedMeshes.data[e];
				t.applySkeleton(t.skeleton)
			}
			this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets), e.customRenderTargets && e.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets), t && t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets), this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture);
			for (const e of this._gatherActiveCameraRenderTargetsStage) e.action(this._renderTargets);
			let n = !1;
			if (this.renderTargetsEnabled) {
				if (this._intermediateRendering = !0, this._renderTargets.length > 0) {
					dd.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
					for (let e = 0; e < this._renderTargets.length; e++) {
						const t = this._renderTargets.data[e];
						if (t._shouldRender()) {
							this._renderId++;
							const e = t.activeCamera && t.activeCamera !== this.activeCamera;
							t.render(e, this.dumpNextRenderTargets), n = !0
						}
					}
					dd.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._renderId++
				}
				for (const e of this._cameraDrawRenderTargetStage) n = e.action(this.activeCamera) || n;
				this._intermediateRendering = !1
			}
			this._engine.currentRenderPassId = e.outputRenderTarget?.renderPassId ?? e.renderPassId ?? 0, n && !this.prePass && (this._bindFrameBuffer(this._activeCamera, !1), this.updateTransformMatrix()), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), !this.postProcessManager || e._multiviewTexture || this.prePass || this.postProcessManager._prepareFrame();
			for (const e of this._beforeCameraDrawStage) e.action(this.activeCamera);
			this.onBeforeDrawPhaseObservable.notifyObservers(this), s.snapshotRendering && 1 === s.snapshotRenderingMode && this.finalizeSceneUbo(), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this);
			for (const e of this._afterCameraDrawStage) e.action(this.activeCamera);
			if (this.postProcessManager && !e._multiviewTexture) {
				const t = e.outputRenderTarget ? e.outputRenderTarget.renderTarget : void 0;
				this.postProcessManager._finalizeFrame(e.isIntermediate, t)
			}
			for (const e of this._afterCameraPostProcessStage) e.action(this.activeCamera);
			this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)
		}
		_forceBlockMaterialDirtyMechanism(e) {
			this._blockMaterialDirtyMechanism = e
		}
		get isDisposed() {
			return this._isDisposed
		}
		whenReadyAsync(e = !1) {
			return new Promise((t => {
				this.executeWhenReady((() => {
					t()
				}), e)
			}))
		}
		_getMaterial(e, t) {
			for (let e = 0; e < this.materials.length; e++) {
				const i = this.materials[e];
				if (t(i)) return i
			}
			if (e)
				for (let e = 0; e < this.multiMaterials.length; e++) {
					const i = this.multiMaterials[e];
					if (t(i)) return i
				}
			return null
		}
		_loadFileAsync(e, t, i, s, n) {
			return new Promise(((a, r) => {
				this._loadFile(e, (e => {
					a(e)
				}), t, i, s, ((e, t) => {
					r(t)
				}), n)
			}))
		}
		getLastMaterialByID(e) {
			return this.getLastMaterialById(e)
		}
		set afterRender(e) {
			this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e))
		}
		get collisionCoordinator() {
			return this._collisionCoordinator || (this._collisionCoordinator = e.CollisionCoordinatorFactory(), this._collisionCoordinator.init(this)), this._collisionCoordinator
		}
		set skipPointerUpPicking(e) {
			this._pointerPickingConfiguration.skipPointerUpPicking = e
		}
		getMaterialByName(e, t = !1) {
			return this._getMaterial(t, (t => t.name === e))
		}
		set fogEnabled(e) {
			this._fogEnabled !== e && (this._fogEnabled = e, this.markAllMaterialsAsDirty(16))
		}
		get skipFrustumClipping() {
			return this._skipFrustumClipping
		}
		_checkIntersections() {
			for (let e = 0; e < this._meshesForIntersections.length; e++) {
				const t = this._meshesForIntersections.data[e];
				if (t.actionManager)
					for (let e = 0; t.actionManager && e < t.actionManager.actions.length; e++) {
						const i = t.actionManager.actions[e];
						if (12 === i.trigger || 13 === i.trigger) {
							const e = i.getTriggerParameter(),
								s = e.mesh ? e.mesh : e,
								n = s.intersectsMesh(t, e.usePreciseIntersection),
								a = t._intersectionsInProgress.indexOf(s);
							n && -1 === a ? 12 === i.trigger ? (i._executeCurrent(G_.CreateNew(t, void 0, s)), t._intersectionsInProgress.push(s)) : 13 === i.trigger && t._intersectionsInProgress.push(s) : !n && a > -1 && (13 === i.trigger && i._executeCurrent(G_.CreateNew(t, void 0, s)), t.actionManager.hasSpecificTrigger(13, (e => {
								const t = e.mesh ? e.mesh : e;
								return s === t
							})) && 13 !== i.trigger || t._intersectionsInProgress.splice(a, 1))
						}
					}
			}
		}
		getGeometryById(e) {
			for (let t = 0; t < this.geometries.length; t++)
				if (this.geometries[t].id === e) return this.geometries[t];
			return null
		}
		addActionManager(e) {
			this.actionManagers.push(e)
		}
		getExternalData(e) {
			return this._externalData ? this._externalData.get(e) : null
		}
		_isInIntermediateRendering() {
			return this._intermediateRendering
		}
		static set DoubleClickDelay(e) {
			yg.DoubleClickDelay = e
		}
		getTransformNodeByName(e) {
			for (let t = 0; t < this.transformNodes.length; t++)
				if (this.transformNodes[t].name === e) return this.transformNodes[t];
			return null
		}
		getMeshesByTags(e, t) {
			return this._getByTags(this.meshes, e, t)
		}
		simulatePointerMove(e, t) {
			return this._inputManager.simulatePointerMove(e, t), this
		}
		createPickingRayToRef(e, t, i, s, n, a = !1, r = !1) {
			throw ic("Ray")
		}
		resetDrawCache(e) {
			if (this.meshes)
				for (const t of this.meshes) t.resetDrawCache(e)
		}
		getLastEntryById(e) {
			let t;
			for (t = this.meshes.length - 1; t >= 0; t--)
				if (this.meshes[t].id === e) return this.meshes[t];
			for (t = this.transformNodes.length - 1; t >= 0; t--)
				if (this.transformNodes[t].id === e) return this.transformNodes[t];
			for (t = this.cameras.length - 1; t >= 0; t--)
				if (this.cameras[t].id === e) return this.cameras[t];
			for (t = this.lights.length - 1; t >= 0; t--)
				if (this.lights[t].id === e) return this.lights[t];
			return null
		}
		getTransformNodesById(e) {
			return this.transformNodes.filter((function(t) {
				return t.id === e
			}))
		}
		removePendingData(e) {
			const t = this.isLoading,
				i = this._pendingData.indexOf(e); - 1 !== i && this._pendingData.splice(i, 1), t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this)
		}
		getCachedEffect() {
			return this._cachedEffect
		}
		setStepId(e) {
			this._currentStepId = e
		}
		getTextureByName(e) {
			for (let t = 0; t < this.textures.length; t++)
				if (this.textures[t].name === e) return this.textures[t];
			return null
		}
		get _pickingAvailable() {
			return !1
		}
		get pointerUpPredicate() {
			return this._pointerPickingConfiguration.pointerUpPredicate
		}
		get skipPointerUpPicking() {
			return this._pointerPickingConfiguration.skipPointerUpPicking
		}
		clearCachedVertexData() {
			for (let e = 0; e < this.meshes.length; e++) {
				const t = this.meshes[e].geometry;
				t && t.clearCachedData()
			}
		}
		render(e = !0, t = !1) {
			if (this.isDisposed) return;
			this.onReadyObservable.hasObservers() && null === this._executeWhenReadyTimeoutId && this._checkIsReady(), this._frameId++, this._defaultFrameBufferCleared = !1, this._checkCameraRenderTarget(this.activeCamera), this.activeCameras?.length && this.activeCameras.forEach(this._checkCameraRenderTarget), this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(11), t || this.animate();
			for (const e of this._beforeCameraUpdateStage) e.action();
			if (e)
				if (this.activeCameras && this.activeCameras.length > 0)
					for (let e = 0; e < this.activeCameras.length; e++) {
						const t = this.activeCameras[e];
						if (t.update(), 0 !== t.cameraRigMode)
							for (let e = 0; e < t._rigCameras.length; e++) t._rigCameras[e].update()
					} else if (this.activeCamera && (this.activeCamera.update(), 0 !== this.activeCamera.cameraRigMode))
						for (let e = 0; e < this.activeCamera._rigCameras.length; e++) this.activeCamera._rigCameras[e].update();
			this.onBeforeRenderObservable.notifyObservers(this);
			const i = this.getEngine();
			this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
			const s = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;
			if (this.renderTargetsEnabled) {
				dd.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !0;
				for (let e = 0; e < this.customRenderTargets.length; e++) {
					const t = this.customRenderTargets[e];
					if (t._shouldRender()) {
						if (this._renderId++, this.activeCamera = t.activeCamera || this.activeCamera, !this.activeCamera) throw new Error("Active camera not set");
						i.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), t.render(s !== this.activeCamera, this.dumpNextRenderTargets)
					}
				}
				dd.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !1, this._renderId++
			}
			this._engine.currentRenderPassId = s?.renderPassId ?? 0, this.activeCamera = s, this._activeCamera && 22 !== this._activeCamera.cameraRigMode && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
			for (const e of this._beforeClearStage) e.action();
			this._clearFrameBuffer(this.activeCamera);
			for (const e of this._gatherRenderTargetsStage) e.action(this._renderTargets);
			if (this.activeCameras && this.activeCameras.length > 0)
				for (let e = 0; e < this.activeCameras.length; e++) this._processSubCameras(this.activeCameras[e], e > 0);
			else {
				if (!this.activeCamera) throw new Error("No camera defined");
				this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget)
			}
			this._checkIntersections();
			for (const e of this._afterRenderStage) e.action();
			if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) {
				for (let e = 0; e < this._toBeDisposed.length; e++) {
					const t = this._toBeDisposed[e];
					t && t.dispose()
				}
				this._toBeDisposed.length = 0
			}
			this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0), this._engine.restoreDefaultFramebuffer()
		}
		removeMesh(e, t = !1) {
			const i = this.meshes.indexOf(e);
			return -1 !== i && (this.meshes[i] = this.meshes[this.meshes.length - 1], this.meshes.pop(), e.parent || e._removeFromSceneRootNodes()), this._inputManager._invalidateMesh(e), this.onMeshRemovedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((e => {
				this.removeMesh(e)
			})), i
		}
		getNodeByID(e) {
			return this.getNodeById(e)
		}
		get blockfreeActiveMeshesAndRenderingGroups() {
			return this._preventFreeActiveMeshesAndRenderingGroups
		}
		executeOnceBeforeRender(e, t) {
			void 0 !== t ? setTimeout((() => {
				this._executeOnceBeforeRender(e)
			}), t) : this._executeOnceBeforeRender(e)
		}
		setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
			this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, s)
		}
		_requestFile(e, t, i, s, n, a, r) {
			const o = zm(e, t, i, s ? this.offlineProvider : void 0, n, a, r);
			return this._activeRequests.push(o), o.onCompleteObservable.add((e => {
				this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
			})), o
		}
		markAllMaterialsAsDirty(e, t) {
			if (!this._blockMaterialDirtyMechanism)
				for (const i of this.materials) t && !t(i) || i.markAsDirty(e)
		}
		getTransformNodesByTags(e, t) {
			return this._getByTags(this.transformNodes, e, t)
		}
		get uid() {
			return this._uid || (this._uid = dd.RandomId()), this._uid
		}
		_animate(e) {}
		getPerfCollector() {
			throw ic("performanceViewerSceneExtension")
		}
		set blockfreeActiveMeshesAndRenderingGroups(e) {
			this._preventFreeActiveMeshesAndRenderingGroups !== e && (e && (this.freeActiveMeshes(), this.freeRenderingGroups()), this._preventFreeActiveMeshesAndRenderingGroups = e)
		}
		set onDispose(e) {
			this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
		}
		getMeshesById(e) {
			return this.meshes.filter((function(t) {
				return t.id === e
			}))
		}
		_rebuildGeometries() {
			for (const e of this.geometries) e._rebuild();
			for (const e of this.meshes) e._rebuild();
			this.postProcessManager && this.postProcessManager._rebuild();
			for (const e of this._components) e.rebuild();
			for (const e of this.particleSystems) e.rebuild();
			if (this.spriteManagers)
				for (const e of this.spriteManagers) e.rebuild()
		}
		removeTransformNode(e) {
			const t = e._indexInSceneTransformNodesArray;
			if (-1 !== t) {
				if (t !== this.transformNodes.length - 1) {
					const e = this.transformNodes[this.transformNodes.length - 1];
					this.transformNodes[t] = e, e._indexInSceneTransformNodesArray = t
				}
				e._indexInSceneTransformNodesArray = -1, this.transformNodes.pop(), e.parent || e._removeFromSceneRootNodes()
			}
			return this.onTransformNodeRemovedObservable.notifyObservers(e), t
		}
		getMeshByUniqueID(e) {
			return this.getMeshByUniqueId(e)
		}
		get isLoading() {
			return this._pendingData.length > 0
		}
		_createUbo() {
			this.setSceneUniformBuffer(this.createSceneUniformBuffer())
		}
		get pointerDownPredicate() {
			return this._pointerPickingConfiguration.pointerDownPredicate
		}
		addExternalData(e, t) {
			return this._externalData || (this._externalData = new D_), this._externalData.add(e, t)
		}
		createSceneUniformBuffer(e) {
			const t = new Bd(this._engine, void 0, !1, e ?? "scene");
			return t.addUniform("viewProjection", 16), t.addUniform("view", 16), t.addUniform("projection", 16), t.addUniform("vEyePosition", 4), t
		}
		getSkeletonByUniqueId(e) {
			for (let t = 0; t < this.skeletons.length; t++)
				if (this.skeletons[t].ik === e) return this.skeletons[t];
			return null
		}
		createPickingRayInCameraSpace(e, t, i) {
			throw ic("Ray")
		}
		addMaterial(e) {
			this._blockEntityCollection || e.getScene() === this && -1 !== e._indexInSceneMaterialArray || (e._indexInSceneMaterialArray = this.materials.length, this.materials.push(e), this.onNewMaterialAddedObservable.notifyObservers(e))
		}
		addMorphTargetManager(e) {
			this._blockEntityCollection || this.morphTargetManagers.push(e)
		}
		get frustumPlanes() {
			return this._frustumPlanes
		}
		isPointerCaptured(e = 0) {
			return this._inputManager.isPointerCaptured(e)
		}
		set fogMode(e) {
			this._fogMode !== e && (this._fogMode = e, this.markAllMaterialsAsDirty(16))
		}
		static get DragMovementThreshold() {
			return yg.DragMovementThreshold
		}
		getNodeByName(e) {
			const t = this.getMeshByName(e);
			if (t) return t;
			const i = this.getTransformNodeByName(e);
			if (i) return i;
			const s = this.getLightByName(e);
			if (s) return s;
			const n = this.getCameraByName(e);
			if (n) return n;
			const a = this.getBoneByName(e);
			return a || null
		}
		getBoneById(e) {
			for (let t = 0; t < this.skeletons.length; t++) {
				const i = this.skeletons[t];
				for (let t = 0; t < i.bones.length; t++)
					if (i.bones[t].id === e) return i.bones[t]
			}
			return null
		}
		pick(e, t, i, s, n, a) {
			const r = ic("Ray", !0);
			return r && Qc.Warn(r), new Ld
		}
		get lightsEnabled() {
			return this._lightsEnabled
		}
		getMeshByUniqueId(e) {
			for (let t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].ik === e) return this.meshes[t];
			return null
		}
		_activeMesh(e, t) {
			this._skeletonsEnabled && null !== t.skeleton && void 0 !== t.skeleton && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && (t.skeleton.prepare(), this._activeBones.addCount(t.skeleton.bones.length, !1)), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t));
			let i = e.hasInstances || e.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || t.alwaysSelectAsActiveMesh;
			if (t && t.subMeshes && t.subMeshes.length > 0) {
				const s = this.getActiveSubMeshCandidates(t),
					n = s.length;
				i = i || 1 === n;
				for (let a = 0; a < n; a++) {
					const n = s.data[a];
					this._evaluateSubMesh(n, t, e, i)
				}
			}
		}
		getPostProcessByName(e) {
			for (let t = 0; t < this.postProcesses.length; ++t) {
				const i = this.postProcesses[t];
				if (i.name === e) return i
			}
			return null
		}
		set beforeRender(e) {
			this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e))
		}
		getMeshByName(e) {
			for (let t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].name === e) return this.meshes[t];
			return null
		}
		get fogMode() {
			return this._fogMode
		}
		freezeActiveMeshes(e = !1, t, i, s = !0, n = !1) {
			return this.executeWhenReady((() => {
				if (this.activeCamera) {
					if (this._frustumPlanes || this.updateTransformMatrix(), this._evaluateActiveMeshes(), this._activeMeshesFrozen = !0, this._activeMeshesFrozenButKeepClipping = n, this._skipEvaluateActiveMeshesCompletely = e, s)
						for (let e = 0; e < this._activeMeshes.length; e++) this._activeMeshes.data[e]._freeze();
					t && t()
				} else i && i("No active camera found")
			})), this
		}
		getLastSkeletonByID(e) {
			return this.getLastSkeletonById(e)
		}
		getEngine() {
			return this._engine
		}
		get animationPropertiesOverride() {
			return this._animationPropertiesOverride
		}
		_requestFileAsync(e, t, i, s, n) {
			return new Promise(((a, r) => {
				this._requestFile(e, (e => {
					a(e)
				}), t, i, s, (e => {
					r(e)
				}), n)
			}))
		}
		getRenderId() {
			return this._renderId
		}
		getLastMeshByID(e) {
			return this.getLastMeshById(e)
		}
		getMaterialByTags(e, t) {
			return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t))
		}
		getLastMaterialById(e, t = !1) {
			for (let t = this.materials.length - 1; t >= 0; t--)
				if (this.materials[t].id === e) return this.materials[t];
			if (t)
				for (let t = this.multiMaterials.length - 1; t >= 0; t--)
					if (this.multiMaterials[t].id === e) return this.multiMaterials[t];
			return null
		}
		get animatables() {
			return this._activeAnimatables
		}
		_executeOnceBeforeRender(e) {
			const t = () => {
				e(), setTimeout((() => {
					this.unregisterBeforeRender(t)
				}))
			};
			this.registerBeforeRender(t)
		}
		attachControl(e = !0, t = !0, i = !0) {
			this._inputManager.attachControl(e, t, i)
		}
		get totalVerticesPerfCounter() {
			return this._totalVertices
		}
		pickWithBoundingInfo(e, t, i, s, n) {
			const a = ic("Ray", !0);
			return a && Qc.Warn(a), new Ld
		}
		bindEyePosition(e, t = "vEyePosition", i = !1) {
			const s = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera.globalPosition,
				n = this.useRightHandedSystem === (null != this._mirroredCameraPosition);
			return Vc.Vector4[0].set(s.x, s.y, s.z, n ? -1 : 1), e && (i ? e.setFloat3(t, Vc.Vector4[0].x, Vc.Vector4[0].y, Vc.Vector4[0].z) : e.setVector4(t, Vc.Vector4[0])), Vc.Vector4[0]
		}
		set afterCameraRender(e) {
			this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e)
		}
		addLight(e) {
			if (!this._blockEntityCollection) {
				this.lights.push(e), this.sortLightsByPriority(), e.parent || e._addToSceneRootNodes();
				for (const t of this.meshes) - 1 === t.lightSources.indexOf(e) && (t.lightSources.push(e), t._resyncLightSources());
				this.onNewLightAddedObservable.notifyObservers(e)
			}
		}
		getCamerasByTags(e, t) {
			return this._getByTags(this.cameras, e, t)
		}
		getTransformNodeByUniqueId(e) {
			for (let t = 0; t < this.transformNodes.length; t++)
				if (this.transformNodes[t].ik === e) return this.transformNodes[t];
			return null
		}
		setActiveCameraByName(e) {
			const t = this.getCameraByName(e);
			return t ? (this.activeCamera = t, t) : null
		}
		getCameraByID(e) {
			return this.getCameraById(e)
		}
		getStepId() {
			return this._currentStepId
		}
		isCachedMaterialInvalid(e, t, i = 1) {
			return this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i
		}
		getMaterialById(e, t = !1) {
			return this._getMaterial(t, (t => t.id === e))
		}
		getAutoClearDepthStencilSetup(e) {
			return this._renderingManager.getAutoClearDepthStencilSetup(e)
		}
		getMorphTargetManagerById(e) {
			for (let t = 0; t < this.morphTargetManagers.length; t++)
				if (this.morphTargetManagers[t].ik === e) return this.morphTargetManagers[t];
			return null
		}
		removeExternalData(e) {
			return this._externalData.remove(e)
		}
		get skeletonsEnabled() {
			return this._skeletonsEnabled
		}
		set shadowsEnabled(e) {
			this._shadowsEnabled !== e && (this._shadowsEnabled = e, this.markAllMaterialsAsDirty(2))
		}
		detachControl() {
			this._inputManager.detachControl()
		}
		get pointerUpFastCheck() {
			return this._pointerPickingConfiguration.pointerUpFastCheck
		}
		getParticleSystemByID(e) {
			return this.getParticleSystemById(e)
		}
		getFrameId() {
			return this._frameId
		}
		get pointerMovePredicate() {
			return this._pointerPickingConfiguration.pointerMovePredicate
		}
		getWaitingItemsCount() {
			return this._pendingData.length
		}
		unfreezeMaterials() {
			for (let e = 0; e < this.materials.length; e++) this.materials[e].unfreeze()
		}
		createPickingRay(e, t, i, s, n = !1) {
			throw ic("Ray")
		}
		constructor(t, i) {
			super(), this._inputManager = new yg(this), this.cameraToUseForPointers = null, this._isScene = !0, this._blockEntityCollection = !1, this.autoClear = !0, this.autoClearDepthAndStencil = !0, this.clearColor = new wc(.2, .2, .3, 1), this.ambientColor = new Tc(0, 0, 0), this.environmentIntensity = 1, this._performancePriority = 0, this.onScenePerformancePriorityChangedObservable = new kc, this._forceWireframe = !1, this._skipFrustumClipping = !1, this._forcePointsCloud = !1, this.animationsEnabled = !0, this._animationPropertiesOverride = null, this.useConstantAnimationDeltaTime = !1, this.constantlyUpdateMeshUnderPointer = !1, this.hoverCursor = "pointer", this.defaultCursor = "", this.doNotHandleCursors = !1, this.preventDefaultOnPointerDown = !0, this.preventDefaultOnPointerUp = !0, this.metadata = null, this.reservedDataStore = null, this.disableOfflineSupportExceptionRules = [], this.onDisposeObservable = new kc, this._onDisposeObserver = null, this.onBeforeRenderObservable = new kc, this._onBeforeRenderObserver = null, this.onAfterRenderObservable = new kc, this.onAfterRenderCameraObservable = new kc, this._onAfterRenderObserver = null, this.onBeforeAnimationsObservable = new kc, this.onAfterAnimationsObservable = new kc, this.onBeforeDrawPhaseObservable = new kc, this.onAfterDrawPhaseObservable = new kc, this.onReadyObservable = new kc, this.onBeforeCameraRenderObservable = new kc, this._onBeforeCameraRenderObserver = null, this.onAfterCameraRenderObservable = new kc, this._onAfterCameraRenderObserver = null, this.onBeforeActiveMeshesEvaluationObservable = new kc, this.onAfterActiveMeshesEvaluationObservable = new kc, this.onBeforeParticlesRenderingObservable = new kc, this.onAfterParticlesRenderingObservable = new kc, this.onDataLoadedObservable = new kc, this.onNewCameraAddedObservable = new kc, this.onCameraRemovedObservable = new kc, this.onNewLightAddedObservable = new kc, this.onLightRemovedObservable = new kc, this.onNewGeometryAddedObservable = new kc, this.onGeometryRemovedObservable = new kc, this.onNewTransformNodeAddedObservable = new kc, this.onTransformNodeRemovedObservable = new kc, this.onNewMeshAddedObservable = new kc, this.onMeshRemovedObservable = new kc, this.onNewSkeletonAddedObservable = new kc, this.onSkeletonRemovedObservable = new kc, this.onNewMaterialAddedObservable = new kc, this.onNewMultiMaterialAddedObservable = new kc, this.onMaterialRemovedObservable = new kc, this.onMultiMaterialRemovedObservable = new kc, this.onNewTextureAddedObservable = new kc, this.onTextureRemovedObservable = new kc, this.onBeforeRenderTargetsRenderObservable = new kc, this.onAfterRenderTargetsRenderObservable = new kc, this.onBeforeStepObservable = new kc, this.onAfterStepObservable = new kc, this.onActiveCameraChanged = new kc, this.onActiveCamerasChanged = new kc, this.onBeforeRenderingGroupObservable = new kc, this.onAfterRenderingGroupObservable = new kc, this.onMeshImportedObservable = new kc, this.onAnimationFileImportedObservable = new kc, this._registeredForLateAnimationBindings = new _d(256), this._pointerPickingConfiguration = new Ag, this.onPrePointerObservable = new kc, this.onPointerObservable = new kc, this.onPreKeyboardObservable = new kc, this.onKeyboardObservable = new kc, this._useRightHandedSystem = !1, this._timeAccumulator = 0, this._currentStepId = 0, this._currentInternalStep = 0, this._fogEnabled = !0, this._fogMode = e.FOGMODE_NONE, this.fogColor = new Tc(.2, .2, .3), this.fogDensity = .1, this.fogStart = 0, this.fogEnd = 1e3, this.needsPreviousWorldMatrices = !1, this._shadowsEnabled = !0, this._lightsEnabled = !0, this._unObserveActiveCameras = null, this._texturesEnabled = !0, this.physicsEnabled = !0, this.particlesEnabled = !0, this.spritesEnabled = !0, this._skeletonsEnabled = !0, this.lensFlaresEnabled = !0, this.collisionsEnabled = !0, this.gravity = new Lc(0, -9.807, 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.dumpNextRenderTargets = !1, this.customRenderTargets = [], this.importedMeshesFiles = [], this.probesEnabled = !0, this._meshesForIntersections = new _d(256), this.proceduralTexturesEnabled = !0, this._totalVertices = new Dd, this._activeIndices = new Dd, this._activeParticles = new Dd, this._activeBones = new Dd, this._animationTime = 0, this.animationTimeScale = 1, this._renderId = 0, this._frameId = 0, this._executeWhenReadyTimeoutId = null, this._intermediateRendering = !1, this._defaultFrameBufferCleared = !1, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1, this._toBeDisposed = new Array(256), this._activeRequests = new Array, this._pendingData = new Array, this._isDisposed = !1, this.dispatchAllSubMeshesOfActiveMeshes = !1, this._activeMeshes = new pd(256), this._processedMaterials = new pd(256), this._renderTargets = new _d(256), this._materialsRenderTargets = new _d(256), this._activeParticleSystems = new pd(256), this._activeSkeletons = new _d(32), this._softwareSkinnedMeshes = new _d(32), this._activeAnimatables = new Array, this._transformMatrix = Hc.Zero(), this.requireLightSorting = !1, this._components = [], this._serializableComponents = [], this._transientComponents = [], this._beforeCameraUpdateStage = Of.Create(), this._beforeClearStage = Of.Create(), this._beforeRenderTargetClearStage = Of.Create(), this._gatherRenderTargetsStage = Of.Create(), this._gatherActiveCameraRenderTargetsStage = Of.Create(), this._isReadyForMeshStage = Of.Create(), this._beforeEvaluateActiveMeshStage = Of.Create(), this._evaluateSubMeshStage = Of.Create(), this._preActiveMeshStage = Of.Create(), this._cameraDrawRenderTargetStage = Of.Create(), this._beforeCameraDrawStage = Of.Create(), this._beforeRenderTargetDrawStage = Of.Create(), this._beforeRenderingGroupDrawStage = Of.Create(), this._beforeRenderingMeshStage = Of.Create(), this._afterRenderingMeshStage = Of.Create(), this._afterRenderingGroupDrawStage = Of.Create(), this._afterCameraDrawStage = Of.Create(), this._afterCameraPostProcessStage = Of.Create(), this._afterRenderTargetDrawStage = Of.Create(), this._afterRenderTargetPostProcessStage = Of.Create(), this._afterRenderStage = Of.Create(), this._pointerMoveStage = Of.Create(), this._pointerDownStage = Of.Create(), this._pointerUpStage = Of.Create(), this._geometriesByUniqueId = null, this._defaultMeshCandidates = {
				data: [],
				length: 0
			}, this._defaultSubMeshCandidates = {
				data: [],
				length: 0
			}, this._preventFreeActiveMeshesAndRenderingGroups = !1, this._activeMeshesFrozen = !1, this._activeMeshesFrozenButKeepClipping = !1, this._skipEvaluateActiveMeshesCompletely = !1, this._allowPostProcessClearColor = !0, this.getDeterministicFrameTime = () => this._engine.getTimeStep(), this._registeredActions = 0, this._blockMaterialDirtyMechanism = !1, this._perfCollector = null, this.activeCameras = [];
			const s = {
				useGeometryUniqueIdsMap: !0,
				useMaterialMeshMap: !0,
				useClonedMeshMap: !0,
				virtual: !1,
				...i
			};
			t = this._engine = t || Dc.LastCreatedEngine, s.virtual ? t._virtualScenes.push(this) : (Dc._LastCreatedScene = this, t.scenes.push(this)), this._uid = null, this._renderingManager = new qp(this), Kp && (this.postProcessManager = new Kp(this)), Cu() && this.attachControl(), this._createUbo(), B_ && (this._imageProcessingConfiguration = new B_), this.setDefaultCandidateProviders(), s.useGeometryUniqueIdsMap && (this._geometriesByUniqueId = {}), this.useMaterialMeshMap = s.useMaterialMeshMap, this.useClonedMeshMap = s.useClonedMeshMap, i && i.virtual || t.onNewSceneAddedObservable.notifyObservers(this)
		}
		set pointerDownFastCheck(e) {
			this._pointerPickingConfiguration.pointerDownFastCheck = e
		}
		set pointerUpFastCheck(e) {
			this._pointerPickingConfiguration.pointerUpFastCheck = e
		}
		getBoneByID(e) {
			return this.getBoneById(e)
		}
		addAnimation(e) {
			this._blockEntityCollection || this.animations.push(e)
		}
		addTexture(e) {
			this._blockEntityCollection || (this.textures.push(e), this.onNewTextureAddedObservable.notifyObservers(e))
		}
		setSceneUniformBuffer(e) {
			this._sceneUbo = e, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1
		}
		get environmentTexture() {
			return this._environmentTexture
		}
		_checkCameraRenderTarget(e) {
			if (e?.outputRenderTarget && !e?.isRigCamera && (e.outputRenderTarget._cleared = !1), e?.rigCameras?.length)
				for (let t = 0; t < e.rigCameras.length; ++t) {
					const i = e.rigCameras[t].outputRenderTarget;
					i && (i._cleared = !1)
				}
		}
		getParticleSystemById(e) {
			for (let t = 0; t < this.particleSystems.length; t++)
				if (this.particleSystems[t].id === e) return this.particleSystems[t];
			return null
		}
		getLastSkeletonById(e) {
			for (let t = this.skeletons.length - 1; t >= 0; t--)
				if (this.skeletons[t].id === e) return this.skeletons[t];
			return null
		}
		set skeletonsEnabled(e) {
			this._skeletonsEnabled !== e && (this._skeletonsEnabled = e, this.markAllMaterialsAsDirty(8))
		}
		getCameraByUniqueId(e) {
			for (let t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].ik === e) return this.cameras[t];
			return null
		}
		static set ExclusiveDoubleClickMode(e) {
			yg.ExclusiveDoubleClickMode = e
		}
		getActiveBones() {
			return this._activeBones.current
		}
		removeCamera(e) {
			const t = this.cameras.indexOf(e);
			if (-1 !== t && (this.cameras.splice(t, 1), e.parent || e._removeFromSceneRootNodes()), this.activeCameras) {
				const t = this.activeCameras.indexOf(e); - 1 !== t && this.activeCameras.splice(t, 1)
			}
			return this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t
		}
		freeProcessedMaterials() {
			this._processedMaterials.dispose()
		}
		getUniqueId() {
			return np.UniqueId
		}
		getAnimationRatio() {
			return void 0 !== this._animationRatio ? this._animationRatio : 1
		}
		get activeBonesPerfCounter() {
			return this._activeBones
		}
		getTextureByUniqueID(e) {
			return this.getTextureByUniqueId(e)
		}
		setTransformMatrix(e, t, i, s) {
			i || s || !this._multiviewSceneUbo || (this._multiviewSceneUbo.dispose(), this._multiviewSceneUbo = null), this._viewUpdateFlag === e.updateFlag && this._projectionUpdateFlag === t.updateFlag || (this._viewUpdateFlag = e.updateFlag, this._projectionUpdateFlag = t.updateFlag, this._viewMatrix = e, this._projectionMatrix = t, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? yd.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = yd.GetPlanes(this._transformMatrix), this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(i, s) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix), this._sceneUbo.updateMatrix("view", this._viewMatrix), this._sceneUbo.updateMatrix("projection", this._projectionMatrix)))
		}
		get activeCameras() {
			return this._activeCameras
		}
		set activeCamera(e) {
			e !== this._activeCamera && (this._activeCamera = e, this.onActiveCameraChanged.notifyObservers(this))
		}
		isReady(e = !0) {
			if (this._isDisposed) return !1;
			let t;
			const i = this.getEngine(),
				s = i.currentRenderPassId;
			i.currentRenderPassId = this.activeCamera?.renderPassId ?? s;
			let n = !0;
			for (this._pendingData.length > 0 && (n = !1), this.prePassRenderer?.update(), this.useOrderIndependentTransparency && this.depthPeelingRenderer && n && (n = this.depthPeelingRenderer.isReady()), e && (this._processedMaterials.reset(), this._materialsRenderTargets.reset()), t = 0; t < this.meshes.length; t++) {
				const s = this.meshes[t];
				if (!s.subMeshes || 0 === s.subMeshes.length) continue;
				if (!s.isReady(!0)) {
					n = !1;
					continue
				}
				const a = s.hasThinInstances || "InstancedMesh" === s.getClassName() || "InstancedLinesMesh" === s.getClassName() || i.getCaps().instancedArrays && s.instances.length > 0;
				for (const e of this._isReadyForMeshStage) e.action(s, a) || (n = !1);
				if (!e) continue;
				const r = s.material || this.defaultMaterial;
				if (r)
					if (r._storeEffectOnSubMeshes)
						for (const e of s.subMeshes) {
							const t = e.getMaterial();
							t && t.hasRenderTargetTextures && null != t.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(t) && (this._processedMaterials.push(t), this._materialsRenderTargets.concatWithNoDuplicate(t.getRenderTargetTextures()))
						} else r.hasRenderTargetTextures && null != r.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(r) && (this._processedMaterials.push(r), this._materialsRenderTargets.concatWithNoDuplicate(r.getRenderTargetTextures()))
			}
			if (e)
				for (t = 0; t < this._materialsRenderTargets.length; ++t) {
					this._materialsRenderTargets.data[t].isReadyForRendering() || (n = !1)
				}
			for (t = 0; t < this.geometries.length; t++) {
				2 === this.geometries[t].delayLoadState && (n = !1)
			}
			if (this.activeCameras && this.activeCameras.length > 0)
				for (const e of this.activeCameras) e.isReady(!0) || (n = !1);
			else this.activeCamera && (this.activeCamera.isReady(!0) || (n = !1));
			for (const e of this.particleSystems) e.isReady() || (n = !1);
			if (this.layers)
				for (const e of this.layers) e.isReady() || (n = !1);
			return i.areAllEffectsReady() || (n = !1), i.currentRenderPassId = s, n
		}
		get useRightHandedSystem() {
			return this._useRightHandedSystem
		}
		removeMorphTargetManager(e) {
			const t = this.morphTargetManagers.indexOf(e);
			return -1 !== t && this.morphTargetManagers.splice(t, 1), t
		}
		getActiveMeshes() {
			return this._activeMeshes
		}
		getTransformMatrix() {
			return this._transformMatrix
		}
		freezeMaterials() {
			for (let e = 0; e < this.materials.length; e++) this.materials[e].freeze()
		}
		_getDefaultSubMeshCandidates(e) {
			return this._defaultSubMeshCandidates.data = e.subMeshes, this._defaultSubMeshCandidates.length = e.subMeshes.length, this._defaultSubMeshCandidates
		}
		getLightByName(e) {
			for (let t = 0; t < this.lights.length; t++)
				if (this.lights[t].name === e) return this.lights[t];
			return null
		}
		removeAnimation(e) {
			const t = this.animations.indexOf(e);
			return -1 !== t && this.animations.splice(t, 1), t
		}
		set skipFrustumClipping(e) {
			this._skipFrustumClipping !== e && (this._skipFrustumClipping = e)
		}
		_executeActiveContainerCleanup(e) {
			(!this._engine.snapshotRendering || 1 !== this._engine.snapshotRenderingMode) && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce((() => e.dispose()))
		}
		get pointerMoveFastCheck() {
			return this._pointerPickingConfiguration.pointerMoveFastCheck
		}
		_getComponent(e) {
			for (const t of this._components)
				if (t.name === e) return t;
			return null
		}
		getClassName() {
			return "Scene"
		}
		_readFileAsync(e, t, i) {
			return new Promise(((s, n) => {
				this._readFile(e, (e => {
					s(e)
				}), t, i, (e => {
					n(e)
				}))
			}))
		}
		set lightsEnabled(e) {
			this._lightsEnabled !== e && (this._lightsEnabled = e, this.markAllMaterialsAsDirty(2))
		}
		unregisterBeforeRender(e) {
			this.onBeforeRenderObservable.removeCallback(e)
		}
		multiPick(e, t, i, s, n) {
			throw ic("Ray")
		}
		executeWhenReady(e, t = !1) {
			this.onReadyObservable.addOnce(e), null === this._executeWhenReadyTimeoutId && this._checkIsReady(t)
		}
		get pointerX() {
			return this._inputManager.pointerX
		}
		addTransformNode(e) {
			this._blockEntityCollection || e.getScene() === this && -1 !== e._indexInSceneTransformNodesArray || (e._indexInSceneTransformNodesArray = this.transformNodes.length, this.transformNodes.push(e), e.parent || e._addToSceneRootNodes(), this.onNewTransformNodeAddedObservable.notifyObservers(e))
		}
		static get DoubleClickDelay() {
			return yg.DoubleClickDelay
		}
		pickWithRay(e, t, i, s) {
			throw ic("Ray")
		}
		set forcePointsCloud(e) {
			this._forcePointsCloud !== e && (this._forcePointsCloud = e, this.markAllMaterialsAsDirty(16))
		}
		pushGeometry(e, t) {
			return !(!t && this._getGeometryByUniqueId(e.ik)) && (this.addGeometry(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0)
		}
		getMeshesByID(e) {
			return this.getMeshesById(e)
		}
		get pointerDownFastCheck() {
			return this._pointerPickingConfiguration.pointerDownFastCheck
		}
		getMaterialByUniqueID(e, t = !1) {
			return this._getMaterial(t, (t => t.ik === e))
		}
		finalizeSceneUbo() {
			const e = this.getSceneUniformBuffer(),
				t = this.bindEyePosition(null);
			return e.updateFloat4("vEyePosition", t.x, t.y, t.z, t.w), e.update(), e
		}
		set performancePriority(e) {
			if (e !== this._performancePriority) {
				switch (this._performancePriority = e, e) {
					case 0:
						this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !1, this.autoClear = !0;
						break;
					case 1:
						this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !0, this.autoClear = !1;
						break;
					case 2:
						this.skipFrustumClipping = !0, this._renderingManager.maintainStateBetweenFrames = !0, this.skipPointerMovePicking = !0, this.autoClear = !1
				}
				this.onScenePerformancePriorityChangedObservable.notifyObservers(e)
			}
		}
		simulatePointerDown(e, t) {
			return this._inputManager.simulatePointerDown(e, t), this
		}
		get totalActiveIndicesPerfCounter() {
			return this._activeIndices
		}
		_getGeometryByUniqueId(e) {
			if (this._geometriesByUniqueId) {
				const t = this._geometriesByUniqueId[e];
				if (void 0 !== t) return this.geometries[t]
			} else
				for (let t = 0; t < this.geometries.length; t++)
					if (this.geometries[t].ik === e) return this.geometries[t];
			return null
		}
		getLastEntryByID(e) {
			return this.getLastEntryById(e)
		}
		setRenderingOrder(e, t = null, i = null, s = null) {
			this._renderingManager.setRenderingOrder(e, t, i, s)
		}
	};
	bg.FOGMODE_NONE = 0, bg.FOGMODE_EXP = 1, bg.FOGMODE_EXP2 = 2, bg.FOGMODE_LINEAR = 3, bg.MinDeltaTime = 1, bg.MaxDeltaTime = 1e3, cc("BABYLON.Scene", bg);
	var xg = class e extends jc {
		get excludedMeshes() {
			return this._excludedMeshes
		}
		getScaledIntensity() {
			return this._photometricScale * this.intensity
		}
		_resyncMeshes() {
			for (const e of this.getScene().meshes) e._resyncLightSource(this)
		}
		get lightmapMode() {
			return this._lightmapMode
		}
		set lightmapMode(e) {
			this._lightmapMode !== e && (this._lightmapMode = e, this._markMeshesAsLightDirty())
		}
		set range(e) {
			this._range = e, this._inverseSquaredRange = 1 / (this.range * this.range)
		}
		dispose(e, t = !1) {
			if (this._shadowGenerators) {
				const e = this._shadowGenerators.values();
				for (let t = e.next(); !0 !== t.done; t = e.next()) {
					t.value.dispose()
				}
				this._shadowGenerators = null
			}
			if (this.getScene().stopAnimation(this), this._parentContainer) {
				const e = this._parentContainer.lights.indexOf(this);
				e > -1 && this._parentContainer.lights.splice(e, 1), this._parentContainer = null
			}
			for (const e of this.getScene().meshes) e._removeLightSource(this, !0);
			this._uniformBuffer.dispose(), this.getScene().removeLight(this), super.dispose(e, t)
		}
		_syncParentEnabledState() {
			super._syncParentEnabledState(), this.isDisposed() || this._resyncMeshes()
		}
		_bindLight(e, t, i, s, n = !0) {
			const a = e.toString();
			let r = !1;
			if (this._uniformBuffer.bindToEffect(i, "Light" + a), this._renderId !== t.getRenderId() || this._lastUseSpecular !== s || !this._uniformBuffer.useUbo) {
				this._renderId = t.getRenderId(), this._lastUseSpecular = s;
				const e = this.getScaledIntensity();
				this.transferToEffect(i, a), this.diffuse.scaleToRef(e, Rc.Color3[0]), this._uniformBuffer.updateColor4("vLightDiffuse", Rc.Color3[0], this.range, a), s && (this.specular.scaleToRef(e, Rc.Color3[1]), this._uniformBuffer.updateColor4("vLightSpecular", Rc.Color3[1], this.radius, a)), r = !0
			}
			if (this.transferTexturesToEffect(i, a), t.shadowsEnabled && this.shadowEnabled && n) {
				const e = this.getShadowGenerator(t.activeCamera) ?? this.getShadowGenerator();
				e && (e.bindShadowLight(a, i), r = !0)
			}
			r ? this._uniformBuffer.update() : this._uniformBuffer.bindUniformBuffer()
		}
		setEnabled(e) {
			super.setEnabled(e), this._resyncMeshes()
		}
		getAbsolutePosition() {
			return Lc.Zero()
		}
		getShadowGenerators() {
			return this._shadowGenerators
		}
		set shadowEnabled(e) {
			this._shadowEnabled !== e && (this._shadowEnabled = e, this._markMeshesAsLightDirty())
		}
		_getPhotometricScale() {
			let t = 0;
			const i = this.getTypeID();
			let s = this.intensityMode;
			switch (s === e.INTENSITYMODE_AUTOMATIC && (s = i === e.LIGHTTYPEID_DIRECTIONALLIGHT ? e.INTENSITYMODE_ILLUMINANCE : e.INTENSITYMODE_LUMINOUSINTENSITY), i) {
				case e.LIGHTTYPEID_POINTLIGHT:
				case e.LIGHTTYPEID_SPOTLIGHT:
					switch (s) {
						case e.INTENSITYMODE_LUMINOUSPOWER:
							t = 1 / (4 * Math.PI);
							break;
						case e.INTENSITYMODE_LUMINOUSINTENSITY:
							t = 1;
							break;
						case e.INTENSITYMODE_LUMINANCE:
							t = this.radius * this.radius
					}
					break;
				case e.LIGHTTYPEID_DIRECTIONALLIGHT:
					switch (s) {
						case e.INTENSITYMODE_ILLUMINANCE:
							t = 1;
							break;
						case e.INTENSITYMODE_LUMINANCE: {
							let e = this.radius;
							e = Math.max(e, .001);
							t = 2 * Math.PI * (1 - Math.cos(e));
							break
						}
					}
					break;
				case e.LIGHTTYPEID_HEMISPHERICLIGHT:
					t = 1
			}
			return t
		}
		clone(t, i = null) {
			const s = e.GetConstructorFromName(this.getTypeID(), t, this.getScene());
			if (!s) return null;
			const n = Xc.Clone(s, this);
			return t && (n.name = t), i && (n.parent = i), n.setEnabled(this.isEnabled()), this.onClonedObservable.notifyObservers(n), n
		}
		static Parse(t, i) {
			const s = e.GetConstructorFromName(t.type, t.name, i);
			if (!s) return null;
			const n = Xc.Parse(s, t, i);
			if (t.excludedMeshesIds && (n._excludedMeshesIds = t.excludedMeshesIds), t.includedOnlyMeshesIds && (n._includedOnlyMeshesIds = t.includedOnlyMeshesIds), void 0 !== t.parentId && (n._waitingParentId = t.parentId), void 0 !== t.parentInstanceIndex && (n._waitingParentInstanceIndex = t.parentInstanceIndex), void 0 !== t.falloffType && (n.falloffType = t.falloffType), void 0 !== t.lightmapMode && (n.lightmapMode = t.lightmapMode), t.animations) {
				for (let e = 0; e < t.animations.length; e++) {
					const i = t.animations[e],
						s = uc("BABYLON.Animation");
					s && n.animations.push(s.Parse(i))
				}
				jc.ParseAnimationRanges(n, t, i)
			}
			return t.autoAnimate && i.beginAnimation(n, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), void 0 !== t.isEnabled && n.setEnabled(t.isEnabled), n
		}
		set excludeWithLayerMask(e) {
			this._excludeWithLayerMask = e, this._resyncMeshes()
		}
		canAffectMesh(e) {
			return !e || !(this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && -1 === this.includedOnlyMeshes.indexOf(e)) && (!(this.excludedMeshes && this.excludedMeshes.length > 0 && -1 !== this.excludedMeshes.indexOf(e)) && (!!(0 === this.includeOnlyWithLayerMask || this.includeOnlyWithLayerMask & e.layerMask) && !(0 !== this.excludeWithLayerMask && this.excludeWithLayerMask & e.layerMask)))
		}
		serialize() {
			const e = Xc.Serialize(this);
			return e.ik = this.ik, e.type = this.getTypeID(), this.parent && this.parent._serializeAsParent(e), this.excludedMeshes.length > 0 && (e.excludedMeshesIds = [], this.excludedMeshes.forEach((t => {
				e.excludedMeshesIds.push(t.id)
			}))), this.includedOnlyMeshes.length > 0 && (e.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach((t => {
				e.includedOnlyMeshesIds.push(t.id)
			}))), Xc.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e
		}
		constructor(t, i) {
			super(t, i, !1), this.diffuse = new Tc(1, 1, 1), this.specular = new Tc(1, 1, 1), this.falloffType = e.FALLOFF_DEFAULT, this.intensity = 1, this._range = Number.MAX_VALUE, this._inverseSquaredRange = 0, this._photometricScale = 1, this._intensityMode = e.INTENSITYMODE_AUTOMATIC, this._radius = 1e-5, this.renderPriority = 0, this._shadowEnabled = !0, this._excludeWithLayerMask = 0, this._includeOnlyWithLayerMask = 0, this._lightmapMode = 0, this._shadowGenerators = null, this._excludedMeshesIds = new Array, this._includedOnlyMeshesIds = new Array, this._isLight = !0, this.getScene().addLight(this), this._uniformBuffer = new Bd(this.getScene().getEngine(), void 0, void 0, t), this._buildUniformLayout(), this.includedOnlyMeshes = [], this.excludedMeshes = [], this._resyncMeshes()
		}
		get includeOnlyWithLayerMask() {
			return this._includeOnlyWithLayerMask
		}
		_hookArrayForIncludedOnly(e) {
			const t = e.push;
			e.push = (...i) => {
				const s = t.apply(e, i);
				return this._resyncMeshes(), s
			};
			const i = e.splice;
			e.splice = (t, s) => {
				const n = i.apply(e, [t, s]);
				return this._resyncMeshes(), n
			}, this._resyncMeshes()
		}
		get intensityMode() {
			return this._intensityMode
		}
		set excludedMeshes(e) {
			this._excludedMeshes = e, this._hookArrayForExcluded(e)
		}
		getClassName() {
			return "Light"
		}
		set radius(e) {
			this._radius = e, this._computePhotometricScale()
		}
		getShadowGenerator(e = null) {
			return null === this._shadowGenerators ? null : this._shadowGenerators.get(e) ?? null
		}
		get excludeWithLayerMask() {
			return this._excludeWithLayerMask
		}
		set includedOnlyMeshes(e) {
			this._includedOnlyMeshes = e, this._hookArrayForIncludedOnly(e)
		}
		_computePhotometricScale() {
			this._photometricScale = this._getPhotometricScale(), this.getScene().resetCachedMaterial()
		}
		get includedOnlyMeshes() {
			return this._includedOnlyMeshes
		}
		static GetConstructorFromName(e, t, i) {
			const s = jc.Construct("Light_Type_" + e, t, i);
			return s || null
		}
		_hookArrayForExcluded(e) {
			const t = e.push;
			e.push = (...i) => {
				const s = t.apply(e, i);
				for (const e of i) e._resyncLightSource(this);
				return s
			};
			const i = e.splice;
			e.splice = (t, s) => {
				const n = i.apply(e, [t, s]);
				for (const e of n) e._resyncLightSource(this);
				return n
			};
			for (const t of e) t._resyncLightSource(this)
		}
		get range() {
			return this._range
		}
		_markMeshesAsLightDirty() {
			for (const e of this.getScene().meshes) - 1 !== e.lightSources.indexOf(this) && e._markSubMeshesAsLightDirty()
		}
		getProjectionMatrix(e, t) {
			return null
		}
		getViewMatrix(e) {
			return null
		}
		set intensityMode(e) {
			this._intensityMode = e, this._computePhotometricScale()
		}
		get shadowEnabled() {
			return this._shadowEnabled
		}
		get radius() {
			return this._radius
		}
		getTypeID() {
			return 0
		}
		toString(e) {
			let t = "Name: " + this.name;
			if (t += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()], this.animations)
				for (let i = 0; i < this.animations.length; i++) t += ", animation[0]: " + this.animations[i].toString(e);
			return t
		}
		transferTexturesToEffect(e, t) {
			return this
		}
		set includeOnlyWithLayerMask(e) {
			this._includeOnlyWithLayerMask = e, this._resyncMeshes()
		}
		_reorderLightsInScene() {
			const e = this.getScene();
			0 != this._renderPriority && (e.requireLightSorting = !0), this.getScene().sortLightsByPriority()
		}
	};
	xg.FALLOFF_DEFAULT = $d.FALLOFF_DEFAULT, xg.FALLOFF_PHYSICAL = $d.FALLOFF_PHYSICAL, xg.FALLOFF_GLTF = $d.FALLOFF_GLTF, xg.FALLOFF_STANDARD = $d.FALLOFF_STANDARD, xg.LIGHTMAP_DEFAULT = $d.LIGHTMAP_DEFAULT, xg.LIGHTMAP_SPECULAR = $d.LIGHTMAP_SPECULAR, xg.LIGHTMAP_SHADOWSONLY = $d.LIGHTMAP_SHADOWSONLY, xg.INTENSITYMODE_AUTOMATIC = $d.INTENSITYMODE_AUTOMATIC, xg.INTENSITYMODE_LUMINOUSPOWER = $d.INTENSITYMODE_LUMINOUSPOWER, xg.INTENSITYMODE_LUMINOUSINTENSITY = $d.INTENSITYMODE_LUMINOUSINTENSITY, xg.INTENSITYMODE_ILLUMINANCE = $d.INTENSITYMODE_ILLUMINANCE, xg.INTENSITYMODE_LUMINANCE = $d.INTENSITYMODE_LUMINANCE, xg.LIGHTTYPEID_POINTLIGHT = $d.LIGHTTYPEID_POINTLIGHT, xg.LIGHTTYPEID_DIRECTIONALLIGHT = $d.LIGHTTYPEID_DIRECTIONALLIGHT, xg.LIGHTTYPEID_SPOTLIGHT = $d.LIGHTTYPEID_SPOTLIGHT, xg.LIGHTTYPEID_HEMISPHERICLIGHT = $d.LIGHTTYPEID_HEMISPHERICLIGHT, Gh([jh()], xg.prototype, "diffuse", void 0), Gh([jh()], xg.prototype, "specular", void 0), Gh([Xh()], xg.prototype, "falloffType", void 0), Gh([Xh()], xg.prototype, "intensity", void 0), Gh([Xh()], xg.prototype, "range", null), Gh([Xh()], xg.prototype, "intensityMode", null), Gh([Xh()], xg.prototype, "radius", null), Gh([Xh()], xg.prototype, "_renderPriority", void 0), Gh([zh("_reorderLightsInScene")], xg.prototype, "renderPriority", void 0), Gh([Xh("shadowEnabled")], xg.prototype, "_shadowEnabled", void 0), Gh([Xh("excludeWithLayerMask")], xg.prototype, "_excludeWithLayerMask", void 0), Gh([Xh("includeOnlyWithLayerMask")], xg.prototype, "_includeOnlyWithLayerMask", void 0), Gh([Xh("lightmapMode")], xg.prototype, "_lightmapMode", void 0), jc.AddNodeConstructor("Light_Type_3", ((e, t) => () => new Mg(e, Lc.Zero(), t)));
	var Mg = class extends xg {
		getClassName() {
			return "HemisphericLight"
		}
		transferToEffect(e, t) {
			const i = Lc.Normalize(this.direction);
			return this._uniformBuffer.updateFloat4("vLightData", i.x, i.y, i.z, 0, t), this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), t), this
		}
		getTypeID() {
			return xg.LIGHTTYPEID_HEMISPHERICLIGHT
		}
		prepareLightSpecificDefines(e, t) {
			e["HEMILIGHT" + t] = !0
		}
		computeWorldMatrix() {
			return this._worldMatrix || (this._worldMatrix = Hc.Identity()), this._worldMatrix
		}
		transferToNodeMaterialEffect(e, t) {
			const i = Lc.Normalize(this.direction);
			return e.setFloat3(t, i.x, i.y, i.z), this
		}
		_buildUniformLayout() {
			this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightGround", 3), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create()
		}
		constructor(e, t, i) {
			super(e, i), this.groundColor = new Tc(0, 0, 0), this.direction = t || Lc.Up()
		}
		getShadowGenerator() {
			return null
		}
		setDirectionToTarget(e) {
			return this.direction = Lc.Normalize(e.subtract(Lc.Zero())), this.direction
		}
	};
	Gh([jh()], Mg.prototype, "groundColor", void 0), Gh([Jh()], Mg.prototype, "direction", void 0), cc("BABYLON.HemisphericLight", Mg);
	var Cg = class extends xg {
		_setPosition(e) {
			this._position = e
		}
		get shadowMaxZ() {
			return this._shadowMaxZ
		}
		getRotation() {
			this.direction.normalize();
			const e = Lc.Cross(this.direction, zd.Y),
				t = Lc.Cross(e, this.direction);
			return Lc.RotationFromAxis(e, t, this.direction)
		}
		set shadowMaxZ(e) {
			this._shadowMaxZ = e, this.forceProjectionMatrixCompute()
		}
		get direction() {
			return this._direction
		}
		constructor() {
			super(...arguments), this._needProjectionMatrixCompute = !0, this._viewMatrix = Hc.Identity(), this._projectionMatrix = Hc.Identity()
		}
		get shadowMinZ() {
			return this._shadowMinZ
		}
		needCube() {
			return !1
		}
		getViewMatrix(e) {
			const t = Vc.Vector3[0];
			let i = this.position;
			this.computeTransformedInformation() && (i = this.transformedPosition), Lc.NormalizeToRef(this.getShadowDirection(e), t), 1 === Math.abs(Lc.Dot(t, Lc.Up())) && (t.z = 1e-13);
			const s = Vc.Vector3[1];
			return i.addToRef(t, s), Hc.LookAtLHToRef(i, s, Lc.Up(), this._viewMatrix), this._viewMatrix
		}
		getDepthMaxZ(e) {
			return void 0 !== this.shadowMaxZ ? this.shadowMaxZ : e.maxZ
		}
		set direction(e) {
			this._setDirection(e)
		}
		_isSynchronized() {
			return !!this._cache.position.equals(this.position)
		}
		getShadowDirection(e) {
			return this.transformedDirection ? this.transformedDirection : this.direction
		}
		set position(e) {
			this._setPosition(e)
		}
		needProjectionMatrixCompute() {
			return this._needProjectionMatrixCompute
		}
		get position() {
			return this._position
		}
		computeTransformedInformation() {
			return !(!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition || (this.transformedPosition = Lc.Zero()), Lc.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), this.direction && (this.transformedDirection || (this.transformedDirection = Lc.Zero()), Lc.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)), !0)
		}
		getAbsolutePosition() {
			return this.transformedPosition ? this.transformedPosition : this.position
		}
		_initCache() {
			super._initCache(), this._cache.position = Lc.Zero()
		}
		getProjectionMatrix(e, t) {
			return this.setShadowProjectionMatrix(this._projectionMatrix, e ?? this._viewMatrix, t ?? []), this._projectionMatrix
		}
		setDirectionToTarget(e) {
			return this.direction = Lc.Normalize(e.subtract(this.position)), this.direction
		}
		getDepthScale() {
			return 50
		}
		set shadowMinZ(e) {
			this._shadowMinZ = e, this.forceProjectionMatrixCompute()
		}
		getDepthMinZ(e) {
			return void 0 !== this.shadowMinZ ? this.shadowMinZ : e.minZ
		}
		_setDirection(e) {
			this._direction = e
		}
		computeWorldMatrix(e) {
			return !e && this.isSynchronized() ? (this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix) : (this._updateCache(), this._cache.position.copyFrom(this.position), this._worldMatrix || (this._worldMatrix = Hc.Identity()), Hc.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix)
		}
		setShadowProjectionMatrix(e, t, i) {
			return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(t, i, e) : this._setDefaultShadowProjectionMatrix(e, t, i), this
		}
		_syncParentEnabledState() {
			super._syncParentEnabledState(), this.parent && this.parent.getWorldMatrix || (this.transformedPosition = null, this.transformedDirection = null)
		}
		forceProjectionMatrixCompute() {
			this._needProjectionMatrixCompute = !0
		}
	};
	Gh([Jh()], Cg.prototype, "position", null), Gh([Jh()], Cg.prototype, "direction", null), Gh([Xh()], Cg.prototype, "shadowMinZ", null), Gh([Xh()], Cg.prototype, "shadowMaxZ", null), jc.AddNodeConstructor("Light_Type_1", ((e, t) => () => new Tg(e, Lc.Zero(), t)));
	var Tg = class extends Cg {
		prepareLightSpecificDefines(e, t) {
			e["DIRLIGHT" + t] = !0
		}
		_buildUniformLayout() {
			this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create()
		}
		set orthoRight(e) {
			this._orthoRight = e
		}
		set shadowFrustumSize(e) {
			this._shadowFrustumSize = e, this.forceProjectionMatrixCompute()
		}
		getTypeID() {
			return xg.LIGHTTYPEID_DIRECTIONALLIGHT
		}
		getDepthMinZ(e) {
			const t = this._scene.getEngine();
			return !t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1
		}
		_setDefaultAutoExtendShadowProjectionMatrix(e, t, i) {
			const s = this.getScene().activeCamera;
			if (!s) return;
			if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
				const e = Lc.Zero();
				this._orthoLeft = Number.MAX_VALUE, this._orthoRight = -Number.MAX_VALUE, this._orthoTop = -Number.MAX_VALUE, this._orthoBottom = Number.MAX_VALUE;
				let s = Number.MAX_VALUE,
					n = -Number.MAX_VALUE;
				for (let a = 0; a < i.length; a++) {
					const r = i[a];
					if (!r) continue;
					const o = r.getBoundingInfo().boundingBox;
					for (let i = 0; i < o.vectorsWorld.length; i++) Lc.TransformCoordinatesToRef(o.vectorsWorld[i], t, e), e.x < this._orthoLeft && (this._orthoLeft = e.x), e.y < this._orthoBottom && (this._orthoBottom = e.y), e.x > this._orthoRight && (this._orthoRight = e.x), e.y > this._orthoTop && (this._orthoTop = e.y), this.autoCalcShadowZBounds && (e.z < s && (s = e.z), e.z > n && (n = e.z))
				}
				this.autoCalcShadowZBounds && (this._shadowMinZ = s, this._shadowMaxZ = n)
			}
			const n = this._orthoRight - this._orthoLeft,
				a = this._orthoTop - this._orthoBottom,
				r = void 0 !== this.shadowMinZ ? this.shadowMinZ : s.minZ,
				o = void 0 !== this.shadowMaxZ ? this.shadowMaxZ : s.maxZ,
				l = this.getScene().getEngine().useReverseDepthBuffer;
			Hc.OrthoOffCenterLHToRef(this._orthoLeft - n * this.shadowOrthoScale, this._orthoRight + n * this.shadowOrthoScale, this._orthoBottom - a * this.shadowOrthoScale, this._orthoTop + a * this.shadowOrthoScale, l ? o : r, l ? r : o, e, this.getScene().getEngine().isNDCHalfZRange)
		}
		set orthoBottom(e) {
			this._orthoBottom = e
		}
		get shadowOrthoScale() {
			return this._shadowOrthoScale
		}
		set orthoTop(e) {
			this._orthoTop = e
		}
		set orthoLeft(e) {
			this._orthoLeft = e
		}
		set shadowOrthoScale(e) {
			this._shadowOrthoScale = e, this.forceProjectionMatrixCompute()
		}
		get orthoLeft() {
			return this._orthoLeft
		}
		transferToNodeMaterialEffect(e, t) {
			return this.computeTransformedInformation() ? (e.setFloat3(t, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z), this) : (e.setFloat3(t, this.direction.x, this.direction.y, this.direction.z), this)
		}
		_setDefaultFixedFrustumShadowProjectionMatrix(e) {
			const t = this.getScene().activeCamera;
			t && Hc.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, void 0 !== this.shadowMinZ ? this.shadowMinZ : t.minZ, void 0 !== this.shadowMaxZ ? this.shadowMaxZ : t.maxZ, e, this.getScene().getEngine().isNDCHalfZRange)
		}
		transferToEffect(e, t) {
			return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, t), this) : (this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, t), this)
		}
		get shadowFrustumSize() {
			return this._shadowFrustumSize
		}
		constructor(e, t, i) {
			super(e, i), this._shadowFrustumSize = 0, this._shadowOrthoScale = .1, this.autoUpdateExtends = !0, this.autoCalcShadowZBounds = !1, this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE, this.position = t.scale(-1), this.direction = t
		}
		getDepthMaxZ(e) {
			const t = this._scene.getEngine();
			return t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1
		}
		get orthoBottom() {
			return this._orthoBottom
		}
		get orthoTop() {
			return this._orthoTop
		}
		_setDefaultShadowProjectionMatrix(e, t, i) {
			this.shadowFrustumSize > 0 ? this._setDefaultFixedFrustumShadowProjectionMatrix(e) : this._setDefaultAutoExtendShadowProjectionMatrix(e, t, i)
		}
		getClassName() {
			return "DirectionalLight"
		}
		get orthoRight() {
			return this._orthoRight
		}
	};
	Gh([Xh()], Tg.prototype, "shadowFrustumSize", null), Gh([Xh()], Tg.prototype, "shadowOrthoScale", null), Gh([Xh()], Tg.prototype, "autoUpdateExtends", void 0), Gh([Xh()], Tg.prototype, "autoCalcShadowZBounds", void 0), Gh([Xh("orthoLeft")], Tg.prototype, "_orthoLeft", void 0), Gh([Xh("orthoRight")], Tg.prototype, "_orthoRight", void 0), Gh([Xh("orthoTop")], Tg.prototype, "_orthoTop", void 0), Gh([Xh("orthoBottom")], Tg.prototype, "_orthoBottom", void 0), cc("BABYLON.DirectionalLight", Tg), ci(), _i();
	var wg = class e extends Bp {
		_glslFloat(e, t = 8) {
			return e.toFixed(t).replace(/0+$/, "")
		}
		_updateParameters(e, t) {
			const i = this._kernel,
				s = (i - 1) / 2;
			let n = [],
				a = [],
				r = 0;
			for (let e = 0; e < i; e++) {
				const t = e / (i - 1),
					o = this._gaussianWeight(2 * t - 1);
				n[e] = e - s, a[e] = o, r += o
			}
			for (let e = 0; e < a.length; e++) a[e] /= r;
			const o = [],
				l = [],
				h = [];
			for (let e = 0; e <= s; e += 2) {
				const t = Math.min(e + 1, Math.floor(s));
				if (e === t) h.push({
					o: n[e],
					w: a[e]
				});
				else {
					const i = t === s,
						r = a[e] + a[t] * (i ? .5 : 1),
						o = n[e] + 1 / (1 + a[e] / a[t]);
					0 === o ? (h.push({
						o: n[e],
						w: a[e]
					}), h.push({
						o: n[e + 1],
						w: a[e + 1]
					})) : (h.push({
						o: o,
						w: r
					}), h.push({
						o: -o,
						w: r
					}))
				}
			}
			for (let e = 0; e < h.length; e++) l[e] = h[e].o, o[e] = h[e].w;
			n = l, a = o;
			const c = this.getEngine().getCaps().maxVaryingVectors - (1 === this.shaderLanguage ? 1 : 0),
				u = Math.max(c, 0) - 1;
			let m = Math.min(n.length, u),
				d = "";
			d += this._staticDefines, -1 != this._staticDefines.indexOf("DOF") && (d += `#define CENTER_WEIGHT ${this._glslFloat(a[m-1])}\n`, m--);
			for (let e = 0; e < m; e++) d += `#define KERNEL_OFFSET${e} ${this._glslFloat(n[e])}\n`, d += `#define KERNEL_WEIGHT${e} ${this._glslFloat(a[e])}\n`;
			let f = 0;
			for (let e = u; e < n.length; e++) d += `#define KERNEL_DEP_OFFSET${f} ${this._glslFloat(n[e])}\n`, d += `#define KERNEL_DEP_WEIGHT${f} ${this._glslFloat(a[e])}\n`, f++;
			this.packedFloat && (d += "#define PACKEDFLOAT 1"), this._blockCompilation = !1, super.updateEffect(d, null, null, {
				varyingCount: m,
				depCount: f
			}, e, t)
		}
		getClassName() {
			return "BlurPostProcess"
		}
		updateEffect(e = null, t = null, i = null, s, n, a) {
			this._updateParameters(n, a)
		}
		static _Parse(t, i, s, n) {
			return Xc.Parse((() => new e(t.name, t.direction, t.kernel, t.options, i, t.renderTargetSamplingMode, s.getEngine(), t.reusable, t.textureType, void 0, !1)), t, s, n)
		}
		set packedFloat(e) {
			this._packedFloat !== e && (this._packedFloat = e, this._blockCompilation || this._updateParameters())
		}
		get kernel() {
			return this._idealKernel
		}
		constructor(e, t, i, s, n, a = Np.BILINEAR_SAMPLINGMODE, r, o, l = 0, h = "", c = !1, u = 5) {
			super(e, "kernelBlur", ["delta", "direction"], ["circleOfConfusionSampler"], s, n, a, r, o, null, l, "kernelBlur", {
				varyingCount: 0,
				depCount: 0
			}, !0, u), this._blockCompilation = c, this._packedFloat = !1, this._staticDefines = "", this._staticDefines = h, this.direction = t, this.onApplyObservable.add((e => {
				this._outputTexture ? e.setFloat2("delta", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y) : e.setFloat2("delta", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y)
			})), this.kernel = i
		}
		async _initShaderSourceAsync(e) {
			e ? (this._webGPUReady = !0, await Promise.all([Promise.resolve().then((() => (xi(), Si))), Promise.resolve().then((() => (Ni(), Ci)))])) : await Promise.all([Promise.resolve().then((() => (ci(), ri))), Promise.resolve().then((() => (_i(), mi)))]), await super._initShaderSourceAsync(e)
		}
		_nearestBestKernel(e) {
			const t = Math.round(e);
			for (const e of [t, t - 1, t + 1, t - 2, t + 2])
				if (e % 2 != 0 && Math.floor(e / 2) % 2 == 0 && e > 0) return Math.max(e, 3);
			return Math.max(t, 3)
		}
		_gaussianWeight(e) {
			const t = 1 / 3,
				i = -e * e / (2 * t * t);
			return 1 / (Math.sqrt(2 * Math.PI) * t) * Math.exp(i)
		}
		set kernel(e) {
			this._idealKernel !== e && (e = Math.max(e, 1), this._idealKernel = e, this._kernel = this._nearestBestKernel(e), this._blockCompilation || this._updateParameters())
		}
		get packedFloat() {
			return this._packedFloat
		}
	};
	Gh([Xh("kernel")], wg.prototype, "_kernel", void 0), Gh([Xh("packedFloat")], wg.prototype, "_packedFloat", void 0), Gh([$h()], wg.prototype, "direction", void 0), cc("BABYLON.BlurPostProcess", wg);
	var Rg = class e {
		get bias() {
			return this._bias
		}
		set filter(t) {
			if (t = this._validateFilter(t), this._light.needCube()) {
				if (t === e.FILTER_BLUREXPONENTIALSHADOWMAP) return void(this.useExponentialShadowMap = !0);
				if (t === e.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) return void(this.useCloseExponentialShadowMap = !0);
				if (t === e.FILTER_PCF || t === e.FILTER_PCSS) return void(this.usePoissonSampling = !0)
			}
			t !== e.FILTER_PCF && t !== e.FILTER_PCSS || this._scene.getEngine()._features.supportShadowSamplers ? this._filter !== t && (this._filter = t, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty()) : this.usePoissonSampling = !0
		}
		get useBlurExponentialShadowMap() {
			return this.filter === e.FILTER_BLUREXPONENTIALSHADOWMAP
		}
		set depthScale(e) {
			this._depthScale = e
		}
		forceCompilation(e, t) {
			const i = {
					useInstances: !1,
					...t
				},
				s = this.getShadowMap();
			if (!s) return void(e && e(this));
			const n = s.Tk;
			if (!n) return void(e && e(this));
			const a = [];
			for (const e of n) a.push(...e.subMeshes);
			if (0 === a.length) return void(e && e(this));
			let r = 0;
			const o = () => {
				if (this._scene && this._scene.getEngine()) {
					for (; this.isReady(a[r], i.useInstances, a[r].getMaterial()?.needAlphaBlendingForMesh(a[r].getMesh()) ?? !1);)
						if (r++, r >= a.length) return void(e && e(this));
					setTimeout(o, 16)
				}
			};
			o()
		}
		get depthScale() {
			return void 0 !== this._depthScale ? this._depthScale : this._light.getDepthScale()
		}
		getTransformMatrix() {
			const e = this._scene;
			if (this._currentRenderId === e.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) return this._transformMatrix;
			this._currentRenderId = e.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;
			let t = this._light.position;
			if (this._light.computeTransformedInformation() && (t = this._light.transformedPosition), Lc.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), 1 === Math.abs(Lc.Dot(this._lightDirection, Lc.Up())) && (this._lightDirection.z = 1e-13), this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !t.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
				this._cachedPosition.copyFrom(t), this._cachedDirection.copyFrom(this._lightDirection), Hc.LookAtLHToRef(t, t.add(this._lightDirection), Lc.Up(), this._viewMatrix);
				const e = this.getShadowMap();
				if (e) {
					const t = e.Tk;
					t && this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, t)
				}
				this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix)
			}
			return this._transformMatrix
		}
		serialize() {
			const e = {},
				t = this.getShadowMap();
			if (!t) return e;
			if (e.className = this.getClassName(), e.lightId = this._light.id, e.cameraId = this._camera?.id, e.id = this.id, e.mapSize = t.getRenderSize(), e.forceBackFacesOnly = this.forceBackFacesOnly, e.darkness = this.getDarkness(), e.transparencyShadow = this._transparencyShadow, e.frustumEdgeFalloff = this.frustumEdgeFalloff, e.bias = this.bias, e.normalBias = this.normalBias, e.usePercentageCloserFiltering = this.usePercentageCloserFiltering, e.useContactHardeningShadow = this.useContactHardeningShadow, e.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio, e.filteringQuality = this.filteringQuality, e.useExponentialShadowMap = this.useExponentialShadowMap, e.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap, e.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.usePoissonSampling = this.usePoissonSampling, e.depthScale = this.depthScale, e.blurBoxOffset = this.blurBoxOffset, e.blurKernel = this.blurKernel, e.blurScale = this.blurScale, e.useKernelBlur = this.useKernelBlur, e.Tk = [], t.Tk)
				for (let i = 0; i < t.Tk.length; i++) {
					const s = t.Tk[i];
					e.Tk.push(s.id)
				}
			return e
		}
		_initializeShadowMap() {
			if (this._createTargetRenderTexture(), null === this._shadowMap) return;
			this._shadowMap.wrapU = Np.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = Np.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(Np.BILINEAR_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.ignoreCameraViewport = !0, this._storedUniqueId && (this._shadowMap.ik = this._storedUniqueId), this._shadowMap.customRenderFunction = (e, t, i, s) => this._renderForShadowMap(e, t, i, s), this._shadowMap.customIsReadyFunction = () => !0;
			const t = this._scene.getEngine();
			this._shadowMap.onBeforeBindObservable.add((() => {
				this._currentSceneUBO = this._scene.getSceneUniformBuffer(), t._debugPushGroup?.(`shadow map generation for pass id ${t.currentRenderPassId}`, 1)
			})), this._shadowMap.onBeforeRenderObservable.add((i => {
				this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[0]), this._currentFaceIndex = i, this._filter === e.FILTER_PCF && t.setColorWrite(!1), this.getTransformMatrix(), this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo())
			})), this._shadowMap.onAfterUnbindObservable.add((() => {
				if (this._sceneUBOs && this._scene.setSceneUniformBuffer(this._currentSceneUBO), this._scene.updateTransformMatrix(), this._filter === e.FILTER_PCF && t.setColorWrite(!0), !this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) return void t._debugPopGroup?.(1);
				const i = this.getShadowMapForRendering();
				i && (this._scene.postProcessManager.directRender(this._blurPostProcesses, i.renderTarget, !0), t.unBindFramebuffer(i.renderTarget, !0), t._debugPopGroup?.(1))
			}));
			const i = new wc(0, 0, 0, 0),
				s = new wc(1, 1, 1, 1);
			this._shadowMap.onClearObservable.add((t => {
				this._filter === e.FILTER_PCF ? t.clear(s, !1, !0, !1) : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? t.clear(i, !0, !0, !1) : t.clear(s, !0, !0, !1)
			})), this._shadowMap.onResizeObservable.add((e => {
				this._storedUniqueId = this._shadowMap.ik, this._mapSize = e.getRenderSize(), this._light._markMeshesAsLightDirty(), this.recreateShadowMap()
			}));
			for (let e = qp.MIN_RENDERINGGROUPS; e < qp.MAX_RENDERINGGROUPS; e++) this._shadowMap.setRenderingAutoClearDepthStencil(e, !1)
		}
		set contactHardeningLightSizeUVRatio(e) {
			this._contactHardeningLightSizeUVRatio = e
		}
		get useCloseExponentialShadowMap() {
			return this.filter === e.FILTER_CLOSEEXPONENTIALSHADOWMAP
		}
		getShadowMap() {
			return this._shadowMap
		}
		getClassName() {
			return e.CLASSNAME
		}
		set mapSize(e) {
			this._mapSize = e, this._light._markMeshesAsLightDirty(), this.recreateShadowMap()
		}
		setDarkness(e) {
			return this._darkness = e >= 1 ? 1 : e <= 0 ? 0 : e, this
		}
		dispose() {
			if (this._disposeRTTandPostProcesses(), this._disposeSceneUBOs(), this._light) {
				if (this._light._shadowGenerators) {
					const e = this._light._shadowGenerators.entries();
					for (let t = e.next(); !0 !== t.done; t = e.next()) {
						const [e, i] = t.value;
						i === this && this._light._shadowGenerators.delete(e)
					}
					0 === this._light._shadowGenerators.size && (this._light._shadowGenerators = null)
				}
				this._light._markMeshesAsLightDirty()
			}
			this.onBeforeShadowMapRenderMeshObservable.clear(), this.onBeforeShadowMapRenderObservable.clear(), this.onAfterShadowMapRenderMeshObservable.clear(), this.onAfterShadowMapRenderObservable.clear()
		}
		_createTargetRenderTexture() {
			const e = this._scene.getEngine();
			e._features.supportDepthStencilTexture ? (this._shadowMap = new r_(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube(), void 0, !1, !1, void 0, this._useRedTextureType ? 6 : 5), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0, void 0, void 0, void 0, `DepthStencilForShadowGenerator-${this._light.name}`)) : this._shadowMap = new r_(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube()), this._shadowMap.noPrePassRenderer = !0
		}
		_isReadyCustomDefines(e, t, i) {}
		get useKernelBlur() {
			return this._useKernelBlur
		}
		set useKernelBlur(e) {
			this._useKernelBlur !== e && (this._useKernelBlur = e, this._disposeBlurPostProcesses())
		}
		_renderForShadowMap(e, t, i, s) {
			let n;
			if (s.length)
				for (n = 0; n < s.length; n++) this._renderSubMeshForShadowMap(s.data[n]);
			for (n = 0; n < e.length; n++) this._renderSubMeshForShadowMap(e.data[n]);
			for (n = 0; n < t.length; n++) this._renderSubMeshForShadowMap(t.data[n]);
			if (this._transparencyShadow)
				for (n = 0; n < i.length; n++) this._renderSubMeshForShadowMap(i.data[n], !0);
			else
				for (n = 0; n < i.length; n++) i.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1
		}
		prepareDefines(t, i) {
			const s = this._scene,
				n = this._light;
			s.shadowsEnabled && n.shadowEnabled && (t["SHADOW" + i] = !0, this.useContactHardeningShadow ? (t["SHADOWPCSS" + i] = !0, this._filteringQuality === e.QUALITY_LOW ? t["SHADOWLOWQUALITY" + i] = !0 : this._filteringQuality === e.QUALITY_MEDIUM && (t["SHADOWMEDIUMQUALITY" + i] = !0)) : this.usePercentageCloserFiltering ? (t["SHADOWPCF" + i] = !0, this._filteringQuality === e.QUALITY_LOW ? t["SHADOWLOWQUALITY" + i] = !0 : this._filteringQuality === e.QUALITY_MEDIUM && (t["SHADOWMEDIUMQUALITY" + i] = !0)) : this.usePoissonSampling ? t["SHADOWPOISSON" + i] = !0 : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? t["SHADOWESM" + i] = !0 : (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (t["SHADOWCLOSEESM" + i] = !0), n.needCube() && (t["SHADOWCUBE" + i] = !0))
		}
		static Parse(t, i, s) {
			const n = i.getLightById(t.lightId),
				a = void 0 !== t.cameraId ? i.getCameraById(t.cameraId) : null,
				r = s ? s(t.mapSize, n, a) : new e(t.mapSize, n, void 0, a),
				o = r.getShadowMap();
			for (let e = 0; e < t.Tk.length; e++) {
				i.getMeshesById(t.Tk[e]).forEach((function(e) {
					o && (o.Tk || (o.Tk = []), o.Tk.push(e))
				}))
			}
			return void 0 !== t.id && (r.id = t.id), r.forceBackFacesOnly = !!t.forceBackFacesOnly, void 0 !== t.darkness && r.setDarkness(t.darkness), t.transparencyShadow && r.setTransparencyShadow(!0), void 0 !== t.frustumEdgeFalloff && (r.frustumEdgeFalloff = t.frustumEdgeFalloff), void 0 !== t.bias && (r.bias = t.bias), void 0 !== t.normalBias && (r.normalBias = t.normalBias), t.usePercentageCloserFiltering ? r.usePercentageCloserFiltering = !0 : t.useContactHardeningShadow ? r.useContactHardeningShadow = !0 : t.usePoissonSampling ? r.usePoissonSampling = !0 : t.useExponentialShadowMap ? r.useExponentialShadowMap = !0 : t.useBlurExponentialShadowMap ? r.useBlurExponentialShadowMap = !0 : t.useCloseExponentialShadowMap ? r.useCloseExponentialShadowMap = !0 : t.useBlurCloseExponentialShadowMap ? r.useBlurCloseExponentialShadowMap = !0 : t.useVarianceShadowMap ? r.useExponentialShadowMap = !0 : t.useBlurVarianceShadowMap && (r.useBlurExponentialShadowMap = !0), void 0 !== t.contactHardeningLightSizeUVRatio && (r.contactHardeningLightSizeUVRatio = t.contactHardeningLightSizeUVRatio), void 0 !== t.filteringQuality && (r.filteringQuality = t.filteringQuality), t.depthScale && (r.depthScale = t.depthScale), t.blurScale && (r.blurScale = t.blurScale), t.blurBoxOffset && (r.blurBoxOffset = t.blurBoxOffset), t.useKernelBlur && (r.useKernelBlur = t.useKernelBlur), t.blurKernel && (r.blurKernel = t.blurKernel), r
		}
		_disposeBlurPostProcesses() {
			this._shadowMap2 && (this._shadowMap2.dispose(), this._shadowMap2 = null), this._boxBlurPostprocess && (this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = null), this._kernelBlurXPostprocess && (this._kernelBlurXPostprocess.dispose(), this._kernelBlurXPostprocess = null), this._kernelBlurYPostprocess && (this._kernelBlurYPostprocess.dispose(), this._kernelBlurYPostprocess = null), this._blurPostProcesses = []
		}
		async _initShaderSourceAsync(t = !1) {
			!this._scene.getEngine().isWebGPU || t || e.ForceGLSL ? await Promise.all([Promise.resolve().then((() => (As(), vs))), Promise.resolve().then((() => (zs(), Hs))), Promise.resolve().then((() => ($s(), Xs))), Promise.resolve().then((() => (en(), Js)))]) : (this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (Gi(), Oi))), Promise.resolve().then((() => (ss(), Zi))), Promise.resolve().then((() => (ls(), ns))), Promise.resolve().then((() => (ds(), hs)))])), this._shadersLoaded = !0
		}
		forceCompilationAsync(e) {
			return new Promise((t => {
				this.forceCompilation((() => {
					t()
				}), e)
			}))
		}
		getLight() {
			return this._light
		}
		_validateFilter(e) {
			return e
		}
		constructor(t, i, s, n, a, r = !1) {
			this.onBeforeShadowMapRenderObservable = new kc, this.onAfterShadowMapRenderObservable = new kc, this.onBeforeShadowMapRenderMeshObservable = new kc, this.onAfterShadowMapRenderMeshObservable = new kc, this._bias = 5e-5, this._normalBias = 0, this._blurBoxOffset = 1, this._blurScale = 2, this._blurKernel = 1, this._useKernelBlur = !1, this._filter = e.FILTER_NONE, this._filteringQuality = e.QUALITY_HIGH, this._contactHardeningLightSizeUVRatio = .1, this._darkness = 0, this._transparencyShadow = !1, this.enableSoftTransparentShadow = !1, this.useOpacityTextureForTransparentShadow = !1, this.frustumEdgeFalloff = 0, this._shaderLanguage = 0, this.forceBackFacesOnly = !1, this._lightDirection = Lc.Zero(), this._viewMatrix = Hc.Zero(), this._projectionMatrix = Hc.Zero(), this._transformMatrix = Hc.Zero(), this._cachedPosition = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cachedDirection = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._defaultTextureMatrix = Hc.Identity(), this._shadersLoaded = !1, this._mapSize = t, this._light = i, this._scene = i.getScene(), this._camera = n ?? null, this._useRedTextureType = !!a, this._initShaderSourceAsync(r);
			let o = i._shadowGenerators;
			o || (o = i._shadowGenerators = new Map), o.set(this._camera, this), this.id = i.id, this._useUBO = this._scene.getEngine().supportsUniformBuffers, this._useUBO && (this._sceneUBOs = [], this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))), e._SceneComponentInitialization(this._scene);
			const l = this._scene.getEngine().getCaps();
			s ? l.textureFloatRender && l.textureFloatLinearFiltering ? this._textureType = 1 : l.textureHalfFloatRender && l.textureHalfFloatLinearFiltering ? this._textureType = 2 : this._textureType = 0 : l.textureHalfFloatRender && l.textureHalfFloatLinearFiltering ? this._textureType = 2 : l.textureFloatRender && l.textureFloatLinearFiltering ? this._textureType = 1 : this._textureType = 0, this._initializeGenerator(), this._applyFilterValues()
		}
		get filteringQuality() {
			return this._filteringQuality
		}
		_initializeBlurRTTAndPostProcesses() {
			const e = this._scene.getEngine(),
				t = this._mapSize / this.blurScale;
			this.useKernelBlur && 1 === this.blurScale || (this._shadowMap2 = new r_(this._light.name + "_shadowMap2", t, this._scene, !1, !0, this._textureType, void 0, void 0, !1), this._shadowMap2.wrapU = Np.CLAMP_ADDRESSMODE, this._shadowMap2.wrapV = Np.CLAMP_ADDRESSMODE, this._shadowMap2.updateSamplingMode(Np.BILINEAR_SAMPLINGMODE)), this.useKernelBlur ? (this._kernelBlurXPostprocess = new wg(this._light.name + "KernelBlurX", new Fc(1, 0), this.blurKernel, 1, null, Np.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.width = t, this._kernelBlurXPostprocess.height = t, this._kernelBlurXPostprocess.externalTextureSamplerBinding = !0, this._kernelBlurXPostprocess.onApplyObservable.add((e => {
				e.setTexture("textureSampler", this._shadowMap)
			})), this._kernelBlurYPostprocess = new wg(this._light.name + "KernelBlurY", new Fc(0, 1), this.blurKernel, 1, null, Np.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.autoClear = !1, this._kernelBlurYPostprocess.autoClear = !1, 0 === this._textureType && (this._kernelBlurXPostprocess.packedFloat = !0, this._kernelBlurYPostprocess.packedFloat = !0), this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess]) : (this._boxBlurPostprocess = new Bp(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Np.BILINEAR_SAMPLINGMODE, e, !1, "#define OFFSET " + this._blurBoxOffset, this._textureType, void 0, void 0, void 0, void 0, this._shaderLanguage), this._boxBlurPostprocess.externalTextureSamplerBinding = !0, this._boxBlurPostprocess.onApplyObservable.add((e => {
				e.setFloat2("screenSize", t, t), e.setTexture("textureSampler", this._shadowMap)
			})), this._boxBlurPostprocess.autoClear = !1, this._blurPostProcesses = [this._boxBlurPostprocess])
		}
		get blurBoxOffset() {
			return this._blurBoxOffset
		}
		_getCamera() {
			return this._camera ?? this._scene.activeCamera
		}
		get shaderLanguage() {
			return this._shaderLanguage
		}
		get useExponentialShadowMap() {
			return this.filter === e.FILTER_EXPONENTIALSHADOWMAP
		}
		get blurKernel() {
			return this._blurKernel
		}
		set useBlurExponentialShadowMap(t) {
			const i = this._validateFilter(e.FILTER_BLUREXPONENTIALSHADOWMAP);
			(t || this.filter === e.FILTER_BLUREXPONENTIALSHADOWMAP) && (this.filter = t ? i : e.FILTER_NONE)
		}
		isReady(t, i, s) {
			if (!this._shadersLoaded) return !1;
			const n = t.getMaterial(),
				a = n?.shadowDepthWrapper;
			if (this._opacityTexture = null, !n) return !1;
			const r = [];
			if (this._prepareShadowDefines(t, i, r, s), a) {
				if (!a.isReadyForSubMesh(t, r, this, i, this._scene.getEngine().currentRenderPassId)) return !1
			} else {
				const s = t._getDrawWrapper(void 0, !0);
				let a = s.effect,
					o = s.defines;
				const l = [eu.PositionKind],
					h = t.getMesh();
				this.normalBias && h.isVerticesDataPresent(eu.NormalKind) && (l.push(eu.NormalKind), r.push("#define NORMAL"), h.nonUniformScaling && r.push("#define NONUNIFORMSCALING"));
				const c = n.needAlphaTesting();
				if ((c || n.needAlphaBlending()) && (this.useOpacityTextureForTransparentShadow ? this._opacityTexture = n.opacityTexture : this._opacityTexture = n.getAlphaTestTexture(), this._opacityTexture)) {
					if (!this._opacityTexture.isReady()) return !1;
					const t = n.alphaCutOff ?? e.DEFAULT_ALPHA_CUTOFF;
					r.push("#define ALPHATEXTURE"), c && r.push(`#define ALPHATESTVALUE ${t}${t%1==0?".":""}`), h.isVerticesDataPresent(eu.UVKind) && (l.push(eu.UVKind), r.push("#define UV1")), h.isVerticesDataPresent(eu.UV2Kind) && 1 === this._opacityTexture.coordinatesIndex && (l.push(eu.UV2Kind), r.push("#define UV2"))
				}
				const u = new Op;
				if (h.useBones && h.computeBonesUsingShaders && h.skeleton) {
					l.push(eu.MatricesIndicesKind), l.push(eu.MatricesWeightsKind), h.numBoneInfluencers > 4 && (l.push(eu.MatricesIndicesExtraKind), l.push(eu.MatricesWeightsExtraKind));
					const e = h.skeleton;
					r.push("#define NUM_BONE_INFLUENCERS " + h.numBoneInfluencers), h.numBoneInfluencers > 0 && u.addCPUSkinningFallback(0, h), e.isUsingTextureForMatrices ? r.push("#define BONETEXTURE") : r.push("#define BonesPerMesh " + (e.bones.length + 1))
				} else r.push("#define NUM_BONE_INFLUENCERS 0");
				const m = h.morphTargetManager;
				let d = 0;
				if (m && (d = m.numMaxInfluencers || m.numInfluencers, d > 0 && (r.push("#define MORPHTARGETS"), r.push("#define NUM_MORPH_INFLUENCERS " + d), m.isUsingTextureForTargets && r.push("#define MORPHTARGETS_TEXTURE"), af(l, h, d))), qd(n, this._scene, r), i && (r.push("#define INSTANCES"), of(l), t.getRenderingMesh().hasThinInstances && r.push("#define THIN_INSTANCES")), this.customShaderOptions && this.customShaderOptions.defines)
					for (const e of this.customShaderOptions.defines) - 1 === r.indexOf(e) && r.push(e);
				const f = h.bakedVertexAnimationManager;
				i && f && f.isEnabled && (r.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"), l.push("bakedVertexAnimationSettingsInstanced"));
				const p = r.join("\n");
				if (o !== p) {
					o = p;
					let e = "shadowMap";
					const t = ["world", "mBones", "viewProjection", "diffuseMatrix", "lightDataSM", "depthValuesSM", "biasAndScaleSM", "morphTargetInfluences", "morphTargetCount", "boneTextureWidth", "softTransparentShadowSM", "morphTargetTextureInfo", "morphTargetTextureIndices", "bakedVertexAnimationSettings", "bakedVertexAnimationTextureSizeInverted", "bakedVertexAnimationTime", "bakedVertexAnimationTexture"],
						i = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"],
						n = ["Scene", "Mesh"];
					if (Jd(t), this.customShaderOptions) {
						if (e = this.customShaderOptions.shaderName, this.customShaderOptions.attributes)
							for (const e of this.customShaderOptions.attributes) - 1 === l.indexOf(e) && l.push(e);
						if (this.customShaderOptions.uniforms)
							for (const e of this.customShaderOptions.uniforms) - 1 === t.indexOf(e) && t.push(e);
						if (this.customShaderOptions.samplers)
							for (const e of this.customShaderOptions.samplers) - 1 === i.indexOf(e) && i.push(e)
					}
					const r = this._scene.getEngine();
					a = r.createEffect(e, {
						attributes: l,
						uniformsNames: t,
						uniformBuffersNames: n,
						samplers: i,
						defines: p,
						fallbacks: u,
						onCompiled: null,
						onError: null,
						indexParameters: {
							maxSimultaneousMorphTargets: d
						},
						shaderLanguage: this._shaderLanguage
					}, r), s.setEffect(a, o)
				}
				if (!a.isReady()) return !1
			}
			return (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (this._blurPostProcesses && this._blurPostProcesses.length || this._initializeBlurRTTAndPostProcesses()), !(this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) && (!(this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) && !(this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()))
		}
		_disposeSceneUBOs() {
			if (this._sceneUBOs) {
				for (const e of this._sceneUBOs) e.dispose();
				this._sceneUBOs = []
			}
		}
		get contactHardeningLightSizeUVRatio() {
			return this._contactHardeningLightSizeUVRatio
		}
		bindShadowLight(t, i) {
			const s = this._light;
			if (!this._scene.shadowsEnabled || !s.shadowEnabled) return;
			const n = this._getCamera();
			if (!n) return;
			const a = this.getShadowMap();
			if (!a) return;
			s.needCube() || i.setMatrix("lightMatrix" + t, this.getTransformMatrix());
			const r = this.getShadowMapForRendering();
			this._filter === e.FILTER_PCF ? (i.setDepthStencilTexture("shadowTexture" + t, r), s._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a.getSize().width, 1 / a.getSize().width, this.frustumEdgeFalloff, t)) : this._filter === e.FILTER_PCSS ? (i.setDepthStencilTexture("shadowTexture" + t, r), i.setTexture("depthTexture" + t, r), s._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / a.getSize().width, this._contactHardeningLightSizeUVRatio * a.getSize().width, this.frustumEdgeFalloff, t)) : (i.setTexture("shadowTexture" + t, r), s._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / a.getSize().width, this.depthScale, this.frustumEdgeFalloff, t)), s._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(n), this.getLight().getDepthMinZ(n) + this.getLight().getDepthMaxZ(n), t)
		}
		set usePercentageCloserFiltering(t) {
			const i = this._validateFilter(e.FILTER_PCF);
			(t || this.filter === e.FILTER_PCF) && (this.filter = t ? i : e.FILTER_NONE)
		}
		set normalBias(e) {
			this._normalBias = e
		}
		get normalBias() {
			return this._normalBias
		}
		get mapSize() {
			return this._mapSize
		}
		removeShadowCaster(e, t = !0) {
			if (!this._shadowMap || !this._shadowMap.Tk) return this;
			const i = this._shadowMap.Tk.indexOf(e);
			if (-1 !== i && this._shadowMap.Tk.splice(i, 1), t)
				for (const t of e.getChildren()) this.removeShadowCaster(t);
			return this
		}
		set useCloseExponentialShadowMap(t) {
			const i = this._validateFilter(e.FILTER_CLOSEEXPONENTIALSHADOWMAP);
			(t || this.filter === e.FILTER_CLOSEEXPONENTIALSHADOWMAP) && (this.filter = t ? i : e.FILTER_NONE)
		}
		get darkness() {
			return this._darkness
		}
		set useExponentialShadowMap(t) {
			const i = this._validateFilter(e.FILTER_EXPONENTIALSHADOWMAP);
			(t || this.filter === e.FILTER_EXPONENTIALSHADOWMAP) && (this.filter = t ? i : e.FILTER_NONE)
		}
		get useBlurCloseExponentialShadowMap() {
			return this.filter === e.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP
		}
		getDarkness() {
			return this._darkness
		}
		set bias(e) {
			this._bias = e
		}
		set transparencyShadow(e) {
			this.setTransparencyShadow(e)
		}
		set usePoissonSampling(t) {
			const i = this._validateFilter(e.FILTER_POISSONSAMPLING);
			(t || this.filter === e.FILTER_POISSONSAMPLING) && (this.filter = t ? i : e.FILTER_NONE)
		}
		get usePercentageCloserFiltering() {
			return this.filter === e.FILTER_PCF
		}
		setTransparencyShadow(e) {
			return this._transparencyShadow = e, this
		}
		set darkness(e) {
			this.setDarkness(e)
		}
		_applyFilterValues() {
			this._shadowMap && (this.filter === e.FILTER_NONE || this.filter === e.FILTER_PCSS ? this._shadowMap.updateSamplingMode(Np.NEAREST_SAMPLINGMODE) : this._shadowMap.updateSamplingMode(Np.BILINEAR_SAMPLINGMODE))
		}
		get useContactHardeningShadow() {
			return this.filter === e.FILTER_PCSS
		}
		get filter() {
			return this._filter
		}
		set useContactHardeningShadow(t) {
			const i = this._validateFilter(e.FILTER_PCSS);
			(t || this.filter === e.FILTER_PCSS) && (this.filter = t ? i : e.FILTER_NONE)
		}
		set blurBoxOffset(e) {
			this._blurBoxOffset !== e && (this._blurBoxOffset = e, this._disposeBlurPostProcesses())
		}
		get projectionMatrix() {
			return this._projectionMatrix
		}
		addShadowCaster(e, t = !0) {
			if (!this._shadowMap) return this;
			if (this._shadowMap.Tk || (this._shadowMap.Tk = []), -1 === this._shadowMap.Tk.indexOf(e) && this._shadowMap.Tk.push(e), t)
				for (const t of e.getChildMeshes()) - 1 === this._shadowMap.Tk.indexOf(t) && this._shadowMap.Tk.push(t);
			return this
		}
		get usePoissonSampling() {
			return this.filter === e.FILTER_POISSONSAMPLING
		}
		getShadowMapForRendering() {
			return this._shadowMap2 ? this._shadowMap2 : this._shadowMap
		}
		get blurScale() {
			return this._blurScale
		}
		set useBlurCloseExponentialShadowMap(t) {
			const i = this._validateFilter(e.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
			(t || this.filter === e.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) && (this.filter = t ? i : e.FILTER_NONE)
		}
		_bindCustomEffectForRenderSubMeshForShadowMap(e, t, i) {
			t.setMatrix("viewProjection", this.getTransformMatrix())
		}
		set blurScale(e) {
			this._blurScale !== e && (this._blurScale = e, this._disposeBlurPostProcesses())
		}
		_renderSubMeshForShadowMap(e, t = !1) {
			const i = e.getRenderingMesh(),
				s = e.getEffectiveMesh(),
				n = this._scene,
				a = n.getEngine(),
				r = e.getMaterial();
			if (s._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !r || 0 === e.verticesCount || e._renderId === n.getRenderId()) return;
			const o = n.useRightHandedSystem,
				l = s._getWorldMatrixDeterminant() < 0;
			let h = r._getEffectiveOrientation(i);
			(l && !o || !l && o) && (h = 0 === h ? 1 : 0);
			const c = 0 === h;
			a.setState(r.backFaceCulling, void 0, void 0, c, r.cullBackFaces);
			const u = i._getInstancesRenderList(e._id, !!e.getReplacementMesh());
			if (u.mustReturn) return;
			const m = a.getCaps().instancedArrays && (null !== u.visibleInstances[e._id] && void 0 !== u.visibleInstances[e._id] || i.hasThinInstances);
			if (!this.customAllowRendering || this.customAllowRendering(e))
				if (this.isReady(e, m, t)) {
					e._renderId = n.getRenderId();
					const o = r.shadowDepthWrapper,
						l = o?.getEffect(e, this, a.currentRenderPassId) ?? e._getDrawWrapper(),
						h = Au.GetEffect(l);
					a.enableEffect(l), m || i._bind(e, h, r.fillMode), this.getTransformMatrix(), h.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale), this.getLight().getTypeID() === xg.LIGHTTYPEID_DIRECTIONALLIGHT ? h.setVector3("lightDataSM", this._cachedDirection) : h.setVector3("lightDataSM", this._cachedPosition);
					const c = this._getCamera();
					if (c && h.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(c), this.getLight().getDepthMinZ(c) + this.getLight().getDepthMaxZ(c)), t && this.enableSoftTransparentShadow && h.setFloat2("softTransparentShadowSM", s.visibility * r.alpha, this._opacityTexture?.getAlphaFromRGB ? 1 : 0), o) e._setMainDrawWrapperOverride(l), o.standalone ? o.baseMaterial.bindForSubMesh(s.getWorldMatrix(), i, e) : r.bindForSubMesh(s.getWorldMatrix(), i, e), e._setMainDrawWrapperOverride(null);
					else {
						if (this._opacityTexture && (h.setTexture("diffuseSampler", this._opacityTexture), h.setMatrix("diffuseMatrix", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix)), i.useBones && i.computeBonesUsingShaders && i.skeleton) {
							const e = i.skeleton;
							if (e.isUsingTextureForMatrices) {
								const t = e.getTransformMatrixTexture(i);
								if (!t) return;
								h.setTexture("boneSampler", t), h.setFloat("boneTextureWidth", 4 * (e.bones.length + 1))
							} else h.setMatrices("mBones", e.getTransformMatrices(i))
						}
						lf(i, h), i.morphTargetManager && i.morphTargetManager.isUsingTextureForTargets && i.morphTargetManager._bind(h);
						const t = e.getMesh().bakedVertexAnimationManager;
						m && t && t.isEnabled && t.bind(h, !0), Qd(h, r, n)
					}
					this._useUBO || o || this._bindCustomEffectForRenderSubMeshForShadowMap(e, h, s), hf(h, this._scene.getSceneUniformBuffer()), this._scene.getSceneUniformBuffer().bindUniformBuffer();
					const d = s.getWorldMatrix();
					m && (s.getMeshUniformBuffer().bindToEffect(h, "Mesh"), s.transferToEffect(d)), this.forceBackFacesOnly && a.setState(!0, 0, !1, !0, r.cullBackFaces), this.onBeforeShadowMapRenderMeshObservable.notifyObservers(i), this.onBeforeShadowMapRenderObservable.notifyObservers(h), i._processRendering(s, e, h, r.fillMode, u, m, ((e, t) => {
						s === i || e ? (s.getMeshUniformBuffer().bindToEffect(h, "Mesh"), s.transferToEffect(e ? t : d)) : (i.getMeshUniformBuffer().bindToEffect(h, "Mesh"), i.transferToEffect(t))
					})), this.forceBackFacesOnly && a.setState(!0, 0, !1, !1, r.cullBackFaces), this.onAfterShadowMapRenderObservable.notifyObservers(h), this.onAfterShadowMapRenderMeshObservable.notifyObservers(i)
				} else this._shadowMap && this._shadowMap.resetRefreshCounter()
		}
		_disposeRTTandPostProcesses() {
			this._shadowMap && (this._shadowMap.dispose(), this._shadowMap = null), this._disposeBlurPostProcesses()
		}
		_initializeGenerator() {
			this._light._markMeshesAsLightDirty(), this._initializeShadowMap()
		}
		recreateShadowMap() {
			const e = this._shadowMap;
			if (!e) return;
			const t = e.Tk;
			if (this._disposeRTTandPostProcesses(), this._initializeGenerator(), this.filter = this._filter, this._applyFilterValues(), t) {
				this._shadowMap.Tk || (this._shadowMap.Tk = []);
				for (const e of t) this._shadowMap.Tk.push(e)
			} else this._shadowMap.Tk = null
		}
		get transparencyShadow() {
			return this._transparencyShadow
		}
		get viewMatrix() {
			return this._viewMatrix
		}
		_prepareShadowDefines(e, t, i, s) {
			i.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase()), i.push("#define SM_FLOAT " + (0 !== this._textureType ? "1" : "0")), i.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0")), i.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
			const n = e.getMesh();
			return i.push("#define SM_NORMALBIAS " + (this.normalBias && n.isVerticesDataPresent(eu.NormalKind) ? "1" : "0")), i.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === xg.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0")), i.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0")), i.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && s ? "1" : "0")), this._isReadyCustomDefines(i, e, t), i
		}
		set blurKernel(e) {
			this._blurKernel !== e && (this._blurKernel = e, this._disposeBlurPostProcesses())
		}
		set filteringQuality(e) {
			this._filteringQuality !== e && (this._filteringQuality = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty())
		}
	};
	Rg.CLASSNAME = "ShadowGenerator", Rg.ForceGLSL = !1, Rg.FILTER_NONE = 0, Rg.FILTER_EXPONENTIALSHADOWMAP = 1, Rg.FILTER_POISSONSAMPLING = 2, Rg.FILTER_BLUREXPONENTIALSHADOWMAP = 3, Rg.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4, Rg.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5, Rg.FILTER_PCF = 6, Rg.FILTER_PCSS = 7, Rg.QUALITY_HIGH = 0, Rg.QUALITY_MEDIUM = 1, Rg.QUALITY_LOW = 2, Rg.DEFAULT_ALPHA_CUTOFF = .5, Rg._SceneComponentInitialization = e => {
		throw ic("ShadowGeneratorSceneComponent")
	}, jc.AddNodeConstructor("TargetCamera", ((e, t) => () => new Ng(e, Lc.Zero(), t)));
	var Ng = class e extends Sd {
		_updateRigCameras() {
			const e = this._rigCameras[0],
				t = this._rigCameras[1];
			switch (this.computeWorldMatrix(), this.cameraRigMode) {
				case Sd.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
				case Sd.RIG_MODE_STEREOSCOPIC_OVERUNDER:
				case Sd.RIG_MODE_STEREOSCOPIC_INTERLACED: {
					const i = this.cameraRigMode === Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1,
						s = this.cameraRigMode === Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
					this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * i, e), this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * s, t);
					break
				}
				case Sd.RIG_MODE_VR:
					e.rotationQuaternion ? (e.rotationQuaternion.copyFrom(this.rotationQuaternion), t.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.rotation.copyFrom(this.rotation), t.rotation.copyFrom(this.rotation)), e.position.copyFrom(this.position), t.position.copyFrom(this.position)
			}
			super._updateRigCameras()
		}
		createRigCamera(t, i) {
			if (this.cameraRigMode !== Sd.RIG_MODE_NONE) {
				const i = new e(t, this.position.clone(), this.getScene());
				return i.isRigCamera = !0, i.rigParent = this, this.cameraRigMode === Sd.RIG_MODE_VR && (this.rotationQuaternion || (this.rotationQuaternion = new Gc), i._cameraRigParams = {}, i.rotationQuaternion = new Gc), i.mode = this.mode, i.orthoLeft = this.orthoLeft, i.orthoRight = this.orthoRight, i.orthoTop = this.orthoTop, i.orthoBottom = this.orthoBottom, i
			}
			return null
		}
		_checkInputs() {
			const e = this.invertRotation ? -this.inverseRotationSpeed : 1,
				t = this._decideIfNeedsToMove(),
				i = this.cameraRotation.x || this.cameraRotation.y;
			if (this._deferredUpdated = !1, this._deferredRotationUpdate.copyFrom(this.rotation), this._deferredPositionUpdate.copyFrom(this.position), this.rotationQuaternion && this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion), t && this._updatePosition(), i) {
				if (this.rotationQuaternion && this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate), this._deferredRotationUpdate.x += this.cameraRotation.x * e, this._deferredRotationUpdate.y += this.cameraRotation.y * e, !this.noRotationConstraint) {
					const e = 1.570796;
					this._deferredRotationUpdate.x > e && (this._deferredRotationUpdate.x = e), this._deferredRotationUpdate.x < -e && (this._deferredRotationUpdate.x = -e)
				}
				if (this._deferOnly ? this._deferredUpdated = !0 : this.rotation.copyFrom(this._deferredRotationUpdate), this.rotationQuaternion) {
					this._deferredRotationUpdate.lengthSquared() && (Gc.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate), this._deferOnly ? this._deferredUpdated = !0 : this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))
				}
			}
			t && (Math.abs(this.cameraDirection.x) < this.speed * pc && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < this.speed * pc && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < this.speed * pc && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), i && (Math.abs(this.cameraRotation.x) < this.speed * pc && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < this.speed * pc && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), super._checkInputs()
		}
		_updateCameraRotationMatrix() {
			this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : Hc.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix)
		}
		_getRigCamPositionAndTarget(t, i) {
			this.getTarget().subtractToRef(this.position, e._TargetFocalPoint), e._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
			const s = e._TargetFocalPoint.addInPlace(this.position);
			Hc.TranslationToRef(-s.x, -s.y, -s.z, e._TargetTransformMatrix), e._TargetTransformMatrix.multiplyToRef(Hc.RotationAxis(i.upVector, t), e._RigCamTransformMatrix), Hc.TranslationToRef(s.x, s.y, s.z, e._TargetTransformMatrix), e._RigCamTransformMatrix.multiplyToRef(e._TargetTransformMatrix, e._RigCamTransformMatrix), Lc.TransformCoordinatesToRef(this.position, e._RigCamTransformMatrix, i.position), i.setTarget(s)
		}
		set target(e) {
			this.setTarget(e)
		}
		_updateCache(e) {
			e || super._updateCache();
			const t = this._getLockedTargetPosition();
			t ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(t) : this._cache.lockedTarget = t.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)
		}
		_isSynchronizedViewMatrix() {
			if (!super._isSynchronizedViewMatrix()) return !1;
			const e = this._getLockedTargetPosition();
			return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))
		}
		getClassName() {
			return "TargetCamera"
		}
		_computeViewMatrix(e, t, i) {
			if (this.ignoreParentScaling) {
				if (this.parent) {
					const s = this.parent.getWorldMatrix();
					Lc.TransformCoordinatesToRef(e, s, this._globalPosition), Lc.TransformCoordinatesToRef(t, s, this._tmpTargetVector), Lc.TransformNormalToRef(i, s, this._tmpUpVector), this._markSyncedWithParent()
				} else this._globalPosition.copyFrom(e), this._tmpTargetVector.copyFrom(t), this._tmpUpVector.copyFrom(i);
				this.getScene().useRightHandedSystem ? Hc.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix) : Hc.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix)
			} else if (this.getScene().useRightHandedSystem ? Hc.LookAtRHToRef(e, t, i, this._viewMatrix) : Hc.LookAtLHToRef(e, t, i, this._viewMatrix), this.parent) {
				const e = this.parent.getWorldMatrix();
				this._viewMatrix.invert(), this._viewMatrix.multiplyToRef(e, this._viewMatrix), this._viewMatrix.getTranslationToRef(this._globalPosition), this._viewMatrix.invert(), this._markSyncedWithParent()
			} else this._globalPosition.copyFrom(e)
		}
		storeState() {
			return this._storedPosition = this.position.clone(), this._storedRotation = this.rotation.clone(), this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()), super.storeState()
		}
		_computeLocalCameraSpeed() {
			const e = this.getEngine();
			return this.speed * Math.sqrt(e.getDeltaTime() / (100 * e.getFps()))
		}
		_restoreStateValues() {
			return !!super._restoreStateValues() && (this.position = this._storedPosition.clone(), this.rotation = this._storedRotation.clone(), this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()), this.cameraDirection.copyFromFloats(0, 0, 0), this.cameraRotation.copyFromFloats(0, 0), !0)
		}
		_rotateUpVectorWithCameraRotationMatrix() {
			return Lc.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector), this
		}
		_updatePosition() {
			if (this.parent) return this.parent.getWorldMatrix().invertToRef(Vc.Matrix[0]), Lc.TransformNormalToRef(this.cameraDirection, Vc.Matrix[0], Vc.Vector3[0]), this._deferredPositionUpdate.addInPlace(Vc.Vector3[0]), void(this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate));
			this._deferredPositionUpdate.addInPlace(this.cameraDirection), this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate)
		}
		constructor(e, t, i, s = !0) {
			super(e, t, i, s), this._tmpUpVector = Lc.Zero(), this._tmpTargetVector = Lc.Zero(), this.cameraDirection = new Lc(0, 0, 0), this.cameraRotation = new Fc(0, 0), this.ignoreParentScaling = !1, this.updateUpVectorFromRotation = !1, this._tmpQuaternion = new Gc, this.rotation = new Lc(0, 0, 0), this.speed = 2, this.noRotationConstraint = !1, this.invertRotation = !1, this.inverseRotationSpeed = .2, this.lockedTarget = null, this._currentTarget = Lc.Zero(), this._initialFocalDistance = 1, this._viewMatrix = Hc.Zero(), this._camMatrix = Hc.Zero(), this._cameraTransformMatrix = Hc.Zero(), this._cameraRotationMatrix = Hc.Zero(), this._referencePoint = new Lc(0, 0, 1), this._transformedReferencePoint = Lc.Zero(), this._deferredPositionUpdate = new Lc, this._deferredRotationQuaternionUpdate = new Gc, this._deferredRotationUpdate = new Lc, this._deferredUpdated = !1, this._deferOnly = !1, this._defaultUp = Lc.Up(), this._cachedRotationZ = 0, this._cachedQuaternionRotationZ = 0
		}
		setTarget(e) {
			this.upVector.normalize(), this._initialFocalDistance = e.subtract(this.position).length(), this.position.z === e.z && (this.position.z += pc), this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance), Hc.LookAtLHToRef(this.position, e, this._defaultUp, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
			const t = e.subtract(this.position);
			t.x >= 0 ? this.rotation.y = -Math.atan(t.z / t.x) + Math.PI / 2 : this.rotation.y = -Math.atan(t.z / t.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && Gc.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion)
		}
		_decideIfNeedsToMove() {
			return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
		}
		_initCache() {
			super._initCache(), this._cache.lockedTarget = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new Gc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
		}
		get target() {
			return this.getTarget()
		}
		getFrontPosition(e) {
			this.getWorldMatrix();
			const t = this.getTarget().subtract(this.position);
			return t.normalize(), t.scaleInPlace(e), this.globalPosition.add(t)
		}
		getTarget() {
			return this._currentTarget
		}
		_getViewMatrix() {
			return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()), this._updateCameraRotationMatrix(), this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ !== this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedRotationZ = this.rotation.z), Lc.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), this.updateUpVectorFromRotation && (this.rotationQuaternion ? zd.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector) : (Gc.FromEulerVectorToRef(this.rotation, this._tmpQuaternion), zd.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector))), this._computeViewMatrix(this.position, this._currentTarget, this.upVector), this._viewMatrix
		}
		_getLockedTargetPosition() {
			if (!this.lockedTarget) return null;
			if (this.lockedTarget.absolutePosition) {
				const e = this.lockedTarget;
				e.computeWorldMatrix().getTranslationToRef(e.absolutePosition)
			}
			return this.lockedTarget.absolutePosition || this.lockedTarget
		}
	};
	Ng._RigCamTransformMatrix = new Hc, Ng._TargetTransformMatrix = new Hc, Ng._TargetFocalPoint = new Lc, Gh([Jh()], Ng.prototype, "rotation", void 0), Gh([Xh()], Ng.prototype, "speed", void 0), Gh([qh("lockedTargetId")], Ng.prototype, "lockedTarget", void 0);
	var Ig = class {
			get idleRotationWaitTime() {
				return this._idleRotationWaitTime
			}
			_applyUserInteraction() {
				this._userIsMoving() && !this._shouldAnimationStopForInteraction() && (this._lastInteractionTime = Pu.Now)
			}
			get idleRotationSpeed() {
				return this._idleRotationSpeed
			}
			set idleRotationSpinupTime(e) {
				this._idleRotationSpinupTime = e
			}
			set zoomStopsAnimation(e) {
				this._zoomStopsAnimation = e
			}
			set idleRotationSpeed(e) {
				this._idleRotationSpeed = e
			}
			get idleRotationSpinupTime() {
				return this._idleRotationSpinupTime
			}
			detach() {
				if (!this._attachedCamera) return;
				const e = this._attachedCamera.getScene();
				this._onPrePointerObservableObserver && e.onPrePointerObservable.remove(this._onPrePointerObservableObserver), this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._attachedCamera = null
			}
			init() {}
			resetLastInteractionTime(e) {
				this._lastInteractionTime = e ?? Pu.Now
			}
			attach(e) {
				this._attachedCamera = e;
				const t = this._attachedCamera.getScene();
				this._onPrePointerObservableObserver = t.onPrePointerObservable.add((e => {
					e.type !== H_.POINTERDOWN ? e.type === H_.POINTERUP && (this._isPointerDown = !1) : this._isPointerDown = !0
				})), this._onAfterCheckInputsObserver = e.onAfterCheckInputsObservable.add((() => {
					if (this._reachTargetAlpha()) return;
					const e = Pu.Now;
					let t = 0;
					null != this._lastFrameTime && (t = e - this._lastFrameTime), this._lastFrameTime = e, this._applyUserInteraction();
					const i = e - this._lastInteractionTime - this._idleRotationWaitTime,
						s = Math.max(Math.min(i / this._idleRotationSpinupTime, 1), 0);
					this._cameraRotationSpeed = this._idleRotationSpeed * s, this._attachedCamera && (this._attachedCamera.alpha -= this._cameraRotationSpeed * (t / 1e3))
				}))
			}
			_userIsMoving() {
				return !!this._attachedCamera && (0 !== this._attachedCamera.inertialAlphaOffset || 0 !== this._attachedCamera.inertialBetaOffset || 0 !== this._attachedCamera.inertialRadiusOffset || 0 !== this._attachedCamera.inertialPanningX || 0 !== this._attachedCamera.inertialPanningY || this._isPointerDown)
			}
			constructor() {
				this._zoomStopsAnimation = !1, this._idleRotationSpeed = .05, this._idleRotationWaitTime = 2e3, this._idleRotationSpinupTime = 2e3, this.targetAlpha = null, this._isPointerDown = !1, this._lastFrameTime = null, this._lastInteractionTime = -1 / 0, this._cameraRotationSpeed = 0, this._lastFrameRadius = 0
			}
			_reachTargetAlpha() {
				return !(!this._attachedCamera || !this.targetAlpha) && Math.abs(this._attachedCamera.alpha - this.targetAlpha) < pc
			}
			_shouldAnimationStopForInteraction() {
				if (!this._attachedCamera) return !1;
				let e = !1;
				return this._lastFrameRadius === this._attachedCamera.radius && 0 !== this._attachedCamera.inertialRadiusOffset && (e = !0), this._lastFrameRadius = this._attachedCamera.radius, this._zoomStopsAnimation ? e : this._userIsZooming()
			}
			set idleRotationWaitTime(e) {
				this._idleRotationWaitTime = e
			}
			get zoomStopsAnimation() {
				return this._zoomStopsAnimation
			}
			get rotationInProgress() {
				return Math.abs(this._cameraRotationSpeed) > 0
			}
			_userIsZooming() {
				return !!this._attachedCamera && 0 !== this._attachedCamera.inertialRadiusOffset
			}
			get name() {
				return "AutoRotation"
			}
		},
		Pg = class e {
			ease(t) {
				switch (this._easingMode) {
					case e.EASINGMODE_EASEIN:
						return this.easeInCore(t);
					case e.EASINGMODE_EASEOUT:
						return 1 - this.easeInCore(1 - t)
				}
				return t >= .5 ? .5 * (1 - this.easeInCore(2 * (1 - t))) + .5 : .5 * this.easeInCore(2 * t)
			}
			constructor() {
				this._easingMode = e.EASINGMODE_EASEIN
			}
			easeInCore(e) {
				throw new Error("You must implement this method")
			}
			getEasingMode() {
				return this._easingMode
			}
			setEasingMode(e) {
				const t = Math.min(Math.max(e, 0), 2);
				this._easingMode = t
			}
		};
	Pg.EASINGMODE_EASEIN = 0, Pg.EASINGMODE_EASEOUT = 1, Pg.EASINGMODE_EASEINOUT = 2;
	var kg = class extends Pg {
			easeInCore(e) {
				return e * e * e
			}
		},
		Dg = class extends Pg {
			easeInCore(e) {
				let t;
				const i = Math.max(0, this.oscillations),
					s = Math.max(0, this.springiness);
				return t = 0 == s ? e : (Math.exp(s * e) - 1) / (Math.exp(s) - 1), t * Math.sin((6.283185307179586 * i + 1.5707963267948966) * e)
			}
			constructor(e = 3, t = 3) {
				super(), this.oscillations = e, this.springiness = t
			}
		},
		Og = class e {
			constructor(e, t, i) {
				this.name = e, this.from = t, this.to = i
			}
			clone() {
				return new e(this.name, this.from, this.to)
			}
		},
		Fg = Object.freeze(new Gc(0, 0, 0, 0)),
		Lg = Object.freeze(Lc.Zero()),
		Bg = Object.freeze(Fc.Zero()),
		Gg = Object.freeze(Ap.Zero()),
		Hg = Object.freeze(Tc.Black()),
		Ug = Object.freeze(new wc(0, 0, 0, 0)),
		Vg = {
			key: 0,
			repeatCount: 0,
			loopMode: 2
		},
		Wg = class e {
			floatInterpolateFunctionWithTangents(e, t, i, s, n) {
				return Ac.Hermite(e, t, i, s, n)
			}
			_interpolate(t, i, s = !1) {
				if (i.loopMode === e.ANIMATIONLOOPMODE_CONSTANT && i.repeatCount > 0) return i.highLimitValue.clone ? i.highLimitValue.clone() : i.highLimitValue;
				const n = this._keys,
					a = n.length;
				let r = i.key;
				for (; r >= 0 && t < n[r].frame;) --r;
				for (; r + 1 <= a - 1 && t >= n[r + 1].frame;) ++r;
				if (i.key = r, r < 0) return s ? void 0 : this._getKeyValue(n[0].value);
				if (r + 1 > a - 1) return s ? void 0 : this._getKeyValue(n[a - 1].value);
				const o = n[r],
					l = n[r + 1];
				if (s && (t === o.frame || t === l.frame)) return;
				const h = this._getKeyValue(o.value),
					c = this._getKeyValue(l.value);
				if (1 === o.interpolation) return l.frame > t ? h : c;
				const u = void 0 !== o.outTangent && void 0 !== l.inTangent,
					m = l.frame - o.frame;
				let d = (t - o.frame) / m;
				const f = o.easingFunction || this.getEasingFunction();
				switch (null !== f && (d = f.ease(d)), this.dataType) {
					case e.ANIMATIONTYPE_FLOAT: {
						const t = u ? this.floatInterpolateFunctionWithTangents(h, o.outTangent * m, c, l.inTangent * m, d) : this.floatInterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return (i.offsetValue ?? 0) * i.repeatCount + t
						}
						break
					}
					case e.ANIMATIONTYPE_QUATERNION: {
						const t = u ? this.quaternionInterpolateFunctionWithTangents(h, o.outTangent.scale(m), c, l.inTangent.scale(m), d) : this.quaternionInterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return t.addInPlace((i.offsetValue || Fg).scale(i.repeatCount))
						}
						return t
					}
					case e.ANIMATIONTYPE_VECTOR3: {
						const t = u ? this.vector3InterpolateFunctionWithTangents(h, o.outTangent.scale(m), c, l.inTangent.scale(m), d) : this.vector3InterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return t.add((i.offsetValue || Lg).scale(i.repeatCount))
						}
						break
					}
					case e.ANIMATIONTYPE_VECTOR2: {
						const t = u ? this.vector2InterpolateFunctionWithTangents(h, o.outTangent.scale(m), c, l.inTangent.scale(m), d) : this.vector2InterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return t.add((i.offsetValue || Bg).scale(i.repeatCount))
						}
						break
					}
					case e.ANIMATIONTYPE_SIZE:
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return this.sizeInterpolateFunction(h, c, d);
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return this.sizeInterpolateFunction(h, c, d).add((i.offsetValue || Gg).scale(i.repeatCount))
						}
						break;
					case e.ANIMATIONTYPE_COLOR3: {
						const t = u ? this.color3InterpolateFunctionWithTangents(h, o.outTangent.scale(m), c, l.inTangent.scale(m), d) : this.color3InterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return t.add((i.offsetValue || Hg).scale(i.repeatCount))
						}
						break
					}
					case e.ANIMATIONTYPE_COLOR4: {
						const t = u ? this.color4InterpolateFunctionWithTangents(h, o.outTangent.scale(m), c, l.inTangent.scale(m), d) : this.color4InterpolateFunction(h, c, d);
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return t;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return t.add((i.offsetValue || Ug).scale(i.repeatCount))
						}
						break
					}
					case e.ANIMATIONTYPE_MATRIX:
						switch (i.loopMode) {
							case e.ANIMATIONLOOPMODE_CYCLE:
							case e.ANIMATIONLOOPMODE_CONSTANT:
							case e.ANIMATIONLOOPMODE_YOYO:
								return e.AllowMatricesInterpolation ? this.matrixInterpolateFunction(h, c, d, i.workValue) : h;
							case e.ANIMATIONLOOPMODE_RELATIVE:
							case e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
								return h
						}
				}
				return 0
			}
			color4InterpolateFunction(e, t, i) {
				return wc.Lerp(e, t, i)
			}
			quaternionInterpolateFunctionWithTangents(e, t, i, s, n) {
				return Gc.Hermite(e, t, i, s, n).normalize()
			}
			_getKeyValue(e) {
				return "function" == typeof e ? e() : e
			}
			toString(e) {
				let t = "Name: " + this.name + ", property: " + this.targetProperty;
				if (t += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType], t += ", nKeys: " + (this._keys ? this._keys.length : "none"), t += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none"), e) {
					t += ", Ranges: {";
					let e = !0;
					for (const i in this._ranges) e && (t += ", ", e = !1), t += i;
					t += "}"
				}
				return t
			}
			quaternionInterpolateFunction(e, t, i) {
				return Gc.Slerp(e, t, i)
			}
			static MakeAnimationAdditive(t, i, s, n = !1, a) {
				let r;
				r = "object" == typeof i ? i : {
					referenceFrame: i ?? 0,
					range: s,
					cloneOriginalAnimation: n,
					clonedAnimationName: a
				};
				let o = t;
				if (r.cloneOriginalAnimation && (o = t.clone(), o.name = r.clonedAnimationName || o.name), !o._keys.length) return o;
				const l = r.referenceFrame && r.referenceFrame >= 0 ? r.referenceFrame : 0;
				let h = 0;
				const c = o._keys[0];
				let u = o._keys.length - 1;
				const m = o._keys[u],
					d = {
						referenceValue: c.value,
						referencePosition: Vc.Vector3[0],
						referenceQuaternion: Vc.uk[0],
						referenceScaling: Vc.Vector3[1],
						keyPosition: Vc.Vector3[2],
						keyQuaternion: Vc.uk[1],
						keyScaling: Vc.Vector3[3]
					};
				let f = c.frame,
					p = m.frame;
				if (r.range) {
					const e = o.getRange(r.range);
					e && (f = e.from, p = e.to)
				} else f = r.fromFrame ?? f, p = r.toFrame ?? p;
				if (f !== c.frame && (h = o.createKeyForFrame(f)), p !== m.frame && (u = o.createKeyForFrame(p)), 1 === o._keys.length) {
					const e = o._getKeyValue(o._keys[0]);
					d.referenceValue = e.clone ? e.clone() : e
				} else if (l <= c.frame) {
					const e = o._getKeyValue(c.value);
					d.referenceValue = e.clone ? e.clone() : e
				} else if (l >= m.frame) {
					const e = o._getKeyValue(m.value);
					d.referenceValue = e.clone ? e.clone() : e
				} else {
					Vg.key = 0;
					const e = o._interpolate(l, Vg);
					d.referenceValue = e.clone ? e.clone() : e
				}
				o.dataType === e.ANIMATIONTYPE_QUATERNION ? d.referenceValue.normalize().conjugateInPlace() : o.dataType === e.ANIMATIONTYPE_MATRIX && (d.referenceValue.decompose(d.referenceScaling, d.referenceQuaternion, d.referencePosition), d.referenceQuaternion.normalize().conjugateInPlace());
				let _ = Number.MAX_VALUE;
				const g = r.clipKeys ? [] : null;
				for (let t = h; t <= u; t++) {
					let i = o._keys[t];
					if ((g || r.cloneOriginalAnimation) && (i = {
							frame: i.frame,
							value: i.value.clone ? i.value.clone() : i.value,
							inTangent: i.inTangent,
							outTangent: i.outTangent,
							interpolation: i.interpolation,
							lockedTangent: i.lockedTangent
						}, g && (_ === Number.MAX_VALUE && (_ = i.frame), i.frame -= _, g.push(i))), !t || o.dataType === e.ANIMATIONTYPE_FLOAT || i.value !== c.value) switch (o.dataType) {
						case e.ANIMATIONTYPE_MATRIX:
							i.value.decompose(d.keyScaling, d.keyQuaternion, d.keyPosition), d.keyPosition.subtractInPlace(d.referencePosition), d.keyScaling.divideInPlace(d.referenceScaling), d.referenceQuaternion.multiplyToRef(d.keyQuaternion, d.keyQuaternion), Hc.ComposeToRef(d.keyScaling, d.keyQuaternion, d.keyPosition, i.value);
							break;
						case e.ANIMATIONTYPE_QUATERNION:
							d.referenceValue.multiplyToRef(i.value, i.value);
							break;
						case e.ANIMATIONTYPE_VECTOR2:
						case e.ANIMATIONTYPE_VECTOR3:
						case e.ANIMATIONTYPE_COLOR3:
						case e.ANIMATIONTYPE_COLOR4:
							i.value.subtractToRef(d.referenceValue, i.value);
							break;
						case e.ANIMATIONTYPE_SIZE:
							i.value.width -= d.referenceValue.width, i.value.height -= d.referenceValue.height;
							break;
						default:
							i.value -= d.referenceValue
					}
				}
				return g && o.setKeys(g, !0), o
			}
			color3InterpolateFunctionWithTangents(e, t, i, s, n) {
				return Tc.Hermite(e, t, i, s, n)
			}
			static _PrepareAnimation(t, i, s, n, a, r, o, l) {
				let h;
				if (!isNaN(parseFloat(a)) && isFinite(a) ? h = e.ANIMATIONTYPE_FLOAT : a instanceof Gc ? h = e.ANIMATIONTYPE_QUATERNION : a instanceof Lc ? h = e.ANIMATIONTYPE_VECTOR3 : a instanceof Fc ? h = e.ANIMATIONTYPE_VECTOR2 : a instanceof Tc ? h = e.ANIMATIONTYPE_COLOR3 : a instanceof wc ? h = e.ANIMATIONTYPE_COLOR4 : a instanceof Ap && (h = e.ANIMATIONTYPE_SIZE), null == h) return null;
				const c = new e(t, i, s, h, o),
					u = [{
						frame: 0,
						value: a
					}, {
						frame: n,
						value: r
					}];
				return c.setKeys(u), void 0 !== l && c.setEasingFunction(l), c
			}
			constructor(t, i, s, n, a, r) {
				this.name = t, this.targetProperty = i, this.framePerSecond = s, this.dataType = n, this.loopMode = a, this.enableBlending = r, this._easingFunction = null, this._runtimeAnimations = new Array, this._events = new Array, this.blendingSpeed = .01, this._ranges = {}, this.targetPropertyPath = i.split("."), this.dataType = n, this.loopMode = void 0 === a ? e.ANIMATIONLOOPMODE_CYCLE : a, this.ik = e._UniqueIdGenerator++
			}
			vector3InterpolateFunctionWithTangents(e, t, i, s, n) {
				return Lc.Hermite(e, t, i, s, n)
			}
			getEasingFunction() {
				return this._easingFunction
			}
			static ParseFromFileAsync(e, t) {
				return new Promise(((i, s) => {
					const n = new ku;
					n.addEventListener("readystatechange", (() => {
						if (4 == n.readyState)
							if (200 == n.status) {
								let t = JSON.parse(n.responseText);
								if (t.animations && (t = t.animations), t.length) {
									const e = [];
									for (const i of t) e.push(this.Parse(i));
									i(e)
								} else {
									const s = this.Parse(t);
									e && (s.name = e), i(s)
								}
							} else s("Unable to load the animation")
					})), n.open("GET", t), n.send()
				}))
			}
			static ParseFromSnippetAsync(e) {
				return new Promise(((t, i) => {
					const s = new ku;
					s.addEventListener("readystatechange", (() => {
						if (4 == s.readyState)
							if (200 == s.status) {
								const i = JSON.parse(JSON.parse(s.responseText).jsonPayload);
								if (i.animations) {
									const s = JSON.parse(i.animations),
										n = [];
									for (const t of s.animations) {
										const i = this.Parse(t);
										i.snippetId = e, n.push(i)
									}
									t(n)
								} else {
									const s = JSON.parse(i.animation),
										n = this.Parse(s);
									n.snippetId = e, t(n)
								}
							} else i("Unable to load the snippet " + e)
					})), s.open("GET", this.SnippetUrl + "/" + e.replace(/#/g, "/")), s.send()
				}))
			}
			vector2InterpolateFunction(e, t, i) {
				return Fc.Lerp(e, t, i)
			}
			get runtimeAnimations() {
				return this._runtimeAnimations
			}
			getRange(e) {
				return this._ranges[e]
			}
			sizeInterpolateFunction(e, t, i) {
				return Ap.Lerp(e, t, i)
			}
			static Parse(t) {
				const i = new e(t.name, t.property, t.framePerSecond, t.dataType, t.loopBehavior),
					s = t.dataType,
					n = [];
				let a, r;
				for (t.enableBlending && (i.enableBlending = t.enableBlending), t.blendingSpeed && (i.blendingSpeed = t.blendingSpeed), r = 0; r < t.keys.length; r++) {
					const i = t.keys[r];
					let o, l, h;
					switch (s) {
						case e.ANIMATIONTYPE_FLOAT:
							a = i.values[0], i.values.length >= 2 && (o = i.values[1]), i.values.length >= 3 && (l = i.values[2]), i.values.length >= 4 && (h = i.values[3]);
							break;
						case e.ANIMATIONTYPE_QUATERNION:
							if (a = Gc.FromArray(i.values), i.values.length >= 8) {
								const e = Gc.FromArray(i.values.slice(4, 8));
								e.equals(Gc.Zero()) || (o = e)
							}
							if (i.values.length >= 12) {
								const e = Gc.FromArray(i.values.slice(8, 12));
								e.equals(Gc.Zero()) || (l = e)
							}
							i.values.length >= 13 && (h = i.values[12]);
							break;
						case e.ANIMATIONTYPE_MATRIX:
							a = Hc.FromArray(i.values), i.values.length >= 17 && (h = i.values[16]);
							break;
						case e.ANIMATIONTYPE_COLOR3:
							a = Tc.FromArray(i.values), i.values[3] && (o = Tc.FromArray(i.values[3])), i.values[4] && (l = Tc.FromArray(i.values[4])), i.values[5] && (h = i.values[5]);
							break;
						case e.ANIMATIONTYPE_COLOR4:
							a = wc.FromArray(i.values), i.values[4] && (o = wc.FromArray(i.values[4])), i.values[5] && (l = wc.FromArray(i.values[5])), i.values[6] && (h = wc.FromArray(i.values[6]));
							break;
						case e.ANIMATIONTYPE_VECTOR3:
						default:
							a = Lc.FromArray(i.values), i.values[3] && (o = Lc.FromArray(i.values[3])), i.values[4] && (l = Lc.FromArray(i.values[4])), i.values[5] && (h = i.values[5])
					}
					const c = {};
					c.frame = i.frame, c.value = a, null != o && (c.inTangent = o), null != l && (c.outTangent = l), null != h && (c.interpolation = h), n.push(c)
				}
				if (i.setKeys(n), t.ranges)
					for (r = 0; r < t.ranges.length; r++) a = t.ranges[r], i.createRange(a.name, a.from, a.to);
				return i
			}
			static _UniversalLerp(e, t, i) {
				const s = e.constructor;
				return s.Lerp ? s.Lerp(e, t, i) : s.Slerp ? s.Slerp(e, t, i) : e.toFixed ? e * (1 - i) + i * t : t
			}
			getHighestFrame() {
				let e = 0;
				for (let t = 0, i = this._keys.length; t < i; t++) e < this._keys[t].frame && (e = this._keys[t].frame);
				return e
			}
			evaluate(e) {
				return Vg.key = 0, this._interpolate(e, Vg)
			}
			static CreateAndStartAnimation(t, i, s, n, a, r, o, l, h, c, u) {
				const m = e._PrepareAnimation(t, s, n, a, r, o, l, h);
				return m ? (i.getScene && (u = i.getScene()), u ? u.beginDirectAnimation(i, [m], 0, a, 1 === m.loopMode, 1, c) : null) : null
			}
			get hasRunningRuntimeAnimations() {
				for (const e of this._runtimeAnimations)
					if (!e.isStopped()) return !0;
				return !1
			}
			deleteRange(e, t = !0) {
				const i = this._ranges[e];
				if (i) {
					if (t) {
						const e = i.from,
							t = i.to;
						for (let i = this._keys.length - 1; i >= 0; i--) this._keys[i].frame >= e && this._keys[i].frame <= t && this._keys.splice(i, 1)
					}
					this._ranges[e] = null
				}
			}
			color3InterpolateFunction(e, t, i) {
				return Tc.Lerp(e, t, i)
			}
			color4InterpolateFunctionWithTangents(e, t, i, s, n) {
				return wc.Hermite(e, t, i, s, n)
			}
			getKeys() {
				return this._keys
			}
			static AppendSerializedAnimations(e, t) {
				Xc.AppendSerializedAnimations(e, t)
			}
			setEasingFunction(e) {
				this._easingFunction = e
			}
			addEvent(e) {
				this._events.push(e), this._events.sort(((e, t) => e.frame - t.frame))
			}
			createKeyForFrame(e) {
				Vg.key = 0;
				const t = this._interpolate(e, Vg, !0);
				if (!t) return this._keys[Vg.key].frame === e ? Vg.key : Vg.key + 1;
				const i = {
					frame: e,
					value: t.clone ? t.clone() : t
				};
				return this._keys.splice(Vg.key + 1, 0, i), Vg.key + 1
			}
			static CreateAnimation(t, i, s, n) {
				const a = new e(t + "Animation", t, s, i, e.ANIMATIONLOOPMODE_CONSTANT);
				return a.setEasingFunction(n), a
			}
			vector3InterpolateFunction(e, t, i) {
				return Lc.Lerp(e, t, i)
			}
			setKeys(e, t = !1) {
				this._keys = t ? e : e.slice(0)
			}
			static TransitionTo(e, t, i, s, n, a, r, o = null) {
				if (r <= 0) return i[e] = t, o && o(), null;
				const l = n * (r / 1e3);
				a.setKeys([{
					frame: 0,
					value: i[e].clone ? i[e].clone() : i[e]
				}, {
					frame: l,
					value: t
				}]), i.animations || (i.animations = []), i.animations.push(a);
				const h = s.beginAnimation(i, 0, l, !1);
				return h.onAnimationEnd = o, h
			}
			getEvents() {
				return this._events
			}
			removeEvents(e) {
				for (let t = 0; t < this._events.length; t++) this._events[t].frame === e && (this._events.splice(t, 1), t--)
			}
			floatInterpolateFunction(e, t, i) {
				return Ac.Lerp(e, t, i)
			}
			clone() {
				const t = new e(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
				if (t.enableBlending = this.enableBlending, t.blendingSpeed = this.blendingSpeed, this._keys && t.setKeys(this._keys), this._ranges) {
					t._ranges = {};
					for (const e in this._ranges) {
						const i = this._ranges[e];
						i && (t._ranges[e] = i.clone())
					}
				}
				return t
			}
			serialize() {
				const t = {};
				t.name = this.name, t.property = this.targetProperty, t.framePerSecond = this.framePerSecond, t.dataType = this.dataType, t.loopBehavior = this.loopMode, t.enableBlending = this.enableBlending, t.blendingSpeed = this.blendingSpeed;
				const i = this.dataType;
				t.keys = [];
				const s = this.getKeys();
				for (let n = 0; n < s.length; n++) {
					const a = s[n],
						r = {};
					switch (r.frame = a.frame, i) {
						case e.ANIMATIONTYPE_FLOAT:
							r.values = [a.value], void 0 !== a.inTangent && r.values.push(a.inTangent), void 0 !== a.outTangent && (void 0 === a.inTangent && r.values.push(void 0), r.values.push(a.outTangent)), void 0 !== a.interpolation && (void 0 === a.inTangent && r.values.push(void 0), void 0 === a.outTangent && r.values.push(void 0), r.values.push(a.interpolation));
							break;
						case e.ANIMATIONTYPE_QUATERNION:
						case e.ANIMATIONTYPE_MATRIX:
						case e.ANIMATIONTYPE_VECTOR3:
						case e.ANIMATIONTYPE_COLOR3:
						case e.ANIMATIONTYPE_COLOR4:
							r.values = a.value.asArray(), null != a.inTangent && r.values.push(a.inTangent.asArray()), null != a.outTangent && (void 0 === a.inTangent && r.values.push(void 0), r.values.push(a.outTangent.asArray())), void 0 !== a.interpolation && (void 0 === a.inTangent && r.values.push(void 0), void 0 === a.outTangent && r.values.push(void 0), r.values.push(a.interpolation))
					}
					t.keys.push(r)
				}
				t.ranges = [];
				for (const e in this._ranges) {
					const i = this._ranges[e];
					if (!i) continue;
					const s = {};
					s.name = e, s.from = i.from, s.to = i.to, t.ranges.push(s)
				}
				return t
			}
			static CreateAndStartHierarchyAnimation(t, i, s, n, a, r, o, l, h, c, u) {
				const m = e._PrepareAnimation(t, n, a, r, o, l, h, c);
				if (!m) return null;
				return i.getScene().beginDirectHierarchyAnimation(i, s, [m], 0, r, 1 === m.loopMode, 1, u)
			}
			createRange(e, t, i) {
				this._ranges[e] || (this._ranges[e] = new Og(e, t, i))
			}
			vector2InterpolateFunctionWithTangents(e, t, i, s, n) {
				return Fc.Hermite(e, t, i, s, n)
			}
			matrixInterpolateFunction(t, i, s, n) {
				return e.AllowMatrixDecomposeForInterpolation ? n ? (Hc.DecomposeLerpToRef(t, i, s, n), n) : Hc.DecomposeLerp(t, i, s) : n ? (Hc.LerpToRef(t, i, s, n), n) : Hc.Lerp(t, i, s)
			}
			static CreateMergeAndStartAnimation(t, i, s, n, a, r, o, l, h, c) {
				const u = e._PrepareAnimation(t, s, n, a, r, o, l, h);
				return u ? (i.animations.push(u), i.getScene().beginAnimation(i, 0, a, 1 === u.loopMode, 1, c)) : null
			}
		};
	Wg._UniqueIdGenerator = 0, Wg.AllowMatricesInterpolation = !1, Wg.AllowMatrixDecomposeForInterpolation = !0, Wg.SnippetUrl = "https://snippet.babylonjs.com", Wg.ANIMATIONTYPE_FLOAT = 0, Wg.ANIMATIONTYPE_VECTOR3 = 1, Wg.ANIMATIONTYPE_QUATERNION = 2, Wg.ANIMATIONTYPE_MATRIX = 3, Wg.ANIMATIONTYPE_COLOR3 = 4, Wg.ANIMATIONTYPE_COLOR4 = 7, Wg.ANIMATIONTYPE_VECTOR2 = 5, Wg.ANIMATIONTYPE_SIZE = 6, Wg.ANIMATIONLOOPMODE_RELATIVE = 0, Wg.ANIMATIONLOOPMODE_CYCLE = 1, Wg.ANIMATIONLOOPMODE_CONSTANT = 2, Wg.ANIMATIONLOOPMODE_YOYO = 4, Wg.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5, Wg.CreateFromSnippetAsync = Wg.ParseFromSnippetAsync, cc("BABYLON.Animation", Wg), jc._AnimationRangeFactory = (e, t, i) => new Og(e, t, i);
	var zg = class e {
		detach() {
			this._attachedCamera && (this._onAfterCheckInputsObserver && this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._onMeshTargetChangedObserver && this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver), this._attachedCamera = null)
		}
		_isRadiusAtLimit(e) {
			return !!this._attachedCamera && (this._attachedCamera.radius === e && !this._radiusIsAnimating)
		}
		_clearAnimationLocks() {
			this._radiusIsAnimating = !1, this._attachedCamera && (this._attachedCamera.wheelPrecision = this._cachedWheelPrecision)
		}
		get name() {
			return "Bouncing"
		}
		get autoTransitionRange() {
			return this._autoTransitionRange
		}
		stopAllAnimations() {
			for (this._attachedCamera && (this._attachedCamera.animations = []); this._animatables.length;) this._animatables[0].onAnimationEnd = null, this._animatables[0].stop(), this._animatables.shift()
		}
		constructor() {
			this.transitionDuration = 450, this.lowerRadiusTransitionRange = 2, this.upperRadiusTransitionRange = -2, this._autoTransitionRange = !1, this._radiusIsAnimating = !1, this._radiusBounceTransition = null, this._animatables = new Array
		}
		_applyBoundRadiusAnimation(t) {
			if (!this._attachedCamera) return;
			this._radiusBounceTransition || (e.EasingFunction.setEasingMode(e.EasingMode), this._radiusBounceTransition = Wg.CreateAnimation("radius", Wg.ANIMATIONTYPE_FLOAT, 60, e.EasingFunction)), this._cachedWheelPrecision = this._attachedCamera.wheelPrecision, this._attachedCamera.wheelPrecision = 1 / 0, this._attachedCamera.inertialRadiusOffset = 0, this.stopAllAnimations(), this._radiusIsAnimating = !0;
			const i = Wg.TransitionTo("radius", this._attachedCamera.radius + t, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, (() => this._clearAnimationLocks()));
			i && this._animatables.push(i)
		}
		init() {}
		attach(e) {
			this._attachedCamera = e, this._onAfterCheckInputsObserver = e.onAfterCheckInputsObservable.add((() => {
				this._attachedCamera && (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit) && this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange), this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit) && this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange))
			}))
		}
		set autoTransitionRange(e) {
			if (this._autoTransitionRange === e) return;
			this._autoTransitionRange = e;
			const t = this._attachedCamera;
			t && (e ? this._onMeshTargetChangedObserver = t.onMeshTargetChangedObservable.add((e => {
				if (e && (e.computeWorldMatrix(!0), e.getBoundingInfo)) {
					const t = e.getBoundingInfo().diagonalLength;
					this.lowerRadiusTransitionRange = .05 * t, this.upperRadiusTransitionRange = .05 * t
				}
			})) : this._onMeshTargetChangedObserver && t.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver))
		}
	};
	zg.EasingFunction = new class extends Pg {
		easeInCore(e) {
			const t = Math.max(0, this.amplitude);
			return Math.pow(e, 3) - e * t * Math.sin(3.141592653589793 * e)
		}
		constructor(e = 1) {
			super(), this.amplitude = e
		}
	}(.3), zg.EasingMode = Pg.EASINGMODE_EASEOUT;
	var Xg = class e {
		get radiusScale() {
			return this._radiusScale
		}
		get zoomStopsAnimation() {
			return this._zoomStopsAnimation
		}
		get elevationReturnWaitTime() {
			return this._elevationReturnWaitTime
		}
		set defaultElevation(e) {
			this._defaultElevation = e
		}
		get elevationReturnTime() {
			return this._elevationReturnTime
		}
		set zoomStopsAnimation(e) {
			this._zoomStopsAnimation = e
		}
		detach() {
			if (!this._attachedCamera) return;
			const e = this._attachedCamera.getScene();
			this._onPrePointerObservableObserver && e.onPrePointerObservable.remove(this._onPrePointerObservableObserver), this._onAfterCheckInputsObserver && this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._onMeshTargetChangedObserver && this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver), this._attachedCamera = null
		}
		set elevationReturnTime(e) {
			this._elevationReturnTime = e
		}
		get name() {
			return "Framing"
		}
		constructor() {
			this.onTargetFramingAnimationEndObservable = new kc, this._mode = e.FitFrustumSidesMode, this._radiusScale = 1, this._positionScale = .5, this._defaultElevation = .3, this._elevationReturnTime = 1500, this._elevationReturnWaitTime = 1e3, this._zoomStopsAnimation = !1, this._framingTime = 1500, this.autoCorrectCameraLimitsAndSensibility = !0, this._isPointerDown = !1, this._lastInteractionTime = -1 / 0, this._animatables = new Array, this._betaIsAnimating = !1
		}
		zoomOnMeshHierarchy(e, t = !1, i = null) {
			e.computeWorldMatrix(!0);
			const s = e.getHierarchyBoundingVectors(!0);
			this.zoomOnBoundingInfo(s.min, s.max, t, i)
		}
		_calculateLowerRadiusFromModelBoundingSphere(t, i) {
			const s = this._attachedCamera;
			if (!s) return 0;
			let n = s._calculateLowerRadiusFromModelBoundingSphere(t, i, this._radiusScale);
			return s.lowerRadiusLimit && this._mode === e.IgnoreBoundsSizeMode && (n = n < s.lowerRadiusLimit ? s.lowerRadiusLimit : n), s.upperRadiusLimit && (n = n > s.upperRadiusLimit ? s.upperRadiusLimit : n), n
		}
		get framingTime() {
			return this._framingTime
		}
		init() {}
		set radiusScale(e) {
			this._radiusScale = e
		}
		zoomOnMeshesHierarchy(e, t = !1, i = null) {
			const s = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
				n = new Lc(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
			for (let t = 0; t < e.length; t++) {
				const i = e[t].getHierarchyBoundingVectors(!0);
				Lc.CheckExtends(i.min, s, n), Lc.CheckExtends(i.max, s, n)
			}
			this.zoomOnBoundingInfo(s, n, t, i)
		}
		get defaultElevation() {
			return this._defaultElevation
		}
		attach(t) {
			this._attachedCamera = t;
			const i = this._attachedCamera.getScene();
			e.EasingFunction.setEasingMode(e.EasingMode), this._onPrePointerObservableObserver = i.onPrePointerObservable.add((e => {
				e.type !== H_.POINTERDOWN ? e.type === H_.POINTERUP && (this._isPointerDown = !1) : this._isPointerDown = !0
			})), this._onMeshTargetChangedObserver = t.onMeshTargetChangedObservable.add((e => {
				e && e.getBoundingInfo && this.zoomOnMesh(e, void 0, (() => {
					this.onTargetFramingAnimationEndObservable.notifyObservers()
				}))
			})), this._onAfterCheckInputsObserver = t.onAfterCheckInputsObservable.add((() => {
				this._applyUserInteraction(), this._maintainCameraAboveGround()
			}))
		}
		get isUserIsMoving() {
			return !!this._attachedCamera && (0 !== this._attachedCamera.inertialAlphaOffset || 0 !== this._attachedCamera.inertialBetaOffset || 0 !== this._attachedCamera.inertialRadiusOffset || 0 !== this._attachedCamera.inertialPanningX || 0 !== this._attachedCamera.inertialPanningY || this._isPointerDown)
		}
		zoomOnBoundingInfo(t, i, s = !1, n = null) {
			let a;
			if (!this._attachedCamera) return !1;
			const r = t.y,
				o = r + (i.y - r) * this._positionScale,
				l = i.subtract(t).scale(.5);
			if (s) a = new Lc(0, o, 0);
			else {
				const e = t.add(l);
				a = new Lc(e.x, o, e.z)
			}
			this._vectorTransition || (this._vectorTransition = Wg.CreateAnimation("target", Wg.ANIMATIONTYPE_VECTOR3, 60, e.EasingFunction)), this._betaIsAnimating = !0;
			let h = Wg.TransitionTo("target", a, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
			h && this._animatables.push(h);
			let c = 0;
			if (this._mode === e.FitFrustumSidesMode) {
				const e = this._calculateLowerRadiusFromModelBoundingSphere(t, i);
				this.autoCorrectCameraLimitsAndSensibility && (this._attachedCamera.lowerRadiusLimit = l.length() + this._attachedCamera.minZ), c = e
			} else this._mode === e.IgnoreBoundsSizeMode && (c = this._calculateLowerRadiusFromModelBoundingSphere(t, i), this.autoCorrectCameraLimitsAndSensibility && null === this._attachedCamera.lowerRadiusLimit && (this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ));
			if (this.autoCorrectCameraLimitsAndSensibility) {
				const e = i.subtract(t).length();
				this._attachedCamera.panningSensibility = 5e3 / e, this._attachedCamera.wheelPrecision = 100 / c
			}
			return this._radiusTransition || (this._radiusTransition = Wg.CreateAnimation("radius", Wg.ANIMATIONTYPE_FLOAT, 60, e.EasingFunction)), h = Wg.TransitionTo("radius", c, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, (() => {
				this.stopAllAnimations(), n && n(), this._attachedCamera && this._attachedCamera.useInputToRestoreState && this._attachedCamera.storeState()
			})), h && this._animatables.push(h), !0
		}
		get positionScale() {
			return this._positionScale
		}
		set positionScale(e) {
			this._positionScale = e
		}
		_clearAnimationLocks() {
			this._betaIsAnimating = !1
		}
		_maintainCameraAboveGround() {
			if (this._elevationReturnTime < 0) return;
			const t = Pu.Now - this._lastInteractionTime,
				i = .5 * Math.PI - this._defaultElevation,
				s = .5 * Math.PI;
			if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > s && t >= this._elevationReturnWaitTime) {
				this._betaIsAnimating = !0, this.stopAllAnimations(), this._betaTransition || (this._betaTransition = Wg.CreateAnimation("beta", Wg.ANIMATIONTYPE_FLOAT, 60, e.EasingFunction));
				const t = Wg.TransitionTo("beta", i, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, (() => {
					this._clearAnimationLocks(), this.stopAllAnimations()
				}));
				t && this._animatables.push(t)
			}
		}
		zoomOnMesh(e, t = !1, i = null) {
			e.computeWorldMatrix(!0);
			const s = e.getBoundingInfo().boundingBox;
			this.zoomOnBoundingInfo(s.minimumWorld, s.maximumWorld, t, i)
		}
		set mode(e) {
			this._mode = e
		}
		_applyUserInteraction() {
			this.isUserIsMoving && (this._lastInteractionTime = Pu.Now, this.stopAllAnimations(), this._clearAnimationLocks())
		}
		stopAllAnimations() {
			for (this._attachedCamera && (this._attachedCamera.animations = []); this._animatables.length;) this._animatables[0] && (this._animatables[0].onAnimationEnd = null, this._animatables[0].stop()), this._animatables.shift()
		}
		set framingTime(e) {
			this._framingTime = e
		}
		get mode() {
			return this._mode
		}
		set elevationReturnWaitTime(e) {
			this._elevationReturnWaitTime = e
		}
	};
	Xg.EasingFunction = new class extends Pg {
		easeInCore(e) {
			return this.exponent <= 0 ? e : (Math.exp(this.exponent * e) - 1) / (Math.exp(this.exponent) - 1)
		}
		constructor(e = 2) {
			super(), this.exponent = e
		}
	}, Xg.EasingMode = Pg.EASINGMODE_EASEINOUT, Xg.IgnoreBoundsSizeMode = 0, Xg.FitFrustumSidesMode = 1;
	var Yg = {},
		jg = class {
			add(e) {
				const t = e.getSimpleName();
				this.attached[t] ? Qc.Warn("camera input of type " + t + " already exists on camera") : (this.attached[t] = e, e.camera = this.camera, e.checkInputs && (this.checkInputs = this._addCheckInputs(e.checkInputs.bind(e))), this.attachedToElement && e.attachControl(this.noPreventDefault))
			}
			detachElement(e = !1) {
				for (const t in this.attached) this.attached[t].detachControl(), e && (this.attached[t].camera = null);
				this.attachedToElement = !1
			}
			clear() {
				this.attachedToElement && this.detachElement(!0), this.attached = {}, this.attachedToElement = !1, this.checkInputs = () => {}
			}
			attachElement(e = !1) {
				if (!this.attachedToElement) {
					e = !Sd.ForceAttachControlToAlwaysPreventDefault && e, this.attachedToElement = !0, this.noPreventDefault = e;
					for (const t in this.attached) this.attached[t].attachControl(e)
				}
			}
			remove(e) {
				for (const t in this.attached) {
					const i = this.attached[t];
					if (i === e) return i.detachControl(), i.camera = null, delete this.attached[t], void this.rebuildInputCheck()
				}
			}
			attachInput(e) {
				this.attachedToElement && e.attachControl(this.noPreventDefault)
			}
			_addCheckInputs(e) {
				const t = this.checkInputs;
				return () => {
					t(), e()
				}
			}
			removeByType(e) {
				for (const t in this.attached) {
					const i = this.attached[t];
					i.getClassName() === e && (i.detachControl(), i.camera = null, delete this.attached[t], this.rebuildInputCheck())
				}
			}
			rebuildInputCheck() {
				this.checkInputs = () => {};
				for (const e in this.attached) {
					const t = this.attached[e];
					t.checkInputs && (this.checkInputs = this._addCheckInputs(t.checkInputs.bind(t)))
				}
			}
			constructor(e) {
				this.attachedToElement = !1, this.attached = {}, this.camera = e, this.checkInputs = () => {}
			}
			serialize(e) {
				const t = {};
				for (const e in this.attached) {
					const i = this.attached[e],
						s = Xc.Serialize(i);
					t[i.getClassName()] = s
				}
				e.inputsmgr = t
			}
			parse(e) {
				const t = e.inputsmgr;
				if (t) {
					this.clear();
					for (const e in t) {
						const i = Yg[e];
						if (i) {
							const s = t[e],
								n = Xc.Parse((() => new i), s, null);
							this.add(n)
						}
					}
				} else
					for (const t in this.attached) {
						const i = Yg[this.attached[t].getClassName()];
						if (i) {
							const s = Xc.Parse((() => new i), e, null);
							this.remove(this.attached[t]), this.add(s)
						}
					}
			}
		},
		Kg = class {
			attachControl(e) {
				e = dd.BackCompatCameraNoPreventDefault(arguments);
				const t = this.camera.getEngine(),
					i = t.getInputElement();
				let s = 0,
					n = null;
				this._pointA = null, this._pointB = null, this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._buttonsPressed = 0, this._pointerInput = a => {
					const r = a.event,
						o = "touch" === r.pointerType;
					if (a.type !== H_.POINTERMOVE && -1 === this.buttons.indexOf(r.button)) return;
					const l = r.target;
					if (this._altKey = r.altKey, this._ctrlKey = r.ctrlKey, this._metaKey = r.metaKey, this._shiftKey = r.shiftKey, this._buttonsPressed = r.buttons, t.isPointerLock) {
						const e = r.movementX,
							t = r.movementY;
						this.onTouch(null, e, t), this._pointA = null, this._pointB = null
					} else {
						if (a.type !== H_.POINTERDOWN && a.type !== H_.POINTERDOUBLETAP && o && this._pointA?.pointerId !== r.pointerId && this._pointB?.pointerId !== r.pointerId) return;
						if (a.type !== H_.POINTERDOWN || -1 !== this._currentActiveButton && !o)
							if (a.type === H_.POINTERDOUBLETAP) this.onDoubleTap(r.pointerType);
							else if (a.type !== H_.POINTERUP || this._currentActiveButton !== r.button && !o) {
							if (a.type === H_.POINTERMOVE)
								if (e || r.preventDefault(), this._pointA && null === this._pointB) {
									const e = r.clientX - this._pointA.x,
										t = r.clientY - this._pointA.y;
									this._pointA.x = r.clientX, this._pointA.y = r.clientY, this.onTouch(this._pointA, e, t)
								} else if (this._pointA && this._pointB) {
								const e = this._pointA.pointerId === r.pointerId ? this._pointA : this._pointB;
								e.x = r.clientX, e.y = r.clientY;
								const t = this._pointA.x - this._pointB.x,
									i = this._pointA.y - this._pointB.y,
									o = t * t + i * i,
									l = {
										x: (this._pointA.x + this._pointB.x) / 2,
										y: (this._pointA.y + this._pointB.y) / 2,
										pointerId: r.pointerId,
										type: a.type
									};
								this.onMultiTouch(this._pointA, this._pointB, s, o, n, l), n = l, s = o
							}
						} else {
							try {
								l?.releasePointerCapture(r.pointerId)
							} catch (e) {}
							o || (this._pointB = null), t._badOS ? this._pointA = this._pointB = null : this._pointB && this._pointA && this._pointA.pointerId == r.pointerId ? (this._pointA = this._pointB, this._pointB = null) : this._pointA && this._pointB && this._pointB.pointerId == r.pointerId ? this._pointB = null : this._pointA = this._pointB = null, (0 !== s || n) && (this.onMultiTouch(this._pointA, this._pointB, s, 0, n, null), s = 0, n = null), this._currentActiveButton = -1, this.onButtonUp(r), e || r.preventDefault()
						} else {
							try {
								l?.setPointerCapture(r.pointerId)
							} catch (e) {}
							if (null === this._pointA) this._pointA = {
								x: r.clientX,
								y: r.clientY,
								pointerId: r.pointerId,
								type: r.pointerType
							};
							else {
								if (null !== this._pointB) return;
								this._pointB = {
									x: r.clientX,
									y: r.clientY,
									pointerId: r.pointerId,
									type: r.pointerType
								}
							} - 1 !== this._currentActiveButton || o || (this._currentActiveButton = r.button), this.onButtonDown(r), e || (r.preventDefault(), i && i.focus())
						}
					}
				}, this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, H_.POINTERDOWN | H_.POINTERUP | H_.POINTERMOVE | H_.POINTERDOUBLETAP), this._onLostFocus = () => {
					this._pointA = this._pointB = null, s = 0, n = null, this.onLostFocus()
				}, this._contextMenuBind = e => this.onContextMenu(e), i && i.addEventListener("contextmenu", this._contextMenuBind, !1);
				const a = this.camera.getScene().getEngine().getHostWindow();
				a && dd.RegisterTopRootEvents(a, [{
					name: "blur",
					handler: this._onLostFocus
				}])
			}
			onMultiTouch(e, t, i, s, n, a) {}
			getClassName() {
				return "BaseCameraPointersInput"
			}
			onButtonUp(e) {}
			onContextMenu(e) {
				e.preventDefault()
			}
			onTouch(e, t, i) {}
			onButtonDown(e) {}
			onLostFocus() {}
			detachControl() {
				if (this._onLostFocus) {
					const e = this.camera.getScene().getEngine().getHostWindow();
					e && dd.UnregisterTopRootEvents(e, [{
						name: "blur",
						handler: this._onLostFocus
					}])
				}
				if (this._observer) {
					if (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer), this._observer = null, this._contextMenuBind) {
						const e = this.camera.getScene().getEngine().getInputElement();
						e && e.removeEventListener("contextmenu", this._contextMenuBind)
					}
					this._onLostFocus = null
				}
				this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._buttonsPressed = 0, this._currentActiveButton = -1
			}
			getSimpleName() {
				return "pointers"
			}
			onDoubleTap(e) {}
			constructor() {
				this._currentActiveButton = -1, this.buttons = [0, 1, 2]
			}
		};
	Gh([Xh()], Kg.prototype, "buttons", void 0);
	var $g = class e extends Kg {
		onLostFocus() {
			this._isPanClick = !1, this._twoFingerActivityCount = 0, this._isPinching = !1
		}
		constructor() {
			super(...arguments), this.buttons = [0, 1, 2], this.angularSensibilityX = 1e3, this.angularSensibilityY = 1e3, this.pinchPrecision = 12, this.pinchDeltaPercentage = 0, this.useNaturalPinchZoom = !1, this.pinchZoom = !0, this.panningSensibility = 1e3, this.multiTouchPanning = !0, this.multiTouchPanAndZoom = !0, this.pinchInwards = !0, this._isPanClick = !1, this._twoFingerActivityCount = 0, this._isPinching = !1
		}
		_computePinchZoom(t, i) {
			const s = this.camera.radius || e.MinimumRadiusForPinch;
			this.useNaturalPinchZoom ? this.camera.radius = s * Math.sqrt(t) / Math.sqrt(i) : this.pinchDeltaPercentage ? this.camera.inertialRadiusOffset += .001 * (i - t) * s * this.pinchDeltaPercentage : this.camera.inertialRadiusOffset += (i - t) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2)
		}
		_computeMultiTouchPanning(e, t) {
			if (0 !== this.panningSensibility && e && t) {
				const i = t.x - e.x,
					s = t.y - e.y;
				this.camera.inertialPanningX += -i / this.panningSensibility, this.camera.inertialPanningY += s / this.panningSensibility
			}
		}
		onButtonDown(e) {
			this._isPanClick = e.button === this.camera._panningMouseButton
		}
		onMultiTouch(e, t, i, s, n, a) {
			0 === i && null === n || 0 === s && null === a || (this.multiTouchPanAndZoom ? (this._computePinchZoom(i, s), this._computeMultiTouchPanning(n, a)) : this.multiTouchPanning && this.pinchZoom ? (this._twoFingerActivityCount++, this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(s) - Math.sqrt(i)) > this.camera.pinchToPanMaxDistance ? (this._computePinchZoom(i, s), this._isPinching = !0) : this._computeMultiTouchPanning(n, a)) : this.multiTouchPanning ? this._computeMultiTouchPanning(n, a) : this.pinchZoom && this._computePinchZoom(i, s))
		}
		onDoubleTap() {
			this.camera.useInputToRestoreState && this.camera.restoreState()
		}
		onButtonUp(e) {
			this._twoFingerActivityCount = 0, this._isPinching = !1
		}
		onTouch(e, t, i) {
			0 !== this.panningSensibility && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick) ? (this.camera.inertialPanningX += -t / this.panningSensibility, this.camera.inertialPanningY += i / this.panningSensibility) : (this.camera.inertialAlphaOffset -= t / this.angularSensibilityX, this.camera.inertialBetaOffset -= i / this.angularSensibilityY)
		}
		getClassName() {
			return "ArcRotateCameraPointersInput"
		}
	};
	$g.MinimumRadiusForPinch = .001, Gh([Xh()], $g.prototype, "buttons", void 0), Gh([Xh()], $g.prototype, "angularSensibilityX", void 0), Gh([Xh()], $g.prototype, "angularSensibilityY", void 0), Gh([Xh()], $g.prototype, "pinchPrecision", void 0), Gh([Xh()], $g.prototype, "pinchDeltaPercentage", void 0), Gh([Xh()], $g.prototype, "useNaturalPinchZoom", void 0), Gh([Xh()], $g.prototype, "pinchZoom", void 0), Gh([Xh()], $g.prototype, "panningSensibility", void 0), Gh([Xh()], $g.prototype, "multiTouchPanning", void 0), Gh([Xh()], $g.prototype, "multiTouchPanAndZoom", void 0), Yg.ArcRotateCameraPointersInput = $g;
	var Jg = class {
		checkInputs() {
			if (this._onKeyboardObserver) {
				const e = this.camera;
				for (let t = 0; t < this._keys.length; t++) {
					const i = this._keys[t]; - 1 !== this.keysLeft.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningX -= 1 / this.panningSensibility : e.inertialAlphaOffset -= this.angularSpeed : -1 !== this.keysUp.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningY += 1 / this.panningSensibility : this._altPressed && this.useAltToZoom ? e.inertialRadiusOffset += 1 / this.zoomingSensibility : e.inertialBetaOffset -= this.angularSpeed : -1 !== this.keysRight.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningX += 1 / this.panningSensibility : e.inertialAlphaOffset += this.angularSpeed : -1 !== this.keysDown.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningY -= 1 / this.panningSensibility : this._altPressed && this.useAltToZoom ? e.inertialRadiusOffset -= 1 / this.zoomingSensibility : e.inertialBetaOffset += this.angularSpeed : -1 !== this.keysReset.indexOf(i) && e.useInputToRestoreState && e.restoreState()
				}
			}
		}
		getSimpleName() {
			return "keyboard"
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments), this._onCanvasBlurObserver || (this._scene = this.camera.getScene(), this._engine = this._scene.getEngine(), this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add((() => {
				this._keys.length = 0
			})), this._onKeyboardObserver = this._scene.onKeyboardObservable.add((t => {
				const i = t.event;
				if (!i.metaKey)
					if (t.type === X_.KEYDOWN) {
						if (this._ctrlPressed = i.ctrlKey, this._altPressed = i.altKey, -1 !== this.keysUp.indexOf(i.keyCode) || -1 !== this.keysDown.indexOf(i.keyCode) || -1 !== this.keysLeft.indexOf(i.keyCode) || -1 !== this.keysRight.indexOf(i.keyCode) || -1 !== this.keysReset.indexOf(i.keyCode)) {
							-1 === this._keys.indexOf(i.keyCode) && this._keys.push(i.keyCode), i.preventDefault && (e || i.preventDefault())
						}
					} else if (-1 !== this.keysUp.indexOf(i.keyCode) || -1 !== this.keysDown.indexOf(i.keyCode) || -1 !== this.keysLeft.indexOf(i.keyCode) || -1 !== this.keysRight.indexOf(i.keyCode) || -1 !== this.keysReset.indexOf(i.keyCode)) {
					const t = this._keys.indexOf(i.keyCode);
					t >= 0 && this._keys.splice(t, 1), i.preventDefault && (e || i.preventDefault())
				}
			})))
		}
		getClassName() {
			return "ArcRotateCameraKeyboardMoveInput"
		}
		detachControl() {
			this._scene && (this._onKeyboardObserver && this._scene.onKeyboardObservable.remove(this._onKeyboardObserver), this._onCanvasBlurObserver && this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver), this._onKeyboardObserver = null, this._onCanvasBlurObserver = null), this._keys.length = 0
		}
		constructor() {
			this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this.keysReset = [220], this.panningSensibility = 50, this.zoomingSensibility = 25, this.useAltToZoom = !0, this.angularSpeed = .01, this._keys = new Array
		}
	};
	Gh([Xh()], Jg.prototype, "keysUp", void 0), Gh([Xh()], Jg.prototype, "keysDown", void 0), Gh([Xh()], Jg.prototype, "keysLeft", void 0), Gh([Xh()], Jg.prototype, "keysRight", void 0), Gh([Xh()], Jg.prototype, "keysReset", void 0), Gh([Xh()], Jg.prototype, "panningSensibility", void 0), Gh([Xh()], Jg.prototype, "zoomingSensibility", void 0), Gh([Xh()], Jg.prototype, "useAltToZoom", void 0), Gh([Xh()], Jg.prototype, "angularSpeed", void 0), Yg.ArcRotateCameraKeyboardMoveInput = Jg;
	var qg = class {
		getClassName() {
			return "ArcRotateCameraMouseWheelInput"
		}
		_updateHitPlane() {
			const e = this.camera,
				t = e.target.subtract(e.position);
			this._hitPlane = vd.FromPositionAndNormal(e.target, t)
		}
		getSimpleName() {
			return "mousewheel"
		}
		_computeDeltaFromMouseWheelLegacyEvent(e, t) {
			let i = 0;
			const s = .01 * e * this.wheelDeltaPercentage * t;
			return i = e > 0 ? s / (1 + this.wheelDeltaPercentage) : s * (1 + this.wheelDeltaPercentage), i
		}
		_getPosition() {
			const e = this.camera,
				t = e.getScene(),
				i = t.createPickingRay(t.pointerX, t.pointerY, Hc.Identity(), e, !1);
			0 === e.targetScreenOffset.x && 0 === e.targetScreenOffset.y || (this._viewOffset.set(e.targetScreenOffset.x, e.targetScreenOffset.y, 0), e.getViewMatrix().invertToRef(e._cameraTransformMatrix), this._globalOffset = Lc.TransformNormal(this._viewOffset, e._cameraTransformMatrix), i.origin.addInPlace(this._globalOffset));
			let s = 0;
			return this._hitPlane && (s = i.intersectsPlane(this._hitPlane) ?? 0), i.origin.addInPlace(i.direction.scaleInPlace(s))
		}
		checkInputs() {
			if (!this.zoomToMouseLocation) return;
			const e = this.camera;
			0 + e.inertialAlphaOffset + e.inertialBetaOffset + e.inertialRadiusOffset && (this._updateHitPlane(), e.target.addInPlace(this._inertialPanning), this._inertialPanning.scaleInPlace(e.inertia), this._zeroIfClose(this._inertialPanning))
		}
		_zoomToMouse(e) {
			const t = this.camera,
				i = 1 - t.inertia;
			if (t.lowerRadiusLimit) {
				const s = t.lowerRadiusLimit ?? 0;
				t.radius - (t.inertialRadiusOffset + e) / i < s && (e = (t.radius - s) * i - t.inertialRadiusOffset)
			}
			if (t.upperRadiusLimit) {
				const s = t.upperRadiusLimit ?? 0;
				t.radius - (t.inertialRadiusOffset + e) / i > s && (e = (t.radius - s) * i - t.inertialRadiusOffset)
			}
			const s = e / i / t.radius,
				n = this._getPosition(),
				a = Vc.Vector3[6];
			n.subtractToRef(t.target, a), a.scaleInPlace(s), a.scaleInPlace(i), this._inertialPanning.addInPlace(a), t.inertialRadiusOffset += e
		}
		constructor() {
			this.wheelPrecision = 3, this.zoomToMouseLocation = !1, this.wheelDeltaPercentage = 0, this.customComputeDeltaFromMouseWheel = null, this._viewOffset = new Lc(0, 0, 0), this._globalOffset = new Lc(0, 0, 0), this._inertialPanning = Lc.Zero()
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments), this._wheel = t => {
				if (t.type !== H_.POINTERWHEEL) return;
				const i = t.event;
				let s = 0;
				const n = i.deltaMode === cg.DOM_DELTA_LINE ? 40 : 1,
					a = -i.deltaY * n;
				if (this.customComputeDeltaFromMouseWheel) s = this.customComputeDeltaFromMouseWheel(a, this, i);
				else if (this.wheelDeltaPercentage) {
					if (s = this._computeDeltaFromMouseWheelLegacyEvent(a, this.camera.radius), s > 0) {
						let e = this.camera.radius,
							t = this.camera.inertialRadiusOffset + s;
						for (let i = 0; i < 20 && Math.abs(t) > .001; i++) e -= t, t *= this.camera.inertia;
						e = Ac.Clamp(e, 0, Number.MAX_VALUE), s = this._computeDeltaFromMouseWheelLegacyEvent(a, e)
					}
				} else s = a / (40 * this.wheelPrecision);
				s && (this.zoomToMouseLocation ? (this._hitPlane || this._updateHitPlane(), this._zoomToMouse(s)) : this.camera.inertialRadiusOffset += s), i.preventDefault && (e || i.preventDefault())
			}, this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, H_.POINTERWHEEL), this.zoomToMouseLocation && this._inertialPanning.setAll(0)
		}
		_zeroIfClose(e) {
			Math.abs(e.x) < pc && (e.x = 0), Math.abs(e.y) < pc && (e.y = 0), Math.abs(e.z) < pc && (e.z = 0)
		}
		detachControl() {
			this._observer && (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer), this._observer = null, this._wheel = null)
		}
	};
	Gh([Xh()], qg.prototype, "wheelPrecision", void 0), Gh([Xh()], qg.prototype, "zoomToMouseLocation", void 0), Gh([Xh()], qg.prototype, "wheelDeltaPercentage", void 0), Yg.ArcRotateCameraMouseWheelInput = qg;
	var Qg = class extends jg {
		constructor(e) {
			super(e)
		}
		addKeyboard() {
			return this.add(new Jg), this
		}
		addPointers() {
			return this.add(new $g), this
		}
		addMouseWheel() {
			return this.add(new qg), this
		}
	};
	jc.AddNodeConstructor("ArcRotateCamera", ((e, t) => () => new Zg(e, 0, 0, 1, Lc.Zero(), t)));
	var Zg = class e extends Ng {
		attachControl(e, t, i = !0, s = 2) {
			const n = arguments;
			t = dd.BackCompatCameraNoPreventDefault(n), this._useCtrlForPanning = i, this._panningMouseButton = s, "boolean" == typeof n[0] && (n.length > 1 && (this._useCtrlForPanning = n[1]), n.length > 2 && (this._panningMouseButton = n[2])), this.inputs.attachElement(t), this._reset = () => {
				this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.inertialPanningX = 0, this.inertialPanningY = 0
			}
		}
		_checkInputs() {
			if (!this._collisionTriggered) {
				if (this.inputs.checkInputs(), this._progressiveRestore) {
					const e = this._scene.getEngine().getDeltaTime() / 1e3,
						t = 1 - Math.pow(2, -e / this.restoreStateInterpolationFactor);
					this.setTarget(Lc.Lerp(this.getTarget(), this._storedTarget, t)), Gc.RotationAlphaBetaGammaToRef(this._storedAlpha, this._storedBeta, 0, Vc.uk[0]), Gc.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, Vc.uk[1]), Gc.SlerpToRef(Vc.uk[1], Vc.uk[0], t, Vc.uk[2]), Vc.uk[2].normalize(), Vc.uk[2].toAlphaBetaGammaToRef(Vc.Vector3[0]), this.alpha = Vc.Vector3[0].x, this.beta = Vc.Vector3[0].y, this.radius += (this._storedRadius - this.radius) * t, Fc.LerpToRef(this.targetScreenOffset, this._storedTargetScreenOffset, t, this.targetScreenOffset), (Lc.DistanceSquared(this.getTarget(), this._storedTarget) < pc && Vc.uk[2].equalsWithEpsilon(Vc.uk[0]) && Math.pow(this._storedRadius - this.radius, 2) < pc && Fc.Distance(this.targetScreenOffset, this._storedTargetScreenOffset) < pc || 0 !== this.inertialAlphaOffset || 0 !== this.inertialBetaOffset || 0 !== this.inertialRadiusOffset || 0 !== this.inertialPanningX || 0 !== this.inertialPanningY) && (this._progressiveRestore = !1)
				}
				if (0 !== this.inertialAlphaOffset || 0 !== this.inertialBetaOffset || 0 !== this.inertialRadiusOffset) {
					const e = this.invertRotation ? -1 : 1,
						t = this._calculateHandednessMultiplier();
					let i = this.inertialAlphaOffset * t;
					this.beta < 0 && (i *= -1), this.alpha += i * e, this.beta += this.inertialBetaOffset * e, this.radius -= this.inertialRadiusOffset, this.inertialAlphaOffset *= this.inertia, this.inertialBetaOffset *= this.inertia, this.inertialRadiusOffset *= this.inertia, Math.abs(this.inertialAlphaOffset) < pc && (this.inertialAlphaOffset = 0), Math.abs(this.inertialBetaOffset) < pc && (this.inertialBetaOffset = 0), Math.abs(this.inertialRadiusOffset) < this.speed * pc && (this.inertialRadiusOffset = 0)
				}
				if (0 !== this.inertialPanningX || 0 !== this.inertialPanningY) {
					const e = new Lc(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
					if (this._viewMatrix.invertToRef(this._cameraTransformMatrix), e.multiplyInPlace(this.panningAxis), Lc.TransformNormalToRef(e, this._cameraTransformMatrix, this._transformedDirection), this.mapPanning) {
						const e = this.upVector,
							t = Lc.CrossToRef(this._transformedDirection, e, this._transformedDirection);
						Lc.CrossToRef(e, t, this._transformedDirection)
					} else this.panningAxis.y || (this._transformedDirection.y = 0);
					if (!this._targetHost)
						if (this.panningDistanceLimit) {
							this._transformedDirection.addInPlace(this._target);
							Lc.DistanceSquared(this._transformedDirection, this.panningOriginTarget) <= this.panningDistanceLimit * this.panningDistanceLimit && this._target.copyFrom(this._transformedDirection)
						} else {
							if (this.parent) {
								const e = Vc.Matrix[0];
								this.parent.getWorldMatrix().getRotationMatrixToRef(e), e.transposeToRef(e), Lc.TransformCoordinatesToRef(this._transformedDirection, e, this._transformedDirection)
							}
							this._target.addInPlace(this._transformedDirection)
						} this.inertialPanningX *= this.panningInertia, this.inertialPanningY *= this.panningInertia, Math.abs(this.inertialPanningX) < this.speed * pc && (this.inertialPanningX = 0), Math.abs(this.inertialPanningY) < this.speed * pc && (this.inertialPanningY = 0)
				}
				this._checkLimits(), super._checkInputs()
			}
		}
		setPosition(e) {
			this._position.equals(e) || (this._position.copyFrom(e), this.rebuildAnglesAndRadius())
		}
		get autoRotationBehavior() {
			return this._autoRotationBehavior
		}
		get keysDown() {
			const e = this.inputs.attached.keyboard;
			return e ? e.keysDown : []
		}
		set target(e) {
			this.setTarget(e)
		}
		_getViewMatrix() {
			const e = Math.cos(this.alpha),
				t = Math.sin(this.alpha),
				i = Math.cos(this.beta);
			let s = Math.sin(this.beta);
			0 === s && (s = 1e-4), 0 === this.radius && (this.radius = 1e-4);
			const n = this._getTargetPosition();
			if (this._computationVector.copyFromFloats(this.radius * e * s, this.radius * i, this.radius * t * s), 0 === this._upVector.x && 1 === this._upVector.y && 0 === this._upVector.z || Lc.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector), n.addToRef(this._computationVector, this._newPosition), this.getScene().collisionsEnabled && this.checkCollisions) {
				const e = this.getScene().collisionCoordinator;
				this._collider || (this._collider = e.createCollider()), this._collider._radius = this.collisionRadius, this._newPosition.subtractToRef(this._position, this._collisionVelocity), this._collisionTriggered = !0, e.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.ik)
			} else {
				this._position.copyFrom(this._newPosition);
				let e = this.upVector;
				this.allowUpsideDown && s < 0 && (e = e.negate()), this._computeViewMatrix(this._position, n, e), this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x), this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y)
			}
			return this._currentTarget = n, this._viewMatrix
		}
		get angularSensibilityX() {
			const e = this.inputs.attached.pointers;
			return e ? e.angularSensibilityX : 0
		}
		set zoomToMouseLocation(e) {
			const t = this.inputs.attached.mousewheel;
			t && (t.zoomToMouseLocation = e)
		}
		focusOn(e, t = !1) {
			let i, s;
			if (void 0 === e.min) {
				const t = e || this.getScene().meshes;
				i = Vf.MinMax(t), s = Lc.Distance(i.min, i.max)
			} else {
				i = e, s = e.distance
			}
			this._target = Vf.Center(i), t || (this.maxZ = 2 * s)
		}
		set keysUp(e) {
			const t = this.inputs.attached.keyboard;
			t && (t.keysUp = e)
		}
		get keysUp() {
			const e = this.inputs.attached.keyboard;
			return e ? e.keysUp : []
		}
		get angularSensibilityY() {
			const e = this.inputs.attached.pointers;
			return e ? e.angularSensibilityY : 0
		}
		set upVector(e) {
			this._upToYMatrix || (this._yToUpMatrix = new Hc, this._upToYMatrix = new Hc, this._upVector = Lc.Zero()), e.normalize(), this._upVector.copyFrom(e), this.setMatUp()
		}
		zoomOn(e, t = !1) {
			e = e || this.getScene().meshes;
			const i = Vf.MinMax(e);
			let s = this._calculateLowerRadiusFromModelBoundingSphere(i.min, i.max);
			s = Math.max(Math.min(s, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0), this.radius = s * this.zoomOnFactor, this.focusOn({
				min: i.min,
				max: i.max,
				distance: s
			}, t)
		}
		setTarget(e, t = !1, i = !1, s = !1) {
			if (s = this.overrideCloneAlphaBetaRadius ?? s, e.computeWorldMatrix) t && e.getBoundingInfo ? this._targetBoundingCenter = e.getBoundingInfo().boundingBox.centerWorld.clone() : this._targetBoundingCenter = null, e.computeWorldMatrix(), this._targetHost = e, this._target = this._getTargetPosition(), this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
			else {
				const t = e,
					s = this._getTargetPosition();
				if (s && !i && s.equals(t)) return;
				this._targetHost = null, this._target = t, this._targetBoundingCenter = null, this.onMeshTargetChangedObservable.notifyObservers(null)
			}
			s || this.rebuildAnglesAndRadius()
		}
		set useAutoRotationBehavior(e) {
			e !== this.useAutoRotationBehavior && (e ? (this._autoRotationBehavior = new Ig, this.addBehavior(this._autoRotationBehavior)) : this._autoRotationBehavior && (this.removeBehavior(this._autoRotationBehavior), this._autoRotationBehavior = null))
		}
		rebuildAnglesAndRadius() {
			this._position.subtractToRef(this._getTargetPosition(), this._computationVector), 0 === this._upVector.x && 1 === this._upVector.y && 0 === this._upVector.z || Lc.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector), this.radius = this._computationVector.length(), 0 === this.radius && (this.radius = 1e-4);
			const e = this.alpha;
			0 === this._computationVector.x && 0 === this._computationVector.z ? this.alpha = Math.PI / 2 : this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2))), this._computationVector.z < 0 && (this.alpha = 2 * Math.PI - this.alpha);
			const t = Math.round((e - this.alpha) / (2 * Math.PI));
			this.alpha += 2 * t * Math.PI, this.beta = Math.acos(this._computationVector.y / this.radius), this._checkLimits()
		}
		get target() {
			return this._target
		}
		set pinchDeltaPercentage(e) {
			const t = this.inputs.attached.pointers;
			t && (t.pinchDeltaPercentage = e)
		}
		get keysLeft() {
			const e = this.inputs.attached.keyboard;
			return e ? e.keysLeft : []
		}
		get pinchDeltaPercentage() {
			const e = this.inputs.attached.pointers;
			return e ? e.pinchDeltaPercentage : 0
		}
		get useFramingBehavior() {
			return null != this._framingBehavior
		}
		set keysDown(e) {
			const t = this.inputs.attached.keyboard;
			t && (t.keysDown = e)
		}
		_checkLimits() {
			null === this.lowerBetaLimit || void 0 === this.lowerBetaLimit ? this.allowUpsideDown && this.beta > Math.PI && (this.beta = this.beta - 2 * Math.PI) : this.beta < this.lowerBetaLimit && (this.beta = this.lowerBetaLimit), null === this.upperBetaLimit || void 0 === this.upperBetaLimit ? this.allowUpsideDown && this.beta < -Math.PI && (this.beta = this.beta + 2 * Math.PI) : this.beta > this.upperBetaLimit && (this.beta = this.upperBetaLimit), null !== this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit && (this.alpha = this.lowerAlphaLimit), null !== this.upperAlphaLimit && this.alpha > this.upperAlphaLimit && (this.alpha = this.upperAlphaLimit), null !== this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit && (this.radius = this.lowerRadiusLimit, this.inertialRadiusOffset = 0), null !== this.upperRadiusLimit && this.radius > this.upperRadiusLimit && (this.radius = this.upperRadiusLimit, this.inertialRadiusOffset = 0)
		}
		set useBouncingBehavior(e) {
			e !== this.useBouncingBehavior && (e ? (this._bouncingBehavior = new zg, this.addBehavior(this._bouncingBehavior)) : this._bouncingBehavior && (this.removeBehavior(this._bouncingBehavior), this._bouncingBehavior = null))
		}
		detachControl() {
			this.inputs.detachElement(), this._reset && this._reset()
		}
		get zoomToMouseLocation() {
			const e = this.inputs.attached.mousewheel;
			return !!e && e.zoomToMouseLocation
		}
		get panningSensibility() {
			const e = this.inputs.attached.pointers;
			return e ? e.panningSensibility : 0
		}
		set position(e) {
			this.setPosition(e)
		}
		get pinchPrecision() {
			const e = this.inputs.attached.pointers;
			return e ? e.pinchPrecision : 0
		}
		getTarget() {
			return this.target
		}
		_restoreStateValues() {
			return this.hasStateStored() && this.restoreStateInterpolationFactor > pc && this.restoreStateInterpolationFactor < 1 ? (this._progressiveRestore = !0, this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.inertialPanningX = 0, this.inertialPanningY = 0, !0) : !!super._restoreStateValues() && (this.setTarget(this._storedTarget.clone()), this.alpha = this._storedAlpha, this.beta = this._storedBeta, this.radius = this._storedRadius, this.targetScreenOffset = this._storedTargetScreenOffset.clone(), this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.inertialPanningX = 0, this.inertialPanningY = 0, !0)
		}
		set useFramingBehavior(e) {
			e !== this.useFramingBehavior && (e ? (this._framingBehavior = new Xg, this.addBehavior(this._framingBehavior)) : this._framingBehavior && (this.removeBehavior(this._framingBehavior), this._framingBehavior = null))
		}
		constructor(e, t, i, s, n, a, r = !0) {
			super(e, Lc.Zero(), a, r), this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.lowerAlphaLimit = null, this.upperAlphaLimit = null, this.lowerBetaLimit = .01, this.upperBetaLimit = Math.PI - .01, this.lowerRadiusLimit = null, this.upperRadiusLimit = null, this.inertialPanningX = 0, this.inertialPanningY = 0, this.pinchToPanMaxDistance = 20, this.panningDistanceLimit = null, this.panningOriginTarget = Lc.Zero(), this.panningInertia = .9, this.zoomOnFactor = 1, this.targetScreenOffset = Fc.Zero(), this.allowUpsideDown = !0, this.useInputToRestoreState = !0, this.restoreStateInterpolationFactor = 0, this._viewMatrix = new Hc, this.panningAxis = new Lc(1, 1, 0), this._transformedDirection = new Lc, this.mapPanning = !1, this._progressiveRestore = !1, this.onMeshTargetChangedObservable = new kc, this.checkCollisions = !1, this.collisionRadius = new Lc(.5, .5, .5), this._previousPosition = Lc.Zero(), this._collisionVelocity = Lc.Zero(), this._newPosition = Lc.Zero(), this._computationVector = Lc.Zero(), this._onCollisionPositionChange = (e, t, i = null) => {
				i ? (this.setPosition(t), this.onCollide && this.onCollide(i)) : this._previousPosition.copyFrom(this._position);
				const s = Math.cos(this.alpha),
					n = Math.sin(this.alpha),
					a = Math.cos(this.beta);
				let r = Math.sin(this.beta);
				0 === r && (r = 1e-4);
				const o = this._getTargetPosition();
				this._computationVector.copyFromFloats(this.radius * s * r, this.radius * a, this.radius * n * r), o.addToRef(this._computationVector, this._newPosition), this._position.copyFrom(this._newPosition);
				let l = this.upVector;
				this.allowUpsideDown && this.beta < 0 && (l = l.clone(), l = l.negate()), this._computeViewMatrix(this._position, o, l), this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x), this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y), this._collisionTriggered = !1
			}, this._target = Lc.Zero(), n && this.setTarget(n), this.alpha = t, this.beta = i, this.radius = s, this.getViewMatrix(), this.inputs = new Qg(this), this.inputs.addKeyboard().addMouseWheel().addPointers()
		}
		_getTargetPosition() {
			if (this._targetHost && this._targetHost.getAbsolutePosition) {
				const e = this._targetHost.getAbsolutePosition();
				this._targetBoundingCenter ? e.addToRef(this._targetBoundingCenter, this._target) : this._target.copyFrom(e)
			}
			const e = this._getLockedTargetPosition();
			return e || this._target
		}
		storeState() {
			return this._storedAlpha = this.alpha, this._storedBeta = this.beta, this._storedRadius = this.radius, this._storedTarget = this._getTargetPosition().clone(), this._storedTargetScreenOffset = this.targetScreenOffset.clone(), super.storeState()
		}
		get position() {
			return this._position
		}
		set targetHost(e) {
			e && this.setTarget(e)
		}
		setMatUp() {
			Hc.RotationAlignToRef(Lc.UpReadOnly, this._upVector, this._yToUpMatrix), Hc.RotationAlignToRef(this._upVector, Lc.UpReadOnly, this._upToYMatrix)
		}
		get useBouncingBehavior() {
			return null != this._bouncingBehavior
		}
		get keysRight() {
			const e = this.inputs.attached.keyboard;
			return e ? e.keysRight : []
		}
		set panningSensibility(e) {
			const t = this.inputs.attached.pointers;
			t && (t.panningSensibility = e)
		}
		get useNaturalPinchZoom() {
			const e = this.inputs.attached.pointers;
			return !!e && e.useNaturalPinchZoom
		}
		_updateRigCameras() {
			const e = this._rigCameras[0],
				t = this._rigCameras[1];
			switch (e.beta = t.beta = this.beta, this.cameraRigMode) {
				case Sd.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case Sd.RIG_MODE_STEREOSCOPIC_OVERUNDER:
				case Sd.RIG_MODE_STEREOSCOPIC_INTERLACED:
				case Sd.RIG_MODE_VR:
					e.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle, t.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
					break;
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
					e.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle, t.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle
			}
			super._updateRigCameras()
		}
		_initCache() {
			super._initCache(), this._cache._target = new Lc(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.alpha = void 0, this._cache.beta = void 0, this._cache.radius = void 0, this._cache.targetScreenOffset = Fc.Zero()
		}
		set useNaturalPinchZoom(e) {
			const t = this.inputs.attached.pointers;
			t && (t.useNaturalPinchZoom = e)
		}
		set wheelPrecision(e) {
			const t = this.inputs.attached.mousewheel;
			t && (t.wheelPrecision = e)
		}
		set keysRight(e) {
			const t = this.inputs.attached.keyboard;
			t && (t.keysRight = e)
		}
		_calculateLowerRadiusFromModelBoundingSphere(e, t, i = 1) {
			const s = Lc.Distance(e, t),
				n = this.getScene().getEngine().getAspectRatio(this),
				a = Math.tan(this.mk / 2),
				r = a * n,
				o = .5 * s * i,
				l = o * Math.sqrt(1 + 1 / (r * r)),
				h = o * Math.sqrt(1 + 1 / (a * a));
			return Math.max(l, h)
		}
		get targetHost() {
			return this._targetHost
		}
		getClassName() {
			return "ArcRotateCamera"
		}
		get upVector() {
			return this._upVector
		}
		_updateCache(e) {
			e || super._updateCache(), this._cache._target.copyFrom(this._getTargetPosition()), this._cache.alpha = this.alpha, this._cache.beta = this.beta, this._cache.radius = this.radius, this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset)
		}
		set keysLeft(e) {
			const t = this.inputs.attached.keyboard;
			t && (t.keysLeft = e)
		}
		dispose() {
			this.inputs.clear(), super.dispose()
		}
		createRigCamera(t, i) {
			let s = 0;
			switch (this.cameraRigMode) {
				case Sd.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case Sd.RIG_MODE_STEREOSCOPIC_OVERUNDER:
				case Sd.RIG_MODE_STEREOSCOPIC_INTERLACED:
				case Sd.RIG_MODE_VR:
					s = this._cameraRigParams.stereoHalfAngle * (0 === i ? 1 : -1);
					break;
				case Sd.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
					s = this._cameraRigParams.stereoHalfAngle * (0 === i ? -1 : 1)
			}
			const n = new e(t, this.alpha + s, this.beta, this.radius, this._target, this.getScene());
			return n._cameraRigParams = {}, n.isRigCamera = !0, n.rigParent = this, n.upVector = this.upVector, n.mode = this.mode, n.orthoLeft = this.orthoLeft, n.orthoRight = this.orthoRight, n.orthoBottom = this.orthoBottom, n.orthoTop = this.orthoTop, n
		}
		set angularSensibilityY(e) {
			const t = this.inputs.attached.pointers;
			t && (t.angularSensibilityY = e)
		}
		set wheelDeltaPercentage(e) {
			const t = this.inputs.attached.mousewheel;
			t && (t.wheelDeltaPercentage = e)
		}
		get wheelDeltaPercentage() {
			const e = this.inputs.attached.mousewheel;
			return e ? e.wheelDeltaPercentage : 0
		}
		set pinchPrecision(e) {
			const t = this.inputs.attached.pointers;
			t && (t.pinchPrecision = e)
		}
		get bouncingBehavior() {
			return this._bouncingBehavior
		}
		set angularSensibilityX(e) {
			const t = this.inputs.attached.pointers;
			t && (t.angularSensibilityX = e)
		}
		_isSynchronizedViewMatrix() {
			return !!super._isSynchronizedViewMatrix() && (this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset))
		}
		get framingBehavior() {
			return this._framingBehavior
		}
		get wheelPrecision() {
			const e = this.inputs.attached.mousewheel;
			return e ? e.wheelPrecision : 0
		}
		get useAutoRotationBehavior() {
			return null != this._autoRotationBehavior
		}
	};
	Gh([Xh()], Zg.prototype, "alpha", void 0), Gh([Xh()], Zg.prototype, "beta", void 0), Gh([Xh()], Zg.prototype, "radius", void 0), Gh([Xh()], Zg.prototype, "overrideCloneAlphaBetaRadius", void 0), Gh([Jh("target")], Zg.prototype, "_target", void 0), Gh([qh("targetHost")], Zg.prototype, "_targetHost", void 0), Gh([Xh()], Zg.prototype, "inertialAlphaOffset", void 0), Gh([Xh()], Zg.prototype, "inertialBetaOffset", void 0), Gh([Xh()], Zg.prototype, "inertialRadiusOffset", void 0), Gh([Xh()], Zg.prototype, "lowerAlphaLimit", void 0), Gh([Xh()], Zg.prototype, "upperAlphaLimit", void 0), Gh([Xh()], Zg.prototype, "lowerBetaLimit", void 0), Gh([Xh()], Zg.prototype, "upperBetaLimit", void 0), Gh([Xh()], Zg.prototype, "lowerRadiusLimit", void 0), Gh([Xh()], Zg.prototype, "upperRadiusLimit", void 0), Gh([Xh()], Zg.prototype, "inertialPanningX", void 0), Gh([Xh()], Zg.prototype, "inertialPanningY", void 0), Gh([Xh()], Zg.prototype, "pinchToPanMaxDistance", void 0), Gh([Xh()], Zg.prototype, "panningDistanceLimit", void 0), Gh([Jh()], Zg.prototype, "panningOriginTarget", void 0), Gh([Xh()], Zg.prototype, "panningInertia", void 0), Gh([Xh()], Zg.prototype, "zoomToMouseLocation", null), Gh([Xh()], Zg.prototype, "zoomOnFactor", void 0), Gh([$h()], Zg.prototype, "targetScreenOffset", void 0), Gh([Xh()], Zg.prototype, "allowUpsideDown", void 0), Gh([Xh()], Zg.prototype, "useInputToRestoreState", void 0), Gh([Xh()], Zg.prototype, "restoreStateInterpolationFactor", void 0), cc("BABYLON.ArcRotateCamera", Zg);
	var ev = class {
		detachControl() {
			this._scene && (this._onKeyboardObserver && this._scene.onKeyboardObservable.remove(this._onKeyboardObserver), this._onCanvasBlurObserver && this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver), this._onKeyboardObserver = null, this._onCanvasBlurObserver = null), this._keys.length = 0
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments), this._onCanvasBlurObserver || (this._scene = this.camera.getScene(), this._engine = this._scene.getEngine(), this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add((() => {
				this._keys.length = 0
			})), this._onKeyboardObserver = this._scene.onKeyboardObservable.add((t => {
				const i = t.event;
				if (!i.metaKey)
					if (t.type === X_.KEYDOWN) {
						if (-1 !== this.keysUp.indexOf(i.keyCode) || -1 !== this.keysDown.indexOf(i.keyCode) || -1 !== this.keysLeft.indexOf(i.keyCode) || -1 !== this.keysRight.indexOf(i.keyCode) || -1 !== this.keysUpward.indexOf(i.keyCode) || -1 !== this.keysDownward.indexOf(i.keyCode) || -1 !== this.keysRotateLeft.indexOf(i.keyCode) || -1 !== this.keysRotateRight.indexOf(i.keyCode) || -1 !== this.keysRotateUp.indexOf(i.keyCode) || -1 !== this.keysRotateDown.indexOf(i.keyCode)) {
							-1 === this._keys.indexOf(i.keyCode) && this._keys.push(i.keyCode), e || i.preventDefault()
						}
					} else if (-1 !== this.keysUp.indexOf(i.keyCode) || -1 !== this.keysDown.indexOf(i.keyCode) || -1 !== this.keysLeft.indexOf(i.keyCode) || -1 !== this.keysRight.indexOf(i.keyCode) || -1 !== this.keysUpward.indexOf(i.keyCode) || -1 !== this.keysDownward.indexOf(i.keyCode) || -1 !== this.keysRotateLeft.indexOf(i.keyCode) || -1 !== this.keysRotateRight.indexOf(i.keyCode) || -1 !== this.keysRotateUp.indexOf(i.keyCode) || -1 !== this.keysRotateDown.indexOf(i.keyCode)) {
					const t = this._keys.indexOf(i.keyCode);
					t >= 0 && this._keys.splice(t, 1), e || i.preventDefault()
				}
			})))
		}
		_onLostFocus() {
			this._keys.length = 0
		}
		_getLocalRotation() {
			const e = this.camera._calculateHandednessMultiplier();
			return this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * e
		}
		getSimpleName() {
			return "keyboard"
		}
		constructor() {
			this.keysUp = [38], this.keysUpward = [33], this.keysDown = [40], this.keysDownward = [34], this.keysLeft = [37], this.keysRight = [39], this.rotationSpeed = .5, this.keysRotateLeft = [], this.keysRotateRight = [], this.keysRotateUp = [], this.keysRotateDown = [], this._keys = new Array
		}
		checkInputs() {
			if (this._onKeyboardObserver) {
				const e = this.camera;
				for (let t = 0; t < this._keys.length; t++) {
					const i = this._keys[t],
						s = e._computeLocalCameraSpeed(); - 1 !== this.keysLeft.indexOf(i) ? e._localDirection.copyFromFloats(-s, 0, 0) : -1 !== this.keysUp.indexOf(i) ? e._localDirection.copyFromFloats(0, 0, s) : -1 !== this.keysRight.indexOf(i) ? e._localDirection.copyFromFloats(s, 0, 0) : -1 !== this.keysDown.indexOf(i) ? e._localDirection.copyFromFloats(0, 0, -s) : -1 !== this.keysUpward.indexOf(i) ? e._localDirection.copyFromFloats(0, s, 0) : -1 !== this.keysDownward.indexOf(i) ? e._localDirection.copyFromFloats(0, -s, 0) : -1 !== this.keysRotateLeft.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0), e.cameraRotation.y -= this._getLocalRotation()) : -1 !== this.keysRotateRight.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0), e.cameraRotation.y += this._getLocalRotation()) : -1 !== this.keysRotateUp.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0), e.cameraRotation.x -= this._getLocalRotation()) : -1 !== this.keysRotateDown.indexOf(i) && (e._localDirection.copyFromFloats(0, 0, 0), e.cameraRotation.x += this._getLocalRotation()), e.getScene().useRightHandedSystem && (e._localDirection.z *= -1), e.getViewMatrix().invertToRef(e._cameraTransformMatrix), Lc.TransformNormalToRef(e._localDirection, e._cameraTransformMatrix, e._transformedDirection), e.cameraDirection.addInPlace(e._transformedDirection)
				}
			}
		}
		getClassName() {
			return "FreeCameraKeyboardMoveInput"
		}
	};
	Gh([Xh()], ev.prototype, "keysUp", void 0), Gh([Xh()], ev.prototype, "keysUpward", void 0), Gh([Xh()], ev.prototype, "keysDown", void 0), Gh([Xh()], ev.prototype, "keysDownward", void 0), Gh([Xh()], ev.prototype, "keysLeft", void 0), Gh([Xh()], ev.prototype, "keysRight", void 0), Gh([Xh()], ev.prototype, "rotationSpeed", void 0), Gh([Xh()], ev.prototype, "keysRotateLeft", void 0), Gh([Xh()], ev.prototype, "keysRotateRight", void 0), Gh([Xh()], ev.prototype, "keysRotateUp", void 0), Gh([Xh()], ev.prototype, "keysRotateDown", void 0), Yg.FreeCameraKeyboardMoveInput = ev;
	var tv = class {
		detachControl() {
			if (this._observer) {
				if (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer), this._contextMenuBind) {
					const e = this.camera.getEngine().getInputElement();
					e && e.removeEventListener("contextmenu", this._contextMenuBind)
				}
				this.onPointerMovedObservable && this.onPointerMovedObservable.clear(), this._observer = null, this._onMouseMove = null, this._previousPosition = null
			}
			this._activePointerId = -1, this._currentActiveButton = -1
		}
		onContextMenu(e) {
			e.preventDefault()
		}
		getClassName() {
			return "FreeCameraMouseInput"
		}
		constructor(e = !0) {
			this.touchEnabled = e, this.buttons = [0, 1, 2], this.angularSensibility = 2e3, this._previousPosition = null, this.onPointerMovedObservable = new kc, this._allowCameraRotation = !0, this._currentActiveButton = -1, this._activePointerId = -1
		}
		getSimpleName() {
			return "mouse"
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments);
			const t = this.camera.getEngine(),
				i = t.getInputElement();
			this._pointerInput || (this._pointerInput = s => {
				const n = s.event,
					a = "touch" === n.pointerType;
				if (!this.touchEnabled && a) return;
				if (s.type !== H_.POINTERMOVE && -1 === this.buttons.indexOf(n.button)) return;
				const r = n.target;
				if (s.type === H_.POINTERDOWN) {
					if (a && -1 !== this._activePointerId || !a && -1 !== this._currentActiveButton) return;
					this._activePointerId = n.pointerId;
					try {
						r?.setPointerCapture(n.pointerId)
					} catch (e) {} - 1 === this._currentActiveButton && (this._currentActiveButton = n.button), this._previousPosition = {
						x: n.clientX,
						y: n.clientY
					}, e || (n.preventDefault(), i && i.focus()), t.isPointerLock && this._onMouseMove && this._onMouseMove(s.event)
				} else if (s.type === H_.POINTERUP) {
					if (a && this._activePointerId !== n.pointerId || !a && this._currentActiveButton !== n.button) return;
					try {
						r?.releasePointerCapture(n.pointerId)
					} catch (e) {}
					this._currentActiveButton = -1, this._previousPosition = null, e || n.preventDefault(), this._activePointerId = -1
				} else if (s.type === H_.POINTERMOVE && (this._activePointerId === n.pointerId || !a))
					if (t.isPointerLock && this._onMouseMove) this._onMouseMove(s.event);
					else if (this._previousPosition) {
					const t = this.camera._calculateHandednessMultiplier(),
						i = (n.clientX - this._previousPosition.x) * t,
						s = n.clientY - this._previousPosition.y;
					this._allowCameraRotation && (this.camera.cameraRotation.y += i / this.angularSensibility, this.camera.cameraRotation.x += s / this.angularSensibility), this.onPointerMovedObservable.notifyObservers({
						offsetX: i,
						offsetY: s
					}), this._previousPosition = {
						x: n.clientX,
						y: n.clientY
					}, e || n.preventDefault()
				}
			}), this._onMouseMove = i => {
				if (!t.isPointerLock) return;
				const s = this.camera._calculateHandednessMultiplier(),
					n = i.movementX * s;
				this.camera.cameraRotation.y += n / this.angularSensibility;
				const a = i.movementY;
				this.camera.cameraRotation.x += a / this.angularSensibility, this._previousPosition = null, e || i.preventDefault()
			}, this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, H_.POINTERDOWN | H_.POINTERUP | H_.POINTERMOVE), i && (this._contextMenuBind = e => this.onContextMenu(e), i.addEventListener("contextmenu", this._contextMenuBind, !1))
		}
	};
	Gh([Xh()], tv.prototype, "buttons", void 0), Gh([Xh()], tv.prototype, "angularSensibility", void 0), Yg.FreeCameraMouseInput = tv;
	var iv, sv, nv = class {
		getClassName() {
			return "BaseCameraMouseWheelInput"
		}
		constructor() {
			this.wheelPrecisionX = 3, this.wheelPrecisionY = 3, this.wheelPrecisionZ = 3, this.onChangedObservable = new kc, this._wheelDeltaX = 0, this._wheelDeltaY = 0, this._wheelDeltaZ = 0, this._ffMultiplier = 12, this._normalize = 120
		}
		checkInputs() {
			this.onChangedObservable.notifyObservers({
				wheelDeltaX: this._wheelDeltaX,
				wheelDeltaY: this._wheelDeltaY,
				wheelDeltaZ: this._wheelDeltaZ
			}), this._wheelDeltaX = 0, this._wheelDeltaY = 0, this._wheelDeltaZ = 0
		}
		getSimpleName() {
			return "mousewheel"
		}
		detachControl() {
			this._observer && (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer), this._observer = null, this._wheel = null), this.onChangedObservable && this.onChangedObservable.clear()
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments), this._wheel = t => {
				if (t.type !== H_.POINTERWHEEL) return;
				const i = t.event,
					s = i.deltaMode === cg.DOM_DELTA_LINE ? this._ffMultiplier : 1;
				this._wheelDeltaX += this.wheelPrecisionX * s * i.deltaX / this._normalize, this._wheelDeltaY -= this.wheelPrecisionY * s * i.deltaY / this._normalize, this._wheelDeltaZ += this.wheelPrecisionZ * s * i.deltaZ / this._normalize, i.preventDefault && (e || i.preventDefault())
			}, this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, H_.POINTERWHEEL)
		}
	};
	Gh([Xh()], nv.prototype, "wheelPrecisionX", void 0), Gh([Xh()], nv.prototype, "wheelPrecisionY", void 0), Gh([Xh()], nv.prototype, "wheelPrecisionZ", void 0), (sv = iv || (iv = {}))[sv.MoveRelative = 0] = "MoveRelative", sv[sv.RotateRelative = 1] = "RotateRelative", sv[sv.MoveScene = 2] = "MoveScene";
	var av = class extends nv {
		set wheelZMoveRelative(e) {
			null === e && this._wheelZAction !== iv.MoveRelative || (this._wheelZAction = iv.MoveRelative, this._wheelZActionCoordinate = e)
		}
		constructor() {
			super(...arguments), this._moveRelative = Lc.Zero(), this._rotateRelative = Lc.Zero(), this._moveScene = Lc.Zero(), this._wheelXAction = iv.MoveRelative, this._wheelXActionCoordinate = 0, this._wheelYAction = iv.MoveRelative, this._wheelYActionCoordinate = 2, this._wheelZAction = null, this._wheelZActionCoordinate = null
		}
		set wheelZRotateRelative(e) {
			null === e && this._wheelZAction !== iv.RotateRelative || (this._wheelZAction = iv.RotateRelative, this._wheelZActionCoordinate = e)
		}
		checkInputs() {
			if (0 === this._wheelDeltaX && 0 === this._wheelDeltaY && 0 == this._wheelDeltaZ) return;
			this._moveRelative.setAll(0), this._rotateRelative.setAll(0), this._moveScene.setAll(0), this._updateCamera(), this.camera.getScene().useRightHandedSystem && (this._moveRelative.z *= -1);
			const e = Hc.Zero();
			this.camera.getViewMatrix().invertToRef(e);
			const t = Lc.Zero();
			Lc.TransformNormalToRef(this._moveRelative, e, t), this.camera.cameraRotation.x += this._rotateRelative.x / 200, this.camera.cameraRotation.y += this._rotateRelative.y / 200, this.camera.cameraDirection.addInPlace(t), this.camera.cameraDirection.addInPlace(this._moveScene), super.checkInputs()
		}
		set wheelZMoveScene(e) {
			null === e && this._wheelZAction !== iv.MoveScene || (this._wheelZAction = iv.MoveScene, this._wheelZActionCoordinate = e)
		}
		get wheelZMoveScene() {
			return this._wheelZAction !== iv.MoveScene ? null : this._wheelZActionCoordinate
		}
		get wheelYRotateRelative() {
			return this._wheelYAction !== iv.RotateRelative ? null : this._wheelYActionCoordinate
		}
		_updateCamera() {
			this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate), this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate), this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate)
		}
		set wheelYRotateRelative(e) {
			null === e && this._wheelYAction !== iv.RotateRelative || (this._wheelYAction = iv.RotateRelative, this._wheelYActionCoordinate = e)
		}
		getClassName() {
			return "FreeCameraMouseWheelInput"
		}
		_updateCameraProperty(e, t, i) {
			if (0 === e) return;
			if (null === t || null === i) return;
			let s = null;
			switch (t) {
				case iv.MoveRelative:
					s = this._moveRelative;
					break;
				case iv.RotateRelative:
					s = this._rotateRelative;
					break;
				case iv.MoveScene:
					s = this._moveScene
			}
			switch (i) {
				case 0:
					s.set(e, 0, 0);
					break;
				case 1:
					s.set(0, e, 0);
					break;
				case 2:
					s.set(0, 0, e)
			}
		}
		get wheelZRotateRelative() {
			return this._wheelZAction !== iv.RotateRelative ? null : this._wheelZActionCoordinate
		}
		get wheelXRotateRelative() {
			return this._wheelXAction !== iv.RotateRelative ? null : this._wheelXActionCoordinate
		}
		get wheelZMoveRelative() {
			return this._wheelZAction !== iv.MoveRelative ? null : this._wheelZActionCoordinate
		}
		set wheelYMoveRelative(e) {
			null === e && this._wheelYAction !== iv.MoveRelative || (this._wheelYAction = iv.MoveRelative, this._wheelYActionCoordinate = e)
		}
		set wheelXRotateRelative(e) {
			null === e && this._wheelXAction !== iv.RotateRelative || (this._wheelXAction = iv.RotateRelative, this._wheelXActionCoordinate = e)
		}
		set wheelXMoveScene(e) {
			null === e && this._wheelXAction !== iv.MoveScene || (this._wheelXAction = iv.MoveScene, this._wheelXActionCoordinate = e)
		}
		get wheelXMoveScene() {
			return this._wheelXAction !== iv.MoveScene ? null : this._wheelXActionCoordinate
		}
		set wheelXMoveRelative(e) {
			null === e && this._wheelXAction !== iv.MoveRelative || (this._wheelXAction = iv.MoveRelative, this._wheelXActionCoordinate = e)
		}
		get wheelYMoveScene() {
			return this._wheelYAction !== iv.MoveScene ? null : this._wheelYActionCoordinate
		}
		get wheelXMoveRelative() {
			return this._wheelXAction !== iv.MoveRelative ? null : this._wheelXActionCoordinate
		}
		get wheelYMoveRelative() {
			return this._wheelYAction !== iv.MoveRelative ? null : this._wheelYActionCoordinate
		}
		set wheelYMoveScene(e) {
			null === e && this._wheelYAction !== iv.MoveScene || (this._wheelYAction = iv.MoveScene, this._wheelYActionCoordinate = e)
		}
	};
	Gh([Xh()], av.prototype, "wheelXMoveRelative", null), Gh([Xh()], av.prototype, "wheelYMoveRelative", null), Gh([Xh()], av.prototype, "wheelZMoveRelative", null), Gh([Xh()], av.prototype, "wheelXRotateRelative", null), Gh([Xh()], av.prototype, "wheelYRotateRelative", null), Gh([Xh()], av.prototype, "wheelZRotateRelative", null), Gh([Xh()], av.prototype, "wheelXMoveScene", null), Gh([Xh()], av.prototype, "wheelYMoveScene", null), Gh([Xh()], av.prototype, "wheelZMoveScene", null), Yg.FreeCameraMouseWheelInput = av;
	var rv = class {
		detachControl() {
			if (this._pointerInput) {
				if (this._observer && (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer), this._observer = null), this._onLostFocus) {
					const e = this.camera.getEngine().getInputElement();
					e && e.removeEventListener("blur", this._onLostFocus), this._onLostFocus = null
				}
				this._pointerPressed.length = 0, this._offsetX = null, this._offsetY = null
			}
		}
		constructor(e = !1) {
			this.allowMouse = e, this.touchAngularSensibility = 2e5, this.touchMoveSensibility = 250, this.singleFingerRotate = !1, this._offsetX = null, this._offsetY = null, this._pointerPressed = new Array, this._isSafari = dd.IsSafari()
		}
		checkInputs() {
			if (null === this._offsetX || null === this._offsetY) return;
			if (0 === this._offsetX && 0 === this._offsetY) return;
			const e = this.camera,
				t = e._calculateHandednessMultiplier();
			e.cameraRotation.y = t * this._offsetX / this.touchAngularSensibility;
			if (this.singleFingerRotate && 1 === this._pointerPressed.length || !this.singleFingerRotate && this._pointerPressed.length > 1) e.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
			else {
				const t = e._computeLocalCameraSpeed(),
					i = new Lc(0, 0, 0 !== this.touchMoveSensibility ? t * this._offsetY / this.touchMoveSensibility : 0);
				Hc.RotationYawPitchRollToRef(e.rotation.y, e.rotation.x, 0, e._cameraRotationMatrix), e.cameraDirection.addInPlace(Lc.TransformCoordinates(i, e._cameraRotationMatrix))
			}
		}
		getSimpleName() {
			return "touch"
		}
		attachControl(e) {
			e = dd.BackCompatCameraNoPreventDefault(arguments);
			let t = null;
			if (void 0 === this._pointerInput && (this._onLostFocus = () => {
					this._offsetX = null, this._offsetY = null
				}, this._pointerInput = i => {
					const s = i.event,
						n = "mouse" === s.pointerType || this._isSafari && void 0 === s.pointerType;
					if (this.allowMouse || !n)
						if (i.type === H_.POINTERDOWN) {
							if (e || s.preventDefault(), this._pointerPressed.push(s.pointerId), 1 !== this._pointerPressed.length) return;
							t = {
								x: s.clientX,
								y: s.clientY
							}
						} else if (i.type === H_.POINTERUP) {
						e || s.preventDefault();
						const i = this._pointerPressed.indexOf(s.pointerId);
						if (-1 === i) return;
						if (this._pointerPressed.splice(i, 1), 0 != i) return;
						t = null, this._offsetX = null, this._offsetY = null
					} else if (i.type === H_.POINTERMOVE) {
						if (e || s.preventDefault(), !t) return;
						if (0 != this._pointerPressed.indexOf(s.pointerId)) return;
						this._offsetX = s.clientX - t.x, this._offsetY = -(s.clientY - t.y)
					}
				}), this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, H_.POINTERDOWN | H_.POINTERUP | H_.POINTERMOVE), this._onLostFocus) {
				const e = this.camera.getEngine().getInputElement();
				e && e.addEventListener("blur", this._onLostFocus)
			}
		}
		getClassName() {
			return "FreeCameraTouchInput"
		}
	};
	Gh([Xh()], rv.prototype, "touchAngularSensibility", void 0), Gh([Xh()], rv.prototype, "touchMoveSensibility", void 0), Yg.FreeCameraTouchInput = rv;
	var ov = class extends jg {
			clear() {
				super.clear(), this._mouseInput = null
			}
			addTouch() {
				return this.add(new rv), this
			}
			removeMouse() {
				return this._mouseInput && this.remove(this._mouseInput), this
			}
			addMouse(e = !0) {
				return this._mouseInput || (this._mouseInput = new tv(e), this.add(this._mouseInput)), this
			}
			removeMouseWheel() {
				return this._mouseWheelInput && this.remove(this._mouseWheelInput), this
			}
			addMouseWheel() {
				return this._mouseWheelInput || (this._mouseWheelInput = new av, this.add(this._mouseWheelInput)), this
			}
			constructor(e) {
				super(e), this._mouseInput = null, this._mouseWheelInput = null
			}
			addKeyboard() {
				return this.add(new ev), this
			}
		},
		lv = class extends Ng {
			get needMoveForGravity() {
				return this._needMoveForGravity
			}
			set keysRotateUp(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysRotateUp = e)
			}
			get keysRotateRight() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysRotateRight : []
			}
			get keysRotateLeft() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysRotateLeft : []
			}
			get collisionMask() {
				return this._collisionMask
			}
			attachControl(e, t) {
				t = dd.BackCompatCameraNoPreventDefault(arguments), this.inputs.attachElement(t)
			}
			get keysUp() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysUp : []
			}
			set angularSensibility(e) {
				const t = this.inputs.attached.mouse;
				t && (t.angularSensibility = e)
			}
			set keysRotateLeft(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysRotateLeft = e)
			}
			set keysLeft(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysLeft = e)
			}
			set keysDownward(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysDownward = e)
			}
			_collideWithWorld(e) {
				let t;
				t = this.parent ? Lc.TransformCoordinates(this.position, this.parent.getWorldMatrix()) : this.position, t.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition), this._oldPosition.addInPlace(this.ellipsoidOffset);
				const i = this.getScene().collisionCoordinator;
				this._collider || (this._collider = i.createCollider()), this._collider._radius = this.ellipsoid, this._collider.collisionMask = this._collisionMask;
				let s = e;
				this.applyGravity && (s = e.add(this.getScene().gravity)), i.getNewPosition(this._oldPosition, s, this._collider, 3, null, this._onCollisionPositionChange, this.ik)
			}
			get angularSensibility() {
				const e = this.inputs.attached.mouse;
				return e ? e.angularSensibility : 0
			}
			get keysLeft() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysLeft : []
			}
			_checkInputs() {
				this._localDirection || (this._localDirection = Lc.Zero(), this._transformedDirection = Lc.Zero()), this.inputs.checkInputs(), super._checkInputs()
			}
			get keysRotateUp() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysRotateUp : []
			}
			set keysDown(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysDown = e)
			}
			set keysUpward(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysUpward = e)
			}
			constructor(e, t, i, s = !0) {
				super(e, t, i, s), this.ellipsoid = new Lc(.5, 1, .5), this.ellipsoidOffset = new Lc(0, 0, 0), this.checkCollisions = !1, this.applyGravity = !1, this._needMoveForGravity = !1, this._oldPosition = Lc.Zero(), this._diffPosition = Lc.Zero(), this._newPosition = Lc.Zero(), this._collisionMask = -1, this._onCollisionPositionChange = (e, t, i = null) => {
					this._newPosition.copyFrom(t), this._newPosition.subtractToRef(this._oldPosition, this._diffPosition), this._diffPosition.length() > Fd.CollisionsEpsilon && (this.position.addToRef(this._diffPosition, this._deferredPositionUpdate), this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate), this.onCollide && i && this.onCollide(i))
				}, this.inputs = new ov(this), this.inputs.addKeyboard().addMouse()
			}
			get keysRotateDown() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysRotateDown : []
			}
			set collisionMask(e) {
				this._collisionMask = isNaN(e) ? -1 : e
			}
			set needMoveForGravity(e) {
				this._needMoveForGravity = e
			}
			get keysDown() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysDown : []
			}
			detachControl() {
				this.inputs.detachElement(), this.cameraDirection = new Lc(0, 0, 0), this.cameraRotation = new Fc(0, 0)
			}
			_decideIfNeedsToMove() {
				return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
			}
			set keysUp(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysUp = e)
			}
			get keysRight() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysRight : []
			}
			getClassName() {
				return "FreeCamera"
			}
			set keysRight(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysRight = e)
			}
			_updatePosition() {
				this.checkCollisions && this.getScene().collisionsEnabled ? this._collideWithWorld(this.cameraDirection) : super._updatePosition()
			}
			get keysDownward() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysDownward : []
			}
			set keysRotateDown(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysRotateDown = e)
			}
			dispose() {
				this.inputs.clear(), super.dispose()
			}
			set keysRotateRight(e) {
				const t = this.inputs.attached.keyboard;
				t && (t.keysRotateRight = e)
			}
			get keysUpward() {
				const e = this.inputs.attached.keyboard;
				return e ? e.keysUpward : []
			}
		};
	Gh([Jh()], lv.prototype, "ellipsoid", void 0), Gh([Jh()], lv.prototype, "ellipsoidOffset", void 0), Gh([Xh()], lv.prototype, "checkCollisions", void 0), Gh([Xh()], lv.prototype, "applyGravity", void 0), cc("BABYLON.FreeCamera", lv), Nd.prototype.createDynamicTexture = function(e, t, i, s) {
		const n = new Pm(this, 4);
		return n.baseWidth = e, n.baseHeight = t, i && (e = this.needPOTTextures ? md(e, this._caps.maxTextureSize) : e, t = this.needPOTTextures ? md(t, this._caps.maxTextureSize) : t), n.width = e, n.height = t, n.isReady = !1, n.generateMipMaps = i, n.samplingMode = s, this.updateTextureSamplingMode(s, n), this._internalTexturesCache.push(n), n
	}, Nd.prototype.updateDynamicTexture = function(e, t, i, s = !1, n, a = !1, r = !1) {
		if (!e) return;
		const o = this._gl,
			l = o.TEXTURE_2D,
			h = this._bindTextureDirectly(l, e, !0, a);
		this._unpackFlipY(void 0 === i ? e.invertY : i), s && o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
		const c = this._getWebGLTextureType(e.type),
			u = this._getInternalFormat(n || e.format),
			m = this._getRGBABufferInternalSizedFormat(e.type, u);
		o.texImage2D(l, 0, m, u, c, t), e.generateMipMaps && o.generateMipmap(l), h || this._bindTextureDirectly(l, null), s && o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), n && (e.format = n), e._dynamicTextureSource = t, e._premulAlpha = s, e.invertY = i || !1, e.isReady = !0
	};
	var hv = class e extends Np {
		constructor(e, t, i = null, s = !1, n = 3, a = 5, r) {
			super(null, i, !s, r, n, void 0, void 0, void 0, void 0, a), this.name = e, this.wrapU = Np.CLAMP_ADDRESSMODE, this.wrapV = Np.CLAMP_ADDRESSMODE, this._generateMipMaps = s;
			const o = this._getEngine();
			if (!o) return;
			t.getContext ? (this._canvas = t, this._ownCanvas = !1, this._texture = o.createDynamicTexture(t.width, t.height, s, n)) : (this._canvas = o.createCanvas(1, 1), this._ownCanvas = !0, t.width || 0 === t.width ? this._texture = o.createDynamicTexture(t.width, t.height, s, n) : this._texture = o.createDynamicTexture(t, t, s, n));
			const l = this.getSize();
			this._canvas.width !== l.width && (this._canvas.width = l.width), this._canvas.height !== l.height && (this._canvas.height = l.height), this._context = this._canvas.getContext("2d")
		}
		scale(e) {
			const t = this.getSize();
			t.width *= e, t.height *= e, this._recreate(t)
		}
		dispose() {
			super.dispose(), this._ownCanvas && this._canvas?.remove?.(), this._canvas = null, this._context = null
		}
		_recreate(e) {
			this._canvas.width = e.width, this._canvas.height = e.height, this.releaseInternalTexture(), this._texture = this._getEngine().createDynamicTexture(e.width, e.height, this._generateMipMaps, this.samplingMode)
		}
		scaleTo(e, t) {
			const i = this.getSize();
			i.width = e, i.height = t, this._recreate(i)
		}
		static _IsCanvasElement(e) {
			return void 0 !== e.toDataURL
		}
		get canRescale() {
			return !0
		}
		getContext() {
			return this._context
		}
		clear(e) {
			const t = this.getSize();
			e && (this._context.fillStyle = e), this._context.clearRect(0, 0, t.width, t.height)
		}
		serialize() {
			const t = this.getScene();
			t && !t.isReady() && Qc.Warn("The scene must be ready before serializing the dynamic texture");
			const i = super.serialize();
			return e._IsCanvasElement(this._canvas) && (i.base64String = this._canvas.toDataURL()), i.invertY = this._invertY, i.samplingMode = this.samplingMode, i
		}
		update(e, t = !1, i = !1) {
			this._getEngine().updateDynamicTexture(this._texture, this._canvas, void 0 === e || e, t, this._format || void 0, void 0, i)
		}
		drawText(e, t, i, s, n, a, r, o = !0) {
			const l = this.getSize();
			if (a && (this._context.fillStyle = a, this._context.fillRect(0, 0, l.width, l.height)), this._context.font = s, null == t) {
				const i = this._context.measureText(e);
				t = (l.width - i.width) / 2
			}
			if (null == i) {
				const e = parseInt(s.replace(/\D/g, ""));
				i = l.height / 2 + e / 3.65
			}
			this._context.fillStyle = n || "", this._context.fillText(e, t, i), o && this.update(r)
		}
		getClassName() {
			return "DynamicTexture"
		}
		_rebuild() {
			this.update()
		}
		clone() {
			const t = this.getScene();
			if (!t) return this;
			const i = this.getSize(),
				s = new e(this.name, i, t, this._generateMipMaps);
			return s.hasAlpha = this.hasAlpha, s.level = this.level, s.wrapU = this.wrapU, s.wrapV = this.wrapV, s
		}
	};
	Dm.prototype._partialLoadFile = function(e, t, i, s, n = null) {
		this._loadFile(e, (e => {
			i[t] = e, i._internalCount++, 6 === i._internalCount && s(i)
		}), void 0, void 0, !0, ((e, t) => {
			n && e && n(e.status + " " + e.statusText, t)
		}))
	}, Dm.prototype._cascadeLoadFiles = function(e, t, i, s = null) {
		const n = [];
		n._internalCount = 0;
		for (let e = 0; e < 6; e++) this._partialLoadFile(i[e], e, n, t, s)
	}, Dm.prototype._cascadeLoadImgs = function(e, t, i, s, n = null, a) {
		const r = [];
		r._internalCount = 0;
		for (let o = 0; o < 6; o++) this._partialLoadImg(s[o], o, r, e, t, i, n, a)
	}, Dm.prototype._partialLoadImg = function(e, t, i, s, n, a, r = null, o) {
		const l = rd();
		Um(e, (e => {
			i[t] = e, i._internalCount++, s && s.removePendingData(l), 6 === i._internalCount && a && a(n, i)
		}), ((e, t) => {
			s && s.removePendingData(l), r && r(e, t)
		}), s ? s.offlineProvider : null, o), s && s.addPendingData(l)
	}, Dm.prototype.createCubeTextureBase = function(e, t, i, s, n = null, a = null, r, o = null, l = !1, h = 0, c = 0, u = null, m = null, d = null, f = !1, p = null) {
		const _ = u || new Pm(this, 7);
		_.isCube = !0, _.url = e, _.generateMipMaps = !s, _._lodGenerationScale = h, _._lodGenerationOffset = c, _._useSRGBBuffer = !!f && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!s), _ !== u && (_.label = e.substring(0, 60)), this._doNotHandleContextLost || (_._extension = o, _._files = i, _._buffer = p);
		const g = e;
		this._transformTextureUrl && !u && (e = this._transformTextureUrl(e));
		const v = e.split("?")[0],
			y = v.lastIndexOf("."),
			S = o || (y > -1 ? v.substring(y).toLowerCase() : "");
		let E = null;
		for (const e of Dm._TextureLoaders)
			if (e.canLoad(S)) {
				E = e;
				break
			} const A = (u, v) => {
			e === g ? a && u && a(u.status + " " + u.statusText, v) : (Qc.Warn(`Failed to load ${e}, falling back to the ${g}`), this.createCubeTextureBase(g, t, i, !!s, n, a, r, o, l, h, c, _, m, d, f, p))
		};
		if (E) {
			const s = e => {
				m && m(_, e), E.loadCubeData(e, _, l, n, a)
			};
			p ? s(p) : i && 6 === i.length ? E.supportCascades ? this._cascadeLoadFiles(t, (e => s(e.map((e => new Uint8Array(e))))), i, a) : a ? a("Textures type does not support cascades.") : Qc.Warn("Texture loader does not support cascades.") : this._loadFile(e, (e => s(new Uint8Array(e))), void 0, void 0, !0, A)
		} else {
			if (!i || 0 === i.length) throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");
			this._cascadeLoadImgs(t, _, ((e, t) => {
				d && d(e, t)
			}), i, a)
		}
		return this._internalTexturesCache.push(_), _
	}, Nd.prototype._createDepthStencilCubeTexture = function(e, t) {
		const i = new Pm(this, 12);
		if (i.isCube = !0, 1 === this.webGLVersion) return Qc.Error("Depth cube texture is not supported by WebGL 1."), i;
		const s = {
				bilinearFiltering: !1,
				comparisonFunction: 0,
				generateStencil: !1,
				...t
			},
			n = this._gl;
		this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, i, !0), this._setupDepthStencilTexture(i, e, s.generateStencil, s.bilinearFiltering, s.comparisonFunction);
		for (let t = 0; t < 6; t++) s.generateStencil ? n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, n.DEPTH24_STENCIL8, e, e, 0, n.DEPTH_STENCIL, n.UNSIGNED_INT_24_8, null) : n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, n.DEPTH_COMPONENT24, e, e, 0, n.DEPTH_COMPONENT, n.UNSIGNED_INT, null);
		return this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, null), this._internalTexturesCache.push(i), i
	}, Nd.prototype._setCubeMapTextureParams = function(e, t, i) {
		const s = this._gl;
		s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, t ? s.LINEAR_MIPMAP_LINEAR : s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), e.samplingMode = t ? 3 : 2, t && this.getCaps().textureMaxLevel && void 0 !== i && i > 0 && (s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAX_LEVEL, i), e._maxLodLevel = i), this._bindTextureDirectly(s.TEXTURE_CUBE_MAP, null)
	}, Nd.prototype.createCubeTexture = function(e, t, i, s, n = null, a = null, r, o = null, l = !1, h = 0, c = 0, u = null, m, d = !1, f = null) {
		const p = this._gl;
		return this.createCubeTextureBase(e, t, i, !!s, n, a, r, o, l, h, c, u, (e => this._bindTextureDirectly(p.TEXTURE_CUBE_MAP, e, !0)), ((e, t) => {
			const i = this.needPOTTextures ? md(t[0].width, this._caps.maxCubemapTextureSize) : t[0].width,
				a = i,
				o = [p.TEXTURE_CUBE_MAP_POSITIVE_X, p.TEXTURE_CUBE_MAP_POSITIVE_Y, p.TEXTURE_CUBE_MAP_POSITIVE_Z, p.TEXTURE_CUBE_MAP_NEGATIVE_X, p.TEXTURE_CUBE_MAP_NEGATIVE_Y, p.TEXTURE_CUBE_MAP_NEGATIVE_Z];
			this._bindTextureDirectly(p.TEXTURE_CUBE_MAP, e, !0), this._unpackFlipY(!1);
			const l = r ? this._getInternalFormat(r, e._useSRGBBuffer) : e._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : p.RGBA;
			let h = r ? this._getInternalFormat(r) : p.RGBA;
			e._useSRGBBuffer && 1 === this.webGLVersion && (h = l);
			for (let e = 0; e < o.length; e++)
				if (t[e].width !== i || t[e].height !== a) {
					if (this._prepareWorkingCanvas(), !this._workingCanvas || !this._workingContext) return void Qc.Warn("Cannot create canvas to resize texture.");
					this._workingCanvas.width = i, this._workingCanvas.height = a, this._workingContext.drawImage(t[e], 0, 0, t[e].width, t[e].height, 0, 0, i, a), p.texImage2D(o[e], 0, l, h, p.UNSIGNED_BYTE, this._workingCanvas)
				} else p.texImage2D(o[e], 0, l, h, p.UNSIGNED_BYTE, t[e]);
			s || p.generateMipmap(p.TEXTURE_CUBE_MAP), this._setCubeMapTextureParams(e, !s), e.width = i, e.height = a, e.isReady = !0, r && (e.format = r), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear(), n && n()
		}), !!d, f)
	}, Nd.prototype.generateMipMapsForCubemap = function(e, t = !0) {
		if (e.generateMipMaps) {
			const i = this._gl;
			this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, e, !0), i.generateMipmap(i.TEXTURE_CUBE_MAP), t && this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null)
		}
	};
	var cv = [Math.sqrt(1 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(3 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(15 / (4 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(5 / (16 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(15 / (16 * Math.PI))],
		uv = [() => 1, e => e.y, e => e.z, e => e.x, e => e.x * e.y, e => e.y * e.z, e => 3 * e.z * e.z - 1, e => e.x * e.z, e => e.x * e.x - e.y * e.y],
		mv = (e, t) => cv[e] * uv[e](t),
		dv = [Math.PI, 2 * Math.PI / 3, 2 * Math.PI / 3, 2 * Math.PI / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4],
		fv = class e {
			updateFromArray(e) {
				return Lc.FromArrayToRef(e[0], 0, this.l00), Lc.FromArrayToRef(e[1], 0, this.l1_1), Lc.FromArrayToRef(e[2], 0, this.l10), Lc.FromArrayToRef(e[3], 0, this.l11), Lc.FromArrayToRef(e[4], 0, this.l2_2), Lc.FromArrayToRef(e[5], 0, this.l2_1), Lc.FromArrayToRef(e[6], 0, this.l20), Lc.FromArrayToRef(e[7], 0, this.l21), Lc.FromArrayToRef(e[8], 0, this.l22), this
			}
			updateFromFloatsArray(e) {
				return Lc.FromFloatsToRef(e[0], e[1], e[2], this.l00), Lc.FromFloatsToRef(e[3], e[4], e[5], this.l1_1), Lc.FromFloatsToRef(e[6], e[7], e[8], this.l10), Lc.FromFloatsToRef(e[9], e[10], e[11], this.l11), Lc.FromFloatsToRef(e[12], e[13], e[14], this.l2_2), Lc.FromFloatsToRef(e[15], e[16], e[17], this.l2_1), Lc.FromFloatsToRef(e[18], e[19], e[20], this.l20), Lc.FromFloatsToRef(e[21], e[22], e[23], this.l21), Lc.FromFloatsToRef(e[24], e[25], e[26], this.l22), this
			}
			static FromPolynomial(t) {
				const i = new e;
				return i.l00 = t.xx.scale(.376127).add(t.yy.scale(.376127)).add(t.zz.scale(.376126)), i.l1_1 = t.y.scale(.977204), i.l10 = t.z.scale(.977204), i.l11 = t.x.scale(.977204), i.l2_2 = t.xy.scale(1.16538), i.l2_1 = t.yz.scale(1.16538), i.l20 = t.zz.scale(1.34567).subtract(t.xx.scale(.672834)).subtract(t.yy.scale(.672834)), i.l21 = t.zx.scale(1.16538), i.l22 = t.xx.scale(1.16538).subtract(t.yy.scale(1.16538)), i.l1_1.scaleInPlace(-1), i.l11.scaleInPlace(-1), i.l2_1.scaleInPlace(-1), i.l21.scaleInPlace(-1), i.scaleInPlace(Math.PI), i
			}
			convertIrradianceToLambertianRadiance() {
				this.scaleInPlace(1 / Math.PI)
			}
			scaleInPlace(e) {
				this.l00.scaleInPlace(e), this.l1_1.scaleInPlace(e), this.l10.scaleInPlace(e), this.l11.scaleInPlace(e), this.l2_2.scaleInPlace(e), this.l2_1.scaleInPlace(e), this.l20.scaleInPlace(e), this.l21.scaleInPlace(e), this.l22.scaleInPlace(e)
			}
			static FromArray(t) {
				return (new e).updateFromArray(t)
			}
			convertIncidentRadianceToIrradiance() {
				this.l00.scaleInPlace(dv[0]), this.l1_1.scaleInPlace(dv[1]), this.l10.scaleInPlace(dv[2]), this.l11.scaleInPlace(dv[3]), this.l2_2.scaleInPlace(dv[4]), this.l2_1.scaleInPlace(dv[5]), this.l20.scaleInPlace(dv[6]), this.l21.scaleInPlace(dv[7]), this.l22.scaleInPlace(dv[8])
			}
			preScaleForRendering() {
				this.preScaled = !0, this.l00.scaleInPlace(cv[0]), this.l1_1.scaleInPlace(cv[1]), this.l10.scaleInPlace(cv[2]), this.l11.scaleInPlace(cv[3]), this.l2_2.scaleInPlace(cv[4]), this.l2_1.scaleInPlace(cv[5]), this.l20.scaleInPlace(cv[6]), this.l21.scaleInPlace(cv[7]), this.l22.scaleInPlace(cv[8])
			}
			addLight(e, t, i) {
				Vc.Vector3[0].set(t.r, t.g, t.b);
				const s = Vc.Vector3[0],
					n = Vc.Vector3[1];
				s.scaleToRef(i, n), n.scaleToRef(mv(0, e), Vc.Vector3[2]), this.l00.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(1, e), Vc.Vector3[2]), this.l1_1.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(2, e), Vc.Vector3[2]), this.l10.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(3, e), Vc.Vector3[2]), this.l11.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(4, e), Vc.Vector3[2]), this.l2_2.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(5, e), Vc.Vector3[2]), this.l2_1.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(6, e), Vc.Vector3[2]), this.l20.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(7, e), Vc.Vector3[2]), this.l21.addInPlace(Vc.Vector3[2]), n.scaleToRef(mv(8, e), Vc.Vector3[2]), this.l22.addInPlace(Vc.Vector3[2])
			}
			constructor() {
				this.preScaled = !1, this.l00 = Lc.Zero(), this.l1_1 = Lc.Zero(), this.l10 = Lc.Zero(), this.l11 = Lc.Zero(), this.l2_2 = Lc.Zero(), this.l2_1 = Lc.Zero(), this.l20 = Lc.Zero(), this.l21 = Lc.Zero(), this.l22 = Lc.Zero()
			}
		},
		pv = class e {
			static FromArray(t) {
				const i = new e;
				return Lc.FromArrayToRef(t[0], 0, i.x), Lc.FromArrayToRef(t[1], 0, i.y), Lc.FromArrayToRef(t[2], 0, i.z), Lc.FromArrayToRef(t[3], 0, i.xx), Lc.FromArrayToRef(t[4], 0, i.yy), Lc.FromArrayToRef(t[5], 0, i.zz), Lc.FromArrayToRef(t[6], 0, i.yz), Lc.FromArrayToRef(t[7], 0, i.zx), Lc.FromArrayToRef(t[8], 0, i.xy), i
			}
			addAmbient(e) {
				Vc.Vector3[0].copyFromFloats(e.r, e.g, e.b);
				const t = Vc.Vector3[0];
				this.xx.addInPlace(t), this.yy.addInPlace(t), this.zz.addInPlace(t)
			}
			scaleInPlace(e) {
				this.x.scaleInPlace(e), this.y.scaleInPlace(e), this.z.scaleInPlace(e), this.xx.scaleInPlace(e), this.yy.scaleInPlace(e), this.zz.scaleInPlace(e), this.yz.scaleInPlace(e), this.zx.scaleInPlace(e), this.xy.scaleInPlace(e)
			}
			constructor() {
				this.x = Lc.Zero(), this.y = Lc.Zero(), this.z = Lc.Zero(), this.xx = Lc.Zero(), this.yy = Lc.Zero(), this.zz = Lc.Zero(), this.xy = Lc.Zero(), this.yz = Lc.Zero(), this.zx = Lc.Zero()
			}
			static FromHarmonics(t) {
				return (new e).updateFromHarmonics(t)
			}
			updateFromHarmonics(e) {
				return this._harmonics = e, this.x.copyFrom(e.l11), this.x.scaleInPlace(1.02333).scaleInPlace(-1), this.y.copyFrom(e.l1_1), this.y.scaleInPlace(1.02333).scaleInPlace(-1), this.z.copyFrom(e.l10), this.z.scaleInPlace(1.02333), this.xx.copyFrom(e.l00), Vc.Vector3[0].copyFrom(e.l20).scaleInPlace(.247708), Vc.Vector3[1].copyFrom(e.l22).scaleInPlace(.429043), this.xx.scaleInPlace(.886277).subtractInPlace(Vc.Vector3[0]).addInPlace(Vc.Vector3[1]), this.yy.copyFrom(e.l00), this.yy.scaleInPlace(.886277).subtractInPlace(Vc.Vector3[0]).subtractInPlace(Vc.Vector3[1]), this.zz.copyFrom(e.l00), Vc.Vector3[0].copyFrom(e.l20).scaleInPlace(.495417), this.zz.scaleInPlace(.886277).addInPlace(Vc.Vector3[0]), this.yz.copyFrom(e.l2_1), this.yz.scaleInPlace(.858086).scaleInPlace(-1), this.zx.copyFrom(e.l21), this.zx.scaleInPlace(.858086).scaleInPlace(-1), this.xy.copyFrom(e.l2_2), this.xy.scaleInPlace(.858086), this.scaleInPlace(1 / Math.PI), this
			}
			get preScaledHarmonics() {
				return this._harmonics || (this._harmonics = fv.FromPolynomial(this)), this._harmonics.preScaled || this._harmonics.preScaleForRendering(), this._harmonics
			}
		},
		_v = class {
			constructor(e, t, i, s) {
				this.name = e, this.worldAxisForNormal = t, this.worldAxisForFileX = i, this.worldAxisForFileY = s
			}
		},
		gv = class {
			static ConvertCubeMapToSphericalPolynomial(e) {
				const t = new fv;
				let i = 0;
				const s = 2 / e.size,
					n = s,
					a = .5 * s,
					r = a - 1;
				for (let o = 0; o < 6; o++) {
					const l = this._FileFaces[o],
						h = e[l.name];
					let c = r;
					const u = 5 === e.format ? 4 : 3;
					for (let o = 0; o < e.size; o++) {
						let m = r;
						for (let n = 0; n < e.size; n++) {
							const r = l.worldAxisForFileX.scale(m).add(l.worldAxisForFileY.scale(c)).add(l.worldAxisForNormal);
							r.normalize();
							const d = this._AreaElement(m - a, c - a) - this._AreaElement(m - a, c + a) - this._AreaElement(m + a, c - a) + this._AreaElement(m + a, c + a);
							let f = h[o * e.size * u + n * u + 0],
								p = h[o * e.size * u + n * u + 1],
								_ = h[o * e.size * u + n * u + 2];
							isNaN(f) && (f = 0), isNaN(p) && (p = 0), isNaN(_) && (_ = 0), 0 === e.type && (f /= 255, p /= 255, _ /= 255), e.gammaSpace && (f = Math.pow(Ac.Clamp(f), dc), p = Math.pow(Ac.Clamp(p), dc), _ = Math.pow(Ac.Clamp(_), dc));
							const g = this.MAX_HDRI_VALUE;
							if (this.PRESERVE_CLAMPED_COLORS) {
								const e = Math.max(f, p, _);
								if (e > g) {
									const t = g / e;
									f *= t, p *= t, _ *= t
								}
							} else f = Ac.Clamp(f, 0, g), p = Ac.Clamp(p, 0, g), _ = Ac.Clamp(_, 0, g);
							const v = new Tc(f, p, _);
							t.addLight(r, v, d), i += d, m += s
						}
						c += n
					}
				}
				const o = 6 * (4 * Math.PI) / 6 / i;
				return t.scaleInPlace(o), t.convertIncidentRadianceToIrradiance(), t.convertIrradianceToLambertianRadiance(), pv.FromHarmonics(t)
			}
			static _AreaElement(e, t) {
				return Math.atan2(e * t, Math.sqrt(e * e + t * t + 1))
			}
			static ConvertCubeMapTextureToSphericalPolynomial(e) {
				if (!e.isCube) return null;
				e.getScene()?.getEngine().flushFramebuffer();
				const t = e.getSize().width,
					i = e.readPixels(0, void 0, void 0, !1),
					s = e.readPixels(1, void 0, void 0, !1);
				let n, a;
				e.isRenderTarget ? (n = e.readPixels(3, void 0, void 0, !1), a = e.readPixels(2, void 0, void 0, !1)) : (n = e.readPixels(2, void 0, void 0, !1), a = e.readPixels(3, void 0, void 0, !1));
				const r = e.readPixels(4, void 0, void 0, !1),
					o = e.readPixels(5, void 0, void 0, !1),
					l = e.gammaSpace;
				let h = 0;
				return 1 != e.textureType && 2 != e.textureType || (h = 1), new Promise((e => {
					Promise.all([s, i, n, a, r, o]).then((([i, s, n, a, r, o]) => {
						const c = {
							size: t,
							right: s,
							left: i,
							up: n,
							down: a,
							front: r,
							back: o,
							format: 5,
							type: h,
							gammaSpace: l
						};
						e(this.ConvertCubeMapToSphericalPolynomial(c))
					}))
				}))
			}
		};
	gv._FileFaces = [new _v("right", new Lc(1, 0, 0), new Lc(0, 0, -1), new Lc(0, -1, 0)), new _v("left", new Lc(-1, 0, 0), new Lc(0, 0, 1), new Lc(0, -1, 0)), new _v("up", new Lc(0, 1, 0), new Lc(1, 0, 0), new Lc(0, 0, 1)), new _v("down", new Lc(0, -1, 0), new Lc(1, 0, 0), new Lc(0, 0, -1)), new _v("front", new Lc(0, 0, 1), new Lc(1, 0, 0), new Lc(0, -1, 0)), new _v("back", new Lc(0, 0, -1), new Lc(-1, 0, 0), new Lc(0, -1, 0))], gv.MAX_HDRI_VALUE = 4096, gv.PRESERVE_CLAMPED_COLORS = !1;
	var vv = class e extends Bp {
		getClassName() {
			return "PassPostProcess"
		}
		async _initShaderSourceAsync(e) {
			e ? (this._webGPUReady = !0, await Promise.all([Promise.resolve().then((() => (rn(), tn)))])) : await Promise.all([Promise.resolve().then((() => (x(), S)))]), await super._initShaderSourceAsync(e)
		}
		static _Parse(t, i, s, n) {
			return Xc.Parse((() => new e(t.name, t.options, i, t.renderTargetSamplingMode, t._engine, t.reusable)), t, s, n)
		}
		constructor(e, t, i = null, s, n, a, r = 0, o = !1) {
			super(e, "pass", null, null, t, i, s, n, a, void 0, r, void 0, null, o)
		}
	};
	cc("BABYLON.PassPostProcess", vv), Dm._RescalePostProcessFactory = e => new vv("rescale", 1, null, 2, e, !1, 0), h();
	e.ShadersStore.lodPixelShader = "#extension GL_EXT_shader_texture_lod : enable\nprecision highp float;const float GammaEncodePowerApprox=1.0/2.2;varying vec2 vUV;uniform sampler2D textureSampler;uniform float lod;uniform vec2 texSize;uniform bool gamma;void main(void)\n{gl_FragColor=textureLod(textureSampler,vUV,lod);if (!gamma) {gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(GammaEncodePowerApprox));}}\n", h();
	var yv, Sv;

	function Ev(e) {
		yv || (yv = new Float32Array(1), Sv = new Int32Array(yv.buffer)), yv[0] = e;
		const t = Sv[0];
		let i = t >> 16 & 32768,
			s = t >> 12 & 2047;
		const n = t >> 23 & 255;
		return n < 103 ? i : n > 142 ? (i |= 31744, i |= (255 == n ? 0 : 1) && 8388607 & t, i) : n < 113 ? (s |= 2048, i |= (s >> 114 - n) + (s >> 113 - n & 1), i) : (i |= n - 112 << 10 | s >> 1, i += 1 & s, i)
	}

	function Av(e) {
		const t = (32768 & e) >> 15,
			i = (31744 & e) >> 10,
			s = 1023 & e;
		return 0 === i ? (t ? -1 : 1) * Math.pow(2, -14) * (s / Math.pow(2, 10)) : 31 == i ? s ? NaN : 1 / 0 * (t ? -1 : 1) : (t ? -1 : 1) * Math.pow(2, i - 15) * (1 + s / Math.pow(2, 10))
	}
	e.ShadersStore.lodCubePixelShader = "precision highp float;const float GammaEncodePowerApprox=1.0/2.2;varying vec2 vUV;uniform samplerCube textureSampler;uniform float lod;uniform bool gamma;void main(void)\n{vec2 uv=vUV*2.0-1.0;\n#ifdef POSITIVEX\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x),lod);\n#endif\n#ifdef NEGATIVEX\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x),lod);\n#endif\n#ifdef POSITIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x),lod);\n#endif\n#ifdef NEGATIVEY\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x),lod);\n#endif\n#ifdef POSITIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001),lod);\n#endif\n#ifdef NEGATIVEZ\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001),lod);\n#endif\nif (!gamma) {gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(GammaEncodePowerApprox));}}\n";
	var bv = 131072,
		xv = 131072;

	function Mv(e) {
		return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24)
	}
	var Cv = Mv("DXT1"),
		Tv = Mv("DXT3"),
		wv = Mv("DXT5"),
		Rv = Mv("DX10"),
		Nv = class e {
			static UploadDDSLevels(t, i, s, n, a, r, o = -1, l, h = !0) {
				let c = null;
				n.sphericalPolynomial && (c = []);
				const u = !!t.getCaps().s3tc;
				i.generateMipMaps = a;
				const m = new Int32Array(s.buffer, s.byteOffset, 31);
				let d, f, p, _, g, v, y, S = 0,
					E = 0,
					A = 1;
				if (542327876 !== m[0]) return void Qc.Error("Invalid magic number in DDS header");
				if (!n.isFourCC && !n.isRGB && !n.isLuminance) return void Qc.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
				if (n.isCompressed && !u) return void Qc.Error("Compressed textures are not supported on this platform.");
				let b = m[22];
				_ = m[1] + 4;
				let x = !1;
				if (n.isFourCC) switch (d = m[21], d) {
					case Cv:
						A = 8, E = 33777;
						break;
					case Tv:
						A = 16, E = 33778;
						break;
					case wv:
						A = 16, E = 33779;
						break;
					case 113:
						x = !0, b = 64;
						break;
					case 116:
						x = !0, b = 128;
						break;
					case Rv: {
						_ += 20;
						let e = !1;
						switch (n.dxgiFormat) {
							case 10:
								x = !0, b = 64, e = !0;
								break;
							case 2:
								x = !0, b = 128, e = !0;
								break;
							case 88:
								n.isRGB = !0, n.isFourCC = !1, b = 32, e = !0
						}
						if (e) break
					}
					default:
						return void Qc.Error(["Unsupported FourCC code:", (M = d, String.fromCharCode(255 & M, M >> 8 & 255, M >> 16 & 255, M >> 24 & 255))])
				}
				var M;
				const C = e._ExtractLongWordOrder(m[23]),
					T = e._ExtractLongWordOrder(m[24]),
					w = e._ExtractLongWordOrder(m[25]),
					R = e._ExtractLongWordOrder(m[26]);
				x && (E = t._getRGBABufferInternalSizedFormat(n.textureType)), v = 1, m[2] & bv && !1 !== a && (v = Math.max(1, m[7]));
				const N = l || 0,
					I = t.getCaps();
				for (let a = N; a < r; a++) {
					for (f = m[4], p = m[3], y = 0; y < v; ++y) {
						if (-1 === o || o === y) {
							const r = -1 === o ? y : 0;
							if (!n.isCompressed && n.isFourCC) {
								i.format = 5, S = f * p * 4;
								let n = null;
								if (t._badOS || t._badDesktopOS || !I.textureHalfFloat && !I.textureFloat) 128 === b ? (n = e._GetFloatAsUIntRGBAArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, r), c && 0 == r && c.push(e._GetFloatRGBAArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, r))) : 64 === b && (n = e._GetHalfFloatAsUIntRGBAArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, r), c && 0 == r && c.push(e._GetHalfFloatAsFloatRGBAArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, r))), i.type = 0;
								else {
									const t = I.textureFloat && (h && I.textureFloatLinearFiltering || !h),
										a = I.textureHalfFloat && (h && I.textureHalfFloatLinearFiltering || !h),
										o = (128 === b || 64 === b && !a) && t ? 1 : (64 === b || 128 === b && !t) && a ? 2 : 0;
									let l, u = null;
									if (128 === b) switch (o) {
										case 1:
											l = e._GetFloatRGBAArrayBuffer, u = null;
											break;
										case 2:
											l = e._GetFloatAsHalfFloatRGBAArrayBuffer, u = e._GetFloatRGBAArrayBuffer;
											break;
										case 0:
											l = e._GetFloatAsUIntRGBAArrayBuffer, u = e._GetFloatRGBAArrayBuffer
									} else switch (o) {
										case 1:
											l = e._GetHalfFloatAsFloatRGBAArrayBuffer, u = null;
											break;
										case 2:
											l = e._GetHalfFloatRGBAArrayBuffer, u = e._GetHalfFloatAsFloatRGBAArrayBuffer;
											break;
										case 0:
											l = e._GetHalfFloatAsUIntRGBAArrayBuffer, u = e._GetHalfFloatAsFloatRGBAArrayBuffer
									}
									i.type = o, n = l(f, p, s.byteOffset + _, S, s.buffer, r), c && 0 == r && c.push(u ? u(f, p, s.byteOffset + _, S, s.buffer, r) : n)
								}
								n && t._uploadDataToTextureDirectly(i, n, a, r)
							} else if (n.isRGB) i.type = 0, 24 === b ? (i.format = 4, S = f * p * 3, g = e._GetRGBArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, C, T, w), t._uploadDataToTextureDirectly(i, g, a, r)) : (i.format = 5, S = f * p * 4, g = e._GetRGBAArrayBuffer(f, p, s.byteOffset + _, S, s.buffer, C, T, w, R), t._uploadDataToTextureDirectly(i, g, a, r));
							else if (n.isLuminance) {
								const n = t._getUnpackAlignement(),
									o = f;
								S = Math.floor((f + n - 1) / n) * n * (p - 1) + o, g = e._GetLuminanceArrayBuffer(f, p, s.byteOffset + _, S, s.buffer), i.format = 1, i.type = 0, t._uploadDataToTextureDirectly(i, g, a, r)
							} else S = Math.max(4, f) / 4 * Math.max(4, p) / 4 * A, g = new Uint8Array(s.buffer, s.byteOffset + _, S), i.type = 0, t._uploadCompressedDataToTextureDirectly(i, E, f, p, g, a, r)
						}
						_ += b ? f * p * (b / 8) : S, f *= .5, p *= .5, f = Math.max(1, f), p = Math.max(1, p)
					}
					if (void 0 !== l) break
				}
				c && c.length > 0 ? n.sphericalPolynomial = gv.ConvertCubeMapToSphericalPolynomial({
					size: m[4],
					right: c[0],
					left: c[1],
					up: c[2],
					down: c[3],
					front: c[4],
					back: c[5],
					format: 5,
					type: 1,
					gammaSpace: !1
				}) : n.sphericalPolynomial = void 0
			}
			static _GetFloatAsUIntRGBAArrayBuffer(t, i, s, n, a, r) {
				const o = new Uint8Array(n),
					l = new Float32Array(a, s);
				let h = 0;
				for (let s = 0; s < i; s++)
					for (let i = 0; i < t; i++) {
						const n = 4 * (i + s * t);
						o[h] = 255 * Ac.Clamp(l[n]), o[h + 1] = 255 * Ac.Clamp(l[n + 1]), o[h + 2] = 255 * Ac.Clamp(l[n + 2]), e.StoreLODInAlphaChannel ? o[h + 3] = r : o[h + 3] = 255 * Ac.Clamp(l[n + 3]), h += 4
					}
				return o
			}
			static _GetFloatRGBAArrayBuffer(t, i, s, n, a, r) {
				if (e.StoreLODInAlphaChannel) {
					const e = new Float32Array(n),
						o = new Float32Array(a, s);
					let l = 0;
					for (let s = 0; s < i; s++)
						for (let i = 0; i < t; i++) {
							const n = 4 * (i + s * t);
							e[l] = o[n], e[l + 1] = o[n + 1], e[l + 2] = o[n + 2], e[l + 3] = r, l += 4
						}
					return e
				}
				return new Float32Array(a, s, n)
			}
			static _GetRGBArrayBuffer(e, t, i, s, n, a, r, o) {
				const l = new Uint8Array(s),
					h = new Uint8Array(n, i);
				let c = 0;
				for (let i = 0; i < t; i++)
					for (let t = 0; t < e; t++) {
						const s = 3 * (t + i * e);
						l[c] = h[s + a], l[c + 1] = h[s + r], l[c + 2] = h[s + o], c += 3
					}
				return l
			}
			static _GetFloatAsHalfFloatRGBAArrayBuffer(t, i, s, n, a, r) {
				const o = new Uint16Array(n),
					l = new Float32Array(a, s);
				let h = 0;
				for (let s = 0; s < i; s++)
					for (let i = 0; i < t; i++) o[h] = Ev(l[h]), o[h + 1] = Ev(l[h + 1]), o[h + 2] = Ev(l[h + 2]), e.StoreLODInAlphaChannel ? o[h + 3] = Ev(r) : o[h + 3] = Ev(l[h + 3]), h += 4;
				return o
			}
			static _GetLuminanceArrayBuffer(e, t, i, s, n) {
				const a = new Uint8Array(s),
					r = new Uint8Array(n, i);
				let o = 0;
				for (let i = 0; i < t; i++)
					for (let t = 0; t < e; t++) {
						const s = t + i * e;
						a[o] = r[s], o++
					}
				return a
			}
			static _GetHalfFloatRGBAArrayBuffer(t, i, s, n, a, r) {
				if (e.StoreLODInAlphaChannel) {
					const e = new Uint16Array(n),
						o = new Uint16Array(a, s);
					let l = 0;
					for (let s = 0; s < i; s++)
						for (let i = 0; i < t; i++) {
							const n = 4 * (i + s * t);
							e[l] = o[n], e[l + 1] = o[n + 1], e[l + 2] = o[n + 2], e[l + 3] = Ev(r), l += 4
						}
					return e
				}
				return new Uint16Array(a, s, n)
			}
			static _GetHalfFloatAsUIntRGBAArrayBuffer(t, i, s, n, a, r) {
				const o = new Uint8Array(n),
					l = new Uint16Array(a, s);
				let h = 0;
				for (let s = 0; s < i; s++)
					for (let i = 0; i < t; i++) {
						const n = 4 * (i + s * t);
						o[h] = 255 * Ac.Clamp(Av(l[n])), o[h + 1] = 255 * Ac.Clamp(Av(l[n + 1])), o[h + 2] = 255 * Ac.Clamp(Av(l[n + 2])), e.StoreLODInAlphaChannel ? o[h + 3] = r : o[h + 3] = 255 * Ac.Clamp(Av(l[n + 3])), h += 4
					}
				return o
			}
			static _GetHalfFloatAsFloatRGBAArrayBuffer(t, i, s, n, a, r) {
				const o = new Float32Array(n),
					l = new Uint16Array(a, s);
				let h = 0;
				for (let s = 0; s < i; s++)
					for (let i = 0; i < t; i++) {
						const n = 4 * (i + s * t);
						o[h] = Av(l[n]), o[h + 1] = Av(l[n + 1]), o[h + 2] = Av(l[n + 2]), e.StoreLODInAlphaChannel ? o[h + 3] = r : o[h + 3] = Av(l[n + 3]), h += 4
					}
				return o
			}
			static _GetRGBAArrayBuffer(e, t, i, s, n, a, r, o, l) {
				const h = new Uint8Array(s),
					c = new Uint8Array(n, i);
				let u = 0;
				for (let i = 0; i < t; i++)
					for (let t = 0; t < e; t++) {
						const s = 4 * (t + i * e);
						h[u] = c[s + a], h[u + 1] = c[s + r], h[u + 2] = c[s + o], h[u + 3] = c[s + l], u += 4
					}
				return h
			}
			static _ExtractLongWordOrder(t) {
				return 0 === t || 255 === t || -16777216 === t ? 0 : 1 + e._ExtractLongWordOrder(t >> 8)
			}
			static GetDDSInfo(e) {
				const t = new Int32Array(e.buffer, e.byteOffset, 31),
					i = new Int32Array(e.buffer, e.byteOffset, 35);
				let s = 1;
				t[2] & bv && (s = Math.max(1, t[7]));
				const n = t[21],
					a = n === Rv ? i[32] : 0;
				let r = 0;
				switch (n) {
					case 113:
						r = 2;
						break;
					case 116:
						r = 1;
						break;
					case Rv:
						if (10 === a) {
							r = 2;
							break
						}
						if (2 === a) {
							r = 1;
							break
						}
				}
				return {
					width: t[4],
					height: t[3],
					mipmapCount: s,
					isFourCC: !(4 & ~t[20]),
					isRGB: !(64 & ~t[20]),
					isLuminance: (t[20] & xv) === xv,
					isCube: !(512 & ~t[28]),
					isCompressed: n === Cv || n === Tv || n === wv,
					dxgiFormat: a,
					textureType: r
				}
			}
		};
	Nv.StoreLODInAlphaChannel = !1, Nd.prototype.createPrefilteredCubeTexture = function(e, t, i, s, n = null, a = null, r, o = null, l = !0) {
		return this.createCubeTexture(e, t, null, !1, (e => {
			if (!e) return void(n && n(null));
			const a = e.texture;
			if (l ? e.info.sphericalPolynomial && (a._sphericalPolynomial = e.info.sphericalPolynomial) : a._sphericalPolynomial = new pv, a._source = 9, this.getCaps().textureLOD) return void(n && n(a));
			const r = this._gl,
				o = e.width;
			if (!o) return;
			const h = [];
			for (let n = 0; n < 3; n++) {
				const l = 1 - n / 2,
					c = s,
					u = Ac.Log2(o) * i + s,
					m = c + (u - c) * l,
					d = Math.round(Math.min(Math.max(m, 0), u)),
					f = new Pm(this, 2);
				if (f.type = a.type, f.format = a.format, f.width = Math.pow(2, Math.max(Ac.Log2(o) - d, 0)), f.height = f.width, f.isCube = !0, f._cachedWrapU = 0, f._cachedWrapV = 0, this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, f, !0), f.samplingMode = 2, r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), e.isDDS) {
					const t = e.info,
						i = e.data;
					this._unpackFlipY(t.isCompressed), Nv.UploadDDSLevels(this, f, i, t, !0, 6, d)
				} else Qc.Warn("DDS is the only prefiltered cube map supported so far.");
				this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, null);
				const p = new wp(t);
				p._isCube = !0, p._texture = f, f.isReady = !0, h.push(p)
			}
			a._lodTextureHigh = h[2], a._lodTextureMid = h[1], a._lodTextureLow = h[0], n && n(a)
		}), a, r, o, l, i, s)
	};
	var Iv = class e extends wp {
		static CreateFromImages(t, i, s) {
			let n = "";
			return t.forEach((e => n += e)), new e(n, i, null, s, t)
		}
		_loadTexture(e = null, t = null) {
			const i = this.getScene(),
				s = this._texture;
			this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
			const n = () => {
					this.onLoadObservable.notifyObservers(this), s && (s.dispose(), this.getScene()?.markAllMaterialsAsDirty(1)), e && e()
				},
				a = (e, i) => {
					this._loadingError = !0, this._errorObject = {
						message: e,
						exception: i
					}, t && t(e, i), Np.OnTextureLoadErrorObservable.notifyObservers(this)
				};
			this._texture ? this._texture.isReady ? dd.SetImmediate((() => n())) : this._texture.onLoadedObservable.add((() => n())) : (this._prefiltered ? this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, i, this._lodScale, this._lodOffset, e, a, this._format, this._forcedExtension, this._createPolynomials) : this._texture = this._getEngine().createCubeTexture(this.url, i, this._files, this._noMipmap, e, a, this._format, this._forcedExtension, !1, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer), this._texture?.onLoadedObservable.add((() => this.onLoadObservable.notifyObservers(this))))
		}
		static CreateFromPrefilteredData(t, i, s = null, n = !0) {
			const a = i.useDelayedTextureLoading;
			i.useDelayedTextureLoading = !1;
			const r = new e(t, i, null, !1, null, null, null, void 0, !0, s, n);
			return i.useDelayedTextureLoading = a, r
		}
		setReflectionTextureMatrix(e) {
			if (e.updateFlag === this._textureMatrix.updateFlag) return;
			if (e.isIdentity() !== this._textureMatrix.isIdentity() && this.getScene()?.markAllMaterialsAsDirty(1, (e => -1 !== e.getActiveTextures().indexOf(this))), this._textureMatrix = e, !this.getScene()?.useRightHandedSystem) return;
			const t = Vc.Vector3[0],
				i = Vc.uk[0],
				s = Vc.Vector3[1];
			this._textureMatrix.decompose(t, i, s), i.z *= -1, i.w *= -1, Hc.ComposeToRef(t, i, s, this._textureMatrixRefraction)
		}
		get rotationY() {
			return this._rotationY
		}
		updateURL(e, t = null, i = null, s = !1, n = null, a = null, r = !1, o = null, l = null) {
			this.name && !this.name.startsWith("data:") || (this.name = e), this.url = e, t && (this._forcedExtension = t);
			const h = e.lastIndexOf("."),
				c = t || (h > -1 ? e.substring(h).toLowerCase() : ""),
				u = 0 === c.indexOf(".dds"),
				m = 0 === c.indexOf(".env"),
				d = 0 === c.indexOf(".basis");
			if (m ? (this.gammaSpace = !1, this._prefiltered = !1, this.anisotropicFilteringLevel = 1) : (this._prefiltered = s, s && (this.gammaSpace = !1, this.anisotropicFilteringLevel = 1)), o) this._files = o;
			else if (d || m || u || a || (a = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"]), this._files = this._files || [], this._files.length = 0, a) {
				for (let t = 0; t < a.length; t++) this._files.push(e + a[t]);
				this._extensions = a
			}
			this._buffer = l, r ? (this.delayLoadState = 4, this._delayedOnLoad = i, this._delayedOnError = n) : this._loadTexture(i, n)
		}
		set boundingBoxSize(e) {
			if (this._boundingBoxSize && this._boundingBoxSize.equals(e)) return;
			this._boundingBoxSize = e;
			const t = this.getScene();
			t && t.markAllMaterialsAsDirty(1)
		}
		getRefractionTextureMatrix() {
			return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix
		}
		getReflectionTextureMatrix() {
			return this._textureMatrix
		}
		get forcedExtension() {
			return this._forcedExtension
		}
		get noMipmap() {
			return this._noMipmap
		}
		static Parse(t, i, s) {
			const n = Xc.Parse((() => {
				let n = !1;
				return t.prefiltered && (n = t.prefiltered), new e(s + (t.url ?? t.name), i, t.extensions, !1, t.files || null, null, null, void 0, n, t.forcedExtension)
			}), t, i);
			if (t.boundingBoxPosition && (n.boundingBoxPosition = Lc.FromArray(t.boundingBoxPosition)), t.boundingBoxSize && (n.boundingBoxSize = Lc.FromArray(t.boundingBoxSize)), t.animations)
				for (let e = 0; e < t.animations.length; e++) {
					const i = t.animations[e],
						s = uc("BABYLON.Animation");
					s && n.animations.push(s.Parse(i))
				}
			return n
		}
		constructor(e, t, i = null, s = !1, n = null, a = null, r = null, o = 5, l = !1, h = null, c = !1, u = .8, m = 0, d, f) {
			super(t), this.onLoadObservable = new kc, this.boundingBoxPosition = Lc.Zero(), this._rotationY = 0, this._files = null, this._forcedExtension = null, this._extensions = null, this._textureMatrixRefraction = new Hc, this._buffer = null, this.name = e, this.url = e, this._noMipmap = s, this.hasAlpha = !1, this.isCube = !0, this._textureMatrix = Hc.Identity(), this.coordinatesMode = Np.CUBIC_MODE;
			let p = null,
				_ = null;
			null === i || Array.isArray(i) ? (this._noMipmap = s, this._format = o, this._createPolynomials = c, p = i, this._loaderOptions = d, this._useSRGBBuffer = f, this._lodScale = u, this._lodOffset = m) : (p = i.extensions ?? null, this._noMipmap = i.noMipmap ?? !1, n = i.files ?? null, _ = i.buffer ?? null, this._format = i.format ?? 5, l = i.prefiltered ?? !1, h = i.forcedExtension ?? null, this._createPolynomials = i.createPolynomials ?? !1, this._lodScale = i.lodScale ?? .8, this._lodOffset = i.lodOffset ?? 0, this._loaderOptions = i.loaderOptions, this._useSRGBBuffer = i.useSRGBBuffer, a = i.onLoad ?? null, r = i.onError ?? null), (e || n) && this.updateURL(e, h, a, l, r, p, this.getScene()?.useDelayedTextureLoading, n, _)
		}
		delayLoad(e) {
			4 === this.delayLoadState && (e && (this._forcedExtension = e), this.delayLoadState = 1, this._loadTexture(this._delayedOnLoad, this._delayedOnError))
		}
		get boundingBoxSize() {
			return this._boundingBoxSize
		}
		clone() {
			let t = 0;
			const i = Xc.Clone((() => {
				const i = new e(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
				return t = i.ik, i
			}), this);
			return i.ik = t, i
		}
		set rotationY(e) {
			this._rotationY = e, this.setReflectionTextureMatrix(Hc.RotationY(this._rotationY))
		}
		getClassName() {
			return "CubeTexture"
		}
	};
	Gh([Xh()], Iv.prototype, "url", void 0), Gh([Jh()], Iv.prototype, "boundingBoxPosition", void 0), Gh([Jh()], Iv.prototype, "boundingBoxSize", null), Gh([Xh("rotationY")], Iv.prototype, "rotationY", null), Gh([Xh("files")], Iv.prototype, "_files", void 0), Gh([Xh("forcedExtension")], Iv.prototype, "_forcedExtension", void 0), Gh([Xh("extensions")], Iv.prototype, "_extensions", void 0), Gh([Zh("textureMatrix")], Iv.prototype, "_textureMatrix", void 0), Gh([Zh("textureMatrixRefraction")], Iv.prototype, "_textureMatrixRefraction", void 0), Np._CubeTextureParser = Iv.Parse, cc("BABYLON.CubeTexture", Iv);
	var Pv = class {
			static AddUniforms(e) {
				e.push("previousWorld", "previousViewProjection", "mPreviousBones")
			}
			bindForSubMesh(e, t, i, s, n) {
				if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && -1 !== t.prePassRenderer.getIndex(2)) {
					this.previousWorldMatrices[i.ik] || (this.previousWorldMatrices[i.ik] = s.clone()), this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(), this.currentViewProjection = t.getTransformMatrix().clone());
					const n = t.getEngine();
					this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection), this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== n.frameId && (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection)), e.setMatrix("previousWorld", this.previousWorldMatrices[i.ik]), e.setMatrix("previousViewProjection", this.previousViewProjection), this.previousWorldMatrices[i.ik] = s.clone()
				}
			}
			static AddSamplers(e) {}
			constructor() {
				this.previousWorldMatrices = {}, this.previousBones = {}
			}
		},
		kv = class {
			static get TranslucencyColorTextureEnabled() {
				return this._TranslucencyColorTextureEnabled
			}
			static get LightmapTextureEnabled() {
				return this._LightmapTextureEnabled
			}
			static set SheenTextureEnabled(e) {
				this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get IridescenceTextureEnabled() {
				return this._IridescenceTextureEnabled
			}
			static set DecalMapEnabled(e) {
				this._DecalMapEnabled !== e && (this._DecalMapEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get FresnelEnabled() {
				return this._FresnelEnabled
			}
			static get ColorGradingTextureEnabled() {
				return this._ColorGradingTextureEnabled
			}
			static get OpacityTextureEnabled() {
				return this._OpacityTextureEnabled
			}
			static set ThicknessTextureEnabled(e) {
				this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set ColorGradingTextureEnabled(e) {
				this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set SpecularTextureEnabled(e) {
				this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set TranslucencyColorTextureEnabled(e) {
				this._TranslucencyColorTextureEnabled !== e && (this._TranslucencyColorTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set OpacityTextureEnabled(e) {
				this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get RefractionIntensityTextureEnabled() {
				return this._ThicknessTextureEnabled
			}
			static set DetailTextureEnabled(e) {
				this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set RefractionTextureEnabled(e) {
				this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get ClearCoatTintTextureEnabled() {
				return this._ClearCoatTintTextureEnabled
			}
			static get BumpTextureEnabled() {
				return this._BumpTextureEnabled
			}
			static set IridescenceTextureEnabled(e) {
				this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get AnisotropicTextureEnabled() {
				return this._AnisotropicTextureEnabled
			}
			static set ClearCoatBumpTextureEnabled(e) {
				this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get ClearCoatTextureEnabled() {
				return this._ClearCoatTextureEnabled
			}
			static get DetailTextureEnabled() {
				return this._DetailTextureEnabled
			}
			static get SpecularTextureEnabled() {
				return this._SpecularTextureEnabled
			}
			static get RefractionTextureEnabled() {
				return this._RefractionTextureEnabled
			}
			static get DecalMapEnabled() {
				return this._DecalMapEnabled
			}
			static get DiffuseTextureEnabled() {
				return this._DiffuseTextureEnabled
			}
			static set FresnelEnabled(e) {
				this._FresnelEnabled !== e && (this._FresnelEnabled = e, Fd.MarkAllMaterialsAsDirty(4))
			}
			static set TranslucencyIntensityTextureEnabled(e) {
				this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set ReflectionTextureEnabled(e) {
				this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set AmbientTextureEnabled(e) {
				this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set ClearCoatTintTextureEnabled(e) {
				this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set RefractionIntensityTextureEnabled(e) {
				this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set LightmapTextureEnabled(e) {
				this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get SheenTextureEnabled() {
				return this._SheenTextureEnabled
			}
			static set ClearCoatTextureEnabled(e) {
				this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get ReflectionTextureEnabled() {
				return this._ReflectionTextureEnabled
			}
			static set AnisotropicTextureEnabled(e) {
				this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get ClearCoatBumpTextureEnabled() {
				return this._ClearCoatBumpTextureEnabled
			}
			static get TranslucencyIntensityTextureEnabled() {
				return this._TranslucencyIntensityTextureEnabled
			}
			static set EmissiveTextureEnabled(e) {
				this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set DiffuseTextureEnabled(e) {
				this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static set BumpTextureEnabled(e) {
				this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e, Fd.MarkAllMaterialsAsDirty(1))
			}
			static get AmbientTextureEnabled() {
				return this._AmbientTextureEnabled
			}
			static get EmissiveTextureEnabled() {
				return this._EmissiveTextureEnabled
			}
			static get ThicknessTextureEnabled() {
				return this._ThicknessTextureEnabled
			}
		};
	kv._DiffuseTextureEnabled = !0, kv._DetailTextureEnabled = !0, kv._DecalMapEnabled = !0, kv._AmbientTextureEnabled = !0, kv._OpacityTextureEnabled = !0, kv._ReflectionTextureEnabled = !0, kv._EmissiveTextureEnabled = !0, kv._SpecularTextureEnabled = !0, kv._BumpTextureEnabled = !0, kv._LightmapTextureEnabled = !0, kv._RefractionTextureEnabled = !0, kv._ColorGradingTextureEnabled = !0, kv._FresnelEnabled = !0, kv._ClearCoatTextureEnabled = !0, kv._ClearCoatBumpTextureEnabled = !0, kv._ClearCoatTintTextureEnabled = !0, kv._SheenTextureEnabled = !0, kv._AnisotropicTextureEnabled = !0, kv._ThicknessTextureEnabled = !0, kv._RefractionIntensityTextureEnabled = !0, kv._TranslucencyIntensityTextureEnabled = !0, kv._TranslucencyColorTextureEnabled = !0, kv._IridescenceTextureEnabled = !0, h();
	var Dv = new RegExp("^([gimus]+)!"),
		Ov = class t {
			_handlePluginEventPrepareDefinesBeforeAttributes(e) {
				for (const t of this._activePlugins) t.prepareDefinesBeforeAttributes(e.defines, this._scene, e.mesh)
			}
			_handlePluginEventPrepareDefines(e) {
				for (const t of this._activePlugins) t.prepareDefines(e.defines, this._scene, e.mesh)
			}
			getPlugin(e) {
				for (let t = 0; t < this._plugins.length; ++t)
					if (this._plugins[t].name === e) return this._plugins[t];
				return null
			}
			_handlePluginEventHardBindForSubMesh(e) {
				for (const t of this._activePluginsForExtraEvents) t.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh)
			}
			constructor(e) {
				this._plugins = [], this._activePlugins = [], this._activePluginsForExtraEvents = [], this._material = e, this._scene = e.getScene(), this._engine = this._scene.getEngine()
			}
			_handlePluginEventFillRenderTargetTextures(e) {
				for (const t of this._activePluginsForExtraEvents) t.fillRenderTargetTextures(e.renderTargets)
			}
			_handlePluginEvent(e, t) {
				switch (e) {
					case 512: {
						const e = t;
						for (const t of this._activePlugins) t.getActiveTextures(e.activeTextures);
						break
					}
					case 256: {
						const e = t;
						for (const t of this._activePlugins) t.getAnimatables(e.animatables);
						break
					}
					case 1024: {
						const e = t;
						let i = !1;
						for (const t of this._activePlugins)
							if (i = t.hasTexture(e.texture), i) break;
						e.hasTexture = i;
						break
					}
					case 2: {
						const e = t;
						for (const t of this._plugins) t.dispose(e.forceDisposeTextures);
						break
					}
					case 4:
						t.defineNames = this._defineNamesFromPlugins;
						break;
					case 128: {
						const e = t;
						for (const t of this._activePlugins) e.fallbackRank = t.addFallbacks(e.defines, e.fallbacks, e.fallbackRank), t.getAttributes(e.attributes, this._scene, e.mesh);
						this._uniformList.length > 0 && e.uniforms.push(...this._uniformList), this._samplerList.length > 0 && e.samplers.push(...this._samplerList), this._uboList.length > 0 && e.uniformBuffersNames.push(...this._uboList), e.customCode = this._injectCustomCode(e, e.customCode);
						break
					}
					case 8: {
						const e = t;
						this._uboDeclaration = "", this._vertexDeclaration = "", this._fragmentDeclaration = "", this._uniformList = [], this._samplerList = [], this._uboList = [];
						const i = 1 === this._material.shaderLanguage;
						for (const t of this._plugins) {
							const s = t.getUniforms(this._material.shaderLanguage);
							if (s) {
								if (s.ubo)
									for (const t of s.ubo) {
										if (t.size && t.type) {
											const s = t.arraySize ?? 0;
											if (e.ubo.addUniform(t.name, t.size, s), i) {
												let e;
												switch (t.type) {
													case "mat4":
														e = "mat4x4f";
														break;
													case "float":
														e = "f32";
														break;
													default:
														e = `${t.type}f`
												}
												this._uboDeclaration += `uniform ${t.name}: ${e}${s>0?`[${s}]`:""};\n`
											} else this._uboDeclaration += `${t.type} ${t.name}${s>0?`[${s}]`:""};\n`
										}
										this._uniformList.push(t.name)
									}
								s.vertex && (this._vertexDeclaration += s.vertex + "\n"), s.fragment && (this._fragmentDeclaration += s.fragment + "\n")
							}
							t.getSamplers(this._samplerList), t.getUniformBuffersNames(this._uboList)
						}
						break
					}
				}
			}
			_addPlugin(e) {
				for (let t = 0; t < this._plugins.length; ++t)
					if (this._plugins[t].name === e.name) return !1;
				if (this._material._uniformBufferLayoutBuilt) throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
				if (!e.isCompatible(this._material.shaderLanguage)) throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because the plugin is not compatible with the shader language of the material.`;
				const i = e.getClassName();
				t._MaterialPluginClassToMainDefine[i] || (t._MaterialPluginClassToMainDefine[i] = "MATERIALPLUGIN_" + ++t._MaterialPluginCounter), this._material._callbackPluginEventGeneric = (e, t) => this._handlePluginEvent(e, t), this._plugins.push(e), this._plugins.sort(((e, t) => e.priority - t.priority)), this._codeInjectionPoints = {};
				const s = {};
				s[t._MaterialPluginClassToMainDefine[i]] = {
					type: "boolean",
					default: !0
				};
				for (const e of this._plugins) e.collectDefines(s), this._collectPointNames("vertex", e.getCustomCode("vertex", this._material.shaderLanguage)), this._collectPointNames("fragment", e.getCustomCode("fragment", this._material.shaderLanguage));
				return this._defineNamesFromPlugins = s, !0
			}
			_injectCustomCode(t, i) {
				return (s, n) => {
					i && (n = i(s, n)), this._uboDeclaration && (n = n.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration)), this._vertexDeclaration && (n = n.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration)), this._fragmentDeclaration && (n = n.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration));
					const a = this._codeInjectionPoints?.[s];
					if (!a) return n;
					let r = null;
					for (let i in a) {
						let a = "";
						for (const n of this._activePlugins) {
							let o = n.getCustomCode(s, this._material.shaderLanguage)?.[i];
							if (o) {
								if (n.resolveIncludes) {
									if (null === r) {
										const i = 0;
										r = {
											defines: [],
											indexParameters: t.indexParameters,
											isFragment: !1,
											shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
											processor: void 0,
											supportsUniformBuffers: this._engine.supportsUniformBuffers,
											shadersRepository: e.GetShadersRepository(i),
											includesShadersStore: e.GetIncludesShadersStore(i),
											version: void 0,
											platformName: this._engine.shaderPlatformName,
											processingContext: void 0,
											isNDCHalfZRange: this._engine.isNDCHalfZRange,
											useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
											processCodeAfterIncludes: void 0
										}
									}
									r.isFragment = "fragment" === s, hm(o, r, (e => o = e))
								}
								a += o + "\n"
							}
						}
						if (a.length > 0)
							if ("!" === i.charAt(0)) {
								i = i.substring(1);
								let e = "g";
								if ("!" === i.charAt(0)) e = "", i = i.substring(1);
								else {
									const t = Dv.exec(i);
									t && t.length >= 2 && (e = t[1], i = i.substring(e.length + 1))
								}
								e.indexOf("g") < 0 && (e += "g");
								const t = n,
									s = new RegExp(i, e);
								let r = s.exec(t);
								for (; null !== r;) {
									let e = a;
									for (let t = 0; t < r.length; ++t) e = e.replace("$" + t, r[t]);
									n = n.replace(r[0], e), r = s.exec(t)
								}
							} else {
								const e = "#define " + i;
								n = n.replace(e, "\n" + a + "\n" + e)
							}
					}
					return n
				}
			}
			_handlePluginEventHasRenderTargetTextures(e) {
				let t = !1;
				for (const e of this._activePluginsForExtraEvents)
					if (t = e.hasRenderTargetTextures(), t) break;
				e.hasRenderTargetTextures = t
			}
			_collectPointNames(e, t) {
				if (t)
					for (const i in t) this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}), this._codeInjectionPoints[e][i] = !0
			}
			_handlePluginEventIsReadyForSubMesh(e) {
				let t = !0;
				for (const i of this._activePlugins) t = t && i.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh);
				e.isReadyForSubMesh = t
			}
			_activatePlugin(e) {
				-1 === this._activePlugins.indexOf(e) && (this._activePlugins.push(e), this._activePlugins.sort(((e, t) => e.priority - t.priority)), this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this), this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this), this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this), this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this), e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e), this._activePluginsForExtraEvents.sort(((e, t) => e.priority - t.priority)), this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this), this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this), this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this)))
			}
			_handlePluginEventBindForSubMesh(e) {
				for (const t of this._activePlugins) t.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh)
			}
		};
	Ov._MaterialPluginClassToMainDefine = {}, Ov._MaterialPluginCounter = 0, Dc.OnEnginesDisposedObservable.add((() => {
		Fv.length = 0, Pf.OnEventObservable.remove(Lv), Lv = null
	}));
	var Fv = [],
		Lv = null;
	var Bv = class {
		isReadyForSubMesh(e, t, i, s) {
			return !0
		}
		_enable(e) {
			e && this._pluginManager._activatePlugin(this)
		}
		dispose(e) {}
		hasRenderTargetTextures() {
			return !1
		}
		serialize() {
			return Xc.Serialize(this)
		}
		fillRenderTargetTextures(e) {}
		bindForSubMesh(e, t, i, s) {}
		getClassName() {
			return "MaterialPluginBase"
		}
		getAttributes(e, t, i) {}
		getActiveTextures(e) {}
		hasTexture(e) {
			return !1
		}
		getAnimatables(e) {}
		collectDefines(e) {
			if (this._pluginDefineNames)
				for (const t of Object.keys(this._pluginDefineNames)) {
					if ("_" === t[0]) continue;
					const i = typeof this._pluginDefineNames[t];
					e[t] = {
						type: "number" === i ? "number" : "string" === i ? "string" : "boolean" === i ? "boolean" : "object",
						default: this._pluginDefineNames[t]
					}
				}
		}
		hardBindForSubMesh(e, t, i, s) {}
		getSamplers(e) {}
		parse(e, t, i) {
			Xc.Parse((() => this), e, t, i)
		}
		addFallbacks(e, t, i) {
			return i
		}
		getUniformBuffersNames(e) {}
		isCompatible(e) {
			return 0 === e
		}
		prepareDefines(e, t, i) {}
		copyTo(e) {
			Xc.Clone((() => e), this)
		}
		getUniforms(e = 0) {
			return {}
		}
		getCustomCode(e, t = 0) {
			return null
		}
		prepareDefinesBeforeAttributes(e, t, i) {}
		constructor(e, t, i, s, n = !0, a = !1, r = !1) {
			this.priority = 500, this.resolveIncludes = !1, this.registerForExtraEvents = !1, this._material = e, this.name = t, this.priority = i, this.resolveIncludes = r, e.pluginManager || (e.pluginManager = new Ov(e), e.onDisposeObservable.add((() => {
				e.pluginManager = void 0
			}))), this._pluginDefineNames = s, this._pluginManager = e.pluginManager, n && this._pluginManager._addPlugin(this), a && this._enable(!0), this.markAllDefinesAsDirty = e._dirtyCallbacks[63]
		}
	};
	Gh([Xh()], Bv.prototype, "name", void 0), Gh([Xh()], Bv.prototype, "priority", void 0), Gh([Xh()], Bv.prototype, "resolveIncludes", void 0), Gh([Xh()], Bv.prototype, "registerForExtraEvents", void 0), cc("BABYLON.MaterialPluginBase", Bv);
	var Gv = class extends ip {
			constructor() {
				super(...arguments), this.DETAIL = !1, this.DETAILDIRECTUV = 0, this.DETAIL_NORMALBLENDMETHOD = 0
			}
		},
		Hv = class extends Bv {
			dispose(e) {
				e && this._texture?.dispose()
			}
			getAnimatables(e) {
				this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture)
			}
			constructor(e, t = !0) {
				super(e, "DetailMap", 140, new Gv, t), this._texture = null, this.diffuseBlendLevel = 1, this.roughnessBlendLevel = 1, this.bumpLevel = 1, this._normalBlendMethod = Pf.MATERIAL_NORMALBLENDMETHOD_WHITEOUT, this._isEnabled = !1, this.isEnabled = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1]
			}
			getClassName() {
				return "DetailMapConfiguration"
			}
			isCompatible() {
				return !0
			}
			prepareDefines(e, t) {
				if (this._isEnabled) {
					e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
					const i = t.getEngine();
					e._areTexturesDirty && (i.getCaps().standardDerivatives && this._texture && kv.DetailTextureEnabled && this._isEnabled ? (cf(this._texture, e, "DETAIL"), e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : e.DETAIL = !1)
				} else e.DETAIL = !1
			}
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			hasTexture(e) {
				return this._texture === e
			}
			bindForSubMesh(e, t) {
				if (!this._isEnabled) return;
				const i = this._material.isFrozen;
				e.useUbo && i && e.isSync || this._texture && kv.DetailTextureEnabled && (e.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel), uf(this._texture, e, "detail")), t.texturesEnabled && this._texture && kv.DetailTextureEnabled && e.setTexture("detailSampler", this._texture)
			}
			isReadyForSubMesh(e, t, i) {
				return !this._isEnabled || !(e._areTexturesDirty && t.texturesEnabled && i.getCaps().standardDerivatives && this._texture && kv.DetailTextureEnabled && !this._texture.isReady())
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vDetailInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "detailMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			getSamplers(e) {
				e.push("detailSampler")
			}
			getActiveTextures(e) {
				this._texture && e.push(this._texture)
			}
		};
	Gh([Yh("detailTexture"), zh("_markAllSubMeshesAsTexturesDirty")], Hv.prototype, "texture", void 0), Gh([Xh()], Hv.prototype, "diffuseBlendLevel", void 0), Gh([Xh()], Hv.prototype, "roughnessBlendLevel", void 0), Gh([Xh()], Hv.prototype, "bumpLevel", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], Hv.prototype, "normalBlendMethod", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], Hv.prototype, "isEnabled", void 0);
	var Uv = {
			effect: null,
			subMesh: null
		},
		Vv = class extends ip {
			constructor(e) {
				super(e), this.MAINUV1 = !1, this.MAINUV2 = !1, this.MAINUV3 = !1, this.MAINUV4 = !1, this.MAINUV5 = !1, this.MAINUV6 = !1, this.DIFFUSE = !1, this.DIFFUSEDIRECTUV = 0, this.BAKED_VERTEX_ANIMATION_TEXTURE = !1, this.AMBIENT = !1, this.AMBIENTDIRECTUV = 0, this.OPACITY = !1, this.OPACITYDIRECTUV = 0, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.EMISSIVEDIRECTUV = 0, this.SPECULAR = !1, this.SPECULARDIRECTUV = 0, this.BUMP = !1, this.BUMPDIRECTUV = 0, this.PARALLAX = !1, this.PARALLAX_RHS = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.ALPHATEST = !1, this.DEPTHPREPASS = !1, this.ALPHAFROMDIFFUSE = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.DIFFUSEFRESNEL = !1, this.OPACITYFRESNEL = !1, this.REFLECTIONFRESNEL = !1, this.REFRACTIONFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.TANGENT = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.BONES_VELOCITY_ENABLED = !1, this.INSTANCES = !1, this.THIN_INSTANCES = !1, this.INSTANCESCOLOR = !1, this.GLOSSINESS = !1, this.ROUGHNESS = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHDIFFUSE = !1, this.REFLECTIONFRESNELFROMSPECULAR = !1, this.LIGHTMAP = !1, this.LIGHTMAPDIRECTUV = 0, this.OBJECTSPACE_NORMALMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFRACTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_OPPOSITEZ = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.REFLECTIONOVERALPHA = !1, this.TWOSIDEDLIGHTING = !1, this.SHADOWFLOAT = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.NONUNIFORMSCALING = !1, this.PREMULTIPLYALPHA = !1, this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1, this.ALPHABLEND = !0, this.PREPASS = !1, this.PREPASS_IRRADIANCE = !1, this.PREPASS_IRRADIANCE_INDEX = -1, this.PREPASS_ALBEDO_SQRT = !1, this.PREPASS_ALBEDO_SQRT_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_NORMAL_WORLDSPACE = !1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_VELOCITY = !1, this.PREPASS_VELOCITY_INDEX = -1, this.PREPASS_REFLECTIVITY = !1, this.PREPASS_REFLECTIVITY_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.RGBDLIGHTMAP = !1, this.RGBDREFLECTION = !1, this.RGBDREFRACTION = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = 0, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.MULTIVIEW = !1, this.ORDER_INDEPENDENT_TRANSPARENCY = !1, this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, this.CAMERA_ORTHOGRAPHIC = !1, this.CAMERA_PERSPECTIVE = !1, this.IS_REFLECTION_LINEAR = !1, this.IS_REFRACTION_LINEAR = !1, this.EXPOSURE = !1, this.DECAL_AFTER_DETAIL = !1, this.rebuild()
			}
			setReflectionMode(e) {
				const t = ["REFLECTIONMAP_CUBIC", "REFLECTIONMAP_EXPLICIT", "REFLECTIONMAP_PLANAR", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_SKYBOX", "REFLECTIONMAP_SPHERICAL", "REFLECTIONMAP_EQUIRECTANGULAR", "REFLECTIONMAP_EQUIRECTANGULAR_FIXED", "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"];
				for (const i of t) this[i] = i === e
			}
		},
		Wv = class e extends $f {
			static get LightmapTextureEnabled() {
				return kv.LightmapTextureEnabled
			}
			get canRenderToMRT() {
				return !0
			}
			static get DiffuseTextureEnabled() {
				return kv.DiffuseTextureEnabled
			}
			_shouldUseAlphaFromDiffuseTexture() {
				return null != this._diffuseTexture && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Pf.MATERIAL_OPAQUE
			}
			getAnimatables() {
				const e = super.getAnimatables();
				return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && e.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && e.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture), e
			}
			static get FresnelEnabled() {
				return kv.FresnelEnabled
			}
			static set DetailTextureEnabled(e) {
				kv.DetailTextureEnabled = e
			}
			static set LightmapTextureEnabled(e) {
				kv.LightmapTextureEnabled = e
			}
			set cameraColorGradingEnabled(e) {
				this.imageProcessingConfiguration.colorGradingEnabled = e
			}
			static get AmbientTextureEnabled() {
				return kv.AmbientTextureEnabled
			}
			set cameraExposure(e) {
				this._imageProcessingConfiguration.exposure = e
			}
			get cameraColorCurves() {
				return this._imageProcessingConfiguration.colorCurves
			}
			_attachImageProcessingConfiguration(e) {
				e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add((() => {
					this._markAllSubMeshesAsImageProcessingDirty()
				}))))
			}
			static Parse(t, i, s) {
				const n = Xc.Parse((() => new e(t.name, i)), t, i, s);
				return t.stencil && n.stencil.parse(t.stencil, i, s), Pf._ParsePlugins(t, n, i, s), n
			}
			static set AmbientTextureEnabled(e) {
				kv.AmbientTextureEnabled = e
			}
			static get EmissiveTextureEnabled() {
				return kv.EmissiveTextureEnabled
			}
			static get ReflectionTextureEnabled() {
				return kv.ReflectionTextureEnabled
			}
			static get DetailTextureEnabled() {
				return kv.DetailTextureEnabled
			}
			set cameraContrast(e) {
				this._imageProcessingConfiguration.contrast = e
			}
			set imageProcessingConfiguration(e) {
				this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty()
			}
			static set ReflectionTextureEnabled(e) {
				kv.ReflectionTextureEnabled = e
			}
			static set BumpTextureEnabled(e) {
				kv.BumpTextureEnabled = e
			}
			get imageProcessingConfiguration() {
				return this._imageProcessingConfiguration
			}
			getAlphaTestTexture() {
				return this._diffuseTexture
			}
			isReadyForSubMesh(t, i, s = !1) {
				if (!this._shadersLoaded) return !1;
				this._uniformBufferLayoutBuilt || this.buildUniformLayout();
				const n = i._drawWrapper;
				if (n.effect && this.isFrozen && n._wasPreviouslyReady && n._wasPreviouslyUsingInstances === s) return !0;
				i.materialDefines || (this._callbackPluginEventGeneric(4, this._eventInfo), i.materialDefines = new Vv(this._eventInfo.defineNames));
				const a = this.getScene(),
					r = i.materialDefines;
				if (this._isReadyForSubMesh(i)) return !0;
				const o = a.getEngine();
				r._needNormals = Ef(a, t, r, !0, this._maxSimultaneousLights, this._disableLighting), Cf(a, r);
				const l = this.needAlphaBlendingForMesh(t) && this.getScene().useOrderIndependentTransparency;
				if (wf(a, r, this.canRenderToMRT && !l), Tf(a, r, l), r._areTexturesDirty) {
					this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, r._needUVs = !1;
					for (let e = 1; e <= 6; ++e) r["MAINUV" + e] = !1;
					if (a.texturesEnabled) {
						if (r.DIFFUSEDIRECTUV = 0, r.BUMPDIRECTUV = 0, r.AMBIENTDIRECTUV = 0, r.OPACITYDIRECTUV = 0, r.EMISSIVEDIRECTUV = 0, r.SPECULARDIRECTUV = 0, r.LIGHTMAPDIRECTUV = 0, this._diffuseTexture && e.DiffuseTextureEnabled) {
							if (!this._diffuseTexture.isReadyOrNotBlocking()) return !1;
							cf(this._diffuseTexture, r, "DIFFUSE")
						} else r.DIFFUSE = !1;
						if (this._ambientTexture && e.AmbientTextureEnabled) {
							if (!this._ambientTexture.isReadyOrNotBlocking()) return !1;
							cf(this._ambientTexture, r, "AMBIENT")
						} else r.AMBIENT = !1;
						if (this._opacityTexture && e.OpacityTextureEnabled) {
							if (!this._opacityTexture.isReadyOrNotBlocking()) return !1;
							cf(this._opacityTexture, r, "OPACITY"), r.OPACITYRGB = this._opacityTexture.getAlphaFromRGB
						} else r.OPACITY = !1;
						if (this._reflectionTexture && e.ReflectionTextureEnabled) {
							if (!this._reflectionTexture.isReadyOrNotBlocking()) return !1;
							switch (r._needNormals = !0, r.REFLECTION = !0, r.ROUGHNESS = this._roughness > 0, r.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, r.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Np.INVCUBIC_MODE, r.REFLECTIONMAP_3D = this._reflectionTexture.isCube, r.REFLECTIONMAP_OPPOSITEZ = r.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ, r.RGBDREFLECTION = this._reflectionTexture.isRGBD, this._reflectionTexture.coordinatesMode) {
								case Np.EXPLICIT_MODE:
									r.setReflectionMode("REFLECTIONMAP_EXPLICIT");
									break;
								case Np.PLANAR_MODE:
									r.setReflectionMode("REFLECTIONMAP_PLANAR");
									break;
								case Np.PROJECTION_MODE:
									r.setReflectionMode("REFLECTIONMAP_PROJECTION");
									break;
								case Np.SKYBOX_MODE:
									r.setReflectionMode("REFLECTIONMAP_SKYBOX");
									break;
								case Np.SPHERICAL_MODE:
									r.setReflectionMode("REFLECTIONMAP_SPHERICAL");
									break;
								case Np.EQUIRECTANGULAR_MODE:
									r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
									break;
								case Np.FIXED_EQUIRECTANGULAR_MODE:
									r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
									break;
								case Np.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
									r.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
									break;
								case Np.CUBIC_MODE:
								case Np.INVCUBIC_MODE:
								default:
									r.setReflectionMode("REFLECTIONMAP_CUBIC")
							}
							r.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize
						} else r.REFLECTION = !1, r.REFLECTIONMAP_OPPOSITEZ = !1;
						if (this._emissiveTexture && e.EmissiveTextureEnabled) {
							if (!this._emissiveTexture.isReadyOrNotBlocking()) return !1;
							cf(this._emissiveTexture, r, "EMISSIVE")
						} else r.EMISSIVE = !1;
						if (this._lightmapTexture && e.LightmapTextureEnabled) {
							if (!this._lightmapTexture.isReadyOrNotBlocking()) return !1;
							cf(this._lightmapTexture, r, "LIGHTMAP"), r.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, r.RGBDLIGHTMAP = this._lightmapTexture.isRGBD
						} else r.LIGHTMAP = !1;
						if (this._specularTexture && e.SpecularTextureEnabled) {
							if (!this._specularTexture.isReadyOrNotBlocking()) return !1;
							cf(this._specularTexture, r, "SPECULAR"), r.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha
						} else r.SPECULAR = !1;
						if (a.getEngine().getCaps().standardDerivatives && this._bumpTexture && e.BumpTextureEnabled) {
							if (!this._bumpTexture.isReady()) return !1;
							cf(this._bumpTexture, r, "BUMP"), r.PARALLAX = this._useParallax, r.PARALLAX_RHS = a.useRightHandedSystem, r.PARALLAXOCCLUSION = this._useParallaxOcclusion, r.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap
						} else r.BUMP = !1, r.PARALLAX = !1, r.PARALLAX_RHS = !1, r.PARALLAXOCCLUSION = !1;
						if (this._refractionTexture && e.RefractionTextureEnabled) {
							if (!this._refractionTexture.isReadyOrNotBlocking()) return !1;
							r._needUVs = !0, r.REFRACTION = !0, r.REFRACTIONMAP_3D = this._refractionTexture.isCube, r.RGBDREFRACTION = this._refractionTexture.isRGBD, r.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize
						} else r.REFRACTION = !1;
						r.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting
					} else r.DIFFUSE = !1, r.AMBIENT = !1, r.OPACITY = !1, r.REFLECTION = !1, r.EMISSIVE = !1, r.LIGHTMAP = !1, r.BUMP = !1, r.REFRACTION = !1;
					r.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), r.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, r.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, r.SPECULAROVERALPHA = this._useSpecularOverAlpha, r.PREMULTIPLYALPHA = 7 === this.alphaMode || 8 === this.alphaMode, r.ALPHATEST_AFTERALLALPHACOMPUTATIONS = null !== this.transparencyMode, r.ALPHABLEND = null === this.transparencyMode || this.needAlphaBlendingForMesh(t)
				}
				if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = r, this._eventInfo.subMesh = i, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh) return !1;
				if (r._areImageProcessingDirty && this._imageProcessingConfiguration) {
					if (!this._imageProcessingConfiguration.isReady()) return !1;
					this._imageProcessingConfiguration.prepareDefines(r), r.IS_REFLECTION_LINEAR = null != this.reflectionTexture && !this.reflectionTexture.gammaSpace, r.IS_REFRACTION_LINEAR = null != this.refractionTexture && !this.refractionTexture.gammaSpace
				}
				r._areFresnelDirty && (e.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (r.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, r.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, r.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, r.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, r.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, r.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, r._needNormals = !0, r.FRESNEL = !0) : r.FRESNEL = !1), Sf(t, a, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(t) || this._forceAlphaTest, r, this._applyDecalMapAfterDetailMap), bf(a, o, this, r, s, null, i.getRenderingMesh().hasThinInstances), this._eventInfo.defines = r, this._eventInfo.mesh = t, this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo), Mf(t, r, !0, !0, !0), this._callbackPluginEventPrepareDefines(this._eventInfo);
				let h = !1;
				if (r.isDirty) {
					const e = r._areLightsDisposed;
					r.markAsProcessed();
					const s = new Op;
					r.REFLECTION && s.addFallback(0, "REFLECTION"), r.SPECULAR && s.addFallback(0, "SPECULAR"), r.BUMP && s.addFallback(0, "BUMP"), r.PARALLAX && s.addFallback(1, "PARALLAX"), r.PARALLAX_RHS && s.addFallback(1, "PARALLAX_RHS"), r.PARALLAXOCCLUSION && s.addFallback(0, "PARALLAXOCCLUSION"), r.SPECULAROVERALPHA && s.addFallback(0, "SPECULAROVERALPHA"), r.FOG && s.addFallback(1, "FOG"), r.POINTSIZE && s.addFallback(0, "POINTSIZE"), r.LOGARITHMICDEPTH && s.addFallback(0, "LOGARITHMICDEPTH"), vf(r, s, this._maxSimultaneousLights), r.SPECULARTERM && s.addFallback(0, "SPECULARTERM"), r.DIFFUSEFRESNEL && s.addFallback(1, "DIFFUSEFRESNEL"), r.OPACITYFRESNEL && s.addFallback(2, "OPACITYFRESNEL"), r.REFLECTIONFRESNEL && s.addFallback(3, "REFLECTIONFRESNEL"), r.EMISSIVEFRESNEL && s.addFallback(4, "EMISSIVEFRESNEL"), r.FRESNEL && s.addFallback(4, "FRESNEL"), r.MULTIVIEW && s.addFallback(0, "MULTIVIEW");
					const n = [eu.PositionKind];
					r.NORMAL && n.push(eu.NormalKind), r.TANGENT && n.push(eu.TangentKind);
					for (let e = 1; e <= 6; ++e) r["UV" + e] && n.push(`uv${1===e?"":e}`);
					r.VERTEXCOLOR && n.push(eu.ColorKind), _f(n, t, r, s), gf(n, r), rf(n, t, r), mf(n, 0, r);
					let l = "default";
					const c = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vDiffuseColor", "vSpecularColor", "vEmissiveColor", "visibility", "vFogInfos", "vFogColor", "pointSize", "vDiffuseInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vSpecularInfos", "vBumpInfos", "vLightmapInfos", "vRefractionInfos", "mBones", "diffuseMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "specularMatrix", "bumpMatrix", "normalMatrix", "lightmapMatrix", "refractionMatrix", "diffuseLeftColor", "diffuseRightColor", "opacityParts", "reflectionLeftColor", "reflectionRightColor", "emissiveLeftColor", "emissiveRightColor", "refractionLeftColor", "refractionRightColor", "vReflectionPosition", "vReflectionSize", "vRefractionPosition", "vRefractionSize", "logarithmicDepthConstant", "vTangentSpaceParams", "alphaCutOff", "boneTextureWidth", "morphTargetTextureInfo", "morphTargetTextureIndices"],
						u = ["diffuseSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "specularSampler", "bumpSampler", "lightmapSampler", "refractionCubeSampler", "refraction2DSampler", "boneSampler", "morphTargets", "oitDepthSampler", "oitFrontColorSampler"],
						m = ["Material", "Scene", "Mesh"],
						d = {
							maxSimultaneousLights: this._maxSimultaneousLights,
							maxSimultaneousMorphTargets: r.NUM_MORPH_INFLUENCERS
						};
					this._eventInfo.fallbacks = s, this._eventInfo.fallbackRank = 0, this._eventInfo.defines = r, this._eventInfo.uniforms = c, this._eventInfo.attributes = n, this._eventInfo.samplers = u, this._eventInfo.uniformBuffersNames = m, this._eventInfo.customCode = void 0, this._eventInfo.mesh = t, this._eventInfo.indexParameters = d, this._callbackPluginEventGeneric(128, this._eventInfo), Pv.AddUniforms(c), Pv.AddSamplers(u), B_ && (B_.PrepareUniforms(c, r), B_.PrepareSamplers(u, r)), If({
						uniformsNames: c,
						uniformBuffersNames: m,
						samplers: u,
						defines: r,
						maxSimultaneousLights: this._maxSimultaneousLights
					}), Jd(c);
					const f = {};
					this.customShaderNameResolve && (l = this.customShaderNameResolve(l, c, m, u, r, n, f));
					const p = r.toString(),
						_ = i.effect;
					let g = a.getEngine().createEffect(l, {
						attributes: n,
						uniformsNames: c,
						uniformBuffersNames: m,
						samplers: u,
						defines: p,
						fallbacks: s,
						onCompiled: this.onCompiled,
						onError: this.onError,
						indexParameters: d,
						processFinalCode: f.processFinalCode,
						processCodeAfterIncludes: this._eventInfo.customCode,
						multiTarget: r.PREPASS,
						shaderLanguage: this._shaderLanguage
					}, o);
					if (this._eventInfo.customCode = void 0, g)
						if (this._onEffectCreatedObservable && (Uv.effect = g, Uv.subMesh = i, this._onEffectCreatedObservable.notifyObservers(Uv)), this.allowShaderHotSwapping && _ && !g.isReady()) {
							if (g = _, r.markAsUnprocessed(), h = this.isFrozen, e) return r._areLightsDisposed = !0, !1
						} else a.resetCachedMaterial(), i.setEffect(g, r, this._materialContext)
				}
				return !(!i.effect || !i.effect.isReady()) && (r._renderId = a.getRenderId(), n._wasPreviouslyReady = !h, n._wasPreviouslyUsingInstances = s, this._checkScenePerformancePriority(), !0)
			}
			set cameraColorCurves(e) {
				this._imageProcessingConfiguration.colorCurves = e
			}
			constructor(t, i, s = !1) {
				super(t, i), this._diffuseTexture = null, this._ambientTexture = null, this._opacityTexture = null, this._reflectionTexture = null, this._emissiveTexture = null, this._specularTexture = null, this._bumpTexture = null, this._lightmapTexture = null, this._refractionTexture = null, this.ambientColor = new Tc(0, 0, 0), this.diffuseColor = new Tc(1, 1, 1), this.specularColor = new Tc(1, 1, 1), this.emissiveColor = new Tc(0, 0, 0), this.specularPower = 64, this._useAlphaFromDiffuseTexture = !1, this._useEmissiveAsIllumination = !1, this._linkEmissiveWithDiffuse = !1, this._useSpecularOverAlpha = !1, this._useReflectionOverAlpha = !1, this._disableLighting = !1, this._useObjectSpaceNormalMap = !1, this._useParallax = !1, this._useParallaxOcclusion = !1, this.parallaxScaleBias = .05, this._roughness = 0, this.indexOfRefraction = .98, this.invertRefractionY = !0, this.alphaCutOff = .4, this._useLightmapAsShadowmap = !1, this._useReflectionFresnelFromSpecular = !1, this._useGlossinessFromSpecularMapAlpha = !1, this._maxSimultaneousLights = 4, this._invertNormalMapX = !1, this._invertNormalMapY = !1, this._twoSidedLighting = !1, this._applyDecalMapAfterDetailMap = !1, this._shadersLoaded = !1, this._renderTargets = new pd(16), this._worldViewProjectionMatrix = Hc.Zero(), this._globalAmbientColor = new Tc(0, 0, 0), this._cacheHasRenderTargetTextures = !1, this._initShaderSourceAsync(s), this.detailMap = new Hv(this), this._attachImageProcessingConfiguration(null), this.prePassConfiguration = new Pv, this.getRenderTargetTextures = () => (this._renderTargets.reset(), e.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture), e.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && this._renderTargets.push(this._refractionTexture), this._eventInfo.renderTargets = this._renderTargets, this._callbackPluginEventFillRenderTargetTextures(this._eventInfo), this._renderTargets)
			}
			static get ColorGradingTextureEnabled() {
				return kv.ColorGradingTextureEnabled
			}
			static get OpacityTextureEnabled() {
				return kv.OpacityTextureEnabled
			}
			static set RefractionTextureEnabled(e) {
				kv.RefractionTextureEnabled = e
			}
			dispose(e, t) {
				t && (this._diffuseTexture?.dispose(), this._ambientTexture?.dispose(), this._opacityTexture?.dispose(), this._reflectionTexture?.dispose(), this._emissiveTexture?.dispose(), this._specularTexture?.dispose(), this._bumpTexture?.dispose(), this._lightmapTexture?.dispose(), this._refractionTexture?.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), super.dispose(e, t)
			}
			static set FresnelEnabled(e) {
				kv.FresnelEnabled = e
			}
			set cameraColorCurvesEnabled(e) {
				this.imageProcessingConfiguration.colorCurvesEnabled = e
			}
			static set EmissiveTextureEnabled(e) {
				kv.EmissiveTextureEnabled = e
			}
			get hasRenderTargetTextures() {
				return !!(e.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) || (!!(e.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) || this._cacheHasRenderTargetTextures)
			}
			static set DiffuseTextureEnabled(e) {
				kv.DiffuseTextureEnabled = e
			}
			static get BumpTextureEnabled() {
				return kv.BumpTextureEnabled
			}
			static set ColorGradingTextureEnabled(e) {
				kv.ColorGradingTextureEnabled = e
			}
			get cameraToneMappingEnabled() {
				return this._imageProcessingConfiguration.toneMappingEnabled
			}
			get cameraExposure() {
				return this._imageProcessingConfiguration.exposure
			}
			needAlphaBlending() {
				return !this._disableAlphaBlending && (this.alpha < 1 || null != this._opacityTexture || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled)
			}
			bindForSubMesh(t, i, s) {
				const n = this.getScene(),
					a = s.materialDefines;
				if (!a) return;
				const r = s.effect;
				if (!r) return;
				this._activeEffect = r, i.getMeshUniformBuffer().bindToEffect(r, "Mesh"), i.transferToEffect(t), this._uniformBuffer.bindToEffect(r, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, n, i, t, this.isFrozen), this._eventInfo.subMesh = s, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), a.OBJECTSPACE_NORMALMAP && (t.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));
				const o = this._mustRebind(n, r, s, i.visibility);
				df(i, r);
				const l = this._uniformBuffer;
				if (o) {
					if (this.bindViewProjection(r), !l.useUbo || !this.isFrozen || !l.isSync || s._drawWrapper._forceRebindOnNextCall) {
						if (e.FresnelEnabled && a.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (l.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), l.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && l.updateColor4("opacityParts", new Tc(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (l.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), l.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (l.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), l.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (l.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), l.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), n.texturesEnabled) {
							if (this._diffuseTexture && e.DiffuseTextureEnabled && (l.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), uf(this._diffuseTexture, l, "diffuse")), this._ambientTexture && e.AmbientTextureEnabled && (l.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), uf(this._ambientTexture, l, "ambient")), this._opacityTexture && e.OpacityTextureEnabled && (l.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), uf(this._opacityTexture, l, "opacity")), this._hasAlphaChannel() && l.updateFloat("alphaCutOff", this.alphaCutOff), this._reflectionTexture && e.ReflectionTextureEnabled && (l.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness), l.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) {
								const e = this._reflectionTexture;
								l.updateVector3("vReflectionPosition", e.boundingBoxPosition), l.updateVector3("vReflectionSize", e.boundingBoxSize)
							}
							if (this._emissiveTexture && e.EmissiveTextureEnabled && (l.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), uf(this._emissiveTexture, l, "emissive")), this._lightmapTexture && e.LightmapTextureEnabled && (l.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), uf(this._lightmapTexture, l, "lightmap")), this._specularTexture && e.SpecularTextureEnabled && (l.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level), uf(this._specularTexture, l, "specular")), this._bumpTexture && n.getEngine().getCaps().standardDerivatives && e.BumpTextureEnabled && (l.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), uf(this._bumpTexture, l, "bump"), n._mirroredCameraPosition ? l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && e.RefractionTextureEnabled) {
								let e = 1;
								if (this._refractionTexture.isCube || (l.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (e = this._refractionTexture.depth)), l.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, e, this.invertRefractionY ? -1 : 1), this._refractionTexture.boundingBoxSize) {
									const e = this._refractionTexture;
									l.updateVector3("vRefractionPosition", e.boundingBoxPosition), l.updateVector3("vRefractionSize", e.boundingBoxSize)
								}
							}
						}
						this.pointsCloud && l.updateFloat("pointSize", this.pointSize), a.SPECULARTERM && l.updateColor4("vSpecularColor", this.specularColor, this.specularPower), l.updateColor3("vEmissiveColor", e.EmissiveTextureEnabled ? this.emissiveColor : Tc.BlackReadOnly), l.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha), n.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), l.updateColor3("vAmbientColor", this._globalAmbientColor)
					}
					n.texturesEnabled && (this._diffuseTexture && e.DiffuseTextureEnabled && r.setTexture("diffuseSampler", this._diffuseTexture), this._ambientTexture && e.AmbientTextureEnabled && r.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && e.OpacityTextureEnabled && r.setTexture("opacitySampler", this._opacityTexture), this._reflectionTexture && e.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? r.setTexture("reflectionCubeSampler", this._reflectionTexture) : r.setTexture("reflection2DSampler", this._reflectionTexture)), this._emissiveTexture && e.EmissiveTextureEnabled && r.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && e.LightmapTextureEnabled && r.setTexture("lightmapSampler", this._lightmapTexture), this._specularTexture && e.SpecularTextureEnabled && r.setTexture("specularSampler", this._specularTexture), this._bumpTexture && n.getEngine().getCaps().standardDerivatives && e.BumpTextureEnabled && r.setTexture("bumpSampler", this._bumpTexture), this._refractionTexture && e.RefractionTextureEnabled && (this._refractionTexture.isCube ? r.setTexture("refractionCubeSampler", this._refractionTexture) : r.setTexture("refraction2DSampler", this._refractionTexture))), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(i) && this.getScene().depthPeelingRenderer.bind(r), this._eventInfo.subMesh = s, this._callbackPluginEventBindForSubMesh(this._eventInfo), Qd(r, this, n), this.bindEyePosition(r)
				} else n.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
				!o && this.isFrozen || (n.lightsEnabled && !this._disableLighting && pf(n, i, r, a, this._maxSimultaneousLights), (n.fogEnabled && i.applyFog && n.fogMode !== bg.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || i.receiveShadows || a.PREPASS) && this.bindView(r), nf(n, i, r), a.NUM_MORPH_INFLUENCERS && lf(i, r), a.BAKED_VERTEX_ANIMATION_TEXTURE && i.bakedVertexAnimationManager?.bind(r, a.INSTANCES), this.useLogarithmicDepth && sf(a, r, n), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._afterBind(i, this._activeEffect, s), l.update()
			}
			clone(t, i = !0, s = "") {
				const n = Xc.Clone((() => new e(t, this.getScene())), this, {
					cloneTexturesOnlyOnce: i
				});
				return n.name = t, n.id = t, this.stencil.copyTo(n.stencil), this._clonePlugins(n, s), n
			}
			get cameraColorCurvesEnabled() {
				return this.imageProcessingConfiguration.colorCurvesEnabled
			}
			getClassName() {
				return "StandardMaterial"
			}
			needAlphaTesting() {
				return !!this._forceAlphaTest || this._hasAlphaChannel() && (null == this._transparencyMode || this._transparencyMode === Pf.MATERIAL_ALPHATEST)
			}
			static set SpecularTextureEnabled(e) {
				kv.SpecularTextureEnabled = e
			}
			static get RefractionTextureEnabled() {
				return kv.RefractionTextureEnabled
			}
			set cameraColorGradingTexture(e) {
				this._imageProcessingConfiguration.colorGradingTexture = e
			}
			hasTexture(e) {
				return !!super.hasTexture(e) || (this._diffuseTexture === e || (this._ambientTexture === e || (this._opacityTexture === e || (this._reflectionTexture === e || (this._emissiveTexture === e || (this._specularTexture === e || (this._bumpTexture === e || (this._lightmapTexture === e || this._refractionTexture === e))))))))
			}
			get cameraContrast() {
				return this._imageProcessingConfiguration.contrast
			}
			static get SpecularTextureEnabled() {
				return kv.SpecularTextureEnabled
			}
			async _initShaderSourceAsync(t = !1) {
				const i = this.getScene().getEngine();
				!i.isWebGPU || t || e.ForceGLSL ? await Promise.all([Promise.resolve().then((() => (ya(), fa))), Promise.resolve().then((() => (Ua(), La)))]) : (this._uniformBuffer && this._uniformBuffer.dispose(), this._uniformBuffer = new Bd(i, void 0, void 0, this.name, !0), this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (wn(), xn))), Promise.resolve().then((() => (Kn(), zn)))])), this._shadersLoaded = !0
			}
			get cameraColorGradingEnabled() {
				return this.imageProcessingConfiguration.colorGradingEnabled
			}
			get cameraColorGradingTexture() {
				return this._imageProcessingConfiguration.colorGradingTexture
			}
			get isPrePassCapable() {
				return !this.disableDepthWrite
			}
			getActiveTextures() {
				const e = super.getActiveTextures();
				return this._diffuseTexture && e.push(this._diffuseTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._specularTexture && e.push(this._specularTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e
			}
			set cameraToneMappingEnabled(e) {
				this._imageProcessingConfiguration.toneMappingEnabled = e
			}
			static set OpacityTextureEnabled(e) {
				kv.OpacityTextureEnabled = e
			}
			_hasAlphaChannel() {
				return null != this._diffuseTexture && this._diffuseTexture.hasAlpha || null != this._opacityTexture
			}
			buildUniformLayout() {
				const e = this._uniformBuffer;
				e.addUniform("diffuseLeftColor", 4), e.addUniform("diffuseRightColor", 4), e.addUniform("opacityParts", 4), e.addUniform("reflectionLeftColor", 4), e.addUniform("reflectionRightColor", 4), e.addUniform("refractionLeftColor", 4), e.addUniform("refractionRightColor", 4), e.addUniform("emissiveLeftColor", 4), e.addUniform("emissiveRightColor", 4), e.addUniform("vDiffuseInfos", 2), e.addUniform("vAmbientInfos", 2), e.addUniform("vOpacityInfos", 2), e.addUniform("vReflectionInfos", 2), e.addUniform("vReflectionPosition", 3), e.addUniform("vReflectionSize", 3), e.addUniform("vEmissiveInfos", 2), e.addUniform("vLightmapInfos", 2), e.addUniform("vSpecularInfos", 2), e.addUniform("vBumpInfos", 3), e.addUniform("diffuseMatrix", 16), e.addUniform("ambientMatrix", 16), e.addUniform("opacityMatrix", 16), e.addUniform("reflectionMatrix", 16), e.addUniform("emissiveMatrix", 16), e.addUniform("lightmapMatrix", 16), e.addUniform("specularMatrix", 16), e.addUniform("bumpMatrix", 16), e.addUniform("vTangentSpaceParams", 2), e.addUniform("pointSize", 1), e.addUniform("alphaCutOff", 1), e.addUniform("refractionMatrix", 16), e.addUniform("vRefractionInfos", 4), e.addUniform("vRefractionPosition", 3), e.addUniform("vRefractionSize", 3), e.addUniform("vSpecularColor", 4), e.addUniform("vEmissiveColor", 3), e.addUniform("vDiffuseColor", 4), e.addUniform("vAmbientColor", 3), super.buildUniformLayout()
			}
		};
	Wv.ForceGLSL = !1, Gh([Yh("diffuseTexture")], Wv.prototype, "_diffuseTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesAndMiscDirty")], Wv.prototype, "diffuseTexture", void 0), Gh([Yh("ambientTexture")], Wv.prototype, "_ambientTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "ambientTexture", void 0), Gh([Yh("opacityTexture")], Wv.prototype, "_opacityTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesAndMiscDirty")], Wv.prototype, "opacityTexture", void 0), Gh([Yh("reflectionTexture")], Wv.prototype, "_reflectionTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "reflectionTexture", void 0), Gh([Yh("emissiveTexture")], Wv.prototype, "_emissiveTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "emissiveTexture", void 0), Gh([Yh("specularTexture")], Wv.prototype, "_specularTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "specularTexture", void 0), Gh([Yh("bumpTexture")], Wv.prototype, "_bumpTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "bumpTexture", void 0), Gh([Yh("lightmapTexture")], Wv.prototype, "_lightmapTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "lightmapTexture", void 0), Gh([Yh("refractionTexture")], Wv.prototype, "_refractionTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "refractionTexture", void 0), Gh([jh("ambient")], Wv.prototype, "ambientColor", void 0), Gh([jh("diffuse")], Wv.prototype, "diffuseColor", void 0), Gh([jh("specular")], Wv.prototype, "specularColor", void 0), Gh([jh("emissive")], Wv.prototype, "emissiveColor", void 0), Gh([Xh()], Wv.prototype, "specularPower", void 0), Gh([Xh("useAlphaFromDiffuseTexture")], Wv.prototype, "_useAlphaFromDiffuseTexture", void 0), Gh([zh("_markAllSubMeshesAsTexturesAndMiscDirty")], Wv.prototype, "useAlphaFromDiffuseTexture", void 0), Gh([Xh("useEmissiveAsIllumination")], Wv.prototype, "_useEmissiveAsIllumination", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useEmissiveAsIllumination", void 0), Gh([Xh("linkEmissiveWithDiffuse")], Wv.prototype, "_linkEmissiveWithDiffuse", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "linkEmissiveWithDiffuse", void 0), Gh([Xh("useSpecularOverAlpha")], Wv.prototype, "_useSpecularOverAlpha", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useSpecularOverAlpha", void 0), Gh([Xh("useReflectionOverAlpha")], Wv.prototype, "_useReflectionOverAlpha", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useReflectionOverAlpha", void 0), Gh([Xh("disableLighting")], Wv.prototype, "_disableLighting", void 0), Gh([zh("_markAllSubMeshesAsLightsDirty")], Wv.prototype, "disableLighting", void 0), Gh([Xh("useObjectSpaceNormalMap")], Wv.prototype, "_useObjectSpaceNormalMap", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useObjectSpaceNormalMap", void 0), Gh([Xh("useParallax")], Wv.prototype, "_useParallax", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useParallax", void 0), Gh([Xh("useParallaxOcclusion")], Wv.prototype, "_useParallaxOcclusion", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useParallaxOcclusion", void 0), Gh([Xh()], Wv.prototype, "parallaxScaleBias", void 0), Gh([Xh("roughness")], Wv.prototype, "_roughness", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "roughness", void 0), Gh([Xh()], Wv.prototype, "indexOfRefraction", void 0), Gh([Xh()], Wv.prototype, "invertRefractionY", void 0), Gh([Xh()], Wv.prototype, "alphaCutOff", void 0), Gh([Xh("useLightmapAsShadowmap")], Wv.prototype, "_useLightmapAsShadowmap", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useLightmapAsShadowmap", void 0), Gh([Kh("diffuseFresnelParameters")], Wv.prototype, "_diffuseFresnelParameters", void 0), Gh([zh("_markAllSubMeshesAsFresnelDirty")], Wv.prototype, "diffuseFresnelParameters", void 0), Gh([Kh("opacityFresnelParameters")], Wv.prototype, "_opacityFresnelParameters", void 0), Gh([zh("_markAllSubMeshesAsFresnelAndMiscDirty")], Wv.prototype, "opacityFresnelParameters", void 0), Gh([Kh("reflectionFresnelParameters")], Wv.prototype, "_reflectionFresnelParameters", void 0), Gh([zh("_markAllSubMeshesAsFresnelDirty")], Wv.prototype, "reflectionFresnelParameters", void 0), Gh([Kh("refractionFresnelParameters")], Wv.prototype, "_refractionFresnelParameters", void 0), Gh([zh("_markAllSubMeshesAsFresnelDirty")], Wv.prototype, "refractionFresnelParameters", void 0), Gh([Kh("emissiveFresnelParameters")], Wv.prototype, "_emissiveFresnelParameters", void 0), Gh([zh("_markAllSubMeshesAsFresnelDirty")], Wv.prototype, "emissiveFresnelParameters", void 0), Gh([Xh("useReflectionFresnelFromSpecular")], Wv.prototype, "_useReflectionFresnelFromSpecular", void 0), Gh([zh("_markAllSubMeshesAsFresnelDirty")], Wv.prototype, "useReflectionFresnelFromSpecular", void 0), Gh([Xh("useGlossinessFromSpecularMapAlpha")], Wv.prototype, "_useGlossinessFromSpecularMapAlpha", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "useGlossinessFromSpecularMapAlpha", void 0), Gh([Xh("maxSimultaneousLights")], Wv.prototype, "_maxSimultaneousLights", void 0), Gh([zh("_markAllSubMeshesAsLightsDirty")], Wv.prototype, "maxSimultaneousLights", void 0), Gh([Xh("invertNormalMapX")], Wv.prototype, "_invertNormalMapX", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "invertNormalMapX", void 0), Gh([Xh("invertNormalMapY")], Wv.prototype, "_invertNormalMapY", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "invertNormalMapY", void 0), Gh([Xh("twoSidedLighting")], Wv.prototype, "_twoSidedLighting", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], Wv.prototype, "twoSidedLighting", void 0), Gh([Xh("applyDecalMapAfterDetailMap")], Wv.prototype, "_applyDecalMapAfterDetailMap", void 0), Gh([zh("_markAllSubMeshesAsMiscDirty")], Wv.prototype, "applyDecalMapAfterDetailMap", void 0), cc("BABYLON.StandardMaterial", Wv), bg.DefaultMaterialFactory = e => new Wv("default material", e);
	var zv = class {
			get animationStarted() {
				return this._animationStarted
			}
			constructor() {
				this.width = 1, this.height = 1, this.angle = 0, this.invertU = !1, this.invertV = !1, this.isVisible = !0, this._animationStarted = !1, this._loopAnimation = !1, this._fromIndex = 0, this._toIndex = 0, this._delay = 0, this._direction = 1, this._time = 0, this._onBaseAnimationEnd = null, this.position = {
					x: 1,
					y: 1,
					z: 1
				}, this.color = {
					r: 1,
					g: 1,
					b: 1,
					a: 1
				}
			}
			get delay() {
				return Math.max(this._delay, 1)
			}
			stopAnimation() {
				this._animationStarted = !1
			}
			_animate(e) {
				this._animationStarted && (this._time += e, this._time > this._delay && (this._time = this._time % this._delay, this.cellIndex += this._direction, (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) && (this._loopAnimation ? this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex : (this.cellIndex = this._toIndex, this._animationStarted = !1, this._onBaseAnimationEnd && this._onBaseAnimationEnd()))))
			}
			get toIndex() {
				return this._toIndex
			}
			get fromIndex() {
				return this._fromIndex
			}
			playAnimation(e, t, i, s, n) {
				this._fromIndex = e, this._toIndex = t, this._loopAnimation = i, this._delay = s || 1, this._animationStarted = !0, this._onBaseAnimationEnd = n, e < t ? this._direction = 1 : (this._direction = -1, this._toIndex = e, this._fromIndex = t), this.cellIndex = e, this._time = 0
			}
			get loopAnimation() {
				return this._loopAnimation
			}
		},
		Xv = class e extends zv {
			getClassName() {
				return "Sprite"
			}
			set toIndex(e) {
				this.playAnimation(this._fromIndex, e, this._loopAnimation, this._delay, this._onAnimationEnd)
			}
			get fromIndex() {
				return this._fromIndex
			}
			playAnimation(e, t, i, s, n = null) {
				this._onAnimationEnd = n, super.playAnimation(e, t, i, s, this._endAnimation)
			}
			get loopAnimation() {
				return this._loopAnimation
			}
			set delay(e) {
				this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, e, this._onAnimationEnd)
			}
			set size(e) {
				this.width = e, this.height = e
			}
			serialize() {
				const e = {};
				return e.name = this.name, e.position = this.position.asArray(), e.color = this.color.asArray(), e.width = this.width, e.height = this.height, e.angle = this.angle, e.cellIndex = this.cellIndex, e.cellRef = this.cellRef, e.invertU = this.invertU, e.invertV = this.invertV, e.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating, e.isPickable = this.isPickable, e.isVisible = this.isVisible, e.useAlphaForPicking = this.useAlphaForPicking, e.animationStarted = this.animationStarted, e.fromIndex = this.fromIndex, e.toIndex = this.toIndex, e.loopAnimation = this.loopAnimation, e.delay = this.delay, e
			}
			get toIndex() {
				return this._toIndex
			}
			constructor(e, t) {
				super(), this.name = e, this.animations = new Array, this.isPickable = !1, this.useAlphaForPicking = !1, this.onDisposeObservable = new kc, this._onAnimationEnd = null, this._endAnimation = () => {
					this._onAnimationEnd && this._onAnimationEnd(), this.disposeWhenFinishedAnimating && this.dispose()
				}, this.color = new wc(1, 1, 1, 1), this.position = Lc.Zero(), this._manager = t, this._manager.sprites.push(this), this.ik = this._manager.scene.getUniqueId()
			}
			set loopAnimation(e) {
				this.playAnimation(this._fromIndex, this._toIndex, e, this._delay, this._onAnimationEnd)
			}
			static Parse(t, i) {
				const s = new e(t.name, i);
				return s.position = Lc.FromArray(t.position), s.color = wc.FromArray(t.color), s.width = t.width, s.height = t.height, s.angle = t.angle, s.cellIndex = t.cellIndex, s.cellRef = t.cellRef, s.invertU = t.invertU, s.invertV = t.invertV, s.disposeWhenFinishedAnimating = t.disposeWhenFinishedAnimating, s.isPickable = t.isPickable, s.isVisible = t.isVisible, s.useAlphaForPicking = t.useAlphaForPicking, s._fromIndex = t.fromIndex, s._toIndex = t.toIndex, s._loopAnimation = t.loopAnimation, s._delay = t.delay, t.animationStarted && s.playAnimation(s.fromIndex, s.toIndex, s.loopAnimation, s.delay), s
			}
			get delay() {
				return Math.max(this._delay, 1)
			}
			dispose() {
				for (let e = 0; e < this._manager.sprites.length; e++) this._manager.sprites[e] == this && this._manager.sprites.splice(e, 1);
				this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear()
			}
			set fromIndex(e) {
				this.playAnimation(e, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd)
			}
			get size() {
				return this.width
			}
			get manager() {
				return this._manager
			}
		},
		Yv = class e {
			static Transform(t, i) {
				const s = new e(new Lc(0, 0, 0), new Lc(0, 0, 0));
				return e.TransformToRef(t, i, s), s
			}
			clone() {
				return new e(this.origin.clone(), this.direction.clone(), this.length)
			}
			static Zero() {
				return new e(Lc.Zero(), Lc.Zero())
			}
			_comparePickingInfo(e, t) {
				return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0
			}
			intersectsBoxMinMax(t, i, s = 0) {
				const n = e._TmpVector3[0].copyFromFloats(t.x - s, t.y - s, t.z - s),
					a = e._TmpVector3[1].copyFromFloats(i.x + s, i.y + s, i.z + s);
				let r, o, l, h, c = 0,
					u = Number.MAX_VALUE;
				if (Math.abs(this.direction.x) < 1e-7) {
					if (this.origin.x < n.x || this.origin.x > a.x) return !1
				} else if (r = 1 / this.direction.x, o = (n.x - this.origin.x) * r, l = (a.x - this.origin.x) * r, l === -1 / 0 && (l = 1 / 0), o > l && (h = o, o = l, l = h), c = Math.max(o, c), u = Math.min(l, u), c > u) return !1;
				if (Math.abs(this.direction.y) < 1e-7) {
					if (this.origin.y < n.y || this.origin.y > a.y) return !1
				} else if (r = 1 / this.direction.y, o = (n.y - this.origin.y) * r, l = (a.y - this.origin.y) * r, l === -1 / 0 && (l = 1 / 0), o > l && (h = o, o = l, l = h), c = Math.max(o, c), u = Math.min(l, u), c > u) return !1;
				if (Math.abs(this.direction.z) < 1e-7) {
					if (this.origin.z < n.z || this.origin.z > a.z) return !1
				} else if (r = 1 / this.direction.z, o = (n.z - this.origin.z) * r, l = (a.z - this.origin.z) * r, l === -1 / 0 && (l = 1 / 0), o > l && (h = o, o = l, l = h), c = Math.max(o, c), u = Math.min(l, u), c > u) return !1;
				return !0
			}
			unprojectRayToRef(e, t, i, s, n, a, r) {
				const o = Vc.Matrix[0];
				n.multiplyToRef(a, o), o.multiplyToRef(r, o), o.invert();
				const l = Dc.LastCreatedEngine,
					h = Vc.Vector3[0];
				h.x = e / i * 2 - 1, h.y = -(t / s * 2 - 1), h.z = l?.useReverseDepthBuffer ? 1 : l?.isNDCHalfZRange ? 0 : -1;
				const c = Vc.Vector3[1].copyFromFloats(h.x, h.y, 1 - 1e-8),
					u = Vc.Vector3[2],
					m = Vc.Vector3[3];
				Lc._UnprojectFromInvertedMatrixToRef(h, o, u), Lc._UnprojectFromInvertedMatrixToRef(c, o, m), this.origin.copyFrom(u), m.subtractToRef(u, this.direction), this.direction.normalize()
			}
			intersectionSegment(t, i, s) {
				const n = this.origin,
					a = Vc.Vector3[0],
					r = Vc.Vector3[1],
					o = Vc.Vector3[2],
					l = Vc.Vector3[3];
				i.subtractToRef(t, a), this.direction.scaleToRef(e._Rayl, o), n.addToRef(o, r), t.subtractToRef(n, l);
				const h = Lc.Dot(a, a),
					c = Lc.Dot(a, o),
					u = Lc.Dot(o, o),
					m = Lc.Dot(a, l),
					d = Lc.Dot(o, l),
					f = h * u - c * c;
				let p, _, g = f,
					v = f;
				f < e._Smallnum ? (p = 0, g = 1, _ = d, v = u) : (p = c * d - u * m, _ = h * d - c * m, p < 0 ? (p = 0, _ = d, v = u) : p > g && (p = g, _ = d + c, v = u)), _ < 0 ? (_ = 0, -m < 0 ? p = 0 : -m > h ? p = g : (p = -m, g = h)) : _ > v && (_ = v, -m + c < 0 ? p = 0 : -m + c > h ? p = g : (p = -m + c, g = h));
				const y = Math.abs(p) < e._Smallnum ? 0 : p / g,
					S = Math.abs(_) < e._Smallnum ? 0 : _ / v,
					E = Vc.Vector3[4];
				o.scaleToRef(S, E);
				const A = Vc.Vector3[5];
				a.scaleToRef(y, A), A.addInPlace(l);
				const b = Vc.Vector3[6];
				A.subtractToRef(E, b);
				return S > 0 && S <= this.length && b.lengthSquared() < s * s ? A.length() : -1
			}
			static CreateFromToToRef(t, i, s, n = Hc.IdentityReadOnly) {
				s.origin.copyFrom(t);
				const a = i.subtractToRef(t, s.direction),
					r = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
				return s.length = r, s.direction.normalize(), e.TransformToRef(s, n, s)
			}
			static TransformToRef(e, t, i) {
				Lc.TransformCoordinatesToRef(e.origin, t, i.origin), Lc.TransformNormalToRef(e.direction, t, i.direction), i.length = e.length, i.epsilon = e.epsilon;
				const s = i.direction,
					n = s.length();
				if (0 !== n && 1 !== n) {
					const e = 1 / n;
					s.x *= e, s.y *= e, s.z *= e, i.length *= n
				}
				return i
			}
			intersectsMesh(t, i, s, n = !1, a, r = !1) {
				const o = Vc.Matrix[0];
				return t.getWorldMatrix().invertToRef(o), this._tmpRay ? e.TransformToRef(this, o, this._tmpRay) : this._tmpRay = e.Transform(this, o), t.intersects(this._tmpRay, i, s, n, a, r)
			}
			static CreateNewFromTo(t, i, s = Hc.IdentityReadOnly) {
				const n = new e(new Lc(0, 0, 0), new Lc(0, 0, 0));
				return e.CreateFromToToRef(t, i, n, s)
			}
			intersectsTriangle(t, i, s) {
				const n = e._TmpVector3[0],
					a = e._TmpVector3[1],
					r = e._TmpVector3[2],
					o = e._TmpVector3[3],
					l = e._TmpVector3[4];
				i.subtractToRef(t, n), s.subtractToRef(t, a), Lc.CrossToRef(this.direction, a, r);
				const h = Lc.Dot(n, r);
				if (0 === h) return null;
				const c = 1 / h;
				this.origin.subtractToRef(t, o);
				const u = Lc.Dot(o, r) * c;
				if (u < -this.epsilon || u > 1 + this.epsilon) return null;
				Lc.CrossToRef(o, n, l);
				const m = Lc.Dot(this.direction, l) * c;
				if (m < -this.epsilon || u + m > 1 + this.epsilon) return null;
				const d = Lc.Dot(a, l) * c;
				return d > this.length ? null : new mu(1 - u - m, u, d)
			}
			update(t, i, s, n, a, r, o, l = !1) {
				if (l) {
					e._RayDistant || (e._RayDistant = e.Zero()), e._RayDistant.unprojectRayToRef(t, i, s, n, Hc.IdentityReadOnly, r, o);
					const l = Vc.Matrix[0];
					a.invertToRef(l), e.TransformToRef(e._RayDistant, l, this)
				} else this.unprojectRayToRef(t, i, s, n, a, r, o);
				return this
			}
			intersectsBox(e, t = 0) {
				return this.intersectsBoxMinMax(e.minimum, e.maximum, t)
			}
			intersectsAxis(e, t = 0) {
				switch (e) {
					case "y": {
						const e = (this.origin.y - t) / this.direction.y;
						return e > 0 ? null : new Lc(this.origin.x + this.direction.x * -e, t, this.origin.z + this.direction.z * -e)
					}
					case "x": {
						const e = (this.origin.x - t) / this.direction.x;
						return e > 0 ? null : new Lc(t, this.origin.y + this.direction.y * -e, this.origin.z + this.direction.z * -e)
					}
					case "z": {
						const e = (this.origin.z - t) / this.direction.z;
						return e > 0 ? null : new Lc(this.origin.x + this.direction.x * -e, this.origin.y + this.direction.y * -e, t)
					}
					default:
						return null
				}
			}
			static CreateNew(t, i, s, n, a, r, o) {
				return e.Zero().update(t, i, s, n, a, r, o)
			}
			intersectsSphere(e, t = 0) {
				const i = e.center.x - this.origin.x,
					s = e.center.y - this.origin.y,
					n = e.center.z - this.origin.z,
					a = i * i + s * s + n * n,
					r = e.radius + t,
					o = r * r;
				if (a <= o) return !0;
				const l = i * this.direction.x + s * this.direction.y + n * this.direction.z;
				if (l < 0) return !1;
				return a - l * l <= o
			}
			intersectsPlane(e) {
				let t;
				const i = Lc.Dot(e.normal, this.direction);
				if (Math.abs(i) < 9.99999997475243e-7) return null;
				{
					const s = Lc.Dot(e.normal, this.origin);
					return t = (-e.d - s) / i, t < 0 ? t < -9.99999997475243e-7 ? null : 0 : t
				}
			}
			intersectsMeshes(e, t, i) {
				i ? i.length = 0 : i = [];
				for (let s = 0; s < e.length; s++) {
					const n = this.intersectsMesh(e[s], t);
					n.hit && i.push(n)
				}
				return i.sort(this._comparePickingInfo), i
			}
			constructor(e, t, i = Number.MAX_VALUE, s = .001) {
				this.origin = e, this.direction = t, this.length = i, this.epsilon = s
			}
		};
	Yv._TmpVector3 = ac(6, Lc.Zero), Yv._RayDistant = Yv.Zero(), Yv._Smallnum = 1e-8, Yv._Rayl = 1e9, bg.prototype.createPickingRay = function(e, t, i, s, n = !1) {
		const a = Yv.Zero();
		return this.createPickingRayToRef(e, t, i, a, s, n), a
	}, bg.prototype.createPickingRayToRef = function(e, t, i, s, n, a = !1, r = !1) {
		const o = this.getEngine();
		if (!n && !(n = this.activeCamera)) return this;
		const l = n.viewport,
			h = o.getRenderHeight(),
			{
				x: c,
				y: u,
				width: m,
				height: d
			} = l.toGlobal(o.getRenderWidth(), h),
			f = 1 / o.getHardwareScalingLevel();
		return e = e * f - c, t = t * f - (h - u - d), s.update(e, t, m, d, i || Hc.IdentityReadOnly, a ? Hc.IdentityReadOnly : n.getViewMatrix(), n.getProjectionMatrix(), r), this
	}, bg.prototype.createPickingRayInCameraSpace = function(e, t, i) {
		const s = Yv.Zero();
		return this.createPickingRayInCameraSpaceToRef(e, t, s, i), s
	}, bg.prototype.createPickingRayInCameraSpaceToRef = function(e, t, i, s) {
		if (!Ld) return this;
		const n = this.getEngine();
		if (!s && !(s = this.activeCamera)) throw new Error("Active camera not set");
		const a = s.viewport,
			r = n.getRenderHeight(),
			{
				x: o,
				y: l,
				width: h,
				height: c
			} = a.toGlobal(n.getRenderWidth(), r),
			u = Hc.Identity(),
			m = 1 / n.getHardwareScalingLevel();
		return e = e * m - o, t = t * m - (r - l - c), i.update(e, t, h, c, u, u, s.getProjectionMatrix()), this
	}, bg.prototype._internalPickForMesh = function(e, t, i, s, n, a, r, o) {
		const l = t(s, i.enableDistantPicking),
			h = i.intersects(l, n, r, a, s, o);
		return h && h.hit ? !n && null != e && h.distance >= e.distance ? null : h : null
	}, bg.prototype._internalPick = function(e, t, i, s, n) {
		let a = null;
		const r = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera),
			o = this.cameraToUseForPointers || this.activeCamera;
		for (let l = 0; l < this.meshes.length; l++) {
			const h = this.meshes[l];
			if (t) {
				if (!t(h)) continue
			} else if (!h.isEnabled() || !h.isVisible || !h.isPickable) continue;
			const c = r && h.isWorldMatrixCameraDependent(),
				u = h.computeWorldMatrix(c, o);
			if (h.hasThinInstances && h.thinInstanceEnablePicking) {
				const t = this._internalPickForMesh(a, e, h, u, !0, !0, n);
				if (t) {
					if (s) return t;
					const r = Vc.Matrix[1],
						o = h.thinInstanceGetWorldMatrices();
					for (let t = 0; t < o.length; t++) {
						o[t].multiplyToRef(u, r);
						const l = this._internalPickForMesh(a, e, h, r, i, s, n, !0);
						if (l && (a = l, a.thinInstanceIndex = t, i)) return a
					}
				}
			} else {
				const t = this._internalPickForMesh(a, e, h, u, i, s, n);
				if (t && (a = t, i)) return a
			}
		}
		return a || new Ld
	}, bg.prototype._internalMultiPick = function(e, t, i) {
		if (!Ld) return null;
		const s = [],
			n = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera),
			a = this.cameraToUseForPointers || this.activeCamera;
		for (let r = 0; r < this.meshes.length; r++) {
			const o = this.meshes[r];
			if (t) {
				if (!t(o)) continue
			} else if (!o.isEnabled() || !o.isVisible || !o.isPickable) continue;
			const l = n && o.isWorldMatrixCameraDependent(),
				h = o.computeWorldMatrix(l, a);
			if (o.hasThinInstances && o.thinInstanceEnablePicking) {
				if (this._internalPickForMesh(null, e, o, h, !0, !0, i)) {
					const t = Vc.Matrix[1],
						n = o.thinInstanceGetWorldMatrices();
					for (let a = 0; a < n.length; a++) {
						n[a].multiplyToRef(h, t);
						const r = this._internalPickForMesh(null, e, o, t, !1, !1, i, !0);
						r && (r.thinInstanceIndex = a, s.push(r))
					}
				}
			} else {
				const t = this._internalPickForMesh(null, e, o, h, !1, !1, i);
				t && s.push(t)
			}
		}
		return s
	}, bg.prototype.pickWithBoundingInfo = function(e, t, i, s, n) {
		if (!Ld) return null;
		const a = this._internalPick((i => (this._tempPickingRay || (this._tempPickingRay = Yv.Zero()), this.createPickingRayToRef(e, t, i, this._tempPickingRay, n || null), this._tempPickingRay)), i, s, !0);
		return a && (a.ray = this.createPickingRay(e, t, Hc.Identity(), n || null)), a
	}, Object.defineProperty(bg.prototype, "_pickingAvailable", {
		get: () => !0,
		enumerable: !1,
		configurable: !1
	}), bg.prototype.pick = function(e, t, i, s, n, a, r = !1) {
		const o = this._internalPick(((i, s) => (this._tempPickingRay || (this._tempPickingRay = Yv.Zero()), this.createPickingRayToRef(e, t, i, this._tempPickingRay, n || null, !1, s), this._tempPickingRay)), i, s, !1, a);
		return o && (o.ray = this.createPickingRay(e, t, Hc.Identity(), n || null)), o
	}, bg.prototype.pickWithRay = function(e, t, i, s) {
		const n = this._internalPick((t => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = Hc.Identity()), t.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = Yv.Zero()), Yv.TransformToRef(e, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform)), t, i, !1, s);
		return n && (n.ray = e), n
	}, bg.prototype.multiPick = function(e, t, i, s, n) {
		return this._internalMultiPick((i => this.createPickingRay(e, t, i, s || null)), i, n)
	}, bg.prototype.multiPickWithRay = function(e, t, i) {
		return this._internalMultiPick((t => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = Hc.Identity()), t.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = Yv.Zero()), Yv.TransformToRef(e, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform)), t, i)
	}, Sd.prototype.getForwardRay = function(e = 100, t, i) {
		return this.getForwardRayToRef(new Yv(Lc.Zero(), Lc.Zero(), e), e, t, i)
	}, Sd.prototype.getForwardRayToRef = function(e, t = 100, i, s) {
		i || (i = this.getWorldMatrix()), e.length = t, s ? e.origin.copyFrom(s) : e.origin.copyFrom(this.position);
		const n = Vc.Vector3[2];
		n.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
		const a = Vc.Vector3[3];
		return Lc.TransformNormalToRef(n, i, a), Lc.NormalizeToRef(a, e.direction), e
	}, bg.prototype._internalPickSprites = function(e, t, i, s) {
		if (!Ld) return null;
		let n = null;
		if (!s) {
			if (!this.activeCamera) return null;
			s = this.activeCamera
		}
		if (this.spriteManagers && this.spriteManagers.length > 0)
			for (let a = 0; a < this.spriteManagers.length; a++) {
				const r = this.spriteManagers[a];
				if (!r.isPickable) continue;
				const o = r.intersects(e, s, t, i);
				if (o && o.hit && ((i || null == n || !(o.distance >= n.distance)) && (n = o, i))) break
			}
		return n || new Ld
	}, bg.prototype._internalMultiPickSprites = function(e, t, i) {
		if (!Ld) return null;
		let s = [];
		if (!i) {
			if (!this.activeCamera) return null;
			i = this.activeCamera
		}
		if (this.spriteManagers && this.spriteManagers.length > 0)
			for (let n = 0; n < this.spriteManagers.length; n++) {
				const a = this.spriteManagers[n];
				if (!a.isPickable) continue;
				const r = a.multiIntersects(e, i, t);
				null !== r && (s = s.concat(r))
			}
		return s
	}, bg.prototype.pickSprite = function(e, t, i, s, n) {
		if (!this._tempSpritePickingRay) return null;
		this.createPickingRayInCameraSpaceToRef(e, t, this._tempSpritePickingRay, n);
		const a = this._internalPickSprites(this._tempSpritePickingRay, i, s, n);
		return a && (a.ray = this.createPickingRayInCameraSpace(e, t, n)), a
	}, bg.prototype.pickSpriteWithRay = function(e, t, i, s) {
		if (!this._tempSpritePickingRay) return null;
		if (!s) {
			if (!this.activeCamera) return null;
			s = this.activeCamera
		}
		Yv.TransformToRef(e, s.getViewMatrix(), this._tempSpritePickingRay);
		const n = this._internalPickSprites(this._tempSpritePickingRay, t, i, s);
		return n && (n.ray = e), n
	}, bg.prototype.multiPickSprite = function(e, t, i, s) {
		return this.createPickingRayInCameraSpaceToRef(e, t, this._tempSpritePickingRay, s), this._internalMultiPickSprites(this._tempSpritePickingRay, i, s)
	}, bg.prototype.multiPickSpriteWithRay = function(e, t, i) {
		if (!this._tempSpritePickingRay) return null;
		if (!i) {
			if (!this.activeCamera) return null;
			i = this.activeCamera
		}
		return Yv.TransformToRef(e, i.getViewMatrix(), this._tempSpritePickingRay), this._internalMultiPickSprites(this._tempSpritePickingRay, t, i)
	}, bg.prototype.setPointerOverSprite = function(e) {
		this._pointerOverSprite !== e && (this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(10, G_.CreateNewFromSprite(this._pointerOverSprite, this)), this._pointerOverSprite = e, this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(9, G_.CreateNewFromSprite(this._pointerOverSprite, this)))
	}, bg.prototype.getPointerOverSprite = function() {
		return this._pointerOverSprite
	};
	var jv = class {
			_pointerUp(e, t, i, s, n) {
				const a = this.scene;
				if (a.spriteManagers && a.spriteManagers.length > 0) {
					const i = a.pickSprite(e, t, this._spritePredicate, !1, a.cameraToUseForPointers || void 0);
					i && (i.hit && i.pickedSprite && i.pickedSprite.actionManager && (i.pickedSprite.actionManager.processTrigger(7, G_.CreateNewFromSprite(i.pickedSprite, a, s)), i.pickedSprite.actionManager && (this.scene._inputManager._isPointerSwiping() || i.pickedSprite.actionManager.processTrigger(1, G_.CreateNewFromSprite(i.pickedSprite, a, s)), n && i.pickedSprite.actionManager.processTrigger(6, G_.CreateNewFromSprite(i.pickedSprite, a, s)))), a._pickedDownSprite && a._pickedDownSprite.actionManager && a._pickedDownSprite !== i.pickedSprite && a._pickedDownSprite.actionManager.processTrigger(16, G_.CreateNewFromSprite(a._pickedDownSprite, a, s)))
				}
				return i
			}
			_pointerDown(e, t, i, s) {
				const n = this.scene;
				if (n._pickedDownSprite = null, n.spriteManagers && n.spriteManagers.length > 0 && (i = n.pickSprite(e, t, this._spritePredicate, !1, n.cameraToUseForPointers || void 0)) && i.hit && i.pickedSprite && i.pickedSprite.actionManager) {
					switch (n._pickedDownSprite = i.pickedSprite, s.button) {
						case 0:
							i.pickedSprite.actionManager.processTrigger(2, G_.CreateNewFromSprite(i.pickedSprite, n, s));
							break;
						case 1:
							i.pickedSprite.actionManager.processTrigger(4, G_.CreateNewFromSprite(i.pickedSprite, n, s));
							break;
						case 2:
							i.pickedSprite.actionManager.processTrigger(3, G_.CreateNewFromSprite(i.pickedSprite, n, s))
					}
					i.pickedSprite.actionManager && i.pickedSprite.actionManager.processTrigger(5, G_.CreateNewFromSprite(i.pickedSprite, n, s))
				}
				return i
			}
			_pickSpriteButKeepRay(e, t, i, s, n) {
				const a = this.scene.pickSprite(t, i, this._spritePredicate, s, n);
				return a && (a.ray = e ? e.ray : null), a
			}
			_pointerMove(e, t, i, s, n) {
				const a = this.scene;
				return s ? a.setPointerOverSprite(null) : (i = this._pickSpriteButKeepRay(i, e, t, !1, a.cameraToUseForPointers || void 0)) && i.hit && i.pickedSprite ? (a.setPointerOverSprite(i.pickedSprite), !a.doNotHandleCursors && n && (a._pointerOverSprite && a._pointerOverSprite.actionManager && a._pointerOverSprite.actionManager.hoverCursor ? n.style.cursor = a._pointerOverSprite.actionManager.hoverCursor : n.style.cursor = a.hoverCursor)) : a.setPointerOverSprite(null), i
			}
			constructor(e) {
				this.name = Df.NAME_SPRITE, this.scene = e, this.scene.spriteManagers = [], this.scene._tempSpritePickingRay = Yv ? Yv.Zero() : null, this.scene.onBeforeSpritesRenderingObservable = new kc, this.scene.onAfterSpritesRenderingObservable = new kc, this._spritePredicate = e => !!e.actionManager && (e.isPickable && e.actionManager.hasPointerTriggers)
			}
			rebuild() {}
			dispose() {
				this.scene.onBeforeSpritesRenderingObservable.clear(), this.scene.onAfterSpritesRenderingObservable.clear();
				const e = this.scene.spriteManagers;
				if (e)
					for (; e.length;) e[0].dispose()
			}
			register() {
				this.scene._pointerMoveStage.registerStep(Df.STEP_POINTERMOVE_SPRITE, this, this._pointerMove), this.scene._pointerDownStage.registerStep(Df.STEP_POINTERDOWN_SPRITE, this, this._pointerDown), this.scene._pointerUpStage.registerStep(Df.STEP_POINTERUP_SPRITE, this, this._pointerUp)
			}
		},
		Kv = class e {
			async _initShaderSourceAsync() {
				this._engine.isWebGPU && !e.ForceGLSL ? (this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (Ya(), Va))), Promise.resolve().then((() => (Qa(), Ka)))])) : await Promise.all([Promise.resolve().then((() => (sr(), Za))), Promise.resolve().then((() => (hr(), ar)))]), this._shadersLoaded = !0, this._createEffects()
			}
			dispose() {
				this._buffer && (this._buffer.dispose(), this._buffer = null), this._spriteBuffer && (this._spriteBuffer.dispose(), this._spriteBuffer = null), this._indexBuffer && (this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this._vertexArrayObject && (this._engine.releaseVertexArrayObject(this._vertexArrayObject), this._vertexArrayObject = null), this.texture && (this.texture.dispose(), this.texture = null), this._drawWrapperBase.dispose(), this._drawWrapperDepth.dispose()
			}
			_createEffects() {
				this._drawWrapperBase?.dispose(), this._drawWrapperDepth?.dispose(), this._drawWrapperBase = new Au(this._engine), this._drawWrapperDepth = new Au(this._engine, !1), this._drawWrapperBase.drawContext && (this._drawWrapperBase.drawContext.useInstancing = this._useInstancing), this._drawWrapperDepth.drawContext && (this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing);
				let e = "";
				this._pixelPerfect && (e += "#define PIXEL_PERFECT\n"), this._scene && this._scene.fogEnabled && 0 !== this._scene.fogMode && this._fogEnabled && (e += "#define FOG\n"), this._useLogarithmicDepth && (e += "#define LOGARITHMICDEPTH\n"), this._drawWrapperBase.effect = this._engine.createEffect("sprites", [eu.PositionKind, "options", "offsets", "inverts", "cellInfo", eu.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor", "logarithmicDepthConstant"], ["diffuseSampler"], e, void 0, void 0, void 0, void 0, this._shaderLanguage), this._drawWrapperDepth.effect = this._drawWrapperBase.effect, this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext
			}
			_appendSpriteVertex(e, t, i, s, n, a, r) {
				let o = e * this._vertexBufferSize;
				if (0 === i ? i = this._epsilon : 1 === i && (i = 1 - this._epsilon), 0 === s ? s = this._epsilon : 1 === s && (s = 1 - this._epsilon), r) r(t, n);
				else {
					t.cellIndex || (t.cellIndex = 0);
					const e = n.width / this.cellWidth,
						i = t.cellIndex / e | 0;
					t._xOffset = (t.cellIndex - i * e) * this.cellWidth / n.width, t._yOffset = i * this.cellHeight / n.height, t._xSize = this.cellWidth, t._ySize = this.cellHeight
				}
				this._vertexData[o] = t.position.x, this._vertexData[o + 1] = t.position.y, this._vertexData[o + 2] = t.position.z, this._vertexData[o + 3] = t.angle, this._vertexData[o + 4] = t.width, this._vertexData[o + 5] = t.height, this._useInstancing ? o -= 2 : (this._vertexData[o + 6] = i, this._vertexData[o + 7] = s), this._vertexData[o + 8] = a ? t.invertU ? 0 : 1 : t.invertU ? 1 : 0, this._vertexData[o + 9] = t.invertV ? 1 : 0, this._vertexData[o + 10] = t._xOffset, this._vertexData[o + 11] = t._yOffset, this._vertexData[o + 12] = t._xSize / n.width, this._vertexData[o + 13] = t._ySize / n.height, this._vertexData[o + 14] = t.color.r, this._vertexData[o + 15] = t.color.g, this._vertexData[o + 16] = t.color.b, this._vertexData[o + 17] = t.color.a
			}
			get shaderLanguage() {
				return this._shaderLanguage
			}
			set pixelPerfect(e) {
				this._pixelPerfect !== e && (this._pixelPerfect = e, this._createEffects())
			}
			get pixelPerfect() {
				return this._pixelPerfect
			}
			set fogEnabled(e) {
				this._fogEnabled !== e && (this._fogEnabled = e, this._createEffects())
			}
			get useLogarithmicDepth() {
				return this._useLogarithmicDepth
			}
			rebuild() {
				this._indexBuffer && this._buildIndexBuffer(), this._useVAO && (this._vertexArrayObject = void 0), this._buffer._rebuild();
				for (const e in this._vertexBuffers) {
					this._vertexBuffers[e]._rebuild()
				}
				this._spriteBuffer?._rebuild()
			}
			get fogEnabled() {
				return this._fogEnabled
			}
			get Yk() {
				return this._capacity
			}
			constructor(e, t, i = .01, s = null) {
				this.blendMode = 2, this.autoResetAlpha = !0, this.disableDepthWrite = !1, this._fogEnabled = !0, this._pixelPerfect = !1, this._shaderLanguage = 0, this._useVAO = !1, this._useInstancing = !1, this._vertexBuffers = {}, this._shadersLoaded = !1, this._capacity = t, this._epsilon = i, this._engine = e, this._useInstancing = e.getCaps().instancedArrays && e._features.supportSpriteInstancing, this._useVAO = e.getCaps().vertexArrayObject && !e.disableVertexArrayObjects, this._scene = s, this._useInstancing || this._buildIndexBuffer(), this._vertexBufferSize = this._useInstancing ? 16 : 18, this._vertexData = new Float32Array(t * this._vertexBufferSize * (this._useInstancing ? 1 : 4)), this._buffer = new Zc(e, this._vertexData, !0, this._vertexBufferSize);
				const n = this._buffer.createVertexBuffer(eu.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing),
					a = this._buffer.createVertexBuffer("options", 4, 2, this._vertexBufferSize, this._useInstancing);
				let r, o = 6;
				if (this._useInstancing) {
					const t = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
					this._spriteBuffer = new Zc(e, t, !1, 2), r = this._spriteBuffer.createVertexBuffer("offsets", 0, 2)
				} else r = this._buffer.createVertexBuffer("offsets", o, 2, this._vertexBufferSize, this._useInstancing), o += 2;
				const l = this._buffer.createVertexBuffer("inverts", o, 2, this._vertexBufferSize, this._useInstancing),
					h = this._buffer.createVertexBuffer("cellInfo", o + 2, 4, this._vertexBufferSize, this._useInstancing),
					c = this._buffer.createVertexBuffer(eu.ColorKind, o + 6, 4, this._vertexBufferSize, this._useInstancing);
				this._vertexBuffers[eu.PositionKind] = n, this._vertexBuffers.options = a, this._vertexBuffers.offsets = r, this._vertexBuffers.inverts = l, this._vertexBuffers.cellInfo = h, this._vertexBuffers[eu.ColorKind] = c, this._initShaderSourceAsync()
			}
			render(e, t, i, s, n = null) {
				if (!(this._shadersLoaded && this.texture && this.texture.isReady() && e.length)) return;
				const a = this._drawWrapperBase,
					r = this._drawWrapperDepth,
					o = this.fogEnabled && this._scene && this._scene.fogEnabled && 0 !== this._scene.fogMode,
					l = a.effect;
				if (!l.isReady()) return;
				const h = this._engine,
					c = !(!this._scene || !this._scene.useRightHandedSystem),
					u = this.texture.getBaseSize(),
					m = Math.min(this._capacity, e.length);
				let d = 0,
					f = !0;
				for (let i = 0; i < m; i++) {
					const s = e[i];
					s && s.isVisible && (f = !1, s._animate(t), this._appendSpriteVertex(d++, s, 0, 0, u, c, n), this._useInstancing || (this._appendSpriteVertex(d++, s, 1, 0, u, c, n), this._appendSpriteVertex(d++, s, 1, 1, u, c, n), this._appendSpriteVertex(d++, s, 0, 1, u, c, n)))
				}
				if (f) return;
				this._buffer.update(this._vertexData);
				const p = !!h.depthCullingState.cull,
					_ = h.depthCullingState.zOffset,
					g = h.depthCullingState.zOffsetUnits;
				if (h.setState(p, _, !1, !1, void 0, void 0, g), h.enableEffect(a), l.setTexture("diffuseSampler", this.texture), l.setMatrix("view", i), l.setMatrix("projection", s), o) {
					const e = this._scene;
					l.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), l.setColor3("vFogColor", e.fogColor)
				}
				this.useLogarithmicDepth && this._scene && sf(a.defines, l, this._scene), this._useVAO ? (this._vertexArrayObject || (this._vertexArrayObject = h.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, l)), h.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer)) : h.bindBuffers(this._vertexBuffers, this._indexBuffer, l), h.depthCullingState.depthFunc = h.useReverseDepthBuffer ? 518 : 515, this.disableDepthWrite || (l.setBool("alphaTest", !0), h.setColorWrite(!1), h.enableEffect(r), this._useInstancing ? h.drawArraysType(7, 0, 4, d) : h.drawElementsType(0, 0, d / 4 * 6), h.enableEffect(a), h.setColorWrite(!0), l.setBool("alphaTest", !1)), h.setAlphaMode(this.blendMode), this._useInstancing ? h.drawArraysType(7, 0, 4, d) : h.drawElementsType(0, 0, d / 4 * 6), this.autoResetAlpha && h.setAlphaMode(0), c && this._scene.getEngine().setState(p, _, !1, !0, void 0, void 0, g), h.unbindInstanceAttributes()
			}
			set useLogarithmicDepth(e) {
				const t = !!this._scene?.getEngine().getCaps().fragmentDepthSupported;
				e && !t && Qc.Warn("Logarithmic depth has been requested for a sprite renderer on a device that doesn't support it."), this._useLogarithmicDepth = e && t, this._createEffects()
			}
			_buildIndexBuffer() {
				const e = [];
				let t = 0;
				for (let i = 0; i < this._capacity; i++) e.push(t), e.push(t + 1), e.push(t + 2), e.push(t), e.push(t + 2), e.push(t + 3), t += 4;
				this._indexBuffer = this._engine.createIndexBuffer(e)
			}
		};
	Kv.ForceGLSL = !1;
	var $v = class e {
		get disableDepthWrite() {
			return this._disableDepthWrite
		}
		get children() {
			return this.sprites
		}
		static ParseFromSnippetAsync(t, i, s = "") {
			return "_BLANK" === t ? Promise.resolve(new e("Default sprite manager", "//playground.babylonjs.com/textures/player.png", 500, 64, i)) : new Promise(((n, a) => {
				const r = new ku;
				r.addEventListener("readystatechange", (() => {
					if (4 == r.readyState)
						if (200 == r.status) {
							const a = JSON.parse(JSON.parse(r.responseText).jsonPayload),
								o = JSON.parse(a.spriteManager),
								l = e.Parse(o, i || Dc.LastCreatedScene, s);
							l.snippetId = t, n(l)
						} else a("Unable to load the snippet " + t)
				})), r.open("GET", this.SnippetUrl + "/" + t.replace(/#/g, "/")), r.send()
			}))
		}
		set fogEnabled(e) {
			this._spriteRenderer.fogEnabled = e
		}
		constructor(e, t, i, s, n, a = .01, r = Np.TRILINEAR_SAMPLINGMODE, o = !1, l = null) {
			this.name = e, this.sprites = [], this.Lk = 0, this.layerMask = 268435455, this.isPickable = !1, this.metadata = null, this._wasDispatched = !1, this.onDisposeObservable = new kc, this._disableDepthWrite = !1, this._packedAndReady = !1, this._customUpdate = (e, t) => {
				e.cellRef || (e.cellIndex = 0);
				const i = e.cellIndex;
				"number" == typeof i && isFinite(i) && Math.floor(i) === i && (e.cellRef = this._spriteMap[e.cellIndex]), e._xOffset = this._cellData[e.cellRef].frame.x / t.width, e._yOffset = this._cellData[e.cellRef].frame.y / t.height, e._xSize = this._cellData[e.cellRef].frame.w, e._ySize = this._cellData[e.cellRef].frame.h
			}, n || (n = Dc.LastCreatedScene), n._getComponent(Df.NAME_SPRITE) || n._addComponent(new jv(n)), this._fromPacked = o, this._scene = n;
			const h = this._scene.getEngine();
			if (this._spriteRenderer = new Kv(h, i, a, n), s.width && s.height) this.cellWidth = s.width, this.cellHeight = s.height;
			else {
				if (void 0 === s) return void(this._spriteRenderer = null);
				this.cellWidth = s, this.cellHeight = s
			}
			this._scene.spriteManagers && this._scene.spriteManagers.push(this), this.ik = this.scene.getUniqueId(), t && (this.texture = new Np(t, n, !0, !1, r)), this._fromPacked && this._makePacked(t, l)
		}
		dispose() {
			if (this._spriteRenderer && (this._spriteRenderer.dispose(), this._spriteRenderer = null), this._textureContent = null, this._scene.spriteManagers) {
				const e = this._scene.spriteManagers.indexOf(this);
				this._scene.spriteManagers.splice(e, 1)
			}
			this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null
		}
		getClassName() {
			return "SpriteManager"
		}
		get texture() {
			return this._spriteRenderer.texture
		}
		set cellHeight(e) {
			this._spriteRenderer.cellHeight = e
		}
		set onDispose(e) {
			this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
		}
		set cellWidth(e) {
			this._spriteRenderer.cellWidth = e
		}
		rebuild() {
			this._spriteRenderer?.rebuild()
		}
		multiIntersects(e, t, i) {
			const s = Math.min(this.Yk, this.sprites.length),
				n = Lc.Zero(),
				a = Lc.Zero();
			let r;
			const o = [],
				l = Vc.Vector3[0].copyFromFloats(0, 0, 0),
				h = Vc.Vector3[1].copyFromFloats(0, 0, 0),
				c = t.getViewMatrix();
			for (let t = 0; t < s; t++) {
				const s = this.sprites[t];
				if (s) {
					if (i) {
						if (!i(s)) continue
					} else if (!s.isPickable) continue;
					if (Lc.TransformCoordinatesToRef(s.position, c, h), n.copyFromFloats(h.x - s.width / 2, h.y - s.height / 2, h.z), a.copyFromFloats(h.x + s.width / 2, h.y + s.height / 2, h.z), e.intersectsBoxMinMax(n, a)) {
						if (r = Lc.Distance(h, e.origin), !this._checkTextureAlpha(s, e, r, n, a)) continue;
						const t = new Ld;
						o.push(t), c.invertToRef(Vc.Matrix[0]), t.hit = !0, t.pickedSprite = s, t.distance = r;
						const i = Vc.Vector3[2];
						i.copyFrom(e.direction), i.normalize(), i.scaleInPlace(r), e.origin.addToRef(i, l), t.pickedPoint = Lc.TransformCoordinates(l, Vc.Matrix[0])
					}
				}
			}
			return o
		}
		static Parse(t, i, s) {
			const n = new e(t.name, "", t.Yk, {
				width: t.cellWidth,
				height: t.cellHeight
			}, i);
			void 0 !== t.fogEnabled && (n.fogEnabled = t.fogEnabled), void 0 !== t.blendMode && (n.blendMode = t.blendMode), void 0 !== t.disableDepthWrite && (n.disableDepthWrite = t.disableDepthWrite), void 0 !== t.pixelPerfect && (n.pixelPerfect = t.pixelPerfect), void 0 !== t.useLogarithmicDepth && (n.useLogarithmicDepth = t.useLogarithmicDepth), void 0 !== t.metadata && (n.metadata = t.metadata), t.texture ? n.texture = Np.Parse(t.texture, i, s) : t.textureName && (n.texture = new Np(s + t.textureUrl, i, !1, void 0 === t.invertY || t.invertY));
			for (const e of t.sprites) Xv.Parse(e, n);
			return n
		}
		get blendMode() {
			return this._spriteRenderer.blendMode
		}
		_checkTextureAlpha(e, t, i, s, n) {
			if (!e.useAlphaForPicking || !this.texture) return !0;
			const a = this.texture.getSize();
			this._textureContent || (this._textureContent = new Uint8Array(a.width * a.height * 4), this.texture.readPixels(0, 0, this._textureContent));
			const r = Vc.Vector3[0];
			r.copyFrom(t.direction), r.normalize(), r.scaleInPlace(i), r.addInPlace(t.origin);
			const o = (r.x - s.x) / (n.x - s.x),
				l = 1 - (r.y - s.y) / (n.y - s.y),
				h = e._xOffset * a.width + o * e._xSize | 0,
				c = e._yOffset * a.height + l * e._ySize | 0;
			return this._textureContent[4 * (h + c * a.width) + 3] > .5
		}
		set disableDepthWrite(e) {
			this._disableDepthWrite = e, this._spriteRenderer.disableDepthWrite = e
		}
		render() {
			if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) return;
			const e = this._scene.getEngine().getDeltaTime();
			this._packedAndReady ? this._spriteRenderer.render(this.sprites, e, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate) : this._spriteRenderer.render(this.sprites, e, this._scene.getViewMatrix(), this._scene.getProjectionMatrix())
		}
		set blendMode(e) {
			this._spriteRenderer.blendMode = e
		}
		set useLogarithmicDepth(e) {
			this._spriteRenderer.useLogarithmicDepth = e
		}
		get scene() {
			return this._scene
		}
		get fogEnabled() {
			return this._spriteRenderer.fogEnabled
		}
		set texture(e) {
			e.wrapU = Np.CLAMP_ADDRESSMODE, e.wrapV = Np.CLAMP_ADDRESSMODE, this._spriteRenderer.texture = e, this._textureContent = null
		}
		get useLogarithmicDepth() {
			return this._spriteRenderer.useLogarithmicDepth
		}
		get pixelPerfect() {
			return this._spriteRenderer.pixelPerfect
		}
		set pixelPerfect(e) {
			this._spriteRenderer.pixelPerfect = e, e && 3 !== this.texture.samplingMode && this.texture.updateSamplingMode(3)
		}
		get cellWidth() {
			return this._spriteRenderer.cellWidth
		}
		_makePacked(e, t) {
			if (null !== t) try {
				let e;
				if (e = "string" == typeof t ? JSON.parse(t) : t, e.frames.length) {
					const t = {};
					for (let i = 0; i < e.frames.length; i++) {
						const s = e.frames[i];
						if ("string" != typeof Object.keys(s)[0]) throw new Error("Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.");
						t[s[Object.keys(s)[0]]] = s
					}
					e.frames = t
				}
				const i = Reflect.ownKeys(e.frames);
				this._spriteMap = i, this._packedAndReady = !0, this._cellData = e.frames
			} catch (e) {
				throw this._fromPacked = !1, this._packedAndReady = !1, new Error("Invalid JSON from string. Spritesheet managed with constant cell size.")
			} else {
				const t = /\./g;
				let i;
				do {
					i = t.lastIndex, t.test(e)
				} while (t.lastIndex > 0);
				const s = e.substring(0, i - 1) + ".json",
					n = () => {
						Qc.Error("JSON ERROR: Unable to load JSON file."), this._fromPacked = !1, this._packedAndReady = !1
					},
					a = e => {
						try {
							const t = JSON.parse(e),
								i = Reflect.ownKeys(t.frames);
							this._spriteMap = i, this._packedAndReady = !0, this._cellData = t.frames
						} catch (e) {
							throw this._fromPacked = !1, this._packedAndReady = !1, new Error("Invalid JSON format. Please check documentation for format specifications.")
						}
					};
				dd.LoadFile(s, a, void 0, void 0, !1, n)
			}
		}
		get Yk() {
			return this._spriteRenderer.Yk
		}
		intersects(e, t, i, s) {
			const n = Math.min(this.Yk, this.sprites.length),
				a = Lc.Zero(),
				r = Lc.Zero();
			let o = Number.MAX_VALUE,
				l = null;
			const h = Vc.Vector3[0],
				c = Vc.Vector3[1],
				u = t.getViewMatrix();
			let m = e,
				d = e;
			for (let t = 0; t < n; t++) {
				const n = this.sprites[t];
				if (n) {
					if (i) {
						if (!i(n)) continue
					} else if (!n.isPickable) continue;
					if (Lc.TransformCoordinatesToRef(n.position, u, c), n.angle ? (Hc.TranslationToRef(-c.x, -c.y, 0, Vc.Matrix[1]), Hc.TranslationToRef(c.x, c.y, 0, Vc.Matrix[2]), Hc.RotationZToRef(-n.angle, Vc.Matrix[3]), Vc.Matrix[1].multiplyToRef(Vc.Matrix[3], Vc.Matrix[4]), Vc.Matrix[4].multiplyToRef(Vc.Matrix[2], Vc.Matrix[0]), m = e.clone(), Lc.TransformCoordinatesToRef(e.origin, Vc.Matrix[0], m.origin), Lc.TransformNormalToRef(e.direction, Vc.Matrix[0], m.direction)) : m = e, a.copyFromFloats(c.x - n.width / 2, c.y - n.height / 2, c.z), r.copyFromFloats(c.x + n.width / 2, c.y + n.height / 2, c.z), m.intersectsBoxMinMax(a, r)) {
						const e = Lc.Distance(c, m.origin);
						if (o > e) {
							if (!this._checkTextureAlpha(n, m, e, a, r)) continue;
							if (d = m, o = e, l = n, s) break
						}
					}
				}
			}
			if (l) {
				const e = new Ld;
				u.invertToRef(Vc.Matrix[0]), e.hit = !0, e.pickedSprite = l, e.distance = o;
				const t = Vc.Vector3[2];
				return t.copyFrom(d.direction), t.normalize(), t.scaleInPlace(o), d.origin.addToRef(t, h), e.pickedPoint = Lc.TransformCoordinates(h, Vc.Matrix[0]), e
			}
			return null
		}
		get cellHeight() {
			return this._spriteRenderer.cellHeight
		}
		static ParseFromFileAsync(t, i, s, n = "") {
			return new Promise(((a, r) => {
				const o = new ku;
				o.addEventListener("readystatechange", (() => {
					if (4 == o.readyState)
						if (200 == o.status) {
							const i = JSON.parse(o.responseText),
								r = e.Parse(i, s || Dc.LastCreatedScene, n);
							t && (r.name = t), a(r)
						} else r("Unable to load the sprite manager")
				})), o.open("GET", i), o.send()
			}))
		}
		serialize(e = !1) {
			const t = {};
			t.name = this.name, t.Yk = this.Yk, t.cellWidth = this.cellWidth, t.cellHeight = this.cellHeight, t.fogEnabled = this.fogEnabled, t.blendMode = this.blendMode, t.disableDepthWrite = this.disableDepthWrite, t.pixelPerfect = this.pixelPerfect, t.useLogarithmicDepth = this.useLogarithmicDepth, this.texture && (e ? t.texture = this.texture.serialize() : (t.textureUrl = this.texture.name, t.invertY = this.texture._invertY)), t.sprites = [];
			for (const e of this.sprites) t.sprites.push(e.serialize());
			return t.metadata = this.metadata, t
		}
	};
	$v.SnippetUrl = "https://snippet.babylonjs.com", $v.CreateFromSnippetAsync = $v.ParseFromSnippetAsync;
	var Jv = class {};

	function qv(e) {
		let t = e.pathArray;
		const i = e.closeArray || !1,
			s = e.closePath || !1,
			n = e.invertUV || !1,
			a = Math.floor(t[0].length / 2);
		let r = e.offset || a;
		r = r > a ? a : Math.floor(r);
		const o = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			l = e.uvs,
			h = e.colors,
			c = [],
			u = [],
			m = [],
			d = [],
			f = [],
			p = [],
			_ = [],
			g = [];
		let v;
		const y = [],
			S = [];
		let E, A, b;
		if (t.length < 2) {
			const e = [],
				i = [];
			for (A = 0; A < t[0].length - r; A++) e.push(t[0][A]), i.push(t[0][A + r]);
			t = [e, i]
		}
		let x = 0;
		const M = s ? 1 : 0,
			C = i ? 1 : 0;
		let T, w, R, N, I, P;
		for (v = t[0].length, E = 0; E < t.length + C; E++) {
			for (_[E] = 0, f[E] = [0], T = E === t.length ? t[0] : t[E], w = T.length, v = v < w ? v : w, b = 0; b < w;) c.push(T[b].x, T[b].y, T[b].z), b > 0 && (R = T[b].subtract(T[b - 1]).length(), N = R + _[E], f[E].push(N), _[E] = N), b++;
			s && (b--, c.push(T[0].x, T[0].y, T[0].z), R = T[b].subtract(T[0]).length(), N = R + _[E], f[E].push(N), _[E] = N), y[E] = w + M, S[E] = x, x += w + M
		}
		let k, D, O = null,
			F = null;
		for (A = 0; A < v + M; A++)
			for (g[A] = 0, p[A] = [0], E = 0; E < t.length - 1 + C; E++) I = t[E], P = E === t.length - 1 ? t[0] : t[E + 1], A === v ? (O = I[0], F = P[0]) : (O = I[A], F = P[A]), R = F.subtract(O).length(), N = R + g[A], p[A].push(N), g[A] = N;
		if (l)
			for (E = 0; E < l.length; E++) d.push(l[E].x, l[E].y);
		else
			for (E = 0; E < t.length + C; E++)
				for (A = 0; A < v + M; A++) k = 0 != _[E] ? f[E][A] / _[E] : 0, D = 0 != g[A] ? p[A][E] / g[A] : 0, n ? d.push(D, k) : d.push(k, D);
		E = 0;
		let L = 0,
			B = y[E] - 1,
			G = y[E + 1] - 1,
			H = B < G ? B : G,
			U = S[1] - S[0];
		const V = y.length - 1;
		for (; L <= H && E < V;) u.push(L, L + U, L + 1), u.push(L + U + 1, L + 1, L + U), L += 1, L === H && (E++, U = S[E + 1] - S[E], B = y[E] - 1, G = y[E + 1] - 1, L = S[E], H = B < G ? B + L : G + L);
		if (Mu.ComputeNormals(c, u, m), s) {
			let e = 0,
				i = 0;
			for (E = 0; E < t.length; E++) {
				e = 3 * S[E], i = E + 1 < t.length ? 3 * (S[E + 1] - 1) : m.length - 3, m[e] = .5 * (m[e] + m[i]), m[e + 1] = .5 * (m[e + 1] + m[i + 1]), m[e + 2] = .5 * (m[e + 2] + m[i + 2]);
				const s = Math.sqrt(m[e] * m[e] + m[e + 1] * m[e + 1] + m[e + 2] * m[e + 2]);
				m[e] /= s, m[e + 1] /= s, m[e + 2] /= s, m[i] = m[e], m[i + 1] = m[e + 1], m[i + 2] = m[e + 2]
			}
		}
		if (i) {
			let e = 3 * S[0],
				i = 3 * S[t.length];
			for (A = 0; A < v + M; A++) {
				m[e] = .5 * (m[e] + m[i]), m[e + 1] = .5 * (m[e + 1] + m[i + 1]), m[e + 2] = .5 * (m[e + 2] + m[i + 2]);
				const t = Math.sqrt(m[e] * m[e] + m[e + 1] * m[e + 1] + m[e + 2] * m[e + 2]);
				m[e] /= t, m[e + 1] /= t, m[e + 2] /= t, m[i] = m[e], m[i + 1] = m[e + 1], m[i + 2] = m[e + 2], e += 3, i += 3
			}
		}
		Mu._ComputeSides(o, c, u, m, d, e.frontUVs, e.backUVs);
		let W = null;
		if (h) {
			W = new Float32Array(4 * h.length);
			for (let e = 0; e < h.length; e++) W[4 * e] = h[e].r, W[4 * e + 1] = h[e].g, W[4 * e + 2] = h[e].b, W[4 * e + 3] = h[e].a
		}
		const z = new Mu,
			X = new Float32Array(c),
			Y = new Float32Array(m),
			j = new Float32Array(d);
		return z.indices = u, z.positions = X, z.normals = Y, z.uvs = j, W && z.set(W, eu.ColorKind), s && (z._idx = S), z
	}

	function Qv(e, t, i = null) {
		const s = t.pathArray,
			n = t.closeArray,
			a = t.closePath,
			r = Vf._GetDefaultSideOrientation(t.sideOrientation),
			o = t.instance,
			l = t.updatable;
		if (o) {
			const e = Vc.Vector3[0].setAll(Number.MAX_VALUE),
				i = Vc.Vector3[1].setAll(-Number.MAX_VALUE),
				n = t => {
					let n = s[0].length;
					const a = o;
					let r = 0;
					const l = a._originalBuilderSideOrientation === Vf.DOUBLESIDE ? 2 : 1;
					for (let o = 1; o <= l; ++o)
						for (let o = 0; o < s.length; ++o) {
							const l = s[o],
								h = l.length;
							n = n < h ? n : h;
							for (let s = 0; s < n; ++s) {
								const n = l[s];
								t[r] = n.x, t[r + 1] = n.y, t[r + 2] = n.z, e.minimizeInPlaceFromFloats(n.x, n.y, n.z), i.maximizeInPlaceFromFloats(n.x, n.y, n.z), r += 3
							}
							if (a._creationDataStorage && a._creationDataStorage.closePath) {
								const e = l[0];
								t[r] = e.x, t[r + 1] = e.y, t[r + 2] = e.z, r += 3
							}
						}
				},
				a = o.getVerticesData(eu.PositionKind);
			if (n(a), o.hasBoundingInfo ? o.getBoundingInfo().reConstruct(e, i, o._worldMatrix) : o.buildBoundingInfo(e, i, o._worldMatrix), o.updateVerticesData(eu.PositionKind, a, !1, !1), t.colors) {
				const e = o.getVerticesData(eu.ColorKind);
				for (let i = 0, s = 0; i < t.colors.length; i++, s += 4) {
					const n = t.colors[i];
					e[s] = n.r, e[s + 1] = n.g, e[s + 2] = n.b, e[s + 3] = n.a
				}
				o.updateVerticesData(eu.ColorKind, e, !1, !1)
			}
			if (t.uvs) {
				const e = o.getVerticesData(eu.UVKind);
				for (let i = 0; i < t.uvs.length; i++) e[2 * i] = t.uvs[i].x, e[2 * i + 1] = t.uvs[i].y;
				o.updateVerticesData(eu.UVKind, e, !1, !1)
			}
			if (!o.areNormalsFrozen || o.isFacetDataEnabled) {
				const e = o.getIndices(),
					t = o.getVerticesData(eu.NormalKind),
					i = o.isFacetDataEnabled ? o.getFacetDataParameters() : null;
				if (Mu.ComputeNormals(a, e, t, i), o._creationDataStorage && o._creationDataStorage.closePath) {
					let e = 0,
						i = 0;
					for (let n = 0; n < s.length; n++) e = 3 * o._creationDataStorage.idx[n], i = n + 1 < s.length ? 3 * (o._creationDataStorage.idx[n + 1] - 1) : t.length - 3, t[e] = .5 * (t[e] + t[i]), t[e + 1] = .5 * (t[e + 1] + t[i + 1]), t[e + 2] = .5 * (t[e + 2] + t[i + 2]), t[i] = t[e], t[i + 1] = t[e + 1], t[i + 2] = t[e + 2]
				}
				o.areNormalsFrozen || o.updateVerticesData(eu.NormalKind, t, !1, !1)
			}
			return o
		} {
			const s = new Vf(e, i);
			s._originalBuilderSideOrientation = r, s._creationDataStorage = new Lf;
			const o = qv(t);
			return a && (s._creationDataStorage.idx = o._idx), s._creationDataStorage.closePath = a, s._creationDataStorage.closeArray = n, o.applyToMesh(s, l), s
		}
	}

	function Zv(e) {
		const t = [],
			i = [],
			s = [],
			n = [],
			a = e.radius || .5,
			r = e.tessellation || 64,
			o = e.arc && (e.arc <= 0 || e.arc > 1) ? 1 : e.arc || 1,
			l = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE;
		t.push(0, 0, 0), n.push(.5, .5);
		const h = 2 * Math.PI * o,
			c = 1 === o ? h / r : h / (r - 1);
		let u = 0;
		for (let e = 0; e < r; e++) {
			const e = Math.cos(u),
				i = Math.sin(u),
				s = (e + 1) / 2,
				r = (1 - i) / 2;
			t.push(a * e, a * i, 0), n.push(s, r), u += c
		}
		1 === o && (t.push(t[3], t[4], t[5]), n.push(n[2], n[3]));
		const m = t.length / 3;
		for (let e = 1; e < m - 1; e++) i.push(e + 1, 0, e);
		Mu.ComputeNormals(t, i, s), Mu._ComputeSides(l, t, i, s, n, e.frontUVs, e.backUVs);
		const d = new Mu;
		return d.indices = i, d.positions = t, d.normals = s, d.uvs = n, d
	}

	function ey(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return Zv(t).applyToMesh(s, t.updatable), s
	}
	Jv.AUTOSAMPLERSUFFIX = "Sampler", Jv.DISABLEUA = "#define DISABLE_UNIFORMITY_ANALYSIS", Jv.ALPHA_DISABLE = 0, Jv.ALPHA_ADD = 1, Jv.ALPHA_COMBINE = 2, Jv.ALPHA_SUBTRACT = 3, Jv.ALPHA_MULTIPLY = 4, Jv.ALPHA_MAXIMIZED = 5, Jv.ALPHA_ONEONE = 6, Jv.ALPHA_PREMULTIPLIED = 7, Jv.ALPHA_PREMULTIPLIED_PORTERDUFF = 8, Jv.ALPHA_INTERPOLATE = 9, Jv.ALPHA_SCREENMODE = 10, Jv.ALPHA_ONEONE_ONEONE = 11, Jv.ALPHA_ALPHATOCOLOR = 12, Jv.ALPHA_REVERSEONEMINUS = 13, Jv.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14, Jv.ALPHA_ONEONE_ONEZERO = 15, Jv.ALPHA_EXCLUSION = 16, Jv.ALPHA_LAYER_ACCUMULATE = 17, Jv.ALPHA_EQUATION_ADD = 0, Jv.ALPHA_EQUATION_SUBSTRACT = 1, Jv.ALPHA_EQUATION_REVERSE_SUBTRACT = 2, Jv.ALPHA_EQUATION_MAX = 3, Jv.ALPHA_EQUATION_MIN = 4, Jv.ALPHA_EQUATION_DARKEN = 5, Jv.DELAYLOADSTATE_NONE = 0, Jv.DELAYLOADSTATE_LOADED = 1, Jv.DELAYLOADSTATE_LOADING = 2, Jv.DELAYLOADSTATE_NOTLOADED = 4, Jv.NEVER = 512, Jv.ALWAYS = 519, Jv.LESS = 513, Jv.EQUAL = 514, Jv.LEQUAL = 515, Jv.GREATER = 516, Jv.GEQUAL = 518, Jv.NOTEQUAL = 517, Jv.KEEP = 7680, Jv.ZERO = 0, Jv.REPLACE = 7681, Jv.INCR = 7682, Jv.DECR = 7683, Jv.INVERT = 5386, Jv.INCR_WRAP = 34055, Jv.DECR_WRAP = 34056, Jv.TEXTURE_CLAMP_ADDRESSMODE = 0, Jv.TEXTURE_WRAP_ADDRESSMODE = 1, Jv.TEXTURE_MIRROR_ADDRESSMODE = 2, Jv.TEXTURE_CREATIONFLAG_STORAGE = 1, Jv.TEXTUREFORMAT_ALPHA = 0, Jv.TEXTUREFORMAT_LUMINANCE = 1, Jv.TEXTUREFORMAT_LUMINANCE_ALPHA = 2, Jv.TEXTUREFORMAT_RGB = 4, Jv.TEXTUREFORMAT_RGBA = 5, Jv.TEXTUREFORMAT_RED = 6, Jv.TEXTUREFORMAT_R = 6, Jv.TEXTUREFORMAT_RG = 7, Jv.TEXTUREFORMAT_RED_INTEGER = 8, Jv.TEXTUREFORMAT_R_INTEGER = 8, Jv.TEXTUREFORMAT_RG_INTEGER = 9, Jv.TEXTUREFORMAT_RGB_INTEGER = 10, Jv.TEXTUREFORMAT_RGBA_INTEGER = 11, Jv.TEXTUREFORMAT_BGRA = 12, Jv.TEXTUREFORMAT_DEPTH24_STENCIL8 = 13, Jv.TEXTUREFORMAT_DEPTH32_FLOAT = 14, Jv.TEXTUREFORMAT_DEPTH16 = 15, Jv.TEXTUREFORMAT_DEPTH24 = 16, Jv.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17, Jv.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18, Jv.TEXTUREFORMAT_STENCIL8 = 19, Jv.TEXTUREFORMAT_UNDEFINED = 4294967295, Jv.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492, Jv.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493, Jv.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495, Jv.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494, Jv.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779, Jv.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919, Jv.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778, Jv.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918, Jv.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777, Jv.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776, Jv.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917, Jv.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916, Jv.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808, Jv.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840, Jv.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196, Jv.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492, Jv.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493, Jv.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494, Jv.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495, Jv.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496, Jv.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497, Jv.TEXTURETYPE_UNSIGNED_BYTE = 0, Jv.TEXTURETYPE_UNSIGNED_INT = 0, Jv.TEXTURETYPE_FLOAT = 1, Jv.TEXTURETYPE_HALF_FLOAT = 2, Jv.TEXTURETYPE_BYTE = 3, Jv.TEXTURETYPE_SHORT = 4, Jv.TEXTURETYPE_UNSIGNED_SHORT = 5, Jv.TEXTURETYPE_INT = 6, Jv.TEXTURETYPE_UNSIGNED_INTEGER = 7, Jv.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8, Jv.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9, Jv.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10, Jv.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11, Jv.TEXTURETYPE_UNSIGNED_INT_24_8 = 12, Jv.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13, Jv.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14, Jv.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15, Jv.TEXTURETYPE_UNDEFINED = 16, Jv.TEXTURE_2D = 3553, Jv.TEXTURE_2D_ARRAY = 35866, Jv.TEXTURE_CUBE_MAP = 34067, Jv.TEXTURE_CUBE_MAP_ARRAY = 3735928559, Jv.TEXTURE_3D = 32879, Jv.TEXTURE_NEAREST_SAMPLINGMODE = 1, Jv.TEXTURE_NEAREST_NEAREST = 1, Jv.TEXTURE_BILINEAR_SAMPLINGMODE = 2, Jv.TEXTURE_LINEAR_LINEAR = 2, Jv.TEXTURE_TRILINEAR_SAMPLINGMODE = 3, Jv.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3, Jv.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4, Jv.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5, Jv.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6, Jv.TEXTURE_NEAREST_LINEAR = 7, Jv.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8, Jv.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9, Jv.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10, Jv.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11, Jv.TEXTURE_LINEAR_NEAREST = 12, Jv.TEXTURE_EXPLICIT_MODE = 0, Jv.TEXTURE_SPHERICAL_MODE = 1, Jv.TEXTURE_PLANAR_MODE = 2, Jv.TEXTURE_CUBIC_MODE = 3, Jv.TEXTURE_PROJECTION_MODE = 4, Jv.TEXTURE_SKYBOX_MODE = 5, Jv.TEXTURE_INVCUBIC_MODE = 6, Jv.TEXTURE_EQUIRECTANGULAR_MODE = 7, Jv.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8, Jv.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, Jv.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096, Jv.TEXTURE_FILTERING_QUALITY_HIGH = 64, Jv.TEXTURE_FILTERING_QUALITY_MEDIUM = 16, Jv.TEXTURE_FILTERING_QUALITY_LOW = 8, Jv.SCALEMODE_FLOOR = 1, Jv.SCALEMODE_NEAREST = 2, Jv.SCALEMODE_CEILING = 3, Jv.MATERIAL_TextureDirtyFlag = 1, Jv.MATERIAL_LightDirtyFlag = 2, Jv.MATERIAL_FresnelDirtyFlag = 4, Jv.MATERIAL_AttributesDirtyFlag = 8, Jv.MATERIAL_MiscDirtyFlag = 16, Jv.MATERIAL_PrePassDirtyFlag = 32, Jv.MATERIAL_AllDirtyFlag = 63, Jv.MATERIAL_TriangleFillMode = 0, Jv.MATERIAL_WireFrameFillMode = 1, Jv.MATERIAL_PointFillMode = 2, Jv.MATERIAL_PointListDrawMode = 3, Jv.MATERIAL_LineListDrawMode = 4, Jv.MATERIAL_LineLoopDrawMode = 5, Jv.MATERIAL_LineStripDrawMode = 6, Jv.MATERIAL_TriangleStripDrawMode = 7, Jv.MATERIAL_TriangleFanDrawMode = 8, Jv.MATERIAL_ClockWiseSideOrientation = 0, Jv.MATERIAL_CounterClockWiseSideOrientation = 1, Jv.ACTION_NothingTrigger = 0, Jv.ACTION_OnPickTrigger = 1, Jv.ACTION_OnLeftPickTrigger = 2, Jv.ACTION_OnRightPickTrigger = 3, Jv.ACTION_OnCenterPickTrigger = 4, Jv.ACTION_OnPickDownTrigger = 5, Jv.ACTION_OnDoublePickTrigger = 6, Jv.ACTION_OnPickUpTrigger = 7, Jv.ACTION_OnPickOutTrigger = 16, Jv.ACTION_OnLongPressTrigger = 8, Jv.ACTION_OnPointerOverTrigger = 9, Jv.ACTION_OnPointerOutTrigger = 10, Jv.ACTION_OnEveryFrameTrigger = 11, Jv.ACTION_OnIntersectionEnterTrigger = 12, Jv.ACTION_OnIntersectionExitTrigger = 13, Jv.ACTION_OnKeyDownTrigger = 14, Jv.ACTION_OnKeyUpTrigger = 15, Jv.PARTICLES_BILLBOARDMODE_Y = 2, Jv.PARTICLES_BILLBOARDMODE_ALL = 7, Jv.PARTICLES_BILLBOARDMODE_STRETCHED = 8, Jv.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL = 9, Jv.MESHES_CULLINGSTRATEGY_STANDARD = 0, Jv.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1, Jv.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2, Jv.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3, Jv.SCENELOADER_NO_LOGGING = 0, Jv.SCENELOADER_MINIMAL_LOGGING = 1, Jv.SCENELOADER_SUMMARY_LOGGING = 2, Jv.SCENELOADER_DETAILED_LOGGING = 3, Jv.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0, Jv.PREPASS_POSITION_TEXTURE_TYPE = 1, Jv.PREPASS_VELOCITY_TEXTURE_TYPE = 2, Jv.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3, Jv.PREPASS_COLOR_TEXTURE_TYPE = 4, Jv.PREPASS_DEPTH_TEXTURE_TYPE = 5, Jv.PREPASS_NORMAL_TEXTURE_TYPE = 6, Jv.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7, Jv.BUFFER_CREATIONFLAG_READ = 1, Jv.BUFFER_CREATIONFLAG_WRITE = 2, Jv.BUFFER_CREATIONFLAG_READWRITE = 3, Jv.BUFFER_CREATIONFLAG_UNIFORM = 4, Jv.BUFFER_CREATIONFLAG_VERTEX = 8, Jv.BUFFER_CREATIONFLAG_INDEX = 16, Jv.BUFFER_CREATIONFLAG_STORAGE = 32, Jv.BUFFER_CREATIONFLAG_INDIRECT = 64, Jv.RENDERPASS_MAIN = 0, Jv.INPUT_ALT_KEY = 18, Jv.INPUT_CTRL_KEY = 17, Jv.INPUT_META_KEY1 = 91, Jv.INPUT_META_KEY2 = 92, Jv.INPUT_META_KEY3 = 93, Jv.INPUT_SHIFT_KEY = 16, Jv.SNAPSHOTRENDERING_STANDARD = 0, Jv.SNAPSHOTRENDERING_FAST = 1, Jv.PERSPECTIVE_CAMERA = 0, Jv.ORTHOGRAPHIC_CAMERA = 1, Jv.FOVMODE_VERTICAL_FIXED = 0, Jv.FOVMODE_HORIZONTAL_FIXED = 1, Jv.RIG_MODE_NONE = 0, Jv.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, Jv.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, Jv.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, Jv.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, Jv.RIG_MODE_STEREOSCOPIC_INTERLACED = 14, Jv.RIG_MODE_VR = 20, Jv.RIG_MODE_CUSTOM = 22, Jv.MAX_SUPPORTED_UV_SETS = 6, Jv.GL_ALPHA_EQUATION_ADD = 32774, Jv.GL_ALPHA_EQUATION_MIN = 32775, Jv.GL_ALPHA_EQUATION_MAX = 32776, Jv.GL_ALPHA_EQUATION_SUBTRACT = 32778, Jv.GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 32779, Jv.GL_ALPHA_FUNCTION_SRC = 768, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 769, Jv.GL_ALPHA_FUNCTION_SRC_ALPHA = 770, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 771, Jv.GL_ALPHA_FUNCTION_DST_ALPHA = 772, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 773, Jv.GL_ALPHA_FUNCTION_DST_COLOR = 774, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 775, Jv.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 776, Jv.GL_ALPHA_FUNCTION_CONSTANT_COLOR = 32769, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 32770, Jv.GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 32771, Jv.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 32772, Jv.SnippetUrl = "https://snippet.babylonjs.com", Jv.FOGMODE_NONE = 0, Jv.FOGMODE_EXP = 1, Jv.FOGMODE_EXP2 = 2, Jv.FOGMODE_LINEAR = 3, Jv.BYTE = 5120, Jv.UNSIGNED_BYTE = 5121, Jv.SHORT = 5122, Jv.UNSIGNED_SHORT = 5123, Jv.INT = 5124, Jv.UNSIGNED_INT = 5125, Jv.FLOAT = 5126, Jv.PositionKind = "position", Jv.NormalKind = "normal", Jv.TangentKind = "tangent", Jv.UVKind = "uv", Jv.UV2Kind = "uv2", Jv.UV3Kind = "uv3", Jv.UV4Kind = "uv4", Jv.UV5Kind = "uv5", Jv.UV6Kind = "uv6", Jv.ColorKind = "color", Jv.ColorInstanceKind = "instanceColor", Jv.MatricesIndicesKind = "matricesIndices", Jv.MatricesWeightsKind = "matricesWeights", Jv.MatricesIndicesExtraKind = "matricesIndicesExtra", Jv.MatricesWeightsExtraKind = "matricesWeightsExtra", Mu.Nk = qv, Vf.Nk = (e, t, i = !1, s, n, a, r = !1, o, l) => Qv(e, {
		pathArray: t,
		closeArray: i,
		closePath: s,
		offset: n,
		updatable: r,
		sideOrientation: o,
		instance: l
	}, a), Mu.gk = Zv, Vf.gk = (e, t, i, s = null, n, a) => ey(e, {
		radius: t,
		tessellation: i,
		sideOrientation: a,
		updatable: n
	}, s), Vf._GroundMeshParser = (e, t) => ty.Parse(e, t);
	var ty = class e extends Vf {
		getClassName() {
			return "GroundMesh"
		}
		updateCoordinateHeights() {
			return this._heightQuads && 0 != this._heightQuads.length || this._initHeightQuads(), this._computeHeightQuads(), this
		}
		_initHeightQuads() {
			const e = this._subdivisionsX,
				t = this._subdivisionsY;
			this._heightQuads = new Array;
			for (let i = 0; i < t; i++)
				for (let t = 0; t < e; t++) {
					const s = {
						slope: Fc.Zero(),
						facet1: new Bc(0, 0, 0, 0),
						facet2: new Bc(0, 0, 0, 0)
					};
					this._heightQuads[i * e + t] = s
				}
			return this
		}
		getNormalAtCoordinatesToRef(e, t, i) {
			const s = this.getWorldMatrix(),
				n = Vc.Matrix[5];
			s.invertToRef(n);
			const a = Vc.Vector3[8];
			if (Lc.TransformCoordinatesFromFloatsToRef(e, 0, t, n, a), e = a.x, t = a.z, e < this._minX || e > this._maxX || t < this._minZ || t > this._maxZ) return this;
			this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());
			const r = this._getFacetAt(e, t);
			return Lc.TransformNormalFromFloatsToRef(r.x, r.y, r.z, s, i), this
		}
		get subdivisions() {
			return Math.min(this._subdivisionsX, this._subdivisionsY)
		}
		static Parse(t, i) {
			const s = new e(t.name, i);
			return s._subdivisionsX = t.subdivisionsX || 1, s._subdivisionsY = t.subdivisionsY || 1, s._minX = t.minX, s._maxX = t.maxX, s._minZ = t.minZ, s._maxZ = t.maxZ, s._width = t.width, s._height = t.height, s
		}
		get subdivisionsY() {
			return this._subdivisionsY
		}
		getHeightAtCoordinates(e, t) {
			const i = this.getWorldMatrix(),
				s = Vc.Matrix[5];
			i.invertToRef(s);
			const n = Vc.Vector3[8];
			if (Lc.TransformCoordinatesFromFloatsToRef(e, 0, t, s, n), e = n.x, t = n.z, e < this._minX || e >= this._maxX || t <= this._minZ || t > this._maxZ) return this.position.y;
			this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());
			const a = this._getFacetAt(e, t),
				r = -(a.x * e + a.z * t + a.w) / a.y;
			return Lc.TransformCoordinatesFromFloatsToRef(0, r, 0, i, n), n.y
		}
		_getFacetAt(e, t) {
			const i = Math.floor((e + this._maxX) * this._subdivisionsX / this._width),
				s = Math.floor(-(t + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY),
				n = this._heightQuads[s * this._subdivisionsX + i];
			let a;
			return a = t < n.slope.x * e + n.slope.y ? n.facet1 : n.facet2, a
		}
		optimize(e, t = 32) {
			this._subdivisionsX = e, this._subdivisionsY = e, this.subdivide(e);
			const i = this;
			i.createOrUpdateSubmeshesOctree && i.createOrUpdateSubmeshesOctree(t)
		}
		_computeHeightQuads() {
			const e = this.getVerticesData(eu.PositionKind);
			if (!e) return this;
			const t = Vc.Vector3[3],
				i = Vc.Vector3[2],
				s = Vc.Vector3[1],
				n = Vc.Vector3[0],
				a = Vc.Vector3[4],
				r = Vc.Vector3[5],
				o = Vc.Vector3[6],
				l = Vc.Vector3[7],
				h = Vc.Vector3[8];
			let c = 0,
				u = 0,
				m = 0,
				d = 0,
				f = 0,
				p = 0,
				_ = 0;
			const g = this._subdivisionsX,
				v = this._subdivisionsY;
			for (let y = 0; y < v; y++)
				for (let v = 0; v < g; v++) {
					c = 3 * v, u = y * (g + 1) * 3, m = (y + 1) * (g + 1) * 3, t.x = e[u + c], t.y = e[u + c + 1], t.z = e[u + c + 2], i.x = e[u + c + 3], i.y = e[u + c + 4], i.z = e[u + c + 5], s.x = e[m + c], s.y = e[m + c + 1], s.z = e[m + c + 2], n.x = e[m + c + 3], n.y = e[m + c + 4], n.z = e[m + c + 5], d = (n.z - t.z) / (n.x - t.x), f = t.z - d * t.x, i.subtractToRef(t, a), s.subtractToRef(t, r), n.subtractToRef(t, o), Lc.CrossToRef(o, r, l), Lc.CrossToRef(a, o, h), l.normalize(), h.normalize(), p = -(l.x * t.x + l.y * t.y + l.z * t.z), _ = -(h.x * i.x + h.y * i.y + h.z * i.z);
					const S = this._heightQuads[y * g + v];
					S.slope.copyFromFloats(d, f), S.facet1.copyFromFloats(l.x, l.y, l.z, p), S.facet2.copyFromFloats(h.x, h.y, h.z, _)
				}
			return this
		}
		serialize(e) {
			super.serialize(e), e.subdivisionsX = this._subdivisionsX, e.subdivisionsY = this._subdivisionsY, e.minX = this._minX, e.maxX = this._maxX, e.minZ = this._minZ, e.maxZ = this._maxZ, e.width = this._width, e.height = this._height
		}
		getNormalAtCoordinates(e, t) {
			const i = new Lc(0, 1, 0);
			return this.getNormalAtCoordinatesToRef(e, t, i), i
		}
		constructor(e, t) {
			super(e, t), this.generateOctree = !1
		}
		get subdivisionsX() {
			return this._subdivisionsX
		}
	};

	function iy(e) {
		const t = [],
			i = [],
			s = [],
			n = [];
		let a, r;
		const o = e.width || 1,
			l = e.height || 1,
			h = 0 | (e.subdivisionsX || e.subdivisions || 1),
			c = 0 | (e.subdivisionsY || e.subdivisions || 1);
		for (a = 0; a <= c; a++)
			for (r = 0; r <= h; r++) {
				const e = new Lc(r * o / h - o / 2, 0, (c - a) * l / c - l / 2),
					t = new Lc(0, 1, 0);
				i.push(e.x, e.y, e.z), s.push(t.x, t.y, t.z), n.push(r / h, 1 - a / c)
			}
		for (a = 0; a < c; a++)
			for (r = 0; r < h; r++) t.push(r + 1 + (a + 1) * (h + 1)), t.push(r + 1 + a * (h + 1)), t.push(r + a * (h + 1)), t.push(r + (a + 1) * (h + 1)), t.push(r + 1 + (a + 1) * (h + 1)), t.push(r + a * (h + 1));
		const u = new Mu;
		return u.indices = t, u.positions = i, u.normals = s, u.uvs = n, u
	}

	function sy(e) {
		const t = void 0 !== e.xmin && null !== e.xmin ? e.xmin : -1,
			i = void 0 !== e.zmin && null !== e.zmin ? e.zmin : -1,
			s = void 0 !== e.xmax && null !== e.xmax ? e.xmax : 1,
			n = void 0 !== e.zmax && null !== e.zmax ? e.zmax : 1,
			a = e.subdivisions || {
				w: 1,
				h: 1
			},
			r = e.precision || {
				w: 1,
				h: 1
			},
			o = [],
			l = [],
			h = [],
			c = [];
		let u, m, d, f;
		a.h = a.h < 1 ? 1 : a.h, a.w = a.w < 1 ? 1 : a.w, r.w = r.w < 1 ? 1 : r.w, r.h = r.h < 1 ? 1 : r.h;
		const p = (s - t) / a.w,
			_ = (n - i) / a.h;

		function g(e, t, i, s) {
			const n = l.length / 3,
				a = r.w + 1;
			for (u = 0; u < r.h; u++)
				for (m = 0; m < r.w; m++) {
					const e = [n + m + u * a, n + (m + 1) + u * a, n + (m + 1) + (u + 1) * a, n + m + (u + 1) * a];
					o.push(e[1]), o.push(e[2]), o.push(e[3]), o.push(e[0]), o.push(e[1]), o.push(e[3])
				}
			const d = Lc.Zero(),
				f = new Lc(0, 1, 0);
			for (u = 0; u <= r.h; u++)
				for (d.z = u * (s - t) / r.h + t, m = 0; m <= r.w; m++) d.x = m * (i - e) / r.w + e, d.y = 0, l.push(d.x, d.y, d.z), h.push(f.x, f.y, f.z), c.push(m / r.w, u / r.h)
		}
		for (d = 0; d < a.h; d++)
			for (f = 0; f < a.w; f++) g(t + f * p, i + d * _, t + (f + 1) * p, i + (d + 1) * _);
		const v = new Mu;
		return v.indices = o, v.positions = l, v.normals = h, v.uvs = c, v
	}

	function ny(e) {
		const t = [],
			i = [],
			s = [],
			n = [];
		let a, r;
		const o = e.colorFilter || new Tc(.3, .59, .11),
			l = e.alphaFilter || 0;
		let h = !1;
		if (e.minHeight > e.maxHeight) {
			h = !0;
			const t = e.maxHeight;
			e.maxHeight = e.minHeight, e.minHeight = t
		}
		for (a = 0; a <= e.subdivisions; a++)
			for (r = 0; r <= e.subdivisions; r++) {
				const t = new Lc(r * e.width / e.subdivisions - e.width / 2, 0, (e.subdivisions - a) * e.height / e.subdivisions - e.height / 2),
					c = 4 * (((t.x + e.width / 2) / e.width * (e.bufferWidth - 1) | 0) + ((1 - (t.z + e.height / 2) / e.height) * (e.bufferHeight - 1) | 0) * e.bufferWidth);
				let u = e.buffer[c] / 255,
					m = e.buffer[c + 1] / 255,
					d = e.buffer[c + 2] / 255;
				const f = e.buffer[c + 3] / 255;
				h && (u = 1 - u, m = 1 - m, d = 1 - d);
				const p = u * o.r + m * o.g + d * o.b;
				t.y = f >= l ? e.minHeight + (e.maxHeight - e.minHeight) * p : e.minHeight - pc, e.heightBuffer && (e.heightBuffer[a * (e.subdivisions + 1) + r] = t.y), i.push(t.x, t.y, t.z), s.push(0, 0, 0), n.push(r / e.subdivisions, 1 - a / e.subdivisions)
			}
		for (a = 0; a < e.subdivisions; a++)
			for (r = 0; r < e.subdivisions; r++) {
				const s = r + 1 + (a + 1) * (e.subdivisions + 1),
					n = r + 1 + a * (e.subdivisions + 1),
					o = r + a * (e.subdivisions + 1),
					l = r + (a + 1) * (e.subdivisions + 1),
					h = i[3 * s + 1] >= e.minHeight,
					c = i[3 * n + 1] >= e.minHeight,
					u = i[3 * o + 1] >= e.minHeight;
				h && c && u && (t.push(s), t.push(n), t.push(o));
				i[3 * l + 1] >= e.minHeight && h && u && (t.push(l), t.push(s), t.push(o))
			}
		Mu.ComputeNormals(i, t, s);
		const c = new Mu;
		return c.indices = t, c.positions = i, c.normals = s, c.uvs = n, c
	}

	function ay(e, t = {}, i) {
		const s = new ty(e, i);
		s._setReady(!1), s._subdivisionsX = t.subdivisionsX || t.subdivisions || 1, s._subdivisionsY = t.subdivisionsY || t.subdivisions || 1, s._width = t.width || 1, s._height = t.height || 1, s._maxX = s._width / 2, s._maxZ = s._height / 2, s._minX = -s._maxX, s._minZ = -s._maxZ;
		return iy(t).applyToMesh(s, t.updatable), s._setReady(!0), s
	}

	function ry(e, t, i = null) {
		const s = new Vf(e, i);
		return sy(t).applyToMesh(s, t.updatable), s
	}

	function oy(e, t, i = {}, s = null) {
		const n = i.width || 10,
			a = i.height || 10,
			r = i.subdivisions || 1,
			o = i.minHeight || 0,
			l = i.maxHeight || 1,
			h = i.colorFilter || new Tc(.3, .59, .11),
			c = i.alphaFilter || 0,
			u = i.updatable,
			m = i.onReady;
		s = s || Dc.LastCreatedScene;
		const d = new ty(e, s);
		let f;
		d._subdivisionsX = r, d._subdivisionsY = r, d._width = n, d._height = a, d._maxX = d._width / 2, d._maxZ = d._height / 2, d._minX = -d._maxX, d._minZ = -d._maxZ, d._setReady(!1), i.passHeightBufferInCallback && (f = new Float32Array((r + 1) * (r + 1)));
		const p = (e, t, i) => {
			ny({
				width: n,
				height: a,
				subdivisions: r,
				minHeight: o,
				maxHeight: l,
				colorFilter: h,
				buffer: e,
				bufferWidth: t,
				bufferHeight: i,
				alphaFilter: c,
				heightBuffer: f
			}).applyToMesh(d, u), m && m(d, f), d._setReady(!0)
		};
		if ("string" == typeof t) {
			const e = e => {
				const t = e.width,
					i = e.height;
				if (s.isDisposed) return;
				const n = s?.getEngine().resizeImageBitmap(e, t, i);
				p(n, t, i)
			};
			dd.LoadImage(t, e, i.onError ? i.onError : () => {}, s.offlineProvider)
		} else p(t.data, t.width, t.height);
		return d
	}

	function ly(e) {
		let t = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
		const i = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0],
			s = [];
		let n = [];
		const a = e.width || e.size || 1,
			r = e.height || e.size || 1,
			o = e.depth || e.size || 1,
			l = e.wrap || !1;
		let h = void 0 === e.topBaseAt ? 1 : e.topBaseAt,
			c = void 0 === e.bottomBaseAt ? 0 : e.bottomBaseAt;
		h = (h + 4) % 4, c = (c + 4) % 4;
		let u = [2, 0, 3, 1][h],
			m = [2, 0, 1, 3][c],
			d = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];
		if (l) {
			t = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14], d = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];
			let e = [
					[1, 1, 1],
					[-1, 1, 1],
					[-1, 1, -1],
					[1, 1, -1]
				],
				i = [
					[-1, -1, 1],
					[1, -1, 1],
					[1, -1, -1],
					[-1, -1, -1]
				];
			const s = [17, 18, 19, 16],
				n = [22, 23, 20, 21];
			for (; u > 0;) e.unshift(e.pop()), s.unshift(s.pop()), u--;
			for (; m > 0;) i.unshift(i.pop()), n.unshift(n.pop()), m--;
			e = e.flat(), i = i.flat(), d = d.concat(e).concat(i), t.push(s[0], s[2], s[3], s[0], s[1], s[2]), t.push(n[0], n[2], n[3], n[0], n[1], n[2])
		}
		const f = [a / 2, r / 2, o / 2];
		n = d.reduce(((e, t, i) => e.concat(t * f[i % 3])), []);
		const p = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			_ = e.faceUV || new Array(6),
			g = e.faceColors,
			v = [];
		for (let e = 0; e < 6; e++) void 0 === _[e] && (_[e] = new Bc(0, 0, 1, 1)), g && void 0 === g[e] && (g[e] = new wc(1, 1, 1, 1));
		for (let e = 0; e < 6; e++)
			if (s.push(_[e].z, _[e].w), s.push(_[e].x, _[e].w), s.push(_[e].x, _[e].y), s.push(_[e].z, _[e].y), g)
				for (let t = 0; t < 4; t++) v.push(g[e].r, g[e].g, g[e].b, g[e].a);
		Mu._ComputeSides(p, n, t, i, s, e.frontUVs, e.backUVs);
		const y = new Mu;
		if (y.indices = t, y.positions = n, y.normals = i, y.uvs = s, g) {
			const e = p === Mu.DOUBLESIDE ? v.concat(v) : v;
			y.colors = e
		}
		return y
	}

	function hy(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return ly(t).applyToMesh(s, t.updatable), s
	}

	function cy(e) {
		const t = e.pattern || Vf.NO_FLIP,
			i = e.tileWidth || e.tileSize || 1,
			s = e.tileHeight || e.tileSize || 1,
			n = e.alignHorizontal || 0,
			a = e.alignVertical || 0,
			r = e.width || e.size || 1,
			o = Math.floor(r / i);
		let l = r - o * i;
		const h = e.height || e.size || 1,
			c = Math.floor(h / s);
		let u = h - c * s;
		const m = i * o / 2,
			d = s * c / 2;
		let f = 0,
			p = 0,
			_ = 0,
			g = 0,
			v = 0,
			y = 0;
		if (l > 0 || u > 0) {
			switch (_ = -m, g = -d, v = m, y = d, n) {
				case Vf.CENTER:
					l /= 2, _ -= l, v += l;
					break;
				case Vf.LEFT:
					v += l, f = -l / 2;
					break;
				case Vf.RIGHT:
					_ -= l, f = l / 2
			}
			switch (a) {
				case Vf.CENTER:
					u /= 2, g -= u, y += u;
					break;
				case Vf.BOTTOM:
					y += u, p = -u / 2;
					break;
				case Vf.TOP:
					g -= u, p = u / 2
			}
		}
		const S = [],
			E = [],
			A = [];
		A[0] = [0, 0, 1, 0, 1, 1, 0, 1], A[1] = [0, 0, 1, 0, 1, 1, 0, 1], t !== Vf.ROTATE_TILE && t !== Vf.ROTATE_ROW || (A[1] = [1, 1, 0, 1, 0, 0, 1, 0]), t !== Vf.FLIP_TILE && t !== Vf.FLIP_ROW || (A[1] = [1, 0, 0, 0, 0, 1, 1, 1]), t !== Vf.FLIP_N_ROTATE_TILE && t !== Vf.FLIP_N_ROTATE_ROW || (A[1] = [0, 1, 1, 1, 1, 0, 0, 0]);
		let b = [];
		const x = [],
			M = [];
		let C = 0;
		for (let e = 0; e < c; e++)
			for (let n = 0; n < o; n++) S.push(n * i - m + f, e * s - d + p, 0), S.push((n + 1) * i - m + f, e * s - d + p, 0), S.push((n + 1) * i - m + f, (e + 1) * s - d + p, 0), S.push(n * i - m + f, (e + 1) * s - d + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), b = t === Vf.FLIP_TILE || t === Vf.ROTATE_TILE || t === Vf.FLIP_N_ROTATE_TILE ? b.concat(A[(n % 2 + e % 2) % 2]) : t === Vf.FLIP_ROW || t === Vf.ROTATE_ROW || t === Vf.FLIP_N_ROTATE_ROW ? b.concat(A[e % 2]) : b.concat(A[0]), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1), C += 4;
		if (l > 0 || u > 0) {
			const e = u > 0 && (a === Vf.CENTER || a === Vf.TOP),
				r = u > 0 && (a === Vf.CENTER || a === Vf.BOTTOM),
				h = l > 0 && (n === Vf.CENTER || n === Vf.RIGHT),
				A = l > 0 && (n === Vf.CENTER || n === Vf.LEFT);
			let T, w, R, N, I = [];
			if (e && h && (S.push(_ + f, g + p, 0), S.push(-m + f, g + p, 0), S.push(-m + f, g + u + p, 0), S.push(_ + f, g + u + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, T = 1 - l / i, w = 1 - u / s, R = 1, N = 1, I = [T, w, R, w, R, N, T, N], t === Vf.ROTATE_ROW && (I = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), t === Vf.FLIP_ROW && (I = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), t === Vf.FLIP_N_ROTATE_ROW && (I = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]), b = b.concat(I), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)), e && A && (S.push(m + f, g + p, 0), S.push(v + f, g + p, 0), S.push(v + f, g + u + p, 0), S.push(m + f, g + u + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, T = 0, w = 1 - u / s, R = l / i, N = 1, I = [T, w, R, w, R, N, T, N], (t === Vf.ROTATE_ROW || t === Vf.ROTATE_TILE && o % 2 == 0) && (I = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), (t === Vf.FLIP_ROW || t === Vf.FLIP_TILE && o % 2 == 0) && (I = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), (t === Vf.FLIP_N_ROTATE_ROW || t === Vf.FLIP_N_ROTATE_TILE && o % 2 == 0) && (I = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]), b = b.concat(I), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)), r && h && (S.push(_ + f, d + p, 0), S.push(-m + f, d + p, 0), S.push(-m + f, y + p, 0), S.push(_ + f, y + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, T = 1 - l / i, w = 0, R = 1, N = u / s, I = [T, w, R, w, R, N, T, N], (t === Vf.ROTATE_ROW && c % 2 == 1 || t === Vf.ROTATE_TILE && c % 1 == 0) && (I = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), (t === Vf.FLIP_ROW && c % 2 == 1 || t === Vf.FLIP_TILE && c % 2 == 0) && (I = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), (t === Vf.FLIP_N_ROTATE_ROW && c % 2 == 1 || t === Vf.FLIP_N_ROTATE_TILE && c % 2 == 0) && (I = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]), b = b.concat(I), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)), r && A && (S.push(m + f, d + p, 0), S.push(v + f, d + p, 0), S.push(v + f, y + p, 0), S.push(m + f, y + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, T = 0, w = 0, R = l / i, N = u / s, I = [T, w, R, w, R, N, T, N], (t === Vf.ROTATE_ROW && c % 2 == 1 || t === Vf.ROTATE_TILE && (c + o) % 2 == 1) && (I = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), (t === Vf.FLIP_ROW && c % 2 == 1 || t === Vf.FLIP_TILE && (c + o) % 2 == 1) && (I = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), (t === Vf.FLIP_N_ROTATE_ROW && c % 2 == 1 || t === Vf.FLIP_N_ROTATE_TILE && (c + o) % 2 == 1) && (I = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]), b = b.concat(I), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)), e) {
				const e = [];
				T = 0, w = 1 - u / s, R = 1, N = 1, e[0] = [T, w, R, w, R, N, T, N], e[1] = [T, w, R, w, R, N, T, N], t !== Vf.ROTATE_TILE && t !== Vf.ROTATE_ROW || (e[1] = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), t !== Vf.FLIP_TILE && t !== Vf.FLIP_ROW || (e[1] = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), t !== Vf.FLIP_N_ROTATE_TILE && t !== Vf.FLIP_N_ROTATE_ROW || (e[1] = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]);
				for (let s = 0; s < o; s++) S.push(s * i - m + f, g + p, 0), S.push((s + 1) * i - m + f, g + p, 0), S.push((s + 1) * i - m + f, g + u + p, 0), S.push(s * i - m + f, g + u + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, b = t === Vf.FLIP_TILE || t === Vf.ROTATE_TILE || t === Vf.FLIP_N_ROTATE_TILE ? b.concat(e[(s + 1) % 2]) : t === Vf.FLIP_ROW || t === Vf.ROTATE_ROW || t === Vf.FLIP_N_ROTATE_ROW ? b.concat(e[1]) : b.concat(e[0]), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)
			}
			if (r) {
				const e = [];
				T = 0, w = 0, R = 1, N = u / s, e[0] = [T, w, R, w, R, N, T, N], e[1] = [T, w, R, w, R, N, T, N], t !== Vf.ROTATE_TILE && t !== Vf.ROTATE_ROW || (e[1] = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), t !== Vf.FLIP_TILE && t !== Vf.FLIP_ROW || (e[1] = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), t !== Vf.FLIP_N_ROTATE_TILE && t !== Vf.FLIP_N_ROTATE_ROW || (e[1] = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]);
				for (let s = 0; s < o; s++) S.push(s * i - m + f, y - u + p, 0), S.push((s + 1) * i - m + f, y - u + p, 0), S.push((s + 1) * i - m + f, y + p, 0), S.push(s * i - m + f, y + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, b = t === Vf.FLIP_TILE || t === Vf.ROTATE_TILE || t === Vf.FLIP_N_ROTATE_TILE ? b.concat(e[(s + c) % 2]) : t === Vf.FLIP_ROW || t === Vf.ROTATE_ROW || t === Vf.FLIP_N_ROTATE_ROW ? b.concat(e[c % 2]) : b.concat(e[0]), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)
			}
			if (h) {
				const e = [];
				T = 1 - l / i, w = 0, R = 1, N = 1, e[0] = [T, w, R, w, R, N, T, N], e[1] = [T, w, R, w, R, N, T, N], t !== Vf.ROTATE_TILE && t !== Vf.ROTATE_ROW || (e[1] = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), t !== Vf.FLIP_TILE && t !== Vf.FLIP_ROW || (e[1] = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), t !== Vf.FLIP_N_ROTATE_TILE && t !== Vf.FLIP_N_ROTATE_ROW || (e[1] = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]);
				for (let i = 0; i < c; i++) S.push(_ + f, i * s - d + p, 0), S.push(_ + l + f, i * s - d + p, 0), S.push(_ + l + f, (i + 1) * s - d + p, 0), S.push(_ + f, (i + 1) * s - d + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, b = t === Vf.FLIP_TILE || t === Vf.ROTATE_TILE || t === Vf.FLIP_N_ROTATE_TILE ? b.concat(e[(i + 1) % 2]) : t === Vf.FLIP_ROW || t === Vf.ROTATE_ROW || t === Vf.FLIP_N_ROTATE_ROW ? b.concat(e[i % 2]) : b.concat(e[0]), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)
			}
			if (A) {
				const e = [];
				T = 0, w = 0, R = l / s, N = 1, e[0] = [T, w, R, w, R, N, T, N], e[1] = [T, w, R, w, R, N, T, N], t !== Vf.ROTATE_TILE && t !== Vf.ROTATE_ROW || (e[1] = [1 - T, 1 - w, 1 - R, 1 - w, 1 - R, 1 - N, 1 - T, 1 - N]), t !== Vf.FLIP_TILE && t !== Vf.FLIP_ROW || (e[1] = [1 - T, w, 1 - R, w, 1 - R, N, 1 - T, N]), t !== Vf.FLIP_N_ROTATE_TILE && t !== Vf.FLIP_N_ROTATE_ROW || (e[1] = [T, 1 - w, R, 1 - w, R, 1 - N, T, 1 - N]);
				for (let i = 0; i < c; i++) S.push(v - l + f, i * s - d + p, 0), S.push(v + f, i * s - d + p, 0), S.push(v + f, (i + 1) * s - d + p, 0), S.push(v - l + f, (i + 1) * s - d + p, 0), M.push(C, C + 1, C + 3, C + 1, C + 2, C + 3), C += 4, b = t === Vf.FLIP_TILE || t === Vf.ROTATE_TILE || t === Vf.FLIP_N_ROTATE_TILE ? b.concat(e[(i + o) % 2]) : t === Vf.FLIP_ROW || t === Vf.ROTATE_ROW || t === Vf.FLIP_N_ROTATE_ROW ? b.concat(e[i % 2]) : b.concat(e[0]), x.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), E.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1)
			}
		}
		const T = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE;
		Mu._ComputeSides(T, S, M, E, b, e.frontUVs, e.backUVs);
		const w = new Mu;
		w.indices = M, w.positions = S, w.normals = E, w.uvs = b;
		const R = T === Mu.DOUBLESIDE ? x.concat(x) : x;
		return w.colors = R, w
	}

	function uy(e) {
		const t = e.faceUV || new Array(6),
			i = e.faceColors,
			s = e.pattern || Vf.NO_FLIP,
			n = e.width || e.size || 1,
			a = e.height || e.size || 1,
			r = e.depth || e.size || 1,
			o = e.tileWidth || e.tileSize || 1,
			l = e.tileHeight || e.tileSize || 1,
			h = e.alignHorizontal || 0,
			c = e.alignVertical || 0,
			u = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE;
		for (let e = 0; e < 6; e++) void 0 === t[e] && (t[e] = new Bc(0, 0, 1, 1)), i && void 0 === i[e] && (i[e] = new wc(1, 1, 1, 1));
		const m = n / 2,
			d = a / 2,
			f = r / 2,
			p = [];
		for (let e = 0; e < 2; e++) p[e] = cy({
			pattern: s,
			tileWidth: o,
			tileHeight: l,
			width: n,
			height: a,
			alignVertical: c,
			alignHorizontal: h,
			sideOrientation: u
		});
		for (let e = 2; e < 4; e++) p[e] = cy({
			pattern: s,
			tileWidth: o,
			tileHeight: l,
			width: r,
			height: a,
			alignVertical: c,
			alignHorizontal: h,
			sideOrientation: u
		});
		let _ = c;
		c === Vf.BOTTOM ? _ = Vf.TOP : c === Vf.TOP && (_ = Vf.BOTTOM);
		for (let e = 4; e < 6; e++) p[e] = cy({
			pattern: s,
			tileWidth: o,
			tileHeight: l,
			width: n,
			height: r,
			alignVertical: _,
			alignHorizontal: h,
			sideOrientation: u
		});
		let g = [],
			v = [],
			y = [],
			S = [];
		const E = [],
			A = [],
			b = [],
			x = [];
		let M = 0,
			C = 0;
		for (let e = 0; e < 6; e++) {
			const s = p[e].positions.length;
			A[e] = [], b[e] = [];
			for (let t = 0; t < s / 3; t++) A[e].push(new Lc(p[e].positions[3 * t], p[e].positions[3 * t + 1], p[e].positions[3 * t + 2])), b[e].push(new Lc(p[e].normals[3 * t], p[e].normals[3 * t + 1], p[e].normals[3 * t + 2]));
			M = p[e].uvs.length, x[e] = [];
			for (let i = 0; i < M; i += 2) x[e][i] = t[e].x + (t[e].z - t[e].x) * p[e].uvs[i], x[e][i + 1] = t[e].y + (t[e].w - t[e].y) * p[e].uvs[i + 1];
			if (y = y.concat(x[e]), S = S.concat(p[e].indices.map((e => e + C))), C += A[e].length, i)
				for (let t = 0; t < 4; t++) E.push(i[e].r, i[e].g, i[e].b, i[e].a)
		}
		const T = new Lc(0, 0, f),
			w = Hc.RotationY(Math.PI);
		g = A[0].map((e => Lc.TransformNormal(e, w).add(T))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []), v = b[0].map((e => Lc.TransformNormal(e, w))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []), g = g.concat(A[1].map((e => e.subtract(T))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), v = v.concat(b[1].map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []));
		const R = new Lc(m, 0, 0),
			N = Hc.RotationY(-Math.PI / 2);
		g = g.concat(A[2].map((e => Lc.TransformNormal(e, N).add(R))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), v = v.concat(b[2].map((e => Lc.TransformNormal(e, N))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []));
		const I = Hc.RotationY(Math.PI / 2);
		g = g.concat(A[3].map((e => Lc.TransformNormal(e, I).subtract(R))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), v = v.concat(b[3].map((e => Lc.TransformNormal(e, I))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []));
		const P = new Lc(0, d, 0),
			k = Hc.RotationX(Math.PI / 2);
		g = g.concat(A[4].map((e => Lc.TransformNormal(e, k).add(P))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), v = v.concat(b[4].map((e => Lc.TransformNormal(e, k))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), []));
		const D = Hc.RotationX(-Math.PI / 2);
		g = g.concat(A[5].map((e => Lc.TransformNormal(e, D).subtract(P))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), v = v.concat(b[5].map((e => Lc.TransformNormal(e, D))).map((e => [e.x, e.y, e.z])).reduce(((e, t) => e.concat(t)), [])), Mu._ComputeSides(u, g, S, v, y);
		const O = new Mu;
		if (O.indices = S, O.positions = g, O.normals = v, O.uvs = y, i) {
			const e = u === Mu.DOUBLESIDE ? E.concat(E) : E;
			O.colors = e
		}
		return O
	}

	function my(e) {
		const t = 0 | (e.segments || 32),
			i = e.diameterX || e.diameter || 1,
			s = e.diameterY || e.diameter || 1,
			n = e.diameterZ || e.diameter || 1,
			a = e.arc && (e.arc <= 0 || e.arc > 1) ? 1 : e.arc || 1,
			r = e.slice && e.slice <= 0 ? 1 : e.slice || 1,
			o = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			l = !!e.dedupTopBottomIndices,
			h = new Lc(i / 2, s / 2, n / 2),
			c = 2 + t,
			u = 2 * c,
			m = [],
			d = [],
			f = [],
			p = [];
		for (let e = 0; e <= c; e++) {
			const t = e / c,
				i = t * Math.PI * r;
			for (let e = 0; e <= u; e++) {
				const s = e / u,
					n = s * Math.PI * 2 * a,
					r = Hc.RotationZ(-i),
					o = Hc.RotationY(n),
					l = Lc.TransformCoordinates(Lc.Up(), r),
					c = Lc.TransformCoordinates(l, o),
					m = c.multiply(h),
					_ = c.divide(h).normalize();
				d.push(m.x, m.y, m.z), f.push(_.x, _.y, _.z), p.push(s, t)
			}
			if (e > 0) {
				const t = d.length / 3;
				for (let i = t - 2 * (u + 1); i + u + 2 < t; i++) l ? (e > 1 && (m.push(i), m.push(i + 1), m.push(i + u + 1)), (e < c || r < 1) && (m.push(i + u + 1), m.push(i + 1), m.push(i + u + 2))) : (m.push(i), m.push(i + 1), m.push(i + u + 1), m.push(i + u + 1), m.push(i + 1), m.push(i + u + 2))
			}
		}
		Mu._ComputeSides(o, d, m, f, p, e.frontUVs, e.backUVs);
		const _ = new Mu;
		return _.indices = m, _.positions = d, _.normals = f, _.uvs = p, _
	}

	function dy(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return my(t).applyToMesh(s, t.updatable), s
	}

	function fy(e) {
		const t = e.height || 2;
		let i = 0 === e.diameterTop ? 0 : e.diameterTop || e.diameter || 1,
			s = 0 === e.diameterBottom ? 0 : e.diameterBottom || e.diameter || 1;
		i = i || 1e-5, s = s || 1e-5;
		const n = 0 | (e.tessellation || 24),
			a = 0 | (e.subdivisions || 1),
			r = !!e.hasRings,
			o = !!e.enclose,
			l = 0 === e.cap ? 0 : e.cap || Vf.CAP_ALL,
			h = e.arc && (e.arc <= 0 || e.arc > 1) ? 1 : e.arc || 1,
			c = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			u = e.faceUV || new Array(3),
			m = e.faceColors,
			d = 2 + (1 + (1 !== h && o ? 2 : 0)) * (r ? a : 1);
		let f;
		for (f = 0; f < d; f++) m && void 0 === m[f] && (m[f] = new wc(1, 1, 1, 1));
		for (f = 0; f < d; f++) u && void 0 === u[f] && (u[f] = new Bc(0, 0, 1, 1));
		const p = [],
			_ = [],
			g = [],
			v = [],
			y = [],
			S = 2 * Math.PI * h / n;
		let E, A, b;
		const x = (s - i) / 2 / t,
			M = Lc.Zero(),
			C = Lc.Zero(),
			T = Lc.Zero(),
			w = Lc.Zero(),
			R = Lc.Zero(),
			N = zd.Y;
		let I, P, k, D = 1,
			O = 1,
			F = 0,
			L = 0;
		for (I = 0; I <= a; I++)
			for (A = I / a, b = (A * (i - s) + s) / 2, D = r && 0 !== I && I !== a ? 2 : 1, k = 0; k < D; k++) {
				for (r && (O += k), o && (O += 2 * k), P = 0; P <= n; P++) E = P * S, M.x = Math.cos(-E) * b, M.y = -t / 2 + A * t, M.z = Math.sin(-E) * b, 0 === i && I === a ? (C.x = g[g.length - 3 * (n + 1)], C.y = g[g.length - 3 * (n + 1) + 1], C.z = g[g.length - 3 * (n + 1) + 2]) : (C.x = M.x, C.z = M.z, C.y = Math.sqrt(C.x * C.x + C.z * C.z) * x, C.normalize()), 0 === P && (T.copyFrom(M), w.copyFrom(C)), _.push(M.x, M.y, M.z), g.push(C.x, C.y, C.z), L = r ? F !== O ? u[O].y : u[O].w : u[O].y + (u[O].w - u[O].y) * A, v.push(u[O].x + (u[O].z - u[O].x) * P / n, L), m && y.push(m[O].r, m[O].g, m[O].b, m[O].a);
				1 !== h && o && (_.push(M.x, M.y, M.z), _.push(0, M.y, 0), _.push(0, M.y, 0), _.push(T.x, T.y, T.z), Lc.CrossToRef(N, C, R), R.normalize(), g.push(R.x, R.y, R.z, R.x, R.y, R.z), Lc.CrossToRef(w, N, R), R.normalize(), g.push(R.x, R.y, R.z, R.x, R.y, R.z), L = r ? F !== O ? u[O + 1].y : u[O + 1].w : u[O + 1].y + (u[O + 1].w - u[O + 1].y) * A, v.push(u[O + 1].x, L), v.push(u[O + 1].z, L), L = r ? F !== O ? u[O + 2].y : u[O + 2].w : u[O + 2].y + (u[O + 2].w - u[O + 2].y) * A, v.push(u[O + 2].x, L), v.push(u[O + 2].z, L), m && (y.push(m[O + 1].r, m[O + 1].g, m[O + 1].b, m[O + 1].a), y.push(m[O + 1].r, m[O + 1].g, m[O + 1].b, m[O + 1].a), y.push(m[O + 2].r, m[O + 2].g, m[O + 2].b, m[O + 2].a), y.push(m[O + 2].r, m[O + 2].g, m[O + 2].b, m[O + 2].a))), F !== O && (F = O)
			}
		const B = 1 !== h && o ? n + 4 : n;
		for (I = 0, O = 0; O < a; O++) {
			let e = 0,
				t = 0,
				i = 0,
				s = 0;
			for (P = 0; P < n; P++) e = I * (B + 1) + P, t = (I + 1) * (B + 1) + P, i = I * (B + 1) + (P + 1), s = (I + 1) * (B + 1) + (P + 1), p.push(e, t, i), p.push(s, i, t);
			1 !== h && o && (p.push(e + 2, t + 2, i + 2), p.push(s + 2, i + 2, t + 2), p.push(e + 4, t + 4, i + 4), p.push(s + 4, i + 4, t + 4)), I = r ? I + 2 : I + 1
		}
		const G = e => {
			const a = e ? i / 2 : s / 2;
			if (0 === a) return;
			let r, o, l;
			const c = e ? u[d - 1] : u[0];
			let f = null;
			m && (f = e ? m[d - 1] : m[0]);
			const S = _.length / 3,
				E = e ? t / 2 : -t / 2,
				A = new Lc(0, E, 0);
			_.push(A.x, A.y, A.z), g.push(0, e ? 1 : -1, 0);
			const b = c.y + .5 * (c.w - c.y);
			v.push(c.x + .5 * (c.z - c.x), b), f && y.push(f.r, f.g, f.b, f.a);
			const x = new Fc(.5, .5);
			for (l = 0; l <= n; l++) {
				r = 2 * Math.PI * l * h / n;
				const t = Math.cos(-r),
					i = Math.sin(-r);
				o = new Lc(t * a, E, i * a);
				const s = new Fc(t * x.x + .5, i * x.y + .5);
				_.push(o.x, o.y, o.z), g.push(0, e ? 1 : -1, 0);
				const u = c.y + (c.w - c.y) * s.y;
				v.push(c.x + (c.z - c.x) * s.x, u), f && y.push(f.r, f.g, f.b, f.a)
			}
			for (l = 0; l < n; l++) e ? (p.push(S), p.push(S + (l + 2)), p.push(S + (l + 1))) : (p.push(S), p.push(S + (l + 1)), p.push(S + (l + 2)))
		};
		l !== Vf.CAP_START && l !== Vf.CAP_ALL || G(!1), l !== Vf.CAP_END && l !== Vf.CAP_ALL || G(!0), Mu._ComputeSides(c, _, p, g, v, e.frontUVs, e.backUVs);
		const H = new Mu;
		return H.indices = p, H.positions = _, H.normals = g, H.uvs = v, m && (H.colors = y), H
	}

	function py(e, t = {}, i) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return fy(t).applyToMesh(s, t.updatable), s
	}

	function _y(e) {
		const t = [],
			i = [],
			s = [],
			n = [],
			a = e.diameter || 1,
			r = e.thickness || .5,
			o = 0 | (e.tessellation || 16),
			l = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			h = o + 1;
		for (let e = 0; e <= o; e++) {
			const l = e / o,
				c = e * Math.PI * 2 / o - Math.PI / 2,
				u = Hc.Translation(a / 2, 0, 0).multiply(Hc.RotationY(c));
			for (let a = 0; a <= o; a++) {
				const c = 1 - a / o,
					m = a * Math.PI * 2 / o + Math.PI,
					d = Math.cos(m),
					f = Math.sin(m);
				let p = new Lc(d, f, 0),
					_ = p.scale(r / 2);
				const g = new Fc(l, c);
				_ = Lc.TransformCoordinates(_, u), p = Lc.TransformNormal(p, u), i.push(_.x, _.y, _.z), s.push(p.x, p.y, p.z), n.push(g.x, g.y);
				const v = (e + 1) % h,
					y = (a + 1) % h;
				t.push(e * h + a), t.push(e * h + y), t.push(v * h + a), t.push(e * h + y), t.push(v * h + y), t.push(v * h + a)
			}
		}
		Mu._ComputeSides(l, i, t, s, n, e.frontUVs, e.backUVs);
		const c = new Mu;
		return c.indices = t, c.positions = i, c.normals = s, c.uvs = n, c
	}

	function gy(e, t = {}, i) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return _y(t).applyToMesh(s, t.updatable), s
	}

	function vy(e) {
		const t = [],
			i = [],
			s = [],
			n = [],
			a = e.radius || 2,
			r = e.tube || .5,
			o = e.radialSegments || 32,
			l = e.tubularSegments || 32,
			h = e.p || 2,
			c = e.q || 3,
			u = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			m = e => {
				const t = Math.cos(e),
					i = Math.sin(e),
					s = c / h * e,
					n = Math.cos(s),
					r = a * (2 + n) * .5 * t,
					o = a * (2 + n) * i * .5,
					l = a * Math.sin(s) * .5;
				return new Lc(r, o, l)
			};
		let d, f;
		for (d = 0; d <= o; d++) {
			const e = d % o / o * 2 * h * Math.PI,
				t = m(e),
				s = m(e + .01),
				a = s.subtract(t);
			let c = s.add(t);
			const u = Lc.Cross(a, c);
			for (c = Lc.Cross(u, a), u.normalize(), c.normalize(), f = 0; f < l; f++) {
				const e = f % l / l * 2 * Math.PI,
					s = -r * Math.cos(e),
					a = r * Math.sin(e);
				i.push(t.x + s * c.x + a * u.x), i.push(t.y + s * c.y + a * u.y), i.push(t.z + s * c.z + a * u.z), n.push(d / o), n.push(f / l)
			}
		}
		for (d = 0; d < o; d++)
			for (f = 0; f < l; f++) {
				const e = (f + 1) % l,
					i = d * l + f,
					s = (d + 1) * l + f,
					n = (d + 1) * l + e,
					a = d * l + e;
				t.push(a), t.push(s), t.push(i), t.push(a), t.push(n), t.push(s)
			}
		Mu.ComputeNormals(i, t, s), Mu._ComputeSides(u, i, t, s, n, e.frontUVs, e.backUVs);
		const p = new Mu;
		return p.indices = t, p.positions = i, p.normals = s, p.uvs = n, p
	}

	function yy(e, t = {}, i) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return vy(t).applyToMesh(s, t.updatable), s
	}
	Mu.CreateGround = iy, Mu.CreateTiledGround = sy, Mu.CreateGroundFromHeightMap = ny, Vf.CreateGround = (e, t, i, s, n, a) => ay(e, {
		width: t,
		height: i,
		subdivisions: s,
		updatable: a
	}, n), Vf.CreateTiledGround = (e, t, i, s, n, a, r, o, l) => ry(e, {
		xmin: t,
		zmin: i,
		xmax: s,
		zmax: n,
		subdivisions: a,
		precision: r,
		updatable: l
	}, o), Vf.CreateGroundFromHeightMap = (e, t, i, s, n, a, r, o, l, h, c) => oy(e, t, {
		width: i,
		height: s,
		subdivisions: n,
		minHeight: a,
		maxHeight: r,
		updatable: l,
		onReady: h,
		alphaFilter: c
	}, o), Mu.dk = ly, Vf.dk = (e, t, i = null, s, n) => hy(e, {
		size: t,
		sideOrientation: n,
		updatable: s
	}, i), Mu.CreateTiledPlane = cy, Mu.CreateTiledBox = uy, Mu.Rk = my, Vf.Rk = (e, t, i, s, n, a) => dy(e, {
		segments: t,
		diameterX: i,
		diameterY: i,
		diameterZ: i,
		sideOrientation: a,
		updatable: n
	}, s), Mu.Ak = fy, Vf.Ak = (e, t, i, s, n, a, r, o, l) => {
		void 0 !== r && r instanceof bg || (void 0 !== r && (l = o || Vf.DEFAULTSIDE, o = r), r = a, a = 1);
		return py(e, {
			height: t,
			diameterTop: i,
			diameterBottom: s,
			tessellation: n,
			subdivisions: a,
			sideOrientation: l,
			updatable: o
		}, r)
	}, Mu.CreateTorus = _y, Vf.CreateTorus = (e, t, i, s, n, a, r) => gy(e, {
		diameter: t,
		thickness: i,
		tessellation: s,
		sideOrientation: r,
		updatable: a
	}, n), Mu.CreateTorusKnot = vy, Vf.CreateTorusKnot = (e, t, i, s, n, a, r, o, l, h) => yy(e, {
		radius: t,
		tube: i,
		radialSegments: s,
		tubularSegments: n,
		p: a,
		q: r,
		sideOrientation: h,
		updatable: l
	}, o), Vf._instancedMeshFactory = (e, t) => {
		const i = new Sy(e, t);
		if (t.instancedBuffers) {
			i.instancedBuffers = {};
			for (const e in t.instancedBuffers) i.instancedBuffers[e] = t.instancedBuffers[e]
		}
		return i
	};
	var Sy = class extends jd {
		get wk() {
			return this._sourceMesh
		}
		isVerticesDataPresent(e) {
			return this._sourceMesh.isVerticesDataPresent(e)
		}
		clone(e, t = null, i, s) {
			const n = (s || this._sourceMesh).createInstance(e);
			if (Iu.DeepCopy(this, n, ["name", "subMeshes", "uniqueId", "parent", "lightSources", "receiveShadows", "material", "visibility", "skeleton", "sourceMesh", "isAnInstance", "facetNb", "isFacetDataEnabled", "isBlocked", "useBones", "hasInstances", "collider", "edgesRenderer", "forward", "up", "right", "absolutePosition", "absoluteScaling", "absoluteRotationQuaternion", "isWorldMatrixFrozen", "nonUniformScaling", "behaviors", "worldMatrixFromCache", "hasThinInstances", "hasBoundingInfo"], []), this.refreshBoundingInfo(), t && (n.parent = t), !i)
				for (let e = 0; e < this.getScene().meshes.length; e++) {
					const t = this.getScene().meshes[e];
					t.parent === this && t.clone(t.name, n)
				}
			return n.computeWorldMatrix(!0), this.onClonedObservable.notifyObservers(n), n
		}
		get _positions() {
			return this._sourceMesh._positions
		}
		get skeleton() {
			return this._sourceMesh.skeleton
		}
		getLOD(e) {
			if (!e) return this;
			const t = this.wk.getLODLevels();
			if (t && 0 !== t.length) {
				const t = this.getBoundingInfo();
				this._currentLOD = this.wk.getLOD(e, t.boundingSphere)
			} else this._currentLOD = this.wk;
			return this._currentLOD
		}
		setIndices(e, t = null) {
			return this.wk && this.wk.setIndices(e, t), this.wk
		}
		getClassName() {
			return "InstancedMesh"
		}
		getVerticesData(e, t, i) {
			return this._sourceMesh.getVerticesData(e, t, i)
		}
		_resyncLightSources() {}
		copyVerticesData(e, t) {
			this._sourceMesh.copyVerticesData(e, t)
		}
		_resyncLightSource() {}
		_updateBoundingInfo() {
			return this.hasBoundingInfo ? this.getBoundingInfo().update(this.worldMatrixFromCache) : this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this
		}
		get visibility() {
			return this._sourceMesh.visibility
		}
		get material() {
			return this._sourceMesh.material
		}
		updateVerticesData(e, t, i, s) {
			return this.wk && this.wk.updateVerticesData(e, t, i, s), this.wk
		}
		createInstance(e) {
			return this._sourceMesh.createInstance(e)
		}
		set material(e) {
			this._sourceMesh?.material !== e && dd.Warn("Setting material on an instanced mesh has no effect")
		}
		_postActivate() {
			this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup ? (this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer), this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())) : this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup && this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)
		}
		getWorldMatrix() {
			if (this._currentLOD && this._currentLOD.billboardMode !== Jc.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
				this._billboardWorldMatrix || (this._billboardWorldMatrix = new Hc);
				const e = this._currentLOD._masterMesh;
				return this._currentLOD._masterMesh = this, Vc.Vector3[7].copyFrom(this._currentLOD.position), this._currentLOD.position.set(0, 0, 0), this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)), this._currentLOD.position.copyFrom(Vc.Vector3[7]), this._currentLOD._masterMesh = e, this._billboardWorldMatrix
			}
			return super.getWorldMatrix()
		}
		set visibility(e) {
			this._sourceMesh?.visibility !== e && dd.Warn("Setting visibility on an instanced mesh has no effect")
		}
		get lightSources() {
			return this._sourceMesh._lightSources
		}
		instantiateHierarchy(e = null, t, i) {
			const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0, t && t.newSourcedMesh);
			s && i && i(this, s);
			for (const e of this.getChildTransformNodes(!0)) e.instantiateHierarchy(s, t, i);
			return s
		}
		get isAnInstance() {
			return !0
		}
		_removeLightSource() {}
		getTotalIndices() {
			return this._sourceMesh.getTotalIndices()
		}
		set receiveShadows(e) {
			this._sourceMesh?.receiveShadows !== e && dd.Warn("Setting receiveShadows on an instanced mesh has no effect")
		}
		_generatePointsArray() {
			return this._sourceMesh._generatePointsArray()
		}
		get receiveShadows() {
			return this._sourceMesh.receiveShadows
		}
		get Lk() {
			return this._sourceMesh.Lk
		}
		constructor(e, t) {
			super(e, t.getScene()), this._indexInSourceMeshInstanceArray = -1, this._distanceToCamera = 0, t.addInstance(this), this._sourceMesh = t, this._unIndexed = t._unIndexed, this.position.copyFrom(t.position), this.rotation.copyFrom(t.rotation), this.scaling.copyFrom(t.scaling), t.rotationQuaternion && (this.rotationQuaternion = t.rotationQuaternion.clone()), this.animations = t.animations.slice();
			for (const e of t.getAnimationRanges()) null != e && this.createAnimationRange(e.name, e.from, e.to);
			this.infiniteDistance = t.infiniteDistance, this.setPivotMatrix(t.getPivotMatrix()), this.refreshBoundingInfo(!0, !0), this._syncSubMeshes()
		}
		setVerticesData(e, t, i, s) {
			return this.wk && this.wk.setVerticesData(e, t, i, s), this.wk
		}
		_preActivate() {
			return this._currentLOD && this._currentLOD._preActivate(), this
		}
		set skeleton(e) {
			this._sourceMesh?.skeleton !== e && dd.Warn("Setting skeleton on an instanced mesh has no effect")
		}
		dispose(e, t = !1) {
			this._sourceMesh.removeInstance(this), super.dispose(e, t)
		}
		_activate(e, t) {
			if (super._activate(e, t), this._sourceMesh.subMeshes || Qc.Warn("Instances should only be created for meshes with geometry."), this._currentLOD) {
				if (this._currentLOD._getWorldMatrixDeterminant() >= 0 != this._getWorldMatrixDeterminant() >= 0) return this._internalAbstractMeshDataInfo._actAsRegularMesh = !0, !0;
				if (this._internalAbstractMeshDataInfo._actAsRegularMesh = !1, this._currentLOD._registerInstanceForRenderId(this, e), t) {
					if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !0, !0
				} else if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = !0, !0
			}
			return !1
		}
		getIndices() {
			return this._sourceMesh.getIndices()
		}
		getTotalVertices() {
			return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0
		}
		set Lk(e) {
			this._sourceMesh && e !== this._sourceMesh.Lk && Qc.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")
		}
		_preActivateForIntermediateRendering(e) {
			return this.wk._preActivateForIntermediateRendering(e)
		}
		refreshBoundingInfo(e = !1, t = !1) {
			if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) return this;
			let i;
			i = "object" == typeof e ? e : {
				applySkeleton: e,
				applyMorph: t
			};
			const s = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
			return this._refreshBoundingInfo(this._sourceMesh._getData(i, null, eu.PositionKind), s), this
		}
		isReady(e = !1) {
			return this._sourceMesh.isReady(e, !0)
		}
		_serializeAsParent(e) {
			super._serializeAsParent(e), e.parentId = this._sourceMesh.ik, e.parentInstanceIndex = this._indexInSourceMeshInstanceArray
		}
		_syncSubMeshes() {
			if (this.releaseSubMeshes(), this._sourceMesh.subMeshes)
				for (let e = 0; e < this._sourceMesh.subMeshes.length; e++) this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh);
			return this
		}
	};
	Vf.prototype.registerInstancedBuffer = function(e, t) {
		if (this._userInstancedBuffersStorage?.vertexBuffers[e]?.dispose(), !this.instancedBuffers) {
			this.instancedBuffers = {};
			for (const e of this.instances) e.instancedBuffers = {}
		}
		this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
			data: {},
			vertexBuffers: {},
			strides: {},
			sizes: {},
			vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
		}), this.instancedBuffers[e] = null, this._userInstancedBuffersStorage.strides[e] = t, this._userInstancedBuffersStorage.sizes[e] = 32 * t, this._userInstancedBuffersStorage.data[e] = new Float32Array(this._userInstancedBuffersStorage.sizes[e]), this._userInstancedBuffersStorage.vertexBuffers[e] = new eu(this.getEngine(), this._userInstancedBuffersStorage.data[e], e, !0, !1, t, !0);
		for (const t of this.instances) t.instancedBuffers[e] = null;
		this._invalidateInstanceVertexArrayObject(), this._markSubMeshesAsAttributesDirty()
	}, Vf.prototype._processInstancedBuffers = function(e, t) {
		const i = e ? e.length : 0;
		for (const s in this.instancedBuffers) {
			let n = this._userInstancedBuffersStorage.sizes[s];
			const a = this._userInstancedBuffersStorage.strides[s],
				r = (i + 1) * a;
			for (; n < r;) n *= 2;
			this._userInstancedBuffersStorage.data[s].length != n && (this._userInstancedBuffersStorage.data[s] = new Float32Array(n), this._userInstancedBuffersStorage.sizes[s] = n, this._userInstancedBuffersStorage.vertexBuffers[s] && (this._userInstancedBuffersStorage.vertexBuffers[s].dispose(), this._userInstancedBuffersStorage.vertexBuffers[s] = null));
			const o = this._userInstancedBuffersStorage.data[s];
			let l = 0;
			if (t) {
				const e = this.instancedBuffers[s];
				e.toArray ? e.toArray(o, l) : e.copyToArray ? e.copyToArray(o, l) : o[l] = e, l += a
			}
			for (let t = 0; t < i; t++) {
				const i = e[t].instancedBuffers[s];
				i.toArray ? i.toArray(o, l) : i.copyToArray ? i.copyToArray(o, l) : o[l] = i, l += a
			}
			this._userInstancedBuffersStorage.vertexBuffers[s] ? this._userInstancedBuffersStorage.vertexBuffers[s].updateDirectly(o, 0) : (this._userInstancedBuffersStorage.vertexBuffers[s] = new eu(this.getEngine(), this._userInstancedBuffersStorage.data[s], s, !0, !1, a, !0), this._invalidateInstanceVertexArrayObject())
		}
	}, Vf.prototype._invalidateInstanceVertexArrayObject = function() {
		if (this._userInstancedBuffersStorage && void 0 !== this._userInstancedBuffersStorage.vertexArrayObjects) {
			for (const e in this._userInstancedBuffersStorage.vertexArrayObjects) this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[e]);
			this._userInstancedBuffersStorage.vertexArrayObjects = {}
		}
	}, Vf.prototype._disposeInstanceSpecificData = function() {
		for (this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null); this.instances.length;) this.instances[0].dispose();
		for (const e in this.instancedBuffers) this._userInstancedBuffersStorage.vertexBuffers[e] && this._userInstancedBuffersStorage.vertexBuffers[e].dispose();
		this._invalidateInstanceVertexArrayObject(), this.instancedBuffers = {}
	}, cc("BABYLON.InstancedMesh", Sy);
	var Ey = {
			effect: null,
			subMesh: null
		},
		Ay = class e extends $f {
			get options() {
				return this._options
			}
			setVector3(e, t) {
				return this._checkUniform(e), this._vectors3[e] = t, this
			}
			setMatrices(e, t) {
				this._checkUniform(e);
				const i = new Float32Array(16 * t.length);
				for (let e = 0; e < t.length; e++) {
					t[e].copyToArray(i, 16 * e)
				}
				return this._matrixArrays[e] = i, this
			}
			setQuaternionArray(e, t) {
				return this._checkUniform(e), this._quaternionsArrays[e] = t.reduce(((e, t) => (t.toArray(e, e.length), e)), []), this
			}
			serialize() {
				const e = Xc.Serialize(this);
				let t;
				for (t in e.customType = "BABYLON.ShaderMaterial", e.ik = this.ik, e.options = this._options, e.shaderPath = this._shaderPath, e.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes, e.stencil = this.stencil.serialize(), e.textures = {}, this._textures) e.textures[t] = this._textures[t].serialize();
				for (t in e.textureArrays = {}, this._textureArrays) {
					e.textureArrays[t] = [];
					const i = this._textureArrays[t];
					for (let s = 0; s < i.length; s++) e.textureArrays[t].push(i[s].serialize())
				}
				for (t in e.ints = {}, this._ints) e.ints[t] = this._ints[t];
				for (t in e.uints = {}, this._uints) e.uints[t] = this._uints[t];
				for (t in e.floats = {}, this._floats) e.floats[t] = this._floats[t];
				for (t in e.floatsArrays = {}, this._floatsArrays) e.floatsArrays[t] = this._floatsArrays[t];
				for (t in e.colors3 = {}, this._colors3) e.colors3[t] = this._colors3[t].asArray();
				for (t in e.colors3Arrays = {}, this._colors3Arrays) e.colors3Arrays[t] = this._colors3Arrays[t];
				for (t in e.colors4 = {}, this._colors4) e.colors4[t] = this._colors4[t].asArray();
				for (t in e.colors4Arrays = {}, this._colors4Arrays) e.colors4Arrays[t] = this._colors4Arrays[t];
				for (t in e.vectors2 = {}, this._vectors2) e.vectors2[t] = this._vectors2[t].asArray();
				for (t in e.vectors3 = {}, this._vectors3) e.vectors3[t] = this._vectors3[t].asArray();
				for (t in e.vectors4 = {}, this._vectors4) e.vectors4[t] = this._vectors4[t].asArray();
				for (t in e.quaternions = {}, this._quaternions) e.quaternions[t] = this._quaternions[t].asArray();
				for (t in e.matrices = {}, this._matrices) e.matrices[t] = this._matrices[t].asArray();
				for (t in e.matrixArray = {}, this._matrixArrays) e.matrixArray[t] = this._matrixArrays[t];
				for (t in e.matrices3x3 = {}, this._matrices3x3) e.matrices3x3[t] = this._matrices3x3[t];
				for (t in e.matrices2x2 = {}, this._matrices2x2) e.matrices2x2[t] = this._matrices2x2[t];
				for (t in e.vectors2Arrays = {}, this._vectors2Arrays) e.vectors2Arrays[t] = this._vectors2Arrays[t];
				for (t in e.vectors3Arrays = {}, this._vectors3Arrays) e.vectors3Arrays[t] = this._vectors3Arrays[t];
				for (t in e.vectors4Arrays = {}, this._vectors4Arrays) e.vectors4Arrays[t] = this._vectors4Arrays[t];
				for (t in e.quaternionsArrays = {}, this._quaternionsArrays) e.quaternionsArrays[t] = this._quaternionsArrays[t];
				return e
			}
			setMatrix(e, t) {
				return this._checkUniform(e), this._matrices[e] = t, this
			}
			setColor4(e, t) {
				return this._checkUniform(e), this._colors4[e] = t, this
			}
			dispose(e, t, i) {
				if (t) {
					let e;
					for (e in this._textures) this._textures[e].dispose();
					for (e in this._textureArrays) {
						const t = this._textureArrays[e];
						for (let e = 0; e < t.length; e++) t[e].dispose()
					}
				}
				this._textures = {}, super.dispose(e, t, i)
			}
			setVector4(e, t) {
				return this._checkUniform(e), this._vectors4[e] = t, this
			}
			static ParseFromSnippetAsync(e, t, i = "") {
				return new Promise(((s, n) => {
					const a = new ku;
					a.addEventListener("readystatechange", (() => {
						if (4 == a.readyState)
							if (200 == a.status) {
								const n = JSON.parse(JSON.parse(a.responseText).jsonPayload),
									r = JSON.parse(n.shaderMaterial),
									o = this.Parse(r, t || Dc.LastCreatedScene, i);
								o.snippetId = e, s(o)
							} else n("Unable to load the snippet " + e)
					})), a.open("GET", this.SnippetUrl + "/" + e.replace(/#/g, "/")), a.send()
				}))
			}
			setColor4Array(e, t) {
				return this._checkUniform(e), this._colors4Arrays[e] = t.reduce(((e, t) => (t.toArray(e, e.length), e)), []), this
			}
			hasTexture(e) {
				if (super.hasTexture(e)) return !0;
				for (const t in this._textures)
					if (this._textures[t] === e) return !0;
				for (const t in this._textureArrays) {
					const i = this._textureArrays[t];
					for (let t = 0; t < i.length; t++)
						if (i[t] === e) return !0
				}
				return !1
			}
			getActiveTextures() {
				const e = super.getActiveTextures();
				for (const t in this._textures) e.push(this._textures[t]);
				for (const t in this._textureArrays) {
					const i = this._textureArrays[t];
					for (let t = 0; t < i.length; t++) e.push(i[t])
				}
				return e
			}
			isReadyForSubMesh(e, t, i) {
				return this.isReady(e, i, t)
			}
			setColor3(e, t) {
				return this._checkUniform(e), this._colors3[e] = t, this
			}
			setArray3(e, t) {
				return this._checkUniform(e), this._vectors3Arrays[e] = t, this
			}
			setTextureArray(e, t) {
				return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e), this._checkUniform(e), this._textureArrays[e] = t, this
			}
			setTextureSampler(e, t) {
				return -1 === this._options.samplerObjects.indexOf(e) && this._options.samplerObjects.push(e), this._textureSamplers[e] = t, this
			}
			get isMultiview() {
				return this._multiview
			}
			setInt(e, t) {
				return this._checkUniform(e), this._ints[e] = t, this
			}
			setStorageBuffer(e, t) {
				return -1 === this._options.storageBuffers.indexOf(e) && this._options.storageBuffers.push(e), this._storageBuffers[e] = t, this
			}
			get shaderPath() {
				return this._shaderPath
			}
			_checkUniform(e) {
				-1 === this._options.uniforms.indexOf(e) && this._options.uniforms.push(e)
			}
			setDefine(e, t) {
				const i = e.trimEnd() + " ",
					s = this.options.defines.findIndex((t => t === e || t.startsWith(i)));
				return s >= 0 && this.options.defines.splice(s, 1), ("boolean" != typeof t || t) && this.options.defines.push(i + t), this
			}
			set shaderPath(e) {
				this._shaderPath = e
			}
			static Parse(t, i, s) {
				const n = Xc.Parse((() => new e(t.name, i, t.shaderPath, t.options, t.storeEffectOnSubMeshes)), t, i, s);
				let a;
				for (a in t.stencil && n.stencil.parse(t.stencil, i, s), t.textures) n.setTexture(a, Np.Parse(t.textures[a], i, s));
				for (a in t.textureArrays) {
					const e = t.textureArrays[a],
						r = [];
					for (let t = 0; t < e.length; t++) r.push(Np.Parse(e[t], i, s));
					n.setTextureArray(a, r)
				}
				for (a in t.ints) n.setInt(a, t.ints[a]);
				for (a in t.uints) n.setUInt(a, t.uints[a]);
				for (a in t.floats) n.setFloat(a, t.floats[a]);
				for (a in t.floatsArrays) n.setFloats(a, t.floatsArrays[a]);
				for (a in t.colors3) n.setColor3(a, Tc.FromArray(t.colors3[a]));
				for (a in t.colors3Arrays) {
					const e = t.colors3Arrays[a].reduce(((e, t, i) => (i % 3 == 0 ? e.push([t]) : e[e.length - 1].push(t), e)), []).map((e => Tc.FromArray(e)));
					n.setColor3Array(a, e)
				}
				for (a in t.colors4) n.setColor4(a, wc.FromArray(t.colors4[a]));
				for (a in t.colors4Arrays) {
					const e = t.colors4Arrays[a].reduce(((e, t, i) => (i % 4 == 0 ? e.push([t]) : e[e.length - 1].push(t), e)), []).map((e => wc.FromArray(e)));
					n.setColor4Array(a, e)
				}
				for (a in t.vectors2) n.setVector2(a, Fc.FromArray(t.vectors2[a]));
				for (a in t.vectors3) n.setVector3(a, Lc.FromArray(t.vectors3[a]));
				for (a in t.vectors4) n.setVector4(a, Bc.FromArray(t.vectors4[a]));
				for (a in t.quaternions) n.setQuaternion(a, Gc.FromArray(t.quaternions[a]));
				for (a in t.matrices) n.setMatrix(a, Hc.FromArray(t.matrices[a]));
				for (a in t.matrixArray) n._matrixArrays[a] = new Float32Array(t.matrixArray[a]);
				for (a in t.matrices3x3) n.setMatrix3x3(a, t.matrices3x3[a]);
				for (a in t.matrices2x2) n.setMatrix2x2(a, t.matrices2x2[a]);
				for (a in t.vectors2Arrays) n.setArray2(a, t.vectors2Arrays[a]);
				for (a in t.vectors3Arrays) n.setArray3(a, t.vectors3Arrays[a]);
				for (a in t.vectors4Arrays) n.setArray4(a, t.vectors4Arrays[a]);
				for (a in t.quaternionsArrays) n.setArray4(a, t.quaternionsArrays[a]);
				return n
			}
			setFloat(e, t) {
				return this._checkUniform(e), this._floats[e] = t, this
			}
			clone(t) {
				const i = Xc.Clone((() => new e(t, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes)), this);
				i.name = t, i.id = t, "object" == typeof i._shaderPath && (i._shaderPath = {
					...i._shaderPath
				}), this._options = {
					...this._options
				}, Object.keys(this._options).forEach((e => {
					const t = this._options[e];
					Array.isArray(t) && (this._options[e] = t.slice(0))
				})), this.stencil.copyTo(i.stencil);
				for (const e in this._textures) i.setTexture(e, this._textures[e]);
				for (const e in this._textureArrays) i.setTextureArray(e, this._textureArrays[e]);
				for (const e in this._externalTextures) i.setExternalTexture(e, this._externalTextures[e]);
				for (const e in this._ints) i.setInt(e, this._ints[e]);
				for (const e in this._uints) i.setUInt(e, this._uints[e]);
				for (const e in this._floats) i.setFloat(e, this._floats[e]);
				for (const e in this._floatsArrays) i.setFloats(e, this._floatsArrays[e]);
				for (const e in this._colors3) i.setColor3(e, this._colors3[e]);
				for (const e in this._colors3Arrays) i._colors3Arrays[e] = this._colors3Arrays[e];
				for (const e in this._colors4) i.setColor4(e, this._colors4[e]);
				for (const e in this._colors4Arrays) i._colors4Arrays[e] = this._colors4Arrays[e];
				for (const e in this._vectors2) i.setVector2(e, this._vectors2[e]);
				for (const e in this._vectors3) i.setVector3(e, this._vectors3[e]);
				for (const e in this._vectors4) i.setVector4(e, this._vectors4[e]);
				for (const e in this._quaternions) i.setQuaternion(e, this._quaternions[e]);
				for (const e in this._quaternionsArrays) i._quaternionsArrays[e] = this._quaternionsArrays[e];
				for (const e in this._matrices) i.setMatrix(e, this._matrices[e]);
				for (const e in this._matrixArrays) i._matrixArrays[e] = this._matrixArrays[e].slice();
				for (const e in this._matrices3x3) i.setMatrix3x3(e, this._matrices3x3[e]);
				for (const e in this._matrices2x2) i.setMatrix2x2(e, this._matrices2x2[e]);
				for (const e in this._vectors2Arrays) i.setArray2(e, this._vectors2Arrays[e]);
				for (const e in this._vectors3Arrays) i.setArray3(e, this._vectors3Arrays[e]);
				for (const e in this._vectors4Arrays) i.setArray4(e, this._vectors4Arrays[e]);
				for (const e in this._uniformBuffers) i.setUniformBuffer(e, this._uniformBuffers[e]);
				for (const e in this._textureSamplers) i.setTextureSampler(e, this._textureSamplers[e]);
				for (const e in this._storageBuffers) i.setStorageBuffer(e, this._storageBuffers[e]);
				return i
			}
			setQuaternion(e, t) {
				return this._checkUniform(e), this._quaternions[e] = t, this
			}
			isReady(e, t, i) {
				const s = i && this._storeEffectOnSubMeshes;
				if (this.isFrozen) {
					const e = s ? i._drawWrapper : this._drawWrapper;
					if (e.effect && e._wasPreviouslyReady && e._wasPreviouslyUsingInstances === t) return !0
				}
				const n = this.getScene(),
					a = n.getEngine(),
					r = [],
					o = [],
					l = new Op;
				let h = this._shaderPath,
					c = this._options.uniforms,
					u = this._options.uniformBuffers,
					m = this._options.samplers;
				a.getCaps().multiview && n.activeCamera && n.activeCamera.outputRenderTarget && n.activeCamera.outputRenderTarget.getViewCount() > 1 && (this._multiview = !0, r.push("#define MULTIVIEW"), -1 !== c.indexOf("viewProjection") && -1 === c.indexOf("viewProjectionR") && c.push("viewProjectionR"));
				for (let e = 0; e < this._options.defines.length; e++) {
					const t = 0 === this._options.defines[e].indexOf("#define") ? this._options.defines[e] : `#define ${this._options.defines[e]}`;
					r.push(t)
				}
				for (let e = 0; e < this._options.attributes.length; e++) o.push(this._options.attributes[e]);
				if (e && e.isVerticesDataPresent(eu.ColorKind) && (-1 === o.indexOf(eu.ColorKind) && o.push(eu.ColorKind), r.push("#define VERTEXCOLOR")), t && (r.push("#define INSTANCES"), of(o, this._materialHelperNeedsPreviousMatrices), e?.hasThinInstances && (r.push("#define THIN_INSTANCES"), e && e.isVerticesDataPresent(eu.ColorInstanceKind) && (o.push(eu.ColorInstanceKind), r.push("#define INSTANCESCOLOR")))), e && e.useBones && e.computeBonesUsingShaders && e.skeleton) {
					o.push(eu.MatricesIndicesKind), o.push(eu.MatricesWeightsKind), e.numBoneInfluencers > 4 && (o.push(eu.MatricesIndicesExtraKind), o.push(eu.MatricesWeightsExtraKind));
					const t = e.skeleton;
					r.push("#define NUM_BONE_INFLUENCERS " + e.numBoneInfluencers), l.addCPUSkinningFallback(0, e), t.isUsingTextureForMatrices ? (r.push("#define BONETEXTURE"), -1 === c.indexOf("boneTextureWidth") && c.push("boneTextureWidth"), -1 === this._options.samplers.indexOf("boneSampler") && this._options.samplers.push("boneSampler")) : (r.push("#define BonesPerMesh " + (t.bones.length + 1)), -1 === c.indexOf("mBones") && c.push("mBones"))
				} else r.push("#define NUM_BONE_INFLUENCERS 0");
				let d = 0;
				const f = e ? e.morphTargetManager : null;
				if (f) {
					const e = f.supportsUVs && -1 !== r.indexOf("#define UV1"),
						t = f.supportsTangents && -1 !== r.indexOf("#define TANGENT"),
						i = f.supportsNormals && -1 !== r.indexOf("#define NORMAL");
					d = f.numMaxInfluencers || f.numInfluencers, e && r.push("#define MORPHTARGETS_UV"), t && r.push("#define MORPHTARGETS_TANGENT"), i && r.push("#define MORPHTARGETS_NORMAL"), d > 0 && r.push("#define MORPHTARGETS"), f.isUsingTextureForTargets && (r.push("#define MORPHTARGETS_TEXTURE"), -1 === c.indexOf("morphTargetTextureIndices") && c.push("morphTargetTextureIndices"), -1 === this._options.samplers.indexOf("morphTargets") && this._options.samplers.push("morphTargets")), r.push("#define NUM_MORPH_INFLUENCERS " + d);
					for (let s = 0; s < d; s++) o.push(eu.PositionKind + s), i && o.push(eu.NormalKind + s), t && o.push(eu.TangentKind + s), e && o.push(eu.UVKind + "_" + s);
					d > 0 && (c = c.slice(), c.push("morphTargetInfluences"), c.push("morphTargetCount"), c.push("morphTargetTextureInfo"), c.push("morphTargetTextureIndices"))
				} else r.push("#define NUM_MORPH_INFLUENCERS 0");
				if (e) {
					const t = e.bakedVertexAnimationManager;
					t && t.isEnabled && (r.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"), -1 === c.indexOf("bakedVertexAnimationSettings") && c.push("bakedVertexAnimationSettings"), -1 === c.indexOf("bakedVertexAnimationTextureSizeInverted") && c.push("bakedVertexAnimationTextureSizeInverted"), -1 === c.indexOf("bakedVertexAnimationTime") && c.push("bakedVertexAnimationTime"), -1 === this._options.samplers.indexOf("bakedVertexAnimationTexture") && this._options.samplers.push("bakedVertexAnimationTexture")), mf(o, 0, r)
				}
				for (const e in this._textures)
					if (!this._textures[e].isReady()) return !1;
				e && this._shouldTurnAlphaTestOn(e) && r.push("#define ALPHATEST"), !1 !== this._options.useClipPlane && (Jd(c), qd(this, n, r)), n.fogEnabled && e?.applyFog && n.fogMode !== bg.FOGMODE_NONE && (r.push("#define FOG"), -1 === c.indexOf("view") && c.push("view"), -1 === c.indexOf("vFogInfos") && c.push("vFogInfos"), -1 === c.indexOf("vFogColor") && c.push("vFogColor")), this._useLogarithmicDepth && (r.push("#define LOGARITHMICDEPTH"), -1 === c.indexOf("logarithmicDepthConstant") && c.push("logarithmicDepthConstant")), this.customShaderNameResolve && (c = c.slice(), u = u.slice(), m = m.slice(), h = this.customShaderNameResolve(this.name, c, u, m, r, o));
				const p = s ? i._getDrawWrapper(void 0, !0) : this._drawWrapper,
					_ = p?.effect ?? null,
					g = p?.defines ?? null,
					v = r.join("\n");
				let y = _;
				return g !== v && (y = a.createEffect(h, {
					attributes: o,
					uniformsNames: c,
					uniformBuffersNames: u,
					samplers: m,
					defines: v,
					fallbacks: l,
					onCompiled: this.onCompiled,
					onError: this.onError,
					indexParameters: {
						maxSimultaneousMorphTargets: d
					},
					shaderLanguage: this._options.shaderLanguage
				}, a), s ? i.setEffect(y, v, this._materialContext) : p && p.setEffect(y, v), this._onEffectCreatedObservable && (Ey.effect = y, Ey.subMesh = i ?? e?.subMeshes[0] ?? null, this._onEffectCreatedObservable.notifyObservers(Ey))), p._wasPreviouslyUsingInstances = !!t, !!y?.isReady() && (_ !== y && n.resetCachedMaterial(), p._wasPreviouslyReady = !0, !0)
			}
			setArray4(e, t) {
				return this._checkUniform(e), this._vectors4Arrays[e] = t, this
			}
			getClassName() {
				return "ShaderMaterial"
			}
			setMatrix2x2(e, t) {
				return this._checkUniform(e), this._matrices2x2[e] = t, this
			}
			bindForSubMesh(e, t, i) {
				this.bind(e, t, i._drawWrapperOverride?.effect, i)
			}
			setVector2(e, t) {
				return this._checkUniform(e), this._vectors2[e] = t, this
			}
			bind(e, t, i, s) {
				const n = s && this._storeEffectOnSubMeshes,
					a = i ?? (n ? s.effect : this.getEffect());
				if (!a) return;
				const r = this.getScene();
				this._activeEffect = a, this.bindOnlyWorldMatrix(e, i);
				const o = this._options.uniformBuffers;
				let l = !1;
				if (a && o && o.length > 0 && r.getEngine().supportsUniformBuffers)
					for (let i = 0; i < o.length; ++i) {
						switch (o[i]) {
							case "Mesh":
								t && (t.getMeshUniformBuffer().bindToEffect(a, "Mesh"), t.transferToEffect(e));
								break;
							case "Scene":
								hf(a, r.getSceneUniformBuffer()), r.finalizeSceneUbo(), l = !0
						}
					}
				const h = t && n ? this._mustRebind(r, a, s, t.visibility) : r.getCachedMaterial() !== this;
				if (a && h) {
					let e;
					for (e in l || -1 === this._options.uniforms.indexOf("view") || a.setMatrix("view", r.getViewMatrix()), l || -1 === this._options.uniforms.indexOf("projection") || a.setMatrix("projection", r.getProjectionMatrix()), l || -1 === this._options.uniforms.indexOf("viewProjection") || (a.setMatrix("viewProjection", r.getTransformMatrix()), this._multiview && a.setMatrix("viewProjectionR", r._transformMatrixR)), r.activeCamera && -1 !== this._options.uniforms.indexOf("cameraPosition") && a.setVector3("cameraPosition", r.activeCamera.globalPosition), df(t, a), Qd(a, this, r), this._useLogarithmicDepth && sf(n ? s.materialDefines : a.defines, a, r), t && nf(r, t, a), this._textures) a.setTexture(e, this._textures[e]);
					for (e in this._textureArrays) a.setTextureArray(e, this._textureArrays[e]);
					for (e in this._ints) a.setInt(e, this._ints[e]);
					for (e in this._uints) a.setUInt(e, this._uints[e]);
					for (e in this._floats) a.setFloat(e, this._floats[e]);
					for (e in this._floatsArrays) a.setArray(e, this._floatsArrays[e]);
					for (e in this._colors3) a.setColor3(e, this._colors3[e]);
					for (e in this._colors3Arrays) a.setArray3(e, this._colors3Arrays[e]);
					for (e in this._colors4) {
						const t = this._colors4[e];
						a.setFloat4(e, t.r, t.g, t.b, t.a)
					}
					for (e in this._colors4Arrays) a.setArray4(e, this._colors4Arrays[e]);
					for (e in this._vectors2) a.setVector2(e, this._vectors2[e]);
					for (e in this._vectors3) a.setVector3(e, this._vectors3[e]);
					for (e in this._vectors4) a.setVector4(e, this._vectors4[e]);
					for (e in this._quaternions) a.setQuaternion(e, this._quaternions[e]);
					for (e in this._matrices) a.setMatrix(e, this._matrices[e]);
					for (e in this._matrixArrays) a.setMatrices(e, this._matrixArrays[e]);
					for (e in this._matrices3x3) a.setMatrix3x3(e, this._matrices3x3[e]);
					for (e in this._matrices2x2) a.setMatrix2x2(e, this._matrices2x2[e]);
					for (e in this._vectors2Arrays) a.setArray2(e, this._vectors2Arrays[e]);
					for (e in this._vectors3Arrays) a.setArray3(e, this._vectors3Arrays[e]);
					for (e in this._vectors4Arrays) a.setArray4(e, this._vectors4Arrays[e]);
					for (e in this._quaternionsArrays) a.setArray4(e, this._quaternionsArrays[e]);
					for (e in this._uniformBuffers) {
						const t = this._uniformBuffers[e].getBuffer();
						t && a.bindUniformBuffer(t, e)
					}
					const i = r.getEngine(),
						o = i.setExternalTexture;
					if (o)
						for (e in this._externalTextures) o.call(i, e, this._externalTextures[e]);
					const h = i.setTextureSampler;
					if (h)
						for (e in this._textureSamplers) h.call(i, e, this._textureSamplers[e]);
					const c = i.setStorageBuffer;
					if (c)
						for (e in this._storageBuffers) c.call(i, e, this._storageBuffers[e])
				}
				if (a && t && (h || !this.isFrozen)) {
					const e = t.morphTargetManager;
					e && e.numInfluencers > 0 && lf(t, a);
					const i = t.bakedVertexAnimationManager;
					if (i && i.isEnabled) {
						const e = n ? s._drawWrapper : this._drawWrapper;
						t.bakedVertexAnimationManager?.bind(a, !!e._wasPreviouslyUsingInstances)
					}
				}
				this._afterBind(t, a, s)
			}
			setMatrix3x3(e, t) {
				return this._checkUniform(e), this._matrices3x3[e] = t, this
			}
			setTexture(e, t) {
				return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e), this._textures[e] = t, this
			}
			needAlphaTesting() {
				return this._options.needAlphaTesting
			}
			setUniformBuffer(e, t) {
				return -1 === this._options.uniformBuffers.indexOf(e) && this._options.uniformBuffers.push(e), this._uniformBuffers[e] = t, this
			}
			bindOnlyWorldMatrix(e, t) {
				const i = this.getScene(),
					s = t ?? this.getEffect();
				s && (-1 !== this._options.uniforms.indexOf("world") && s.setMatrix("world", e), -1 !== this._options.uniforms.indexOf("worldView") && (e.multiplyToRef(i.getViewMatrix(), this._cachedWorldViewMatrix), s.setMatrix("worldView", this._cachedWorldViewMatrix)), -1 !== this._options.uniforms.indexOf("worldViewProjection") && (e.multiplyToRef(i.getTransformMatrix(), this._cachedWorldViewProjectionMatrix), s.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix)), -1 !== this._options.uniforms.indexOf("view") && s.setMatrix("view", i.getViewMatrix()))
			}
			setColor3Array(e, t) {
				return this._checkUniform(e), this._colors3Arrays[e] = t.reduce(((e, t) => (t.toArray(e, e.length), e)), []), this
			}
			setExternalTexture(e, t) {
				return -1 === this._options.externalTextures.indexOf(e) && this._options.externalTextures.push(e), this._externalTextures[e] = t, this
			}
			needAlphaBlending() {
				return this.alpha < 1 || this._options.needAlphaBlending
			}
			setUInt(e, t) {
				return this._checkUniform(e), this._uints[e] = t, this
			}
			static ParseFromFileAsync(e, t, i, s = "") {
				return new Promise(((n, a) => {
					const r = new ku;
					r.addEventListener("readystatechange", (() => {
						if (4 == r.readyState)
							if (200 == r.status) {
								const t = JSON.parse(r.responseText),
									a = this.Parse(t, i || Dc.LastCreatedScene, s);
								e && (a.name = e), n(a)
							} else a("Unable to load the ShaderMaterial")
					})), r.open("GET", t), r.send()
				}))
			}
			constructor(e, t, i, s = {}, n = !0) {
				super(e, t, n), this._textures = {}, this._textureArrays = {}, this._externalTextures = {}, this._floats = {}, this._ints = {}, this._uints = {}, this._floatsArrays = {}, this._colors3 = {}, this._colors3Arrays = {}, this._colors4 = {}, this._colors4Arrays = {}, this._vectors2 = {}, this._vectors3 = {}, this._vectors4 = {}, this._quaternions = {}, this._quaternionsArrays = {}, this._matrices = {}, this._matrixArrays = {}, this._matrices3x3 = {}, this._matrices2x2 = {}, this._vectors2Arrays = {}, this._vectors3Arrays = {}, this._vectors4Arrays = {}, this._uniformBuffers = {}, this._textureSamplers = {}, this._storageBuffers = {}, this._cachedWorldViewMatrix = new Hc, this._cachedWorldViewProjectionMatrix = new Hc, this._multiview = !1, this._materialHelperNeedsPreviousMatrices = !1, this._shaderPath = i, this._options = {
					needAlphaBlending: !1,
					needAlphaTesting: !1,
					attributes: ["position", "normal", "uv"],
					uniforms: ["worldViewProjection"],
					uniformBuffers: [],
					samplers: [],
					externalTextures: [],
					samplerObjects: [],
					storageBuffers: [],
					defines: [],
					useClipPlane: !1,
					...s
				}
			}
			setArray2(e, t) {
				return this._checkUniform(e), this._vectors2Arrays[e] = t, this
			}
			setFloats(e, t) {
				return this._checkUniform(e), this._floatsArrays[e] = t, this
			}
		};
	Ay.SnippetUrl = "https://snippet.babylonjs.com", Ay.CreateFromSnippetAsync = Ay.ParseFromSnippetAsync, cc("BABYLON.ShaderMaterial", Ay), Vf._LinesMeshParser = (e, t) => by.Parse(e, t);
	var by = class e extends Vf {
		_draw(e, t, i) {
			if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this;
			const s = this.getScene().getEngine();
			return this._unIndexed ? s.drawArraysType(Pf.LineListDrawMode, e.verticesStart, e.verticesCount, i) : s.drawElementsType(Pf.LineListDrawMode, e.indexStart, e.indexCount, i), this
		}
		set checkCollisions(e) {}
		get material() {
			return this._lineMaterial
		}
		_isShaderMaterial(e) {
			return "ShaderMaterial" === e.getClassName()
		}
		get checkCollisions() {
			return !1
		}
		getClassName() {
			return "LinesMesh"
		}
		constructor(e, t = null, i = null, s = null, n, a, r, o) {
			super(e, t, i, s, n), this.useVertexColor = a, this.useVertexAlpha = r, this.color = new Tc(1, 1, 1), this.alpha = 1, this._shaderLanguage = 0, this._shadersLoaded = !1, s && (this.color = s.color.clone(), this.alpha = s.alpha, this.useVertexColor = s.useVertexColor, this.useVertexAlpha = s.useVertexAlpha), this.intersectionThreshold = .1;
			const l = {
				attributes: [eu.PositionKind],
				uniforms: ["world", "viewProjection"],
				needAlphaBlending: !0,
				defines: [],
				useClipPlane: null
			};
			!1 === r ? l.needAlphaBlending = !1 : l.defines.push("#define VERTEXALPHA"), a ? (l.defines.push("#define VERTEXCOLOR"), l.attributes.push(eu.ColorKind)) : (l.uniforms.push("color"), this._color4 = new wc), o ? (this.material = o, this._shadersLoaded = !0) : this._initShaderSourceAsync(l)
		}
		serialize(e) {
			super.serialize(e), e.color = this.color.asArray(), e.alpha = this.alpha
		}
		static Parse(t, i) {
			const s = new e(t.name, i);
			return s.color = Tc.FromArray(t.color), s.alpha = t.alpha, s
		}
		set material(e) {
			this._lineMaterial = e, this._lineMaterial.fillMode = Pf.LineListDrawMode
		}
		isReady() {
			return !!this._shadersLoaded && (!!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances) && super.isReady())
		}
		clone(t, i = null, s) {
			return new e(t, this.getScene(), i, this, s)
		}
		_bind(e, t) {
			if (!this._geometry) return this;
			const i = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
			if (!this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(t, i) : this._geometry._bind(t, i, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects), !this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {
				const {
					r: e,
					g: t,
					b: i
				} = this.color;
				this._color4.set(e, t, i, this.alpha), this._lineMaterial.setColor4("color", this._color4)
			}
			return this
		}
		createInstance(e) {
			const t = new xy(e, this);
			if (this.instancedBuffers) {
				t.instancedBuffers = {};
				for (const e in this.instancedBuffers) t.instancedBuffers[e] = this.instancedBuffers[e]
			}
			return t
		}
		dispose(e, t = !1, i) {
			i || this._lineMaterial.dispose(!1, !1, !0), super.dispose(e)
		}
		async _initShaderSourceAsync(t) {
			this.getScene().getEngine().isWebGPU && !e.ForceGLSL ? (this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (fr(), cr))), Promise.resolve().then((() => (yr(), pr)))])) : await Promise.all([Promise.resolve().then((() => (xr(), Sr))), Promise.resolve().then((() => (Rr(), Mr)))]), this._shadersLoaded = !0, t.shaderLanguage = this._shaderLanguage, this.material = new Ay("colorShader", this.getScene(), "color", t, !1), this.material.doNotSerialize = !0
		}
	};
	by.ForceGLSL = !1;
	var xy = class extends Sy {
		getClassName() {
			return "InstancedLinesMesh"
		}
		constructor(e, t) {
			super(e, t), this.intersectionThreshold = t.intersectionThreshold
		}
	};

	function My(e) {
		const t = [],
			i = [],
			s = e.lines,
			n = e.colors,
			a = [];
		let r = 0;
		for (let e = 0; e < s.length; e++) {
			const o = s[e];
			for (let s = 0; s < o.length; s++) {
				const {
					x: l,
					y: h,
					z: c
				} = o[s];
				if (i.push(l, h, c), n) {
					const t = n[e],
						{
							r: i,
							g: r,
							b: o,
							a: l
						} = t[s];
					a.push(i, r, o, l)
				}
				s > 0 && (t.push(r - 1), t.push(r)), r++
			}
		}
		const o = new Mu;
		return o.indices = t, o.positions = i, n && (o.colors = a), o
	}

	function Cy(e) {
		const t = e.dashSize || 3,
			i = e.gapSize || 1,
			s = e.dashNb || 200,
			n = e.points,
			a = [],
			r = [],
			o = Lc.Zero();
		let l = 0,
			h = 0,
			c = 0,
			u = 0,
			m = 0,
			d = 0,
			f = 0;
		for (f = 0; f < n.length - 1; f++) n[f + 1].subtractToRef(n[f], o), l += o.length();
		for (c = l / s, u = t * c / (t + i), f = 0; f < n.length - 1; f++) {
			n[f + 1].subtractToRef(n[f], o), h = Math.floor(o.length() / c), o.normalize();
			for (let e = 0; e < h; e++) m = c * e, a.push(n[f].x + m * o.x, n[f].y + m * o.y, n[f].z + m * o.z), a.push(n[f].x + (m + u) * o.x, n[f].y + (m + u) * o.y, n[f].z + (m + u) * o.z), r.push(d, d + 1), d += 2
		}
		const p = new Mu;
		return p.positions = a, p.indices = r, p
	}

	function Ty(e, t, i = null) {
		const s = t.instance,
			n = t.lines,
			a = t.colors;
		if (s) {
			const e = s.getVerticesData(eu.PositionKind);
			let t, i;
			a && (t = s.getVerticesData(eu.ColorKind));
			let r = 0,
				o = 0;
			for (let s = 0; s < n.length; s++) {
				const l = n[s];
				for (let n = 0; n < l.length; n++) e[r] = l[n].x, e[r + 1] = l[n].y, e[r + 2] = l[n].z, a && t && (i = a[s], t[o] = i[n].r, t[o + 1] = i[n].g, t[o + 2] = i[n].b, t[o + 3] = i[n].a, o += 4), r += 3
			}
			return s.updateVerticesData(eu.PositionKind, e, !1, !1), a && t && s.updateVerticesData(eu.ColorKind, t, !1, !1), s.refreshBoundingInfo(), s
		}
		const r = new by(e, i, null, void 0, void 0, !!a, t.useVertexAlpha, t.material);
		return My(t).applyToMesh(r, t.updatable), r
	}

	function wy(e, t, i = null) {
		const s = t.colors ? [t.colors] : null;
		return Ty(e, {
			lines: [t.points],
			updatable: t.updatable,
			instance: t.instance,
			colors: s,
			useVertexAlpha: t.useVertexAlpha,
			material: t.material
		}, i)
	}

	function Ry(e, t, i = null) {
		const s = t.points,
			n = t.instance,
			a = t.gapSize || 1,
			r = t.dashSize || 3;
		if (n) {
			const e = e => {
				const t = Lc.Zero(),
					i = e.length / 6;
				let a = 0,
					r = 0,
					o = 0,
					l = 0,
					h = 0,
					c = 0,
					u = 0,
					m = 0;
				for (u = 0; u < s.length - 1; u++) s[u + 1].subtractToRef(s[u], t), a += t.length();
				o = a / i;
				const d = n._creationDataStorage.dashSize;
				for (l = d * o / (d + n._creationDataStorage.gapSize), u = 0; u < s.length - 1; u++)
					for (s[u + 1].subtractToRef(s[u], t), r = Math.floor(t.length() / o), t.normalize(), m = 0; m < r && c < e.length;) h = o * m, e[c] = s[u].x + h * t.x, e[c + 1] = s[u].y + h * t.y, e[c + 2] = s[u].z + h * t.z, e[c + 3] = s[u].x + (h + l) * t.x, e[c + 4] = s[u].y + (h + l) * t.y, e[c + 5] = s[u].z + (h + l) * t.z, c += 6, m++;
				for (; c < e.length;) e[c] = s[u].x, e[c + 1] = s[u].y, e[c + 2] = s[u].z, c += 3
			};
			return (t.dashNb || t.dashSize || t.gapSize || t.useVertexAlpha || t.material) && Qc.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."), n.updateMeshPositions(e, !1), n
		}
		const o = new by(e, i, null, void 0, void 0, void 0, t.useVertexAlpha, t.material);
		return Cy(t).applyToMesh(o, t.updatable), o._creationDataStorage = new Lf, o._creationDataStorage.dashSize = r, o._creationDataStorage.gapSize = a, o
	}
	Mu.CreateLineSystem = My, Mu.CreateDashedLines = Cy, Vf._k = (e, t, i = null, s = !1, n = null) => wy(e, {
		points: t,
		updatable: s,
		instance: n
	}, i), Vf.CreateDashedLines = (e, t, i, s, n, a = null, r, o) => Ry(e, {
		points: t,
		dashSize: i,
		gapSize: s,
		dashNb: n,
		updatable: r,
		instance: o
	}, a);
	var Ny = class extends Fc {
			constructor(e, t) {
				super(e.x, e.y), this.index = t
			}
		},
		Iy = class {
			computeBounds() {
				const e = new Fc(this.elements[0].x, this.elements[0].y),
					t = new Fc(this.elements[0].x, this.elements[0].y);
				return this.elements.forEach((i => {
					i.x < e.x ? e.x = i.x : i.x > t.x && (t.x = i.x), i.y < e.y ? e.y = i.y : i.y > t.y && (t.y = i.y)
				})), {
					min: e,
					max: t,
					width: t.x - e.x,
					height: t.y - e.y
				}
			}
			constructor() {
				this.elements = []
			}
			add(e) {
				const t = [];
				return e.forEach((e => {
					const i = new Ny(e, this.elements.length);
					t.push(i), this.elements.push(i)
				})), t
			}
		},
		Py = class {
			_addToepoint(e) {
				for (const t of e) this._epoints.push(t.x, t.y)
			}
			_addSide(e, t, i, s, n, a, r, o, l) {
				let h = e.length / 3,
					c = 0;
				for (let u = 0; u < a.elements.length; u++) {
					const m = a.elements[u],
						d = a.elements[(u + 1) % a.elements.length];
					e.push(m.x, 0, m.y), e.push(m.x, -r, m.y), e.push(d.x, 0, d.y), e.push(d.x, -r, d.y);
					const f = a.elements[(u + a.elements.length - 1) % a.elements.length],
						p = a.elements[(u + 2) % a.elements.length];
					let _ = new Lc(-(d.y - m.y), 0, d.x - m.x),
						g = new Lc(-(m.y - f.y), 0, m.x - f.x),
						v = new Lc(-(p.y - d.y), 0, p.x - d.x);
					o || (_ = _.scale(-1), g = g.scale(-1), v = v.scale(-1));
					const y = _.normalizeToNew();
					let S = g.normalizeToNew(),
						E = v.normalizeToNew();
					const A = Lc.Dot(S, y);
					S = A > l ? A < -.999 ? new Lc(m.x, 0, m.y).subtract(new Lc(d.x, 0, d.y)).normalize() : g.add(_).normalize() : y;
					const b = Lc.Dot(v, _);
					E = b > l ? b < -.999 ? new Lc(d.x, 0, d.y).subtract(new Lc(m.x, 0, m.y)).normalize() : v.add(_).normalize() : y, i.push(c / n.width, 0), i.push(c / n.width, 1), c += _.length(), i.push(c / n.width, 0), i.push(c / n.width, 1), t.push(S.x, S.y, S.z), t.push(S.x, S.y, S.z), t.push(E.x, E.y, E.z), t.push(E.x, E.y, E.z), o ? (s.push(h), s.push(h + 2), s.push(h + 1), s.push(h + 1), s.push(h + 2), s.push(h + 3)) : (s.push(h), s.push(h + 1), s.push(h + 2), s.push(h + 1), s.push(h + 3), s.push(h + 2)), h += 4
				}
			}
			constructor(e, t, i, s = earcut) {
				let n;
				this._points = new Iy, this._outlinepoints = new Iy, this._holes = new Array, this._epoints = new Array, this._eholes = new Array, this.bjsEarcut = s, this._name = e, this._scene = i || Dc.LastCreatedScene, n = t instanceof Sp ? t.getPoints() : t, this._addToepoint(n), this._points.add(n), this._outlinepoints.add(n), void 0 === this.bjsEarcut && Qc.Warn("Earcut was not found, the polygon will not be built.")
			}
			addHole(e) {
				this._points.add(e);
				const t = new Iy;
				return t.add(e), this._holes.push(t), this._eholes.push(this._epoints.length / 2), this._addToepoint(e), this
			}
			build(e = !1, t = 0, i = 2) {
				const s = new Vf(this._name, this._scene),
					n = this.buildVertexData(t, i);
				return s.setVerticesData(eu.PositionKind, n.positions, e), s.setVerticesData(eu.NormalKind, n.normals, e), s.setVerticesData(eu.UVKind, n.uvs, e), s.setIndices(n.indices), s
			}
			buildVertexData(e = 0, t = 2) {
				const i = new Mu,
					s = [],
					n = [],
					a = [],
					r = this._points.computeBounds();
				this._points.elements.forEach((e => {
					s.push(0, 1, 0), n.push(e.x, 0, e.y), a.push((e.x - r.min.x) / r.width, (e.y - r.min.y) / r.height)
				}));
				const o = [],
					l = this.bjsEarcut(this._epoints, this._eholes, 2);
				for (let e = 0; e < l.length; e++) o.push(l[e]);
				if (e > 0) {
					const i = n.length / 3;
					this._points.elements.forEach((t => {
						s.push(0, -1, 0), n.push(t.x, -e, t.y), a.push(1 - (t.x - r.min.x) / r.width, 1 - (t.y - r.min.y) / r.height)
					}));
					const l = o.length;
					for (let e = 0; e < l; e += 3) {
						const t = o[e + 0],
							s = o[e + 1],
							n = o[e + 2];
						o.push(n + i), o.push(s + i), o.push(t + i)
					}
					this._addSide(n, s, a, o, r, this._outlinepoints, e, !1, t), this._holes.forEach((i => {
						this._addSide(n, s, a, o, r, i, e, !0, t)
					}))
				}
				return i.indices = o, i.positions = n, i.normals = s, i.uvs = a, i
			}
		};

	function ky(e, t, i, s, n, a, r) {
		const o = i || new Array(3),
			l = s,
			h = [],
			c = r || !1;
		for (let e = 0; e < 3; e++) void 0 === o[e] && (o[e] = new Bc(0, 0, 1, 1)), l && void 0 === l[e] && (l[e] = new wc(1, 1, 1, 1));
		const u = e.getVerticesData(eu.PositionKind),
			m = e.getVerticesData(eu.NormalKind),
			d = e.getVerticesData(eu.UVKind),
			f = e.getIndices(),
			p = u.length / 9;
		let _ = 0,
			g = 0,
			v = 0,
			y = 0,
			S = 0;
		const E = [0];
		if (c)
			for (let e = p; e < u.length / 3; e += 4) g = u[3 * (e + 2)] - u[3 * e], v = u[3 * (e + 2) + 2] - u[3 * e + 2], y = Math.sqrt(g * g + v * v), S += y, E.push(S);
		let A = 0,
			b = 0;
		for (let e = 0; e < m.length; e += 3) Math.abs(m[e + 1]) < .001 && (b = 1), Math.abs(m[e + 1] - 1) < .001 && (b = 0), Math.abs(m[e + 1] + 1) < .001 && (b = 2), A = e / 3, 1 === b ? (_ = A - p, d[2 * A] = _ % 4 < 1.5 ? c ? o[b].x + (o[b].z - o[b].x) * E[Math.floor(_ / 4)] / S : o[b].x : c ? o[b].x + (o[b].z - o[b].x) * E[Math.floor(_ / 4) + 1] / S : o[b].z, d[2 * A + 1] = _ % 2 == 0 ? o[b].w : o[b].y) : (d[2 * A] = (1 - d[2 * A]) * o[b].x + d[2 * A] * o[b].z, d[2 * A + 1] = (1 - d[2 * A + 1]) * o[b].y + d[2 * A + 1] * o[b].w), l && h.push(l[b].r, l[b].g, l[b].b, l[b].a);
		Mu._ComputeSides(t, u, f, m, d, n, a);
		const x = new Mu;
		if (x.indices = f, x.positions = u, x.normals = m, x.uvs = d, l) {
			const e = t === Mu.DOUBLESIDE ? h.concat(h) : h;
			x.colors = e
		}
		return x
	}

	function Dy(e, t, i = null, s = earcut) {
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation);
		const n = t.shape,
			a = t.holes || [],
			r = t.depth || 0,
			o = t.smoothingThreshold || 2,
			l = [];
		let h = [];
		for (let e = 0; e < n.length; e++) l[e] = new Fc(n[e].x, n[e].z);
		l[0].equalsWithEpsilon(l[l.length - 1], 1e-8) && l.pop();
		const c = new Py(e, l, i || Dc.LastCreatedScene, s);
		for (let e = 0; e < a.length; e++) {
			h = [];
			for (let t = 0; t < a[e].length; t++) h.push(new Fc(a[e][t].x, a[e][t].z));
			c.addHole(h)
		}
		const u = c.build(!1, r, o);
		u._originalBuilderSideOrientation = t.sideOrientation;
		return ky(u, t.sideOrientation, t.faceUV, t.faceColors, t.frontUVs, t.backUVs, t.wrap).applyToMesh(u, t.updatable), u
	}

	function Oy(e, t, i = null, s = earcut) {
		return Dy(e, t, i, s)
	}

	function Fy(e, t, i = null) {
		const s = t.path,
			n = t.shape,
			a = t.scale || 1,
			r = t.rotation || 0,
			o = 0 === t.cap ? 0 : t.cap || Vf.NO_CAP,
			l = t.updatable,
			h = Vf._GetDefaultSideOrientation(t.sideOrientation),
			c = t.instance || null,
			u = t.invertUV || !1,
			m = t.closeShape || !1;
		return By(e, n, s, a, r, null, null, t.closePath || !1, m, o, !1, i, !!l, h, c, u, t.frontUVs || null, t.backUVs || null, t.firstNormal || null, !!t.adjustFrame)
	}

	function Ly(e, t, i = null) {
		const s = t.path,
			n = t.shape,
			a = t.scaleFunction || (() => 1),
			r = t.rotationFunction || (() => 0),
			o = t.closePath || t.ribbonCloseArray || !1,
			l = t.closeShape || t.ribbonClosePath || !1,
			h = 0 === t.cap ? 0 : t.cap || Vf.NO_CAP,
			c = t.updatable,
			u = t.firstNormal || null,
			m = t.adjustFrame || !1;
		return By(e, n, s, null, null, a, r, o, l, h, !0, i, !!c, Vf._GetDefaultSideOrientation(t.sideOrientation), t.instance || null, t.invertUV || !1, t.frontUVs || null, t.backUVs || null, u, m)
	}

	function By(e, t, i, s, n, a, r, o, l, h, c, u, m, d, f, p, _, g, v, y) {
		const S = (e, t, i, s, n, a, r, o, l, h, c) => {
			const u = i.getTangents(),
				m = i.getNormals(),
				d = i.getBinormals(),
				f = i.getDistances();
			if (c)
				for (let e = 0; e < u.length; e++)
					if (0 == u[e].x && 0 == u[e].y && 0 == u[e].z && u[e].copyFrom(u[e - 1]), 0 == m[e].x && 0 == m[e].y && 0 == m[e].z && m[e].copyFrom(m[e - 1]), 0 == d[e].x && 0 == d[e].y && 0 == d[e].z && d[e].copyFrom(d[e - 1]), e > 0) {
						let t = u[e - 1];
						Lc.Dot(t, u[e]) < 0 && u[e].scaleInPlace(-1), t = m[e - 1], Lc.Dot(t, m[e]) < 0 && m[e].scaleInPlace(-1), t = d[e - 1], Lc.Dot(t, d[e]) < 0 && d[e].scaleInPlace(-1)
					} let p = 0;
			const _ = h && o ? o : () => null !== a ? a : 0,
				g = h && r ? r : () => null !== n ? n : 1;
			let v = l === Vf.NO_CAP || l === Vf.CAP_END ? 0 : 2;
			const y = Vc.Matrix[0];
			for (let i = 0; i < t.length; i++) {
				const n = [],
					a = _(i, f[i]),
					r = g(i, f[i]);
				Hc.RotationAxisToRef(u[i], p, y);
				for (let s = 0; s < e.length; s++) {
					const a = u[i].scale(e[s].z).add(m[i].scale(e[s].x)).add(d[i].scale(e[s].y)),
						o = Lc.Zero();
					Lc.TransformCoordinatesToRef(a, y, o), o.scaleInPlace(r).addInPlace(t[i]), n[s] = o
				}
				s[v] = n, p += a, v++
			}
			const S = e => {
				const t = Array(),
					i = Lc.Zero();
				let s;
				for (s = 0; s < e.length; s++) i.addInPlace(e[s]);
				for (i.scaleInPlace(1 / e.length), s = 0; s < e.length; s++) t.push(i);
				return t
			};
			switch (l) {
				case Vf.NO_CAP:
					break;
				case Vf.CAP_START:
					s[0] = S(s[2]), s[1] = s[2];
					break;
				case Vf.CAP_END:
					s[v] = s[v - 1], s[v + 1] = S(s[v - 1]);
					break;
				case Vf.CAP_ALL:
					s[0] = S(s[2]), s[1] = s[2], s[v] = s[v - 1], s[v + 1] = S(s[v - 1])
			}
			return s
		};
		let E, A;
		if (f) {
			const e = f._creationDataStorage;
			return E = v ? e.path3D.update(i, v) : e.path3D.update(i), A = S(t, i, e.path3D, e.pathArray, s, n, a, r, e.cap, c, y), f = Qv("", {
				pathArray: A,
				closeArray: !1,
				closePath: !1,
				offset: 0,
				updatable: !1,
				sideOrientation: 0,
				instance: f
			}, u || void 0)
		}
		E = v ? new Ep(i, v) : new Ep(i);
		A = S(t, i, E, new Array, s, n, a, r, h = h < 0 || h > 3 ? 0 : h, c, y);
		const b = Qv(e, {
			pathArray: A,
			closeArray: o,
			closePath: l,
			updatable: m,
			sideOrientation: d,
			invertUV: p,
			frontUVs: _ || void 0,
			backUVs: g || void 0
		}, u);
		return b._creationDataStorage.pathArray = A, b._creationDataStorage.path3D = E, b._creationDataStorage.cap = h, b
	}

	function Gy(e, t, i = null) {
		const s = t.arc ? t.arc <= 0 || t.arc > 1 ? 1 : t.arc : 1,
			n = void 0 === t.closed || t.closed,
			a = t.shape,
			r = t.radius || 1,
			o = t.tessellation || 64,
			l = t.clip || 0,
			h = t.updatable,
			c = Vf._GetDefaultSideOrientation(t.sideOrientation),
			u = t.cap || Vf.NO_CAP,
			m = 2 * Math.PI,
			d = [],
			f = t.invertUV || !1;
		let p = 0,
			_ = 0;
		const g = m / o * s;
		let v, y;
		for (p = 0; p <= o - l; p++) {
			for (y = [], u != Vf.CAP_START && u != Vf.CAP_ALL || (y.push(new Lc(0, a[0].y, 0)), y.push(new Lc(Math.cos(p * g) * a[0].x * r, a[0].y, Math.sin(p * g) * a[0].x * r))), _ = 0; _ < a.length; _++) v = new Lc(Math.cos(p * g) * a[_].x * r, a[_].y, Math.sin(p * g) * a[_].x * r), y.push(v);
			u != Vf.CAP_END && u != Vf.CAP_ALL || (y.push(new Lc(Math.cos(p * g) * a[a.length - 1].x * r, a[a.length - 1].y, Math.sin(p * g) * a[a.length - 1].x * r)), y.push(new Lc(0, a[a.length - 1].y, 0))), d.push(y)
		}
		return Qv(e, {
			pathArray: d,
			closeArray: n,
			sideOrientation: c,
			updatable: h,
			invertUV: f,
			frontUVs: t.frontUVs,
			backUVs: t.backUVs
		}, i)
	}

	function Hy(e) {
		const t = [],
			i = [],
			s = [],
			n = [],
			a = e.width || e.size || 1,
			r = e.height || e.size || 1,
			o = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			l = a / 2,
			h = r / 2;
		i.push(-l, -h, 0), s.push(0, 0, -1), n.push(0, 0), i.push(l, -h, 0), s.push(0, 0, -1), n.push(1, 0), i.push(l, h, 0), s.push(0, 0, -1), n.push(1, 1), i.push(-l, h, 0), s.push(0, 0, -1), n.push(0, 1), t.push(0), t.push(1), t.push(2), t.push(0), t.push(2), t.push(3), Mu._ComputeSides(o, i, t, s, n, e.frontUVs, e.backUVs);
		const c = new Mu;
		return c.indices = t, c.positions = i, c.normals = s, c.uvs = n, c
	}

	function Uy(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return Hy(t).applyToMesh(s, t.updatable), t.sourcePlane && (s.translate(t.sourcePlane.normal, -t.sourcePlane.d), s.setDirection(t.sourcePlane.normal.scale(-1))), s
	}

	function Vy(e, t, i = null) {
		const s = t.path;
		let n = t.instance,
			a = 1;
		void 0 !== t.radius ? a = t.radius : n && (a = n._creationDataStorage.radius);
		const r = t.tessellation || 64,
			o = t.radiusFunction || null;
		let l = t.cap || Vf.NO_CAP;
		const h = t.invertUV || !1,
			c = t.updatable,
			u = Vf._GetDefaultSideOrientation(t.sideOrientation);
		t.arc = t.arc && (t.arc <= 0 || t.arc > 1) ? 1 : t.arc || 1;
		const m = (e, t, i, s, n, a, r, o) => {
			const l = t.getTangents(),
				h = t.getNormals(),
				c = t.getDistances(),
				u = 2 * Math.PI / n * o,
				m = a || (() => s);
			let d, f, p, _;
			const g = Vc.Matrix[0];
			let v = r === Vf.NO_CAP || r === Vf.CAP_END ? 0 : 2;
			for (let t = 0; t < e.length; t++) {
				f = m(t, c[t]), d = Array(), p = h[t];
				for (let i = 0; i < n; i++) Hc.RotationAxisToRef(l[t], u * i, g), _ = d[i] ? d[i] : Lc.Zero(), Lc.TransformCoordinatesToRef(p, g, _), _.scaleInPlace(f).addInPlace(e[t]), d[i] = _;
				i[v] = d, v++
			}
			const y = (t, i) => {
				const s = Array();
				for (let n = 0; n < t; n++) s.push(e[i]);
				return s
			};
			switch (r) {
				case Vf.NO_CAP:
					break;
				case Vf.CAP_START:
					i[0] = y(n, 0), i[1] = i[2].slice(0);
					break;
				case Vf.CAP_END:
					i[v] = i[v - 1].slice(0), i[v + 1] = y(n, e.length - 1);
					break;
				case Vf.CAP_ALL:
					i[0] = y(n, 0), i[1] = i[2].slice(0), i[v] = i[v - 1].slice(0), i[v + 1] = y(n, e.length - 1)
			}
			return i
		};
		let d, f;
		if (n) {
			const e = n._creationDataStorage,
				i = t.arc || e.arc;
			return d = e.path3D.update(s), f = m(s, d, e.pathArray, a, e.tessellation, o, e.cap, i), n = Qv("", {
				pathArray: f,
				instance: n
			}), e.path3D = d, e.pathArray = f, e.arc = i, e.radius = a, n
		}
		d = new Ep(s);
		l = l < 0 || l > 3 ? 0 : l, f = m(s, d, new Array, a, r, o, l, t.arc);
		const p = Qv(e, {
			pathArray: f,
			closePath: !0,
			closeArray: !1,
			updatable: c,
			sideOrientation: u,
			invertUV: h,
			frontUVs: t.frontUVs,
			backUVs: t.backUVs
		}, i);
		return p._creationDataStorage.pathArray = f, p._creationDataStorage.path3D = d, p._creationDataStorage.tessellation = r, p._creationDataStorage.cap = l, p._creationDataStorage.arc = t.arc, p._creationDataStorage.radius = a, p
	}

	function Wy(e) {
		const t = [];
		t[0] = {
			vertex: [
				[0, 0, 1.732051],
				[1.632993, 0, -.5773503],
				[-.8164966, 1.414214, -.5773503],
				[-.8164966, -1.414214, -.5773503]
			],
			face: [
				[0, 1, 2],
				[0, 2, 3],
				[0, 3, 1],
				[1, 3, 2]
			]
		}, t[1] = {
			vertex: [
				[0, 0, 1.414214],
				[1.414214, 0, 0],
				[0, 1.414214, 0],
				[-1.414214, 0, 0],
				[0, -1.414214, 0],
				[0, 0, -1.414214]
			],
			face: [
				[0, 1, 2],
				[0, 2, 3],
				[0, 3, 4],
				[0, 4, 1],
				[1, 4, 5],
				[1, 5, 2],
				[2, 5, 3],
				[3, 5, 4]
			]
		}, t[2] = {
			vertex: [
				[0, 0, 1.070466],
				[.7136442, 0, .7978784],
				[-.3568221, .618034, .7978784],
				[-.3568221, -.618034, .7978784],
				[.7978784, .618034, .3568221],
				[.7978784, -.618034, .3568221],
				[-.9341724, .381966, .3568221],
				[.1362939, 1, .3568221],
				[.1362939, -1, .3568221],
				[-.9341724, -.381966, .3568221],
				[.9341724, .381966, -.3568221],
				[.9341724, -.381966, -.3568221],
				[-.7978784, .618034, -.3568221],
				[-.1362939, 1, -.3568221],
				[-.1362939, -1, -.3568221],
				[-.7978784, -.618034, -.3568221],
				[.3568221, .618034, -.7978784],
				[.3568221, -.618034, -.7978784],
				[-.7136442, 0, -.7978784],
				[0, 0, -1.070466]
			],
			face: [
				[0, 1, 4, 7, 2],
				[0, 2, 6, 9, 3],
				[0, 3, 8, 5, 1],
				[1, 5, 11, 10, 4],
				[2, 7, 13, 12, 6],
				[3, 9, 15, 14, 8],
				[4, 10, 16, 13, 7],
				[5, 8, 14, 17, 11],
				[6, 12, 18, 15, 9],
				[10, 11, 17, 19, 16],
				[12, 13, 16, 19, 18],
				[14, 15, 18, 19, 17]
			]
		}, t[3] = {
			vertex: [
				[0, 0, 1.175571],
				[1.051462, 0, .5257311],
				[.3249197, 1, .5257311],
				[-.8506508, .618034, .5257311],
				[-.8506508, -.618034, .5257311],
				[.3249197, -1, .5257311],
				[.8506508, .618034, -.5257311],
				[.8506508, -.618034, -.5257311],
				[-.3249197, 1, -.5257311],
				[-1.051462, 0, -.5257311],
				[-.3249197, -1, -.5257311],
				[0, 0, -1.175571]
			],
			face: [
				[0, 1, 2],
				[0, 2, 3],
				[0, 3, 4],
				[0, 4, 5],
				[0, 5, 1],
				[1, 5, 7],
				[1, 7, 6],
				[1, 6, 2],
				[2, 6, 8],
				[2, 8, 3],
				[3, 8, 9],
				[3, 9, 4],
				[4, 9, 10],
				[4, 10, 5],
				[5, 10, 7],
				[6, 7, 11],
				[6, 11, 8],
				[7, 10, 11],
				[8, 11, 9],
				[9, 11, 10]
			]
		}, t[4] = {
			vertex: [
				[0, 0, 1.070722],
				[.7148135, 0, .7971752],
				[-.104682, .7071068, .7971752],
				[-.6841528, .2071068, .7971752],
				[-.104682, -.7071068, .7971752],
				[.6101315, .7071068, .5236279],
				[1.04156, .2071068, .1367736],
				[.6101315, -.7071068, .5236279],
				[-.3574067, 1, .1367736],
				[-.7888348, -.5, .5236279],
				[-.9368776, .5, .1367736],
				[-.3574067, -1, .1367736],
				[.3574067, 1, -.1367736],
				[.9368776, -.5, -.1367736],
				[.7888348, .5, -.5236279],
				[.3574067, -1, -.1367736],
				[-.6101315, .7071068, -.5236279],
				[-1.04156, -.2071068, -.1367736],
				[-.6101315, -.7071068, -.5236279],
				[.104682, .7071068, -.7971752],
				[.6841528, -.2071068, -.7971752],
				[.104682, -.7071068, -.7971752],
				[-.7148135, 0, -.7971752],
				[0, 0, -1.070722]
			],
			face: [
				[0, 2, 3],
				[1, 6, 5],
				[4, 9, 11],
				[7, 15, 13],
				[8, 16, 10],
				[12, 14, 19],
				[17, 22, 18],
				[20, 21, 23],
				[0, 1, 5, 2],
				[0, 3, 9, 4],
				[0, 4, 7, 1],
				[1, 7, 13, 6],
				[2, 5, 12, 8],
				[2, 8, 10, 3],
				[3, 10, 17, 9],
				[4, 11, 15, 7],
				[5, 6, 14, 12],
				[6, 13, 20, 14],
				[8, 12, 19, 16],
				[9, 17, 18, 11],
				[10, 16, 22, 17],
				[11, 18, 21, 15],
				[13, 15, 21, 20],
				[14, 20, 23, 19],
				[16, 19, 23, 22],
				[18, 22, 23, 21]
			]
		}, t[5] = {
			vertex: [
				[0, 0, 1.322876],
				[1.309307, 0, .1889822],
				[-.9819805, .8660254, .1889822],
				[.1636634, -1.299038, .1889822],
				[.3273268, .8660254, -.9449112],
				[-.8183171, -.4330127, -.9449112]
			],
			face: [
				[0, 3, 1],
				[2, 4, 5],
				[0, 1, 4, 2],
				[0, 2, 5, 3],
				[1, 3, 5, 4]
			]
		}, t[6] = {
			vertex: [
				[0, 0, 1.159953],
				[1.013464, 0, .5642542],
				[-.3501431, .9510565, .5642542],
				[-.7715208, -.6571639, .5642542],
				[.6633206, .9510565, -.03144481],
				[.8682979, -.6571639, -.3996071],
				[-1.121664, .2938926, -.03144481],
				[-.2348831, -1.063314, -.3996071],
				[.5181548, .2938926, -.9953061],
				[-.5850262, -.112257, -.9953061]
			],
			face: [
				[0, 1, 4, 2],
				[0, 2, 6, 3],
				[1, 5, 8, 4],
				[3, 6, 9, 7],
				[5, 7, 9, 8],
				[0, 3, 7, 5, 1],
				[2, 4, 8, 9, 6]
			]
		}, t[7] = {
			vertex: [
				[0, 0, 1.118034],
				[.8944272, 0, .6708204],
				[-.2236068, .8660254, .6708204],
				[-.7826238, -.4330127, .6708204],
				[.6708204, .8660254, .2236068],
				[1.006231, -.4330127, -.2236068],
				[-1.006231, .4330127, .2236068],
				[-.6708204, -.8660254, -.2236068],
				[.7826238, .4330127, -.6708204],
				[.2236068, -.8660254, -.6708204],
				[-.8944272, 0, -.6708204],
				[0, 0, -1.118034]
			],
			face: [
				[0, 1, 4, 2],
				[0, 2, 6, 3],
				[1, 5, 8, 4],
				[3, 6, 10, 7],
				[5, 9, 11, 8],
				[7, 10, 11, 9],
				[0, 3, 7, 9, 5, 1],
				[2, 4, 8, 11, 10, 6]
			]
		}, t[8] = {
			vertex: [
				[-.729665, .670121, .319155],
				[-.655235, -.29213, -.754096],
				[-.093922, -.607123, .537818],
				[.702196, .595691, .485187],
				[.776626, -.36656, -.588064]
			],
			face: [
				[1, 4, 2],
				[0, 1, 2],
				[3, 0, 2],
				[4, 3, 2],
				[4, 1, 0, 3]
			]
		}, t[9] = {
			vertex: [
				[-.868849, -.100041, .61257],
				[-.329458, .976099, .28078],
				[-.26629, -.013796, -.477654],
				[-.13392, -1.034115, .229829],
				[.738834, .707117, -.307018],
				[.859683, -.535264, -.338508]
			],
			face: [
				[3, 0, 2],
				[5, 3, 2],
				[4, 5, 2],
				[1, 4, 2],
				[0, 1, 2],
				[0, 3, 5, 4, 1]
			]
		}, t[10] = {
			vertex: [
				[-.610389, .243975, .531213],
				[-.187812, -.48795, -.664016],
				[-.187812, .9759, -.664016],
				[.187812, -.9759, .664016],
				[.798201, .243975, .132803]
			],
			face: [
				[1, 3, 0],
				[3, 4, 0],
				[3, 1, 4],
				[0, 2, 1],
				[0, 4, 2],
				[2, 4, 1]
			]
		}, t[11] = {
			vertex: [
				[-1.028778, .392027, -.048786],
				[-.640503, -.646161, .621837],
				[-.125162, -.395663, -.540059],
				[.004683, .888447, -.651988],
				[.125161, .395663, .540059],
				[.632925, -.791376, .433102],
				[1.031672, .157063, -.354165]
			],
			face: [
				[3, 2, 0],
				[2, 1, 0],
				[2, 5, 1],
				[0, 4, 3],
				[0, 1, 4],
				[4, 1, 5],
				[2, 3, 6],
				[3, 4, 6],
				[5, 2, 6],
				[4, 5, 6]
			]
		}, t[12] = {
			vertex: [
				[-.669867, .334933, -.529576],
				[-.669867, .334933, .529577],
				[-.4043, 1.212901, 0],
				[-.334933, -.669867, -.529576],
				[-.334933, -.669867, .529577],
				[.334933, .669867, -.529576],
				[.334933, .669867, .529577],
				[.4043, -1.212901, 0],
				[.669867, -.334933, -.529576],
				[.669867, -.334933, .529577]
			],
			face: [
				[8, 9, 7],
				[6, 5, 2],
				[3, 8, 7],
				[5, 0, 2],
				[4, 3, 7],
				[0, 1, 2],
				[9, 4, 7],
				[1, 6, 2],
				[9, 8, 5, 6],
				[8, 3, 0, 5],
				[3, 4, 1, 0],
				[4, 9, 6, 1]
			]
		}, t[13] = {
			vertex: [
				[-.931836, .219976, -.264632],
				[-.636706, .318353, .692816],
				[-.613483, -.735083, -.264632],
				[-.326545, .979634, 0],
				[-.318353, -.636706, .692816],
				[-.159176, .477529, -.856368],
				[.159176, -.477529, -.856368],
				[.318353, .636706, .692816],
				[.326545, -.979634, 0],
				[.613482, .735082, -.264632],
				[.636706, -.318353, .692816],
				[.931835, -.219977, -.264632]
			],
			face: [
				[11, 10, 8],
				[7, 9, 3],
				[6, 11, 8],
				[9, 5, 3],
				[2, 6, 8],
				[5, 0, 3],
				[4, 2, 8],
				[0, 1, 3],
				[10, 4, 8],
				[1, 7, 3],
				[10, 11, 9, 7],
				[11, 6, 5, 9],
				[6, 2, 0, 5],
				[2, 4, 1, 0],
				[4, 10, 7, 1]
			]
		}, t[14] = {
			vertex: [
				[-.93465, .300459, -.271185],
				[-.838689, -.260219, -.516017],
				[-.711319, .717591, .128359],
				[-.710334, -.156922, .080946],
				[-.599799, .556003, -.725148],
				[-.503838, -.004675, -.969981],
				[-.487004, .26021, .48049],
				[-.460089, -.750282, -.512622],
				[-.376468, .973135, -.325605],
				[-.331735, -.646985, .084342],
				[-.254001, .831847, .530001],
				[-.125239, -.494738, -.966586],
				[.029622, .027949, .730817],
				[.056536, -.982543, -.262295],
				[.08085, 1.087391, .076037],
				[.125583, -.532729, .485984],
				[.262625, .599586, .780328],
				[.391387, -.726999, -.716259],
				[.513854, -.868287, .139347],
				[.597475, .85513, .326364],
				[.641224, .109523, .783723],
				[.737185, -.451155, .538891],
				[.848705, -.612742, -.314616],
				[.976075, .365067, .32976],
				[1.072036, -.19561, .084927]
			],
			face: [
				[15, 18, 21],
				[12, 20, 16],
				[6, 10, 2],
				[3, 0, 1],
				[9, 7, 13],
				[2, 8, 4, 0],
				[0, 4, 5, 1],
				[1, 5, 11, 7],
				[7, 11, 17, 13],
				[13, 17, 22, 18],
				[18, 22, 24, 21],
				[21, 24, 23, 20],
				[20, 23, 19, 16],
				[16, 19, 14, 10],
				[10, 14, 8, 2],
				[15, 9, 13, 18],
				[12, 15, 21, 20],
				[6, 12, 16, 10],
				[3, 6, 2, 0],
				[9, 3, 1, 7],
				[9, 15, 12, 6, 3],
				[22, 17, 11, 5, 4, 8, 14, 19, 23, 24]
			]
		};
		const i = e.type && (e.type < 0 || e.type >= t.length) ? 0 : e.type || 0,
			s = e.size,
			n = e.sizeX || s || 1,
			a = e.sizeY || s || 1,
			r = e.sizeZ || s || 1,
			o = e.custom || t[i],
			l = o.face.length,
			h = e.faceUV || new Array(l),
			c = e.faceColors,
			u = void 0 === e.flat || e.flat,
			m = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
			d = [],
			f = [],
			p = [],
			_ = [],
			g = [];
		let v = 0,
			y = 0;
		const S = [];
		let E, A, b, x, M, C, T = 0,
			w = 0;
		if (u)
			for (w = 0; w < l; w++) c && void 0 === c[w] && (c[w] = new wc(1, 1, 1, 1)), h && void 0 === h[w] && (h[w] = new Bc(0, 0, 1, 1));
		if (u)
			for (w = 0; w < l; w++) {
				const e = o.face[w].length;
				for (b = 2 * Math.PI / e, x = .5 * Math.tan(b / 2), M = .5, T = 0; T < e; T++) d.push(o.vertex[o.face[w][T]][0] * n, o.vertex[o.face[w][T]][1] * a, o.vertex[o.face[w][T]][2] * r), S.push(v), v++, E = h[w].x + (h[w].z - h[w].x) * (.5 + x), A = h[w].y + (h[w].w - h[w].y) * (M - .5), _.push(E, A), C = x * Math.cos(b) - M * Math.sin(b), M = x * Math.sin(b) + M * Math.cos(b), x = C, c && g.push(c[w].r, c[w].g, c[w].b, c[w].a);
				for (T = 0; T < e - 2; T++) f.push(S[0 + y], S[T + 2 + y], S[T + 1 + y]);
				y += e
			} else {
				for (T = 0; T < o.vertex.length; T++) d.push(o.vertex[T][0] * n, o.vertex[T][1] * a, o.vertex[T][2] * r), _.push(0, 0);
				for (w = 0; w < l; w++)
					for (T = 0; T < o.face[w].length - 2; T++) f.push(o.face[w][0], o.face[w][T + 2], o.face[w][T + 1])
			}
		Mu.ComputeNormals(d, f, p), Mu._ComputeSides(m, d, f, p, _, e.frontUVs, e.backUVs);
		const R = new Mu;
		return R.positions = d, R.indices = f, R.normals = p, R.uvs = _, c && u && (R.colors = g), R
	}

	function zy(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return Wy(t).applyToMesh(s, t.updatable), s
	}

	function Xy(e) {
		const t = e.sideOrientation || Mu.DEFAULTSIDE,
			i = e.radius || 1,
			s = void 0 === e.flat || e.flat,
			n = 0 | (e.subdivisions || 4),
			a = e.radiusX || i,
			r = e.radiusY || i,
			o = e.radiusZ || i,
			l = (1 + Math.sqrt(5)) / 2,
			h = [-1, l, -0, 1, l, 0, -1, -l, 0, 1, -l, 0, 0, -1, -l, 0, 1, -l, 0, -1, l, 0, 1, l, l, 0, 1, l, 0, -1, -l, 0, 1, -l, 0, -1],
			c = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1],
			u = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 2, 3, 3, 3, 4, 7, 8, 9, 9, 10, 11],
			m = [5, 1, 3, 1, 6, 4, 0, 0, 5, 3, 4, 2, 2, 2, 4, 0, 2, 0, 1, 1, 6, 0, 6, 2, 0, 4, 3, 3, 4, 4, 3, 1, 4, 2, 4, 4, 0, 2, 1, 1, 2, 2, 3, 3, 1, 3, 2, 4],
			d = [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0],
			f = [],
			p = [],
			_ = [],
			g = [];
		let v = 0;
		const y = new Array(3),
			S = new Array(3);
		let E;
		for (E = 0; E < 3; E++) y[E] = Lc.Zero(), S[E] = Fc.Zero();
		for (let e = 0; e < 20; e++) {
			for (E = 0; E < 3; E++) {
				const t = c[3 * e + E];
				y[E].copyFromFloats(h[3 * u[t]], h[3 * u[t] + 1], h[3 * u[t] + 2]), y[E].normalize(), S[E].copyFromFloats(.134765625 * m[2 * t] + .05859375 + -.0390625 * d[e], .2333984375 * m[2 * t + 1] + .025390625 + .01953125 * d[e])
			}
			const t = (e, t, i, l) => {
				const h = Lc.Lerp(y[0], y[2], t / n),
					c = Lc.Lerp(y[1], y[2], t / n),
					u = n === t ? y[2] : Lc.Lerp(h, c, e / (n - t));
				let m;
				if (u.normalize(), s) {
					const e = Lc.Lerp(y[0], y[2], l / n),
						t = Lc.Lerp(y[1], y[2], l / n);
					m = Lc.Lerp(e, t, i / (n - l))
				} else m = new Lc(u.x, u.y, u.z);
				m.x /= a, m.y /= r, m.z /= o, m.normalize();
				const d = Fc.Lerp(S[0], S[2], t / n),
					E = Fc.Lerp(S[1], S[2], t / n),
					A = n === t ? S[2] : Fc.Lerp(d, E, e / (n - t));
				p.push(u.x * a, u.y * r, u.z * o), _.push(m.x, m.y, m.z), g.push(A.x, A.y), f.push(v), v++
			};
			for (let e = 0; e < n; e++)
				for (let i = 0; i + e < n; i++) t(i, e, i + 1 / 3, e + 1 / 3), t(i + 1, e, i + 1 / 3, e + 1 / 3), t(i, e + 1, i + 1 / 3, e + 1 / 3), i + e + 1 < n && (t(i + 1, e, i + 2 / 3, e + 2 / 3), t(i + 1, e + 1, i + 2 / 3, e + 2 / 3), t(i, e + 1, i + 2 / 3, e + 2 / 3))
		}
		Mu._ComputeSides(t, p, f, _, g, e.frontUVs, e.backUVs);
		const A = new Mu;
		return A.indices = f, A.positions = p, A.normals = _, A.uvs = g, A
	}

	function Yy(e, t = {}, i = null) {
		const s = new Vf(e, i);
		t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation;
		return Xy(t).applyToMesh(s, t.updatable), s
	}
	Mu.CreatePolygon = ky, Vf.CreatePolygon = (e, t, i, s, n, a, r = earcut) => Dy(e, {
		shape: t,
		holes: s,
		updatable: n,
		sideOrientation: a
	}, i, r), Vf.ExtrudePolygon = (e, t, i, s, n, a, r, o = earcut) => Oy(e, {
		shape: t,
		holes: n,
		depth: i,
		updatable: a,
		sideOrientation: r
	}, s, o), Vf.ExtrudeShape = (e, t, i, s, n, a, r = null, o, l, h) => Fy(e, {
		shape: t,
		path: i,
		scale: s,
		rotation: n,
		cap: 0 === a ? 0 : a || Vf.NO_CAP,
		sideOrientation: l,
		instance: h,
		updatable: o
	}, r), Vf.ExtrudeShapeCustom = (e, t, i, s, n, a, r, o, l, h, c, u) => Ly(e, {
		shape: t,
		path: i,
		scaleFunction: s,
		rotationFunction: n,
		ribbonCloseArray: a,
		ribbonClosePath: r,
		cap: 0 === o ? 0 : o || Vf.NO_CAP,
		sideOrientation: c,
		instance: u,
		updatable: h
	}, l), Vf.ka = (e, t, i, s, n, a, r) => Gy(e, {
		shape: t,
		radius: i,
		tessellation: s,
		sideOrientation: r,
		updatable: a
	}, n), Mu.Pk = Hy, Vf.Pk = (e, t, i, s, n) => Uy(e, {
		size: t,
		width: t,
		height: t,
		sideOrientation: n,
		updatable: s
	}, i), Vf.CreateTube = (e, t, i, s, n, a, r, o, l, h) => Vy(e, {
		path: t,
		radius: i,
		tessellation: s,
		radiusFunction: n,
		arc: 1,
		cap: a,
		updatable: o,
		sideOrientation: l,
		instance: h
	}, r), Mu.CreatePolyhedron = Wy, Vf.CreatePolyhedron = (e, t, i) => zy(e, t, i), Mu.CreateIcoSphere = Xy, Vf.CreateIcoSphere = (e, t, i) => Yy(e, t, i);
	var jy = new Lc(1, 0, 0),
		Ky = new Lc(-1, 0, 0),
		$y = new Lc(0, 1, 0),
		Jy = new Lc(0, -1, 0),
		qy = new Lc(0, 0, 1),
		Qy = new Lc(0, 0, -1),
		Zy = class e {
			clone() {
				return new e(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, this.localPositionOverride?.slice(), this.localNormalOverride?.slice(), this.matrixIndicesOverride?.slice(), this.matrixWeightsOverride?.slice())
			}
			constructor(e = Lc.Zero(), t = Lc.Up(), i = Fc.Zero(), s = 0, n = 0, a = null, r = null, o = null, l = null) {
				this.position = e, this.normal = t, this.uv = i, this.vertexIdx = s, this.vertexIdxForBones = n, this.localPositionOverride = a, this.localNormalOverride = r, this.matrixIndicesOverride = o, this.matrixWeightsOverride = l
			}
		};

	function eS(e, t, i) {
		const s = !!t.skeleton,
			n = i.localMode || s,
			a = t.getIndices(),
			r = s ? t.getPositionData(!0, !0) : t.getVerticesData(eu.PositionKind),
			o = s ? t.getNormalsData(!0, !0) : t.getVerticesData(eu.NormalKind),
			l = n ? s ? t.getVerticesData(eu.PositionKind) : r : null,
			h = n ? s ? t.getVerticesData(eu.NormalKind) : o : null,
			c = t.getVerticesData(eu.UVKind),
			u = s ? t.getVerticesData(eu.MatricesIndicesKind) : null,
			m = s ? t.getVerticesData(eu.MatricesWeightsKind) : null,
			d = s ? t.getVerticesData(eu.MatricesIndicesExtraKind) : null,
			f = s ? t.getVerticesData(eu.MatricesWeightsExtraKind) : null,
			p = i.position || Lc.Zero();
		let _ = i.normal || Lc.Up();
		const g = i.size || Lc.One(),
			v = i.angle || 0;
		if (!_) {
			const e = new Lc(0, 0, 1),
				i = t.getScene().activeCamera,
				s = Lc.TransformCoordinates(e, i.getWorldMatrix());
			_ = i.globalPosition.subtract(s)
		}
		const y = -Math.atan2(_.z, _.x) - Math.PI / 2,
			S = Math.sqrt(_.x * _.x + _.z * _.z),
			E = Math.atan2(_.y, S),
			A = new Mu;
		A.indices = [], A.positions = [], A.normals = [], A.uvs = [], A.matricesIndices = s ? [] : null, A.matricesWeights = s ? [] : null, A.matricesIndicesExtra = d ? [] : null, A.matricesWeightsExtra = f ? [] : null;
		let b = 0;
		const x = (e, t) => {
				const s = new Zy;
				if (!a || !r || !o) return s;
				const n = a[e];
				if (s.vertexIdx = 3 * n, s.vertexIdxForBones = 4 * n, s.position = new Lc(r[3 * n], r[3 * n + 1], r[3 * n + 2]), Lc.TransformCoordinatesToRef(s.position, t, s.position), s.normal = new Lc(o[3 * n], o[3 * n + 1], o[3 * n + 2]), Lc.TransformNormalToRef(s.normal, t, s.normal), i.captureUVS && c) {
					const e = c[2 * n + 1];
					s.uv = new Fc(c[2 * n], e)
				}
				return s
			},
			M = [0, 0, 0, 0],
			C = (e, t) => {
				if (0 === e.length) return e;
				const i = .5 * Math.abs(Lc.Dot(g, t)),
					s = (e, t, i, s) => {
						for (let n = 0; n < s; ++n)
							if (e[i + n] === t) return i + n;
						return -1
					},
					n = (e, n) => {
						const a = Lc.GetClipFactor(e.position, n.position, t, i);
						let r = M,
							o = M;
						if (u && m) {
							const t = e.matrixIndicesOverride ? 0 : e.vertexIdxForBones,
								i = e.matrixIndicesOverride ?? u,
								l = e.matrixWeightsOverride ?? m,
								h = n.matrixIndicesOverride ? 0 : n.vertexIdxForBones,
								c = n.matrixIndicesOverride ?? u,
								d = n.matrixWeightsOverride ?? m;
							r = [0, 0, 0, 0], o = [0, 0, 0, 0];
							let f = 0;
							for (let e = 0; e < 4; ++e)
								if (l[t + e] > 0) {
									const n = s(c, i[t + e], h, 4);
									r[f] = i[t + e], o[f] = Ac.Lerp(l[t + e], n >= 0 ? d[n] : 0, a), f++
								} for (let e = 0; e < 4 && f < 4; ++e) {
								const n = c[h + e]; - 1 === s(i, n, t, 4) && (r[f] = n, o[f] = Ac.Lerp(0, d[h + e], a), f++)
							}
							const p = o[0] + o[1] + o[2] + o[3];
							o[0] /= p, o[1] /= p, o[2] /= p, o[3] /= p
						}
						const c = e.localPositionOverride ? e.localPositionOverride[0] : l?.[e.vertexIdx] ?? 0,
							d = e.localPositionOverride ? e.localPositionOverride[1] : l?.[e.vertexIdx + 1] ?? 0,
							f = e.localPositionOverride ? e.localPositionOverride[2] : l?.[e.vertexIdx + 2] ?? 0,
							p = n.localPositionOverride ? n.localPositionOverride[0] : l?.[n.vertexIdx] ?? 0,
							_ = n.localPositionOverride ? n.localPositionOverride[1] : l?.[n.vertexIdx + 1] ?? 0,
							g = n.localPositionOverride ? n.localPositionOverride[2] : l?.[n.vertexIdx + 2] ?? 0,
							v = e.localNormalOverride ? e.localNormalOverride[0] : h?.[e.vertexIdx] ?? 0,
							y = e.localNormalOverride ? e.localNormalOverride[1] : h?.[e.vertexIdx + 1] ?? 0,
							S = e.localNormalOverride ? e.localNormalOverride[2] : h?.[e.vertexIdx + 2] ?? 0,
							E = v + ((n.localNormalOverride ? n.localNormalOverride[0] : h?.[n.vertexIdx] ?? 0) - v) * a,
							A = y + ((n.localNormalOverride ? n.localNormalOverride[1] : h?.[n.vertexIdx + 1] ?? 0) - y) * a,
							b = S + ((n.localNormalOverride ? n.localNormalOverride[2] : h?.[n.vertexIdx + 2] ?? 0) - S) * a,
							x = Math.sqrt(E * E + A * A + b * b);
						return new Zy(Lc.Lerp(e.position, n.position, a), Lc.Lerp(e.normal, n.normal, a).normalize(), Fc.Lerp(e.uv, n.uv, a), -1, -1, l ? [c + (p - c) * a, d + (_ - d) * a, f + (g - f) * a] : null, h ? [E / x, A / x, b / x] : null, r, o)
					};
				let a = null;
				e.length > 3 && (a = []);
				for (let s = 0; s < e.length; s += 3) {
					let r = 0,
						o = null,
						l = null,
						h = null,
						c = null;
					const u = Lc.Dot(e[s].position, t) - i > 0,
						m = Lc.Dot(e[s + 1].position, t) - i > 0,
						d = Lc.Dot(e[s + 2].position, t) - i > 0;
					switch (r = (u ? 1 : 0) + (m ? 1 : 0) + (d ? 1 : 0), r) {
						case 0:
							e.length > 3 ? (a.push(e[s]), a.push(e[s + 1]), a.push(e[s + 2])) : a = e;
							break;
						case 1:
							if (a = a ?? new Array, u && (o = e[s + 1], l = e[s + 2], h = n(e[s], o), c = n(e[s], l)), m) {
								o = e[s], l = e[s + 2], h = n(e[s + 1], o), c = n(e[s + 1], l), a.push(h), a.push(l.clone()), a.push(o.clone()), a.push(l.clone()), a.push(h.clone()), a.push(c);
								break
							}
							d && (o = e[s], l = e[s + 1], h = n(e[s + 2], o), c = n(e[s + 2], l)), o && l && h && c && (a.push(o.clone()), a.push(l.clone()), a.push(h), a.push(c), a.push(h.clone()), a.push(l.clone()));
							break;
						case 2:
							a = a ?? new Array, u || (o = e[s].clone(), l = n(o, e[s + 1]), h = n(o, e[s + 2]), a.push(o), a.push(l), a.push(h)), m || (o = e[s + 1].clone(), l = n(o, e[s + 2]), h = n(o, e[s]), a.push(o), a.push(l), a.push(h)), d || (o = e[s + 2].clone(), l = n(o, e[s]), h = n(o, e[s + 1]), a.push(o), a.push(l), a.push(h))
					}
				}
				return a
			},
			T = t instanceof Vf ? t : null,
			w = T?._thinInstanceDataStorage.matrixData,
			R = T?.thinInstanceCount || 1,
			N = Vc.Matrix[0];
		N.copyFrom(Hc.IdentityReadOnly);
		for (let e = 0; e < R; ++e) {
			if (T?.hasThinInstances && w) {
				const t = 16 * e;
				N.setRowFromFloats(0, w[t + 0], w[t + 1], w[t + 2], w[t + 3]), N.setRowFromFloats(1, w[t + 4], w[t + 5], w[t + 6], w[t + 7]), N.setRowFromFloats(2, w[t + 8], w[t + 9], w[t + 10], w[t + 11]), N.setRowFromFloats(3, w[t + 12], w[t + 13], w[t + 14], w[t + 15])
			}
			const s = Hc.Jk(y, E, v).multiply(Hc.Translation(p.x, p.y, p.z)),
				r = Hc.Invert(s),
				o = t.getWorldMatrix(),
				c = N.multiply(o).multiply(r),
				_ = new Array(3);
			for (let e = 0; e < a.length; e += 3) {
				let t = _;
				if (t[0] = x(e, c), t[1] = x(e + 1, c), t[2] = x(e + 2, c), !(i.cullBackFaces && -t[0].normal.z <= 0 && -t[1].normal.z <= 0 && -t[2].normal.z <= 0) && (t = C(t, jy), t && (t = C(t, Ky), t && (t = C(t, $y), t && (t = C(t, Jy), t && (t = C(t, qy), t && (t = C(t, Qy), t)))))))
					for (let e = 0; e < t.length; e++) {
						const s = t[e];
						if (A.indices.push(b), n ? (s.localPositionOverride ? (A.positions[3 * b] = s.localPositionOverride[0], A.positions[3 * b + 1] = s.localPositionOverride[1], A.positions[3 * b + 2] = s.localPositionOverride[2]) : l && (A.positions[3 * b] = l[s.vertexIdx], A.positions[3 * b + 1] = l[s.vertexIdx + 1], A.positions[3 * b + 2] = l[s.vertexIdx + 2]), s.localNormalOverride ? (A.normals[3 * b] = s.localNormalOverride[0], A.normals[3 * b + 1] = s.localNormalOverride[1], A.normals[3 * b + 2] = s.localNormalOverride[2]) : h && (A.normals[3 * b] = h[s.vertexIdx], A.normals[3 * b + 1] = h[s.vertexIdx + 1], A.normals[3 * b + 2] = h[s.vertexIdx + 2])) : (s.position.toArray(A.positions, 3 * b), s.normal.toArray(A.normals, 3 * b)), A.matricesIndices && A.matricesWeights && (s.matrixIndicesOverride ? (A.matricesIndices[4 * b] = s.matrixIndicesOverride[0], A.matricesIndices[4 * b + 1] = s.matrixIndicesOverride[1], A.matricesIndices[4 * b + 2] = s.matrixIndicesOverride[2], A.matricesIndices[4 * b + 3] = s.matrixIndicesOverride[3]) : (u && (A.matricesIndices[4 * b] = u[s.vertexIdxForBones], A.matricesIndices[4 * b + 1] = u[s.vertexIdxForBones + 1], A.matricesIndices[4 * b + 2] = u[s.vertexIdxForBones + 2], A.matricesIndices[4 * b + 3] = u[s.vertexIdxForBones + 3]), d && A.matricesIndicesExtra && (A.matricesIndicesExtra[4 * b] = d[s.vertexIdxForBones], A.matricesIndicesExtra[4 * b + 1] = d[s.vertexIdxForBones + 1], A.matricesIndicesExtra[4 * b + 2] = d[s.vertexIdxForBones + 2], A.matricesIndicesExtra[4 * b + 3] = d[s.vertexIdxForBones + 3])), s.matrixWeightsOverride ? (A.matricesWeights[4 * b] = s.matrixWeightsOverride[0], A.matricesWeights[4 * b + 1] = s.matrixWeightsOverride[1], A.matricesWeights[4 * b + 2] = s.matrixWeightsOverride[2], A.matricesWeights[4 * b + 3] = s.matrixWeightsOverride[3]) : (m && (A.matricesWeights[4 * b] = m[s.vertexIdxForBones], A.matricesWeights[4 * b + 1] = m[s.vertexIdxForBones + 1], A.matricesWeights[4 * b + 2] = m[s.vertexIdxForBones + 2], A.matricesWeights[4 * b + 3] = m[s.vertexIdxForBones + 3]), f && A.matricesWeightsExtra && (A.matricesWeightsExtra[4 * b] = f[s.vertexIdxForBones], A.matricesWeightsExtra[4 * b + 1] = f[s.vertexIdxForBones + 1], A.matricesWeightsExtra[4 * b + 2] = f[s.vertexIdxForBones + 2], A.matricesWeightsExtra[4 * b + 3] = f[s.vertexIdxForBones + 3]))), i.captureUVS) s.uv.toArray(A.uvs, 2 * b);
						else {
							A.uvs.push(.5 + s.position.x / g.x);
							const e = .5 + s.position.y / g.y;
							A.uvs.push(e)
						}
						b++
					}
			}
		}
		0 === A.indices.length && (A.indices = null), 0 === A.positions.length && (A.positions = null), 0 === A.normals.length && (A.normals = null), 0 === A.uvs.length && (A.uvs = null), 0 === A.matricesIndices?.length && (A.matricesIndices = null), 0 === A.matricesWeights?.length && (A.matricesWeights = null), 0 === A.matricesIndicesExtra?.length && (A.matricesIndicesExtra = null), 0 === A.matricesWeightsExtra?.length && (A.matricesWeightsExtra = null);
		const I = new Vf(e, t.getScene());
		return A.applyToMesh(I), n ? (I.skeleton = t.skeleton, I.parent = t) : (I.position = p.clone(), I.rotation = new Lc(E, y, v)), I.computeWorldMatrix(!0), I.refreshBoundingInfo(!0, !0), I
	}

	function tS(e = {
		subdivisions: 2,
		tessellation: 16,
		height: 1,
		radius: .25,
		capSubdivisions: 6
	}) {
		const t = 0 | Math.max(e.subdivisions ? e.subdivisions : 2, 1),
			i = 0 | Math.max(e.tessellation ? e.tessellation : 16, 3),
			s = Math.max(e.height ? e.height : 1, 0),
			n = Math.max(e.radius ? e.radius : .25, 0),
			a = 0 | Math.max(e.capSubdivisions ? e.capSubdivisions : 6, 1),
			r = i,
			o = t,
			l = Math.max(e.radiusTop ? e.radiusTop : n, 0),
			h = Math.max(e.radiusBottom ? e.radiusBottom : n, 0),
			c = s - (l + h),
			u = 2 * Math.PI,
			m = Math.max(e.topCapSubdivisions ? e.topCapSubdivisions : a, 1),
			d = Math.max(e.bottomCapSubdivisions ? e.bottomCapSubdivisions : a, 1),
			f = Math.acos((h - l) / s);
		let p = [];
		const _ = [],
			g = [],
			v = [];
		let y = 0;
		const S = [],
			E = .5 * c,
			A = .5 * Math.PI;
		let b, x;
		const M = Lc.Zero(),
			C = Lc.Zero(),
			T = Math.cos(f),
			w = Math.sin(f),
			R = new Fc(l * w, E + l * T).subtract(new Fc(h * w, h * T - E)).length(),
			N = l * f + R + h * (A - f);
		let I = 0;
		for (x = 0; x <= m; x++) {
			const e = [],
				t = A - f * (x / m);
			I += l * f / m;
			const i = Math.cos(t),
				s = Math.sin(t),
				n = i * l;
			for (b = 0; b <= r; b++) {
				const t = b / r,
					a = t * u + 0,
					o = Math.sin(a),
					h = Math.cos(a);
				C.x = n * o, C.y = E + s * l, C.z = n * h, _.push(C.x, C.y, C.z), M.set(i * o, s, i * h), g.push(M.x, M.y, M.z), v.push(t, 1 - I / N), e.push(y), y++
			}
			S.push(e)
		}
		const P = s - l - h + T * l - T * h,
			k = w * (h - l) / P;
		for (x = 1; x <= o; x++) {
			const e = [];
			I += R / o;
			const t = w * (x * (h - l) / o + l);
			for (b = 0; b <= r; b++) {
				const i = b / r,
					s = i * u + 0,
					n = Math.sin(s),
					a = Math.cos(s);
				C.x = t * n, C.y = E + T * l - x * P / o, C.z = t * a, _.push(C.x, C.y, C.z), M.set(n, k, a).normalize(), g.push(M.x, M.y, M.z), v.push(i, 1 - I / N), e.push(y), y++
			}
			S.push(e)
		}
		for (x = 1; x <= d; x++) {
			const e = [],
				t = A - f - (Math.PI - f) * (x / d);
			I += h * f / d;
			const i = Math.cos(t),
				s = Math.sin(t),
				n = i * h;
			for (b = 0; b <= r; b++) {
				const t = b / r,
					a = t * u + 0,
					o = Math.sin(a),
					l = Math.cos(a);
				C.x = n * o, C.y = s * h - E, C.z = n * l, _.push(C.x, C.y, C.z), M.set(i * o, s, i * l), g.push(M.x, M.y, M.z), v.push(t, 1 - I / N), e.push(y), y++
			}
			S.push(e)
		}
		for (b = 0; b < r; b++)
			for (x = 0; x < m + o + d; x++) {
				const e = S[x][b],
					t = S[x + 1][b],
					i = S[x + 1][b + 1],
					s = S[x][b + 1];
				p.push(e), p.push(t), p.push(s), p.push(t), p.push(i), p.push(s)
			}
		if (p = p.reverse(), e.orientation && !e.orientation.equals(Lc.Up())) {
			const t = new Hc;
			e.orientation.clone().scale(.5 * Math.PI).cross(Lc.Up()).toQuaternion().toRotationMatrix(t);
			const i = Lc.Zero();
			for (let e = 0; e < _.length; e += 3) i.set(_[e], _[e + 1], _[e + 2]), Lc.TransformCoordinatesToRef(i.clone(), t, i), _[e] = i.x, _[e + 1] = i.y, _[e + 2] = i.z
		}
		const D = new Mu;
		return D.positions = _, D.normals = g, D.uvs = v, D.indices = p, D
	}

	function iS(e, t = {
		orientation: Lc.Up(),
		subdivisions: 2,
		tessellation: 16,
		height: 1,
		radius: .25,
		capSubdivisions: 6,
		updatable: !1
	}, i = null) {
		const s = new Vf(e, i);
		return tS(t).applyToMesh(s, t.updatable), s
	}
	Vf.CreateDecal = (e, t, i, s, n, a) => eS(e, t, {
		position: i,
		normal: s,
		size: n,
		angle: a
	}), Vf.CreateCapsule = (e, t, i) => iS(e, t, i), Mu.CreateCapsule = tS;
	var sS = class e {
			rotate120(e, t) {
				e !== Math.floor(e) && (e = Math.floor(e), Qc.Warn("m not an integer only floor(m) used")), t !== Math.floor(t) && (t = Math.floor(t), Qc.Warn("n not an integer only floor(n) used"));
				const i = this.x;
				return this.x = e - i - this.y, this.y = t + i, this
			}
			static Zero() {
				return new e(0, 0)
			}
			rotate60About(e) {
				const t = this.x;
				return this.x = e.x + e.y - this.y, this.y = t + this.y - e.x, this
			}
			rotateNeg60About(e) {
				const t = this.x;
				return this.x = t + this.y - e.y, this.y = e.x + e.y - t, this
			}
			clone() {
				return new e(this.x, this.y)
			}
			toCartesianOrigin(e, t) {
				const i = Lc.Zero();
				return i.x = e.x + 2 * this.x * t + this.y * t, i.y = e.y + Math.sqrt(3) * this.y * t, i
			}
			rotateNeg120(e, t) {
				e !== Math.floor(e) && (e = Math.floor(e), Qc.Warn("m is not an integer, floor(m) used")), t !== Math.floor(t) && (t = Math.floor(t), Qc.Warn("n is not an integer,   floor(n) used"));
				const i = this.x;
				return this.x = this.y - t, this.y = e + t - i - this.y, this
			}
			constructor(e = 0, t = 0) {
				this.x = e, this.y = t, e !== Math.floor(e) && (e = Math.floor(e), Qc.Warn("x is not an integer, floor(x) used")), t !== Math.floor(t) && (t = Math.floor(t), Qc.Warn("y is not an integer, floor(y) used"))
			}
		},
		nS = class {
			mapABOBtoBAOA() {
				const e = new sS(0, 0);
				for (let t = 0; t < this.isoVecsABOB.length; t++) {
					const i = [];
					for (let s = 0; s < 3; s++) e.x = this.isoVecsABOB[t][s].x, e.y = this.isoVecsABOB[t][s].y, 1 === this.vertexTypes[t][s] && e.rotate120(this.m, this.n), i.push(e.clone());
					this.isoVecsBAOA.push(i)
				}
			}
			setIndices() {
				let e = 12;
				const t = {},
					i = this.m,
					s = this.n;
				let n, a, r, o, l, h = i,
					c = 1,
					u = 0;
				0 !== s && (h = Ac.HCF(i, s)), c = i / h, u = s / h;
				const m = sS.Zero(),
					d = new sS(i, s),
					f = new sS(-s, i + s),
					p = sS.Zero(),
					_ = sS.Zero(),
					g = sS.Zero();
				let v, y, S, E, A = [];
				const b = [],
					x = this.vertByDist,
					M = (i, s, n, a) => {
						v = i + "|" + n, y = s + "|" + a, v in t || y in t ? v in t && !(y in t) ? t[y] = t[v] : y in t && !(v in t) && (t[v] = t[y]) : (t[v] = e, t[y] = e, e++), x[n][0] > 2 ? b[t[v]] = [-x[n][0], x[n][1], t[v]] : b[t[v]] = [A[x[n][0]], x[n][1], t[v]]
					};
				this.IDATA.edgematch = [
					[1, "B"],
					[2, "B"],
					[3, "B"],
					[4, "B"],
					[0, "B"],
					[10, "O", 14, "A"],
					[11, "O", 10, "A"],
					[12, "O", 11, "A"],
					[13, "O", 12, "A"],
					[14, "O", 13, "A"],
					[0, "O"],
					[1, "O"],
					[2, "O"],
					[3, "O"],
					[4, "O"],
					[19, "B", 5, "A"],
					[15, "B", 6, "A"],
					[16, "B", 7, "A"],
					[17, "B", 8, "A"],
					[18, "B", 9, "A"]
				];
				for (let y = 0; y < 20; y++) {
					if (A = this.IDATA.face[y], r = A[2], o = A[1], l = A[0], S = m.x + "|" + m.y, v = y + "|" + S, v in t || (t[v] = r, b[r] = [A[x[S][0]], x[S][1]]), S = d.x + "|" + d.y, v = y + "|" + S, v in t || (t[v] = o, b[o] = [A[x[S][0]], x[S][1]]), S = f.x + "|" + f.y, v = y + "|" + S, v in t || (t[v] = l, b[l] = [A[x[S][0]], x[S][1]]), n = this.IDATA.edgematch[y][0], a = this.IDATA.edgematch[y][1], "B" === a)
						for (let e = 1; e < h; e++) _.x = i - e * (c + u), _.y = s + e * c, g.x = -e * u, g.y = e * (c + u), S = _.x + "|" + _.y, E = g.x + "|" + g.y, M(y, n, S, E);
					if ("O" === a)
						for (let e = 1; e < h; e++) g.x = -e * u, g.y = e * (c + u), p.x = e * c, p.y = e * u, S = g.x + "|" + g.y, E = p.x + "|" + p.y, M(y, n, S, E);
					if (n = this.IDATA.edgematch[y][2], a = this.IDATA.edgematch[y][3], a && "A" === a)
						for (let e = 1; e < h; e++) p.x = e * c, p.y = e * u, _.x = i - (h - e) * (c + u), _.y = s + (h - e) * c, S = p.x + "|" + p.y, E = _.x + "|" + _.y, M(y, n, S, E);
					for (let i = 0; i < this.vertices.length; i++) S = this.vertices[i].x + "|" + this.vertices[i].y, v = y + "|" + S, v in t || (t[v] = e++, x[S][0] > 2 ? b[t[v]] = [-x[S][0], x[S][1], t[v]] : b[t[v]] = [A[x[S][0]], x[S][1], t[v]])
				}
				this.closestTo = b, this.vecToidx = t
			}
			constructor() {
				this.cartesian = [], this.vertices = [], this.max = [], this.min = [], this.closestTo = [], this.innerFacets = [], this.isoVecsABOB = [], this.isoVecsOBOA = [], this.isoVecsBAOA = [], this.vertexTypes = [], this.IDATA = new aS("icosahedron", "Regular", [
					[0, fc, -1],
					[-fc, 1, 0],
					[-1, 0, -fc],
					[1, 0, -fc],
					[fc, 1, 0],
					[0, fc, 1],
					[-1, 0, fc],
					[-fc, -1, 0],
					[0, -fc, -1],
					[fc, -1, 0],
					[1, 0, fc],
					[0, -fc, 1]
				], [
					[0, 2, 1],
					[0, 3, 2],
					[0, 4, 3],
					[0, 5, 4],
					[0, 1, 5],
					[7, 6, 1],
					[8, 7, 2],
					[9, 8, 3],
					[10, 9, 4],
					[6, 10, 5],
					[2, 7, 1],
					[3, 8, 2],
					[4, 9, 3],
					[5, 10, 4],
					[1, 6, 5],
					[11, 6, 7],
					[11, 7, 8],
					[11, 8, 9],
					[11, 9, 10],
					[11, 10, 6]
				])
			}
			build(e, t) {
				const i = [],
					s = sS.Zero(),
					n = new sS(e, t),
					a = new sS(-t, e + t);
				i.push(s, n, a);
				for (let s = t; s < e + 1; s++)
					for (let t = 0; t < e + 1 - s; t++) i.push(new sS(t, s));
				if (t > 0) {
					const s = Ac.HCF(e, t),
						n = e / s,
						a = t / s;
					for (let r = 1; r < s; r++) i.push(new sS(r * n, r * a)), i.push(new sS(-r * a, r * (n + a))), i.push(new sS(e - r * (n + a), t + r * n));
					const r = e / t;
					for (let s = 1; s < t; s++)
						for (let n = 0; n < s * r; n++) i.push(new sS(n, s)), i.push(new sS(n, s).rotate120(e, t)), i.push(new sS(n, s).rotateNeg120(e, t))
				}
				i.sort(((e, t) => e.x - t.x)), i.sort(((e, t) => e.y - t.y));
				const r = new Array(e + t + 1),
					o = new Array(e + t + 1);
				for (let e = 0; e < r.length; e++) r[e] = 1 / 0, o[e] = -1 / 0;
				let l = 0,
					h = 0;
				const c = i.length;
				for (let e = 0; e < c; e++) h = i[e].x, l = i[e].y, r[l] = Math.min(h, r[l]), o[l] = Math.max(h, o[l]);
				const u = (i, s) => {
						const n = i.clone();
						return "A" === s && n.rotateNeg120(e, t), "B" === s && n.rotate120(e, t), n.x < 0 ? n.y : n.x + n.y
					},
					m = [],
					d = [],
					f = [],
					p = [],
					_ = {},
					g = [];
				let v = -1,
					y = -1;
				for (let e = 0; e < c; e++) m[e] = i[e].toCartesianOrigin(new sS(0, 0), .5), d[e] = u(i[e], "O"), f[e] = u(i[e], "A"), p[e] = u(i[e], "B"), d[e] === f[e] && f[e] === p[e] ? (v = 3, y = d[e]) : d[e] === f[e] ? (v = 4, y = d[e]) : f[e] === p[e] ? (v = 5, y = f[e]) : p[e] === d[e] && (v = 6, y = d[e]), d[e] < f[e] && d[e] < p[e] && (v = 2, y = d[e]), f[e] < d[e] && f[e] < p[e] && (v = 1, y = f[e]), p[e] < f[e] && p[e] < d[e] && (v = 0, y = p[e]), g.push([v, y, i[e].x, i[e].y]);
				g.sort(((e, t) => e[2] - t[2])), g.sort(((e, t) => e[3] - t[3])), g.sort(((e, t) => e[1] - t[1])), g.sort(((e, t) => e[0] - t[0]));
				for (let e = 0; e < g.length; e++) _[g[e][2] + "|" + g[e][3]] = [g[e][0], g[e][1], e];
				return this.m = e, this.n = t, this.vertices = i, this.vertByDist = _, this.cartesian = m, this.min = r, this.max = o, this
			}
			calcCoeffs() {
				const e = this.m,
					t = this.n,
					i = Math.sqrt(3) / 3,
					s = e * e + t * t + e * t;
				this.coau = (e + t) / s, this.cobu = -t / s, this.coav = -i * (e - t) / s, this.cobv = i * (2 * e + t) / s
			}
			mapABOBtoOBOA() {
				const e = new sS(0, 0);
				for (let t = 0; t < this.isoVecsABOB.length; t++) {
					const i = [];
					for (let s = 0; s < 3; s++) e.x = this.isoVecsABOB[t][s].x, e.y = this.isoVecsABOB[t][s].y, 0 === this.vertexTypes[t][s] && e.rotateNeg120(this.m, this.n), i.push(e.clone());
					this.isoVecsOBOA.push(i)
				}
			}
			createInnerFacets() {
				const e = this.m,
					t = this.n;
				for (let i = 0; i < t + e + 1; i++)
					for (let e = this.min[i]; e < this.max[i] + 1; e++) e < this.max[i] && e < this.max[i + 1] + 1 && this.innerFacets.push(["|" + e + "|" + i, "|" + e + "|" + (i + 1), "|" + (e + 1) + "|" + i]), i > 0 && e < this.max[i - 1] && e + 1 < this.max[i] + 1 && this.innerFacets.push(["|" + e + "|" + i, "|" + (e + 1) + "|" + i, "|" + (e + 1) + "|" + (i - 1)])
			}
			edgeVecsABOB() {
				const e = this.m,
					t = this.n,
					i = new sS(-t, e + t);
				for (let s = 1; s < e + t; s++) {
					const e = new sS(this.min[s], s),
						t = new sS(this.min[s - 1], s - 1),
						n = new sS(this.min[s + 1], s + 1),
						a = e.clone(),
						r = t.clone(),
						o = n.clone();
					a.rotate60About(i), r.rotate60About(i), o.rotate60About(i);
					const l = new sS(this.max[a.y], a.y),
						h = new sS(this.max[a.y - 1], a.y - 1),
						c = new sS(this.max[a.y - 1] - 1, a.y - 1);
					a.x === l.x && a.y === l.y || (a.x !== h.x ? (this.vertexTypes.push([1, 0, 0]), this.isoVecsABOB.push([e, h, c]), this.vertexTypes.push([1, 0, 0]), this.isoVecsABOB.push([e, c, l])) : a.y === o.y ? (this.vertexTypes.push([1, 1, 0]), this.isoVecsABOB.push([e, t, h]), this.vertexTypes.push([1, 0, 1]), this.isoVecsABOB.push([e, h, n])) : (this.vertexTypes.push([1, 1, 0]), this.isoVecsABOB.push([e, t, h]), this.vertexTypes.push([1, 0, 0]), this.isoVecsABOB.push([e, h, l])))
				}
			}
			MapToFace(e, t) {
				const i = this.IDATA.face[e],
					s = i[2],
					n = i[1],
					a = i[0],
					r = Lc.FromArray(this.IDATA.vertex[s]),
					o = Lc.FromArray(this.IDATA.vertex[n]),
					l = Lc.FromArray(this.IDATA.vertex[a]),
					h = o.subtract(r),
					c = l.subtract(r),
					u = h.scale(this.coau).add(c.scale(this.cobu)),
					m = h.scale(this.coav).add(c.scale(this.cobv)),
					d = [];
				let f, p = Vc.Vector3[0];
				for (let i = 0; i < this.cartesian.length; i++) p = u.scale(this.cartesian[i].x).add(m.scale(this.cartesian[i].y)).add(r), d[i] = [p.x, p.y, p.z], f = e + "|" + this.vertices[i].x + "|" + this.vertices[i].y, t.vertex[this.vecToidx[f]] = [p.x, p.y, p.z]
			}
		},
		aS = class {
			constructor(e, t, i, s) {
				this.name = e, this.category = t, this.vertex = i, this.face = s
			}
		},
		rS = class e extends aS {
			mapBAOAtoDATA(e, t) {
				const i = t.IDATA.edgematch[e][2];
				for (let s = 0; s < t.isoVecsBAOA.length; s++) {
					const n = [];
					for (let a = 0; a < 3; a++) 1 === t.vertexTypes[s][a] ? n.push(e + "|" + t.isoVecsBAOA[s][a].x + "|" + t.isoVecsBAOA[s][a].y) : n.push(i + "|" + t.isoVecsBAOA[s][a].x + "|" + t.isoVecsBAOA[s][a].y);
					this.face.push([t.vecToidx[n[0]], t.vecToidx[n[1]], t.vecToidx[n[2]]])
				}
			}
			mapABOBtoDATA(e, t) {
				const i = t.IDATA.edgematch[e][0];
				for (let s = 0; s < t.isoVecsABOB.length; s++) {
					const n = [];
					for (let a = 0; a < 3; a++) 0 === t.vertexTypes[s][a] ? n.push(e + "|" + t.isoVecsABOB[s][a].x + "|" + t.isoVecsABOB[s][a].y) : n.push(i + "|" + t.isoVecsABOB[s][a].x + "|" + t.isoVecsABOB[s][a].y);
					this.face.push([t.vecToidx[n[0]], t.vecToidx[n[1]], t.vecToidx[n[2]]])
				}
			}
			mapOBOAtoDATA(e, t) {
				const i = t.IDATA.edgematch[e][0];
				for (let s = 0; s < t.isoVecsOBOA.length; s++) {
					const n = [];
					for (let a = 0; a < 3; a++) 1 === t.vertexTypes[s][a] ? n.push(e + "|" + t.isoVecsOBOA[s][a].x + "|" + t.isoVecsOBOA[s][a].y) : n.push(i + "|" + t.isoVecsOBOA[s][a].x + "|" + t.isoVecsOBOA[s][a].y);
					this.face.push([t.vecToidx[n[0]], t.vecToidx[n[1]], t.vecToidx[n[2]]])
				}
			}
			toGoldbergPolyhedronData() {
				const e = new aS("GeoDual", "Goldberg", [], []);
				e.name = "GD dual";
				const t = this.vertex.length,
					i = new Array(t);
				for (let e = 0; e < t; e++) i[e] = [];
				for (let e = 0; e < this.face.length; e++)
					for (let t = 0; t < 3; t++) i[this.face[e][t]].push(e);
				let s = 0,
					n = 0,
					a = 0,
					r = [],
					o = [];
				this.adjacentFaces = [];
				for (let t = 0; t < i.length; t++) e.face[t] = this.setOrder(t, i[t].concat([])), i[t].forEach((t => {
					s = 0, n = 0, a = 0, r = this.face[t];
					for (let e = 0; e < 3; e++) o = this.vertex[r[e]], s += o[0], n += o[1], a += o[2];
					e.vertex[t] = [s / 3, n / 3, a / 3]
				}));
				return e
			}
			orderData(e) {
				const t = [];
				for (let e = 0; e < 13; e++) t[e] = [];
				const i = e.closestTo;
				for (let e = 0; e < i.length; e++) i[e][0] > -1 ? i[e][1] > 0 && t[i[e][0]].push([e, i[e][1]]) : t[12].push([e, i[e][0]]);
				const s = [];
				for (let e = 0; e < 12; e++) s[e] = e;
				let n = 12;
				for (let e = 0; e < 12; e++) {
					t[e].sort(((e, t) => e[1] - t[1]));
					for (let i = 0; i < t[e].length; i++) s[t[e][i][0]] = n++
				}
				for (let e = 0; e < t[12].length; e++) s[t[12][e][0]] = n++;
				for (let e = 0; e < this.vertex.length; e++) this.vertex[e].push(s[e]);
				this.vertex.sort(((e, t) => e[3] - t[3]));
				for (let e = 0; e < this.vertex.length; e++) this.vertex[e].pop();
				for (let e = 0; e < this.face.length; e++)
					for (let t = 0; t < this.face[e].length; t++) this.face[e][t] = s[this.face[e][t]];
				this.sharedNodes = t[12].length, this.poleNodes = this.vertex.length - this.sharedNodes
			}
			static BuildGeodesicData(t) {
				const i = new e("Geodesic-m-n", "Geodesic", [
					[0, fc, -1],
					[-fc, 1, 0],
					[-1, 0, -fc],
					[1, 0, -fc],
					[fc, 1, 0],
					[0, fc, 1],
					[-1, 0, fc],
					[-fc, -1, 0],
					[0, -fc, -1],
					[fc, -1, 0],
					[1, 0, fc],
					[0, -fc, 1]
				], []);
				t.setIndices(), t.calcCoeffs(), t.createInnerFacets(), t.edgeVecsABOB(), t.mapABOBtoOBOA(), t.mapABOBtoBAOA();
				for (let e = 0; e < t.IDATA.face.length; e++) t.MapToFace(e, i), i.innerToData(e, t), "B" === t.IDATA.edgematch[e][1] && i.mapABOBtoDATA(e, t), "O" === t.IDATA.edgematch[e][1] && i.mapOBOAtoDATA(e, t), "A" === t.IDATA.edgematch[e][3] && i.mapBAOAtoDATA(e, t);
				i.orderData(t);
				return i.vertex = i.vertex.map((function(e) {
					const t = e[0],
						i = e[1],
						s = e[2],
						n = Math.sqrt(t * t + i * i + s * s);
					return e[0] *= 1 / n, e[1] *= 1 / n, e[2] *= 1 / n, e
				})), i
			}
			setOrder(e, t) {
				const i = [],
					s = [];
				let n = t.pop();
				s.push(n);
				let a = this.face[n].indexOf(e);
				a = (a + 2) % 3;
				let r = this.face[n][a];
				i.push(r);
				let o = 0;
				for (; t.length > 0;) n = t[o], this.face[n].indexOf(r) > -1 ? (a = (this.face[n].indexOf(r) + 1) % 3, r = this.face[n][a], i.push(r), s.push(n), t.splice(o, 1), o = 0) : o++;
				return this.adjacentFaces.push(i), s
			}
			innerToData(e, t) {
				for (let i = 0; i < t.innerFacets.length; i++) this.face.push(t.innerFacets[i].map((i => t.vecToidx[e + i])))
			}
		};
	Vf._GoldbergMeshParser = (e, t) => oS.Parse(e, t);
	var oS = class e extends Vf {
		_changeGoldbergFaceColors(e) {
			for (let t = 0; t < e.length; t++) {
				const i = e[t][0],
					s = e[t][1],
					n = e[t][2];
				for (let e = i; e < s + 1; e++) this.goldbergData.faceColors[e] = n
			}
			const t = [];
			for (let e = 0; e < 12; e++)
				for (let i = 0; i < 5; i++) t.push(this.goldbergData.faceColors[e].r, this.goldbergData.faceColors[e].g, this.goldbergData.faceColors[e].b, this.goldbergData.faceColors[e].a);
			for (let e = 12; e < this.goldbergData.faceColors.length; e++)
				for (let i = 0; i < 6; i++) t.push(this.goldbergData.faceColors[e].r, this.goldbergData.faceColors[e].g, this.goldbergData.faceColors[e].b, this.goldbergData.faceColors[e].a);
			return t
		}
		setGoldbergFaceUVs(e) {
			const t = this._changeGoldbergFaceUVs(e);
			this.setVerticesData(eu.UVKind, t)
		}
		static Parse(t, i) {
			const s = t.goldbergData;
			s.faceColors = s.faceColors.map((e => wc.FromArray(e))), s.faceCenters = s.faceCenters.map((e => Lc.FromArray(e))), s.faceZaxis = s.faceZaxis.map((e => Lc.FromArray(e))), s.faceXaxis = s.faceXaxis.map((e => Lc.FromArray(e))), s.faceYaxis = s.faceYaxis.map((e => Lc.FromArray(e)));
			const n = new e(t.name, i);
			return n.goldbergData = s, n
		}
		constructor() {
			super(...arguments), this.goldbergData = {
				faceColors: [],
				faceCenters: [],
				faceZaxis: [],
				faceXaxis: [],
				faceYaxis: [],
				nbSharedFaces: 0,
				nbUnsharedFaces: 0,
				nbFaces: 0,
				nbFacesAtPole: 0,
				adjacentFaces: []
			}
		}
		relatedGoldbergFace(e, t) {
			return void 0 === t ? (e > this.goldbergData.nbUnsharedFaces - 1 && (Qc.Warn("Maximum number of unshared faces used"), e = this.goldbergData.nbUnsharedFaces - 1), this.goldbergData.nbUnsharedFaces + e) : (e > 11 && (Qc.Warn("Last pole used"), e = 11), t > this.goldbergData.nbFacesAtPole - 1 && (Qc.Warn("Maximum number of faces at a pole used"), t = this.goldbergData.nbFacesAtPole - 1), 12 + e * this.goldbergData.nbFacesAtPole + t)
		}
		updateGoldbergFaceUVs(e) {
			const t = this._changeGoldbergFaceUVs(e);
			this.updateVerticesData(eu.UVKind, t)
		}
		setGoldbergFaceColors(e) {
			const t = this._changeGoldbergFaceColors(e);
			this.setVerticesData(eu.ColorKind, t)
		}
		_changeGoldbergFaceUVs(e) {
			const t = this.getVerticesData(eu.UVKind);
			for (let i = 0; i < e.length; i++) {
				const s = e[i][0],
					n = e[i][1],
					a = e[i][2],
					r = e[i][3],
					o = e[i][4],
					l = [],
					h = [];
				let c, u;
				for (let e = 0; e < 5; e++) c = a.x + r * Math.cos(o + e * Math.PI / 2.5), u = a.y + r * Math.sin(o + e * Math.PI / 2.5), c < 0 && (c = 0), c > 1 && (c = 1), l.push(c, u);
				for (let e = 0; e < 6; e++) c = a.x + r * Math.cos(o + e * Math.PI / 3), u = a.y + r * Math.sin(o + e * Math.PI / 3), c < 0 && (c = 0), c > 1 && (c = 1), h.push(c, u);
				for (let e = s; e < Math.min(12, n + 1); e++)
					for (let i = 0; i < 5; i++) t[10 * e + 2 * i] = l[2 * i], t[10 * e + 2 * i + 1] = l[2 * i + 1];
				for (let e = Math.max(12, s); e < n + 1; e++)
					for (let i = 0; i < 6; i++) t[12 * e - 24 + 2 * i] = h[2 * i], t[12 * e - 23 + 2 * i] = h[2 * i + 1]
			}
			return t
		}
		updateGoldbergFaceColors(e) {
			const t = this._changeGoldbergFaceColors(e);
			this.updateVerticesData(eu.ColorKind, t)
		}
		placeOnGoldbergFaceAt(e, t, i) {
			const s = Lc.RotationFromAxis(this.goldbergData.faceXaxis[t], this.goldbergData.faceYaxis[t], this.goldbergData.faceZaxis[t]);
			e.rotation = s, e.position = this.goldbergData.faceCenters[t].add(this.goldbergData.faceXaxis[t].scale(i.x)).add(this.goldbergData.faceYaxis[t].scale(i.y)).add(this.goldbergData.faceZaxis[t].scale(i.z))
		}
		serialize(e) {
			super.serialize(e), e.type = "GoldbergMesh";
			const t = {};
			if (t.adjacentFaces = this.goldbergData.adjacentFaces, t.nbSharedFaces = this.goldbergData.nbSharedFaces, t.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces, t.nbFaces = this.goldbergData.nbFaces, t.nbFacesAtPole = this.goldbergData.nbFacesAtPole, this.goldbergData.faceColors) {
				t.faceColors = [];
				for (const e of this.goldbergData.faceColors) t.faceColors.push(e.asArray())
			}
			if (this.goldbergData.faceCenters) {
				t.faceCenters = [];
				for (const e of this.goldbergData.faceCenters) t.faceCenters.push(e.asArray())
			}
			if (this.goldbergData.faceZaxis) {
				t.faceZaxis = [];
				for (const e of this.goldbergData.faceZaxis) t.faceZaxis.push(e.asArray())
			}
			if (this.goldbergData.faceYaxis) {
				t.faceYaxis = [];
				for (const e of this.goldbergData.faceYaxis) t.faceYaxis.push(e.asArray())
			}
			if (this.goldbergData.faceXaxis) {
				t.faceXaxis = [];
				for (const e of this.goldbergData.faceXaxis) t.faceXaxis.push(e.asArray())
			}
			e.goldbergData = t
		}
	};
	var lS = class {
		quadraticCurveTo(e, t, i, s) {
			this._currentPath.addQuadraticCurveTo(e, t, i, s, this._resolution)
		}
		lineTo(e, t) {
			this._currentPath.addLineTo(e, t)
		}
		constructor(e) {
			this._paths = [], this._tempPaths = [], this._holes = [], this._resolution = e
		}
		moveTo(e, t) {
			this._currentPath = new Sp(e, t), this._tempPaths.push(this._currentPath)
		}
		get holes() {
			return this._holes
		}
		get paths() {
			return this._paths
		}
		extractHoles() {
			for (const e of this._tempPaths) e.area() > 0 ? this._holes.push(e) : this._paths.push(e);
			if (!this._paths.length && this._holes.length) {
				const e = this._holes;
				this._holes = this._paths, this._paths = e
			}
			this._tempPaths.length = 0
		}
		bezierCurveTo(e, t, i, s, n, a) {
			this._currentPath.addBezierCurveTo(e, t, i, s, n, a, this._resolution)
		}
	};

	function hS(e, t, i, s, n, a) {
		const r = a.glyphs[e] || a.glyphs["?"];
		if (!r) return null;
		const o = new lS(n);
		if (r.o) {
			const e = r.o.split(" ");
			for (let n = 0, a = e.length; n < a;) {
				switch (e[n++]) {
					case "m": {
						const a = parseInt(e[n++]) * t + i,
							r = parseInt(e[n++]) * t + s;
						o.moveTo(a, r);
						break
					}
					case "l": {
						const a = parseInt(e[n++]) * t + i,
							r = parseInt(e[n++]) * t + s;
						o.lineTo(a, r);
						break
					}
					case "q": {
						const a = parseInt(e[n++]) * t + i,
							r = parseInt(e[n++]) * t + s,
							l = parseInt(e[n++]) * t + i,
							h = parseInt(e[n++]) * t + s;
						o.quadraticCurveTo(l, h, a, r);
						break
					}
					case "b": {
						const a = parseInt(e[n++]) * t + i,
							r = parseInt(e[n++]) * t + s,
							l = parseInt(e[n++]) * t + i,
							h = parseInt(e[n++]) * t + s,
							c = parseInt(e[n++]) * t + i,
							u = parseInt(e[n++]) * t + s;
						o.bezierCurveTo(l, h, c, u, a, r);
						break
					}
				}
			}
		}
		return o.extractHoles(), {
			offsetX: r.ha * t,
			shapePath: o
		}
	}
	var cS = {
			dk: hy,
			CreateTiledBox: function(e, t, i = null) {
				const s = new Vf(e, i);
				return t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation, uy(t).applyToMesh(s, t.updatable), s
			},
			Rk: dy,
			gk: ey,
			CreateIcoSphere: Yy,
			Nk: Qv,
			Ak: py,
			CreateTorus: gy,
			CreateTorusKnot: yy,
			CreateLineSystem: Ty,
			_k: wy,
			CreateDashedLines: Ry,
			ExtrudeShape: Fy,
			ExtrudeShapeCustom: Ly,
			ka: Gy,
			CreateTiledPlane: function(e, t, i = null) {
				const s = new Vf(e, i);
				return t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), s._originalBuilderSideOrientation = t.sideOrientation, cy(t).applyToMesh(s, t.updatable), s
			},
			Pk: Uy,
			CreateGround: ay,
			CreateTiledGround: ry,
			CreateGroundFromHeightMap: oy,
			CreatePolygon: Dy,
			ExtrudePolygon: Oy,
			CreateTube: Vy,
			CreatePolyhedron: zy,
			CreateGeodesic: function(e, t, i = null) {
				let s = t.m || 1;
				s !== Math.floor(s) && (s = Math.floor(s), Qc.Warn("m not an integer only floor(m) used"));
				let n = t.n || 0;
				if (n !== Math.floor(n) && (n = Math.floor(n), Qc.Warn("n not an integer only floor(n) used")), n > s) {
					const e = n;
					n = s, s = e, Qc.Warn("n > m therefore m and n swapped")
				}
				const a = new nS;
				return a.build(s, n), zy(e, {
					custom: rS.BuildGeodesicData(a),
					size: t.size,
					sizeX: t.sizeX,
					sizeY: t.sizeY,
					sizeZ: t.sizeZ,
					faceUV: t.faceUV,
					faceColors: t.faceColors,
					flat: t.flat,
					updatable: t.updatable,
					sideOrientation: t.sideOrientation,
					frontUVs: t.frontUVs,
					backUVs: t.backUVs
				}, i)
			},
			CreateGoldberg: function(e, t, i = null) {
				const s = t.size,
					n = t.sizeX || s || 1,
					a = t.sizeY || s || 1,
					r = t.sizeZ || s || 1;
				let o = t.m || 1;
				o !== Math.floor(o) && (o = Math.floor(o), Qc.Warn("m not an integer only floor(m) used"));
				let l = t.n || 0;
				if (l !== Math.floor(l) && (l = Math.floor(l), Qc.Warn("n not an integer only floor(n) used")), l > o) {
					const e = l;
					l = o, o = e, Qc.Warn("n > m therefore m and n swapped")
				}
				const h = new nS;
				h.build(o, l);
				const c = rS.BuildGeodesicData(h),
					u = c.toGoldbergPolyhedronData(),
					m = new oS(e, i);
				t.sideOrientation = Vf._GetDefaultSideOrientation(t.sideOrientation), m._originalBuilderSideOrientation = t.sideOrientation;
				(function(e, t) {
					const i = e.size,
						s = e.sizeX || i || 1,
						n = e.sizeY || i || 1,
						a = e.sizeZ || i || 1,
						r = 0 === e.sideOrientation ? 0 : e.sideOrientation || Mu.DEFAULTSIDE,
						o = [],
						l = [],
						h = [],
						c = [];
					let u = 1 / 0,
						m = -1 / 0,
						d = 1 / 0,
						f = -1 / 0;
					for (let e = 0; e < t.vertex.length; e++) u = Math.min(u, t.vertex[e][0] * s), m = Math.max(m, t.vertex[e][0] * s), d = Math.min(d, t.vertex[e][1] * n), f = Math.max(f, t.vertex[e][1] * n);
					let p = 0;
					for (let e = 0; e < t.face.length; e++) {
						const i = t.face[e],
							r = Lc.FromArray(t.vertex[i[0]]),
							_ = Lc.FromArray(t.vertex[i[2]]),
							g = Lc.FromArray(t.vertex[i[1]]),
							v = _.subtract(r),
							y = g.subtract(r),
							S = Lc.Cross(y, v).normalize();
						for (let e = 0; e < i.length; e++) {
							h.push(S.x, S.y, S.z);
							const r = t.vertex[i[e]];
							o.push(r[0] * s, r[1] * n, r[2] * a);
							const l = (r[1] * n - d) / (f - d);
							c.push((r[0] * s - u) / (m - u), l)
						}
						for (let e = 0; e < i.length - 2; e++) l.push(p, p + e + 2, p + e + 1);
						p += i.length
					}
					Mu._ComputeSides(r, o, l, h, c);
					const _ = new Mu;
					return _.positions = o, _.indices = l, _.normals = h, _.uvs = c, _
				})(t, u).applyToMesh(m, t.updatable), m.goldbergData.nbSharedFaces = c.sharedNodes, m.goldbergData.nbUnsharedFaces = c.poleNodes, m.goldbergData.adjacentFaces = c.adjacentFaces, m.goldbergData.nbFaces = m.goldbergData.nbSharedFaces + m.goldbergData.nbUnsharedFaces, m.goldbergData.nbFacesAtPole = (m.goldbergData.nbUnsharedFaces - 12) / 12;
				for (let e = 0; e < c.vertex.length; e++) m.goldbergData.faceCenters.push(Lc.FromArray(c.vertex[e])), m.goldbergData.faceCenters[e].x *= n, m.goldbergData.faceCenters[e].y *= a, m.goldbergData.faceCenters[e].z *= r, m.goldbergData.faceColors.push(new wc(1, 1, 1, 1));
				for (let e = 0; e < u.face.length; e++) {
					const t = u.face[e],
						i = Lc.FromArray(u.vertex[t[0]]),
						s = Lc.FromArray(u.vertex[t[2]]),
						n = Lc.FromArray(u.vertex[t[1]]),
						a = s.subtract(i),
						r = n.subtract(i),
						o = Lc.Cross(r, a).normalize(),
						l = Lc.Cross(r, o).normalize();
					m.goldbergData.faceXaxis.push(r.normalize()), m.goldbergData.faceYaxis.push(o), m.goldbergData.faceZaxis.push(l)
				}
				return m
			},
			CreateDecal: eS,
			CreateCapsule: iS,
			CreateText: function(e, t, i, s = {
				size: 50,
				resolution: 8,
				depth: 1
			}, n = null, a = earcut) {
				const r = function(e, t, i, s) {
						const n = Array.from(e),
							a = t / s.resolution,
							r = (s.boundingBox.yMax - s.boundingBox.yMin + s.underlineThickness) * a,
							o = [];
						let l = 0,
							h = 0;
						for (let e = 0; e < n.length; e++) {
							const t = n[e];
							if ("\n" === t) l = 0, h -= r;
							else {
								const e = hS(t, a, l, h, i, s);
								e && (l += e.offsetX, o.push(e.shapePath))
							}
						}
						return o
					}(t, s.size || 50, s.resolution || 8, i),
					o = [];
				let l = 0;
				for (const t of r) {
					if (!t.paths.length) continue;
					const i = t.holes.slice();
					for (const r of t.paths) {
						const t = [],
							h = [],
							c = r.getPoints();
						for (const e of c) h.push(new Lc(e.x, 0, e.y));
						const u = i.slice();
						for (const e of u) {
							const s = e.getPoints();
							let n = !1;
							for (const e of s)
								if (r.isPointInside(e)) {
									n = !0;
									break
								} if (!n) continue;
							const a = [];
							for (const e of s) a.push(new Lc(e.x, 0, e.y));
							t.push(a), i.splice(i.indexOf(e), 1)
						}
						if (!t.length && i.length)
							for (const e of i) {
								const i = e.getPoints(),
									s = [];
								for (const e of i) s.push(new Lc(e.x, 0, e.y));
								t.push(s)
							}
						const m = Oy(e, {
							shape: h,
							holes: t.length ? t : void 0,
							depth: s.depth || 1,
							faceUV: s.faceUV || s.perLetterFaceUV?.(l),
							faceColors: s.faceColors || s.perLetterFaceColors?.(l),
							sideOrientation: Vf._GetDefaultSideOrientation(s.sideOrientation || Vf.DOUBLESIDE)
						}, n, a);
						o.push(m), l++
					}
				}
				const h = Vf.MergeMeshes(o, !0, !0);
				if (h) {
					const t = h.getBoundingInfo().boundingBox;
					h.position.x += -(t.minimumWorld.x + t.maximumWorld.x) / 2, h.position.y += -(t.minimumWorld.y + t.maximumWorld.y) / 2, h.position.z += -(t.minimumWorld.z + t.maximumWorld.z) / 2 + t.extendSize.z, h.name = e;
					const i = new Jc("pivot", n);
					i.rotation.x = -Math.PI / 2, h.parent = i, h.bakeCurrentTransformIntoVertices(), h.parent = null, i.dispose()
				}
				return h
			}
		},
		uS = class e {
			_clone() {
				return new e(this.frame, this.action, this.onlyOnce)
			}
			constructor(e, t, i) {
				this.frame = e, this.action = t, this.onlyOnce = i, this.isDone = !1
			}
		},
		mS = class e extends jc {
			getScale() {
				return this._decompose(), this._localScaling
			}
			getAbsolutePosition(e = null) {
				const t = Lc.Zero();
				return this.getPositionToRef(1, e, t), t
			}
			set rotationQuaternion(e) {
				this.setRotationQuaternion(e)
			}
			_updateAbsoluteBindMatrices(e, t = !0) {
				if (e || (e = this._bindMatrix), this.parent ? e.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix) : this._absoluteBindMatrix.copyFrom(e), this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix), t)
					for (let e = 0; e < this.children.length; e++) this.children[e]._updateAbsoluteBindMatrices();
				this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1
			}
			getRestMatrix() {
				return this._restMatrix
			}
			updateMatrix(e, t = !0, i = !0) {
				this._bindMatrix.copyFrom(e), t && this._updateAbsoluteBindMatrices(), i ? this._matrix = e : this.markAsDirty()
			}
			getBindPose() {
				return this.getBindMatrix()
			}
			setCurrentPoseAsRest() {
				this.setRestMatrix(this.getLocalMatrix())
			}
			getAbsolutePositionToRef(e, t) {
				this.getPositionToRef(1, e, t)
			}
			getPositionToRef(t = 0, i, s) {
				if (0 == t) {
					const e = this.getLocalMatrix();
					s.x = e.m[12], s.y = e.m[13], s.z = e.m[14]
				} else {
					let t = null;
					i && (t = i.getWorldMatrix()), this._skeleton.computeAbsoluteMatrices();
					let n = e._TmpMats[0];
					i && t ? (n.copyFrom(this.getAbsoluteMatrix()), n.multiplyToRef(t, n)) : n = this.getAbsoluteMatrix(), s.x = n.m[12], s.y = n.m[13], s.z = n.m[14]
				}
			}
			setYawPitchRoll(t, i, s, n = 0, a) {
				if (0 === n) {
					const r = e._TmpQuat;
					return Gc.RotationYawPitchRollToRef(t, i, s, r), void this.setRotationQuaternion(r, n, a)
				}
				const r = e._TmpMats[0];
				if (!this._getAbsoluteInverseMatrixUnscaledToRef(r, a)) return;
				const o = e._TmpMats[1];
				Hc.RotationYawPitchRollToRef(t, i, s, o), r.multiplyToRef(o, o), this._rotateWithMatrix(o, n, a)
			}
			setParent(e, t = !0) {
				if (this.parent !== e) {
					if (this.parent) {
						const e = this.parent.children.indexOf(this); - 1 !== e && this.parent.children.splice(e, 1)
					}
					this._parentNode = e, this.parent && this.parent.children.push(this), t && this._updateAbsoluteBindMatrices(), this.markAsDirty()
				}
			}
			_markAsDirtyAndCompose() {
				this.markAsDirty(), this._needToCompose = !0
			}
			get position() {
				return this._decompose(), this._localPosition
			}
			_updatePosition(t, i = 0, s, n = !0) {
				const a = this.getLocalMatrix();
				if (0 == i) n ? (a.addAtIndex(12, t.x), a.addAtIndex(13, t.y), a.addAtIndex(14, t.z)) : a.setTranslationFromFloats(t.x, t.y, t.z);
				else {
					let i = null;
					s && (i = s.getWorldMatrix()), this._skeleton.computeAbsoluteMatrices();
					const r = e._TmpMats[0],
						o = e._TmpVecs[0];
					this.parent ? s && i ? (r.copyFrom(this.parent.getAbsoluteMatrix()), r.multiplyToRef(i, r)) : r.copyFrom(this.parent.getAbsoluteMatrix()) : Hc.IdentityToRef(r), n && r.setTranslationFromFloats(0, 0, 0), r.invert(), Lc.TransformCoordinatesToRef(t, r, o), n ? (a.addAtIndex(12, o.x), a.addAtIndex(13, o.y), a.addAtIndex(14, o.z)) : a.setTranslationFromFloats(o.x, o.y, o.z)
				}
				this._markAsDirtyAndDecompose()
			}
			getInvertedAbsoluteTransform() {
				return this.getAbsoluteInverseBindMatrix()
			}
			getDirection(e, t = null) {
				const i = Lc.Zero();
				return this.getDirectionToRef(e, t, i), i
			}
			getScaleToRef(e) {
				this._decompose(), e.copyFrom(this._localScaling)
			}
			scale(t, i, s, n = !1) {
				const a = this.getLocalMatrix(),
					r = e._TmpMats[0];
				Hc.ScalingToRef(t, i, s, r), r.multiplyToRef(a, a), r.invert();
				for (const e of this.children) {
					const n = e.getLocalMatrix();
					n.multiplyToRef(r, n), n.multiplyAtIndex(12, t), n.multiplyAtIndex(13, i), n.multiplyAtIndex(14, s), e._markAsDirtyAndDecompose()
				}
				if (this._markAsDirtyAndDecompose(), n)
					for (const e of this.children) e.scale(t, i, s, n)
			}
			get _matrix() {
				return this._compose(), this._localMatrix
			}
			setScale(e) {
				this._decompose(), this._localScaling.copyFrom(e), this._markAsDirtyAndCompose()
			}
			getFinalMatrix() {
				return this._finalMatrix
			}
			set parent(e) {
				this.setParent(e)
			}
			get rotationQuaternion() {
				return this._decompose(), this._localRotation
			}
			setRestPose(e) {
				this.setRestMatrix(e)
			}
			setAbsolutePosition(e, t) {
				this.setPosition(e, 1, t)
			}
			getRestPose() {
				return this.getRestMatrix()
			}
			getClassName() {
				return "Bone"
			}
			getDirectionToRef(t, i = null, s) {
				let n = null;
				i && (n = i.getWorldMatrix()), this._skeleton.computeAbsoluteMatrices();
				const a = e._TmpMats[0];
				a.copyFrom(this.getAbsoluteMatrix()), i && n && a.multiplyToRef(n, a), Lc.TransformNormalToRef(t, a, s), s.normalize()
			}
			_decompose() {
				this._needToDecompose && (this._needToDecompose = !1, this._localScaling || (this._localScaling = Lc.Zero(), this._localRotation = Gc.Zero(), this._localPosition = Lc.Zero()), this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition))
			}
			markAsDirty() {
				return this._currentRenderId++, this._childUpdateId++, this._skeleton._markAsDirty(), this
			}
			getRotationMatrixToRef(t = 0, i, s) {
				if (0 == t) this.getLocalMatrix().getRotationMatrixToRef(s);
				else {
					const t = e._TmpMats[0],
						n = this.getAbsoluteMatrix();
					i ? n.multiplyToRef(i.getWorldMatrix(), t) : t.copyFrom(n), t.multiplyAtIndex(0, this._scalingDeterminant), t.multiplyAtIndex(1, this._scalingDeterminant), t.multiplyAtIndex(2, this._scalingDeterminant), t.getRotationMatrixToRef(s)
				}
			}
			setRestMatrix(e) {
				this._restMatrix.copyFrom(e)
			}
			computeAbsoluteMatrices() {
				if (this._compose(), this.parent) this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);
				else {
					this._absoluteMatrix.copyFrom(this._localMatrix);
					const e = this._skeleton.getPoseMatrix();
					e && this._absoluteMatrix.multiplyToRef(e, this._absoluteMatrix)
				}
				const e = this.children,
					t = e.length;
				for (let i = 0; i < t; i++) e[i].computeAbsoluteMatrices()
			}
			get rotation() {
				return this.getRotation()
			}
			getBaseMatrix() {
				return this.getBindMatrix()
			}
			get parent() {
				return this._parentNode
			}
			getParent() {
				return this.parent
			}
			setBindMatrix(e) {
				this.updateMatrix(e)
			}
			setPosition(e, t = 0, i) {
				this._updatePosition(e, t, i, !1)
			}
			_getAbsoluteInverseMatrixUnscaledToRef(t, i) {
				const s = e._TmpMats[2];
				return t.copyFrom(this.getAbsoluteMatrix()), i ? (t.multiplyToRef(i.getWorldMatrix(), t), Hc.ScalingToRef(i.scaling.x, i.scaling.y, i.scaling.z, s)) : Hc.IdentityToRef(s), t.invert(), !isNaN(t.m[0]) && (s.multiplyAtIndex(0, this._scalingDeterminant), t.multiplyToRef(s, t), !0)
			}
			getPosition(e = 0, t = null) {
				const i = Lc.Zero();
				return this.getPositionToRef(e, t, i), i
			}
			getLocalMatrix() {
				return this._compose(), this._localMatrix
			}
			getWorldMatrix() {
				return this.getFinalMatrix()
			}
			setRotation(e, t = 0, i) {
				this.setYawPitchRoll(e.y, e.x, e.z, t, i)
			}
			getSkeleton() {
				return this._skeleton
			}
			set rotation(e) {
				this.setRotation(e)
			}
			returnToRest() {
				if (this._linkedTransformNode) {
					const e = Vc.Vector3[0],
						t = Vc.uk[0],
						i = Vc.Vector3[1];
					this.getRestMatrix().decompose(e, t, i), this._linkedTransformNode.position.copyFrom(i), this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Gc.Identity(), this._linkedTransformNode.rotationQuaternion.copyFrom(t), this._linkedTransformNode.scaling.copyFrom(e)
				} else this._matrix = this._restMatrix
			}
			computeAbsoluteTransforms() {
				this.computeAbsoluteMatrices()
			}
			getRotationQuaternion(e = 0, t = null) {
				const i = Gc.Identity();
				return this.getRotationQuaternionToRef(e, t, i), i
			}
			getAbsoluteMatrix() {
				return this._absoluteMatrix
			}
			rotate(t, i, s = 0, n) {
				const a = e._TmpMats[0];
				a.setTranslationFromFloats(0, 0, 0), Hc.RotationAxisToRef(t, i, a), this._rotateWithMatrix(a, s, n)
			}
			getAbsoluteTransform() {
				return this._absoluteMatrix
			}
			setBindPose(e) {
				this.setBindMatrix(e)
			}
			set scaling(e) {
				this.setScale(e)
			}
			setRotationQuaternion(t, i = 0, s) {
				if (0 === i) return this._decompose(), this._localRotation.copyFrom(t), void this._markAsDirtyAndCompose();
				const n = e._TmpMats[0];
				if (!this._getAbsoluteInverseMatrixUnscaledToRef(n, s)) return;
				const a = e._TmpMats[1];
				Hc.FromQuaternionToRef(t, a), n.multiplyToRef(a, a), this._rotateWithMatrix(a, i, s)
			}
			set position(e) {
				this._decompose(), this._localPosition.copyFrom(e), this._markAsDirtyAndCompose()
			}
			constructor(e, t, i = null, s = null, n = null, a = null, r = null) {
				super(e, t.getScene(), !1), this.name = e, this.children = [], this.animations = [], this._index = null, this._scalingDeterminant = 1, this._needToDecompose = !0, this._needToCompose = !1, this._linkedTransformNode = null, this._waitingTransformNodeId = null, this._skeleton = t, this._localMatrix = s?.clone() ?? Hc.Identity(), this._restMatrix = n ?? this._localMatrix.clone(), this._bindMatrix = a ?? this._localMatrix.clone(), this._index = r, this._absoluteMatrix = new Hc, this._absoluteBindMatrix = new Hc, this._absoluteInverseBindMatrix = new Hc, this._finalMatrix = new Hc, t.bones.push(this), this.setParent(i, !1), this._updateAbsoluteBindMatrices()
			}
			getLocalPositionFromAbsoluteToRef(t, i = null, s) {
				let n = null;
				i && (n = i.getWorldMatrix()), this._skeleton.computeAbsoluteMatrices();
				const a = e._TmpMats[0];
				a.copyFrom(this.getAbsoluteMatrix()), i && n && a.multiplyToRef(n, a), a.invert(), Lc.TransformCoordinatesToRef(t, a, s)
			}
			setAxisAngle(t, i, s = 0, n) {
				if (0 === s) {
					const a = e._TmpQuat;
					return Gc.RotationAxisToRef(t, i, a), void this.setRotationQuaternion(a, s, n)
				}
				const a = e._TmpMats[0];
				if (!this._getAbsoluteInverseMatrixUnscaledToRef(a, n)) return;
				const r = e._TmpMats[1];
				Hc.RotationAxisToRef(t, i, r), a.multiplyToRef(r, r), this._rotateWithMatrix(r, s, n)
			}
			getTransformNode() {
				return this._linkedTransformNode
			}
			translate(e, t = 0, i) {
				this._updatePosition(e, t, i, !0)
			}
			getChildren() {
				return this.children
			}
			getRotationMatrix(e = 0, t) {
				const i = Hc.Identity();
				return this.getRotationMatrixToRef(e, t, i), i
			}
			get scaling() {
				return this.getScale()
			}
			getAbsolutePositionFromLocal(e, t = null) {
				const i = Lc.Zero();
				return this.getAbsolutePositionFromLocalToRef(e, t, i), i
			}
			get animationPropertiesOverride() {
				return this._skeleton.animationPropertiesOverride
			}
			getBindMatrix() {
				return this._bindMatrix
			}
			set _matrix(e) {
				(e.updateFlag !== this._localMatrix.updateFlag || this._needToCompose) && (this._needToCompose = !1, this._localMatrix.copyFrom(e), this._markAsDirtyAndDecompose())
			}
			getRotation(e = 0, t = null) {
				const i = Lc.Zero();
				return this.getRotationToRef(e, t, i), i
			}
			getRotationToRef(t = 0, i = null, s) {
				const n = e._TmpQuat;
				this.getRotationQuaternionToRef(t, i, n), n.toEulerAnglesToRef(s)
			}
			_compose() {
				this._needToCompose && (this._localScaling ? (this._needToCompose = !1, Hc.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix)) : this._needToCompose = !1)
			}
			getAbsoluteInverseBindMatrix() {
				return this._absoluteInverseBindMatrix
			}
			linkTransformNode(e) {
				this._linkedTransformNode && this._skeleton._numBonesWithLinkedTransformNode--, this._linkedTransformNode = e, this._linkedTransformNode && this._skeleton._numBonesWithLinkedTransformNode++
			}
			getIndex() {
				return null === this._index ? this.getSkeleton().bones.indexOf(this) : this._index
			}
			getRotationQuaternionToRef(t = 0, i = null, s) {
				if (0 == t) this._decompose(), s.copyFrom(this._localRotation);
				else {
					const t = e._TmpMats[0],
						n = this.getAbsoluteMatrix();
					i ? n.multiplyToRef(i.getWorldMatrix(), t) : t.copyFrom(n), t.multiplyAtIndex(0, this._scalingDeterminant), t.multiplyAtIndex(1, this._scalingDeterminant), t.multiplyAtIndex(2, this._scalingDeterminant), t.decompose(void 0, s, void 0)
				}
			}
			_markAsDirtyAndDecompose() {
				this.markAsDirty(), this._needToDecompose = !0
			}
			_rotateWithMatrix(t, i = 0, s) {
				const n = this.getLocalMatrix(),
					a = n.m[12],
					r = n.m[13],
					o = n.m[14],
					l = this.getParent(),
					h = e._TmpMats[3],
					c = e._TmpMats[4];
				l && 1 == i ? (s ? (h.copyFrom(s.getWorldMatrix()), l.getAbsoluteMatrix().multiplyToRef(h, h)) : h.copyFrom(l.getAbsoluteMatrix()), c.copyFrom(h), c.invert(), n.multiplyToRef(h, n), n.multiplyToRef(t, n), n.multiplyToRef(c, n)) : 1 == i && s ? (h.copyFrom(s.getWorldMatrix()), c.copyFrom(h), c.invert(), n.multiplyToRef(h, n), n.multiplyToRef(t, n), n.multiplyToRef(c, n)) : n.multiplyToRef(t, n), n.setTranslationFromFloats(a, r, o), this.computeAbsoluteMatrices(), this._markAsDirtyAndDecompose()
			}
			setRotationMatrix(t, i = 0, s) {
				if (0 === i) {
					const n = e._TmpQuat;
					return Gc.FromRotationMatrixToRef(t, n), void this.setRotationQuaternion(n, i, s)
				}
				const n = e._TmpMats[0];
				if (!this._getAbsoluteInverseMatrixUnscaledToRef(n, s)) return;
				const a = e._TmpMats[1];
				a.copyFrom(t), n.multiplyToRef(t, a), this._rotateWithMatrix(a, i, s)
			}
			getLocalPositionFromAbsolute(e, t = null) {
				const i = Lc.Zero();
				return this.getLocalPositionFromAbsoluteToRef(e, t, i), i
			}
			getAbsolutePositionFromLocalToRef(t, i = null, s) {
				let n = null;
				i && (n = i.getWorldMatrix()), this._skeleton.computeAbsoluteMatrices();
				const a = e._TmpMats[0];
				a.copyFrom(this.getAbsoluteMatrix()), i && n && a.multiplyToRef(n, a), Lc.TransformCoordinatesToRef(t, a, s)
			}
		};

	function dS(e, t, i, s) {
		let n, a = 1;
		1 === s ? n = new Float32Array(t * i * 4) : 2 === s ? (n = new Uint16Array(t * i * 4), a = 15360) : n = 7 === s ? new Uint32Array(t * i * 4) : new Uint8Array(t * i * 4);
		for (let s = 0; s < t; s++)
			for (let r = 0; r < i; r++) {
				const i = 3 * (r * t + s),
					o = 4 * (r * t + s);
				n[o + 0] = e[i + 0], n[o + 1] = e[i + 1], n[o + 2] = e[i + 2], n[o + 3] = a
			}
		return n
	}

	function fS(e) {
		return function(t, i, s, n, a, r, o, l, h = null, c = 0) {
			const u = e ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY,
				m = new Pm(this, e ? 10 : 11);
			m.baseWidth = i, m.baseHeight = s, m.baseDepth = n, m.width = i, m.height = s, m.depth = n, m.format = a, m.type = c, m.generateMipMaps = r, m.samplingMode = l, e ? m.is3D = !0 : m.is2DArray = !0, this._doNotHandleContextLost || (m._bufferView = t), e ? this.updateRawTexture3D(m, t, a, o, h, c) : this.updateRawTexture2DArray(m, t, a, o, h, c), this._bindTextureDirectly(u, m, !0);
			const d = this._getSamplingParameters(l, r);
			return this._gl.texParameteri(u, this._gl.TEXTURE_MAG_FILTER, d.mag), this._gl.texParameteri(u, this._gl.TEXTURE_MIN_FILTER, d.min), r && this._gl.generateMipmap(u), this._bindTextureDirectly(u, null), this._internalTexturesCache.push(m), m
		}
	}

	function pS(e) {
		return function(t, i, s, n, a = null, r = 0) {
			const o = e ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY,
				l = this._getWebGLTextureType(r),
				h = this._getInternalFormat(s),
				c = this._getRGBABufferInternalSizedFormat(r, s);
			this._bindTextureDirectly(o, t, !0), this._unpackFlipY(void 0 === n || !!n), this._doNotHandleContextLost || (t._bufferView = i, t.format = s, t.invertY = n, t._compression = a), t.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1), a && i ? this._gl.compressedTexImage3D(o, 0, this.getCaps().s3tc[a], t.width, t.height, t.depth, 0, i) : this._gl.texImage3D(o, 0, c, t.width, t.height, t.depth, 0, h, l, i), t.generateMipMaps && this._gl.generateMipmap(o), this._bindTextureDirectly(o, null), t.isReady = !0
		}
	}
	mS._TmpVecs = ac(2, Lc.Zero), mS._TmpQuat = Gc.Identity(), mS._TmpMats = ac(5, Hc.Identity), Nd.prototype.updateRawTexture = function(e, t, i, s, n = null, a = 0, r = !1) {
		if (!e) return;
		const o = this._getRGBABufferInternalSizedFormat(a, i, r),
			l = this._getInternalFormat(i),
			h = this._getWebGLTextureType(a);
		this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._unpackFlipY(void 0 === s || !!s), this._doNotHandleContextLost || (e._bufferView = t, e.format = i, e.type = a, e.invertY = s, e._compression = n), e.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1), n && t ? this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[n], e.width, e.height, 0, t) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, o, e.width, e.height, 0, l, h, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), e.isReady = !0
	}, Nd.prototype.createRawTexture = function(e, t, i, s, n, a, r, o = null, l = 0, h = 0, c = !1) {
		const u = new Pm(this, 3);
		u.baseWidth = t, u.baseHeight = i, u.width = t, u.height = i, u.format = s, u.generateMipMaps = n, u.samplingMode = r, u.invertY = a, u._compression = o, u.type = l, u._useSRGBBuffer = this._getUseSRGBBuffer(c, !n), this._doNotHandleContextLost || (u._bufferView = e), this.updateRawTexture(u, e, s, a, o, l, u._useSRGBBuffer), this._bindTextureDirectly(this._gl.TEXTURE_2D, u, !0);
		const m = this._getSamplingParameters(r, n);
		return this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, m.mag), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, m.min), n && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._internalTexturesCache.push(u), u
	}, Nd.prototype.createRawCubeTexture = function(e, t, i, s, n, a, r, o = null) {
		const l = this._gl,
			h = new Pm(this, 8);
		h.isCube = !0, h.format = i, h.type = s, this._doNotHandleContextLost || (h._bufferViewArray = e);
		const c = this._getWebGLTextureType(s);
		let u = this._getInternalFormat(i);
		u === l.RGB && (u = l.RGBA), c !== l.FLOAT || this._caps.textureFloatLinearFiltering ? c !== this._gl.HALF_FLOAT_OES || this._caps.textureHalfFloatLinearFiltering ? c !== l.FLOAT || this._caps.textureFloatRender ? c !== l.HALF_FLOAT || this._caps.colorBufferFloat || (n = !1, Qc.Warn("Render to half float textures is not supported. Mipmap generation forced to false.")) : (n = !1, Qc.Warn("Render to float textures is not supported. Mipmap generation forced to false.")) : (n = !1, r = 1, Qc.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")) : (n = !1, r = 1, Qc.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively."));
		const m = t,
			d = m;
		h.width = m, h.height = d, h.invertY = a, h._compression = o;
		if (!this.needPOTTextures || od(h.width) && od(h.height) || (n = !1), e) this.updateRawCubeTexture(h, e, i, s, a, o);
		else {
			const e = this._getRGBABufferInternalSizedFormat(s),
				t = 0;
			this._bindTextureDirectly(l.TEXTURE_CUBE_MAP, h, !0);
			for (let i = 0; i < 6; i++) o ? l.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + i, t, this.getCaps().s3tc[o], h.width, h.height, 0, void 0) : l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + i, t, e, h.width, h.height, 0, u, c, null);
			this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)
		}
		this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, h, !0), e && n && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
		const f = this._getSamplingParameters(r, n);
		return l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_MAG_FILTER, f.mag), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_MIN_FILTER, f.min), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), this._bindTextureDirectly(l.TEXTURE_CUBE_MAP, null), h.generateMipMaps = n, h.samplingMode = r, h.isReady = !0, h
	}, Nd.prototype.updateRawCubeTexture = function(e, t, i, s, n, a = null, r = 0) {
		e._bufferViewArray = t, e.format = i, e.type = s, e.invertY = n, e._compression = a;
		const o = this._gl,
			l = this._getWebGLTextureType(s);
		let h = this._getInternalFormat(i);
		const c = this._getRGBABufferInternalSizedFormat(s);
		let u = !1;
		h === o.RGB && (h = o.RGBA, u = !0), this._bindTextureDirectly(o.TEXTURE_CUBE_MAP, e, !0), this._unpackFlipY(void 0 === n || !!n), e.width % 4 != 0 && o.pixelStorei(o.UNPACK_ALIGNMENT, 1);
		for (let i = 0; i < 6; i++) {
			let n = t[i];
			a ? o.compressedTexImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + i, r, this.getCaps().s3tc[a], e.width, e.height, 0, n) : (u && (n = dS(n, e.width, e.height, s)), o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + i, r, c, e.width, e.height, 0, h, l, n))
		}(!this.needPOTTextures || od(e.width) && od(e.height)) && e.generateMipMaps && 0 === r && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), e.isReady = !0
	}, Nd.prototype.createRawCubeTextureFromUrl = function(e, t, i, s, n, a, r, o, l = null, h = null, c = 3, u = !1) {
		const m = this._gl,
			d = this.createRawCubeTexture(null, i, s, n, !a, u, c, null);
		t?.addPendingData(d), d.url = e, d.isReady = !1, this._internalTexturesCache.push(d);
		const f = e => {
			const i = d.width,
				a = r(e);
			if (a) {
				if (o) {
					const e = this._getWebGLTextureType(n);
					let t = this._getInternalFormat(s);
					const r = this._getRGBABufferInternalSizedFormat(n);
					let l = !1;
					t === m.RGB && (t = m.RGBA, l = !0), this._bindTextureDirectly(m.TEXTURE_CUBE_MAP, d, !0), this._unpackFlipY(!1);
					const h = o(a);
					for (let s = 0; s < h.length; s++) {
						const a = i >> s;
						for (let i = 0; i < 6; i++) {
							let o = h[s][i];
							l && (o = dS(o, a, a, n)), m.texImage2D(i, s, r, a, a, 0, t, e, o)
						}
					}
					this._bindTextureDirectly(m.TEXTURE_CUBE_MAP, null)
				} else this.updateRawCubeTexture(d, a, s, n, u);
				d.isReady = !0, t?.removePendingData(d), d.onLoadedObservable.notifyObservers(d), d.onLoadedObservable.clear(), l && l()
			}
		};
		return this._loadFile(e, (e => {
			f(e)
		}), void 0, t?.offlineProvider, !0, ((e, i) => {
			t?.removePendingData(d), h && e && h(e.status + " " + e.statusText, i)
		})), d
	}, Nd.prototype.createRawTexture2DArray = fS(!1), Nd.prototype.createRawTexture3D = fS(!0), Nd.prototype.updateRawTexture2DArray = pS(!1), Nd.prototype.updateRawTexture3D = pS(!0);
	var _S = class e extends Np {
			static CreateLuminanceAlphaTexture(t, i, s, n, a = !0, r = !1, o = 3) {
				return new e(t, i, s, 2, n, a, r, o)
			}
			static CreateRGBTexture(t, i, s, n, a = !0, r = !1, o = 3, l = 0, h = 0, c = !1) {
				return new e(t, i, s, 4, n, a, r, o, l, h, c)
			}
			clone() {
				if (!this._texture) return super.clone();
				const t = new e(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);
				return t._texture = this._texture, this._texture.incrementReferences(), t
			}
			static CreateRGBATexture(t, i, s, n, a = !0, r = !1, o = 3, l = 0, h = 0, c = !1) {
				return new e(t, i, s, 5, n, a, r, o, l, h, c)
			}
			static CreateLuminanceTexture(t, i, s, n, a = !0, r = !1, o = 3) {
				return new e(t, i, s, 1, n, a, r, o)
			}
			constructor(e, t, i, s, n, a = !0, r = !1, o = 3, l = 0, h, c) {
				super(null, n, !a, r, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, h), this.format = s, this._engine && (this._engine._caps.textureFloatLinearFiltering || 1 !== l || (o = 1), this._engine._caps.textureHalfFloatLinearFiltering || 2 !== l || (o = 1), this._texture = this._engine.createRawTexture(e, t, i, s, a, r, o, null, l, h ?? 0, c ?? !1), this.wrapU = Np.CLAMP_ADDRESSMODE, this.wrapV = Np.CLAMP_ADDRESSMODE)
			}
			static CreateAlphaTexture(t, i, s, n, a = !0, r = !1, o = 3) {
				return new e(t, i, s, 0, n, a, r, o)
			}
			update(e) {
				this._getEngine().updateRawTexture(this._texture, e, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer)
			}
			static CreateRStorageTexture(t, i, s, n, a = !0, r = !1, o = Np.TRILINEAR_SAMPLINGMODE, l = 1) {
				return new e(t, i, s, 6, n, a, r, o, l, 1)
			}
			static CreateRGBAStorageTexture(t, i, s, n, a = !0, r = !1, o = 3, l = 0, h = !1) {
				return new e(t, i, s, 5, n, a, r, o, l, 1, h)
			}
			static CreateRTexture(t, i, s, n, a = !0, r = !1, o = Np.TRILINEAR_SAMPLINGMODE, l = 1) {
				return new e(t, i, s, 6, n, a, r, o, l)
			}
		},
		gS = class e {
			static MakeAnimationAdditive(e, t = 0, i) {
				const s = e.getAnimationRange(i);
				if (!s) return null;
				const n = e._scene.getAllAnimatablesByTarget(e);
				let a = null;
				for (let e = 0; e < n.length; e++) {
					const t = n[e];
					if (t.fromFrame === s?.from && t.toFrame === s?.to) {
						a = t;
						break
					}
				}
				const r = e.getAnimatables();
				for (let e = 0; e < r.length; e++) {
					const s = r[e].animations;
					if (s)
						for (let e = 0; e < s.length; e++) Wg.MakeAnimationAdditive(s[e], t, i)
				}
				return a && (a.isAdditive = !0), e
			}
			setCurrentPoseAsRest() {
				this.bones.forEach((e => {
					e.setCurrentPoseAsRest()
				}))
			}
			getClassName() {
				return "Skeleton"
			}
			computeAbsoluteTransforms(e = !1) {
				this.computeAbsoluteMatrices(e)
			}
			_computeTransformMatrices(e, t) {
				this.onBeforeComputeObservable.notifyObservers(this);
				for (let i = 0; i < this.bones.length; i++) {
					const s = this.bones[i];
					s._childUpdateId++;
					const n = s.getParent();
					if (n ? s.getLocalMatrix().multiplyToRef(n.getFinalMatrix(), s.getFinalMatrix()) : t ? s.getLocalMatrix().multiplyToRef(t, s.getFinalMatrix()) : s.getFinalMatrix().copyFrom(s.getLocalMatrix()), -1 !== s._index) {
						const t = null === s._index ? i : s._index;
						s.getAbsoluteInverseBindMatrix().multiplyToArray(s.getFinalMatrix(), e, 16 * t)
					}
				}
				this._identity.copyToArray(e, 16 * this.bones.length)
			}
			_unregisterMeshWithPoseMatrix(e) {
				const t = this._meshesWithPoseMatrix.indexOf(e);
				t > -1 && this._meshesWithPoseMatrix.splice(t, 1)
			}
			serialize() {
				const e = {};
				e.name = this.name, e.id = this.id, this.dimensionsAtRest && (e.dimensionsAtRest = this.dimensionsAtRest.asArray()), e.bones = [], e.needInitialSkinMatrix = this.needInitialSkinMatrix;
				for (let t = 0; t < this.bones.length; t++) {
					const i = this.bones[t],
						s = i.getParent(),
						n = {
							parentBoneIndex: s ? this.bones.indexOf(s) : -1,
							index: i.getIndex(),
							name: i.name,
							id: i.id,
							matrix: i.getBindMatrix().asArray(),
							rest: i.getRestMatrix().asArray(),
							linkedTransformNodeId: i.getTransformNode()?.id
						};
					e.bones.push(n), i.length && (n.length = i.length), i.metadata && (n.metadata = i.metadata), i.animations && i.animations.length > 0 && (n.animation = i.animations[0].serialize()), e.ranges = [];
					for (const t in this._ranges) {
						const i = this._ranges[t];
						if (!i) continue;
						const s = {};
						s.name = t, s.from = i.from, s.to = i.to, e.ranges.push(s)
					}
				}
				return e
			}
			get animationPropertiesOverride() {
				return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride
			}
			getAnimationRange(e) {
				return this._ranges[e] || null
			}
			get useTextureToStoreBoneMatrices() {
				return this._useTextureToStoreBoneMatrices
			}
			_markAsDirty() {
				this._isDirty = !0, this._absoluteTransformIsDirty = !0
			}
			getAnimatables() {
				if (!this._animatables || this._animatables.length !== this.bones.length) {
					this._animatables = [];
					for (let e = 0; e < this.bones.length; e++) this._animatables.push(this.bones[e])
				}
				return this._animatables
			}
			constructor(e, t, i) {
				this.name = e, this.id = t, this.bones = [], this.needInitialSkinMatrix = !1, this._isDirty = !0, this._meshesWithPoseMatrix = new Array, this._identity = Hc.Identity(), this._currentRenderId = -1, this._ranges = {}, this._absoluteTransformIsDirty = !0, this._canUseTextureForBones = !1, this._uniqueId = 0, this._numBonesWithLinkedTransformNode = 0, this._hasWaitingData = null, this._parentContainer = null, this.doNotSerialize = !1, this._useTextureToStoreBoneMatrices = !0, this._animationPropertiesOverride = null, this.onBeforeComputeObservable = new kc, this.bones = [], this._scene = i || Dc.LastCreatedScene, this._uniqueId = this._scene.getUniqueId(), this._scene.addSkeleton(this), this._isDirty = !0;
				const s = this._scene.getEngine().getCaps();
				this._canUseTextureForBones = s.textureFloat && s.maxVertexTextureImageUnits > 0
			}
			getTransformMatrixTexture(e) {
				return this.needInitialSkinMatrix && e._transformMatrixTexture ? e._transformMatrixTexture : this._transformMatrixTexture
			}
			get ik() {
				return this._uniqueId
			}
			clone(t, i) {
				const s = new e(t, i || t, this._scene);
				s.needInitialSkinMatrix = this.needInitialSkinMatrix;
				for (let e = 0; e < this.bones.length; e++) {
					const t = this.bones[e];
					let i = null;
					const n = t.getParent();
					if (n) {
						const e = this.bones.indexOf(n);
						i = s.bones[e]
					}
					const a = new mS(t.name, s, i, t.getBindMatrix().clone(), t.getRestMatrix().clone());
					a._index = t._index, t._linkedTransformNode && a.linkTransformNode(t._linkedTransformNode), Iu.DeepCopy(t.animations, a.animations)
				}
				if (this._ranges) {
					s._ranges = {};
					for (const e in this._ranges) {
						const t = this._ranges[e];
						t && (s._ranges[e] = t.clone())
					}
				}
				return this._isDirty = !0, s.prepare(!0), s
			}
			getPoseMatrix() {
				let e = null;
				return this._meshesWithPoseMatrix.length > 0 && (e = this._meshesWithPoseMatrix[0].getPoseMatrix()), e
			}
			getBoneIndexByName(e) {
				for (let t = 0, i = this.bones.length; t < i; t++)
					if (this.bones[t].name === e) return t;
				return -1
			}
			dispose() {
				if (this._meshesWithPoseMatrix.length = 0, this.getScene().stopAnimation(this), this.getScene().removeSkeleton(this), this._parentContainer) {
					const e = this._parentContainer.skeletons.indexOf(this);
					e > -1 && this._parentContainer.skeletons.splice(e, 1), this._parentContainer = null
				}
				this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null)
			}
			createAnimationRange(e, t, i) {
				if (!this._ranges[e]) {
					this._ranges[e] = new Og(e, t, i);
					for (let s = 0, n = this.bones.length; s < n; s++) this.bones[s].animations[0] && this.bones[s].animations[0].createRange(e, t, i)
				}
			}
			prepare(e = !1) {
				if (!e) {
					const e = this.getScene().getRenderId();
					if (this._currentRenderId === e) return;
					this._currentRenderId = e
				}
				if (this._numBonesWithLinkedTransformNode > 0)
					for (const e of this.bones)
						if (e._linkedTransformNode) {
							const t = e._linkedTransformNode;
							e.position = t.position, t.rotationQuaternion ? e.rotationQuaternion = t.rotationQuaternion : e.rotation = t.rotation, e.scaling = t.scaling
						} if (this.needInitialSkinMatrix)
					for (const e of this._meshesWithPoseMatrix) {
						const t = e.getPoseMatrix();
						let i = this._isDirty;
						if (e._bonesTransformMatrices && e._bonesTransformMatrices.length === 16 * (this.bones.length + 1) || (e._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1)), i = !0), i) {
							if (this._synchronizedWithMesh !== e) {
								this._synchronizedWithMesh = e;
								for (const e of this.bones)
									if (!e.getParent()) {
										e.getBindMatrix().multiplyToRef(t, Vc.Matrix[1]), e._updateAbsoluteBindMatrices(Vc.Matrix[1])
									} if (this.isUsingTextureForMatrices) {
									const t = 4 * (this.bones.length + 1);
									e._transformMatrixTexture && e._transformMatrixTexture.getSize().width === t || (e._transformMatrixTexture && e._transformMatrixTexture.dispose(), e._transformMatrixTexture = _S.CreateRGBATexture(e._bonesTransformMatrices, 4 * (this.bones.length + 1), 1, this._scene, !1, !1, 1, 1))
								}
							}
							this._computeTransformMatrices(e._bonesTransformMatrices, t), this.isUsingTextureForMatrices && e._transformMatrixTexture && e._transformMatrixTexture.update(e._bonesTransformMatrices)
						}
					} else {
						if (!this._isDirty) return;
						this._transformMatrices && this._transformMatrices.length === 16 * (this.bones.length + 1) || (this._transformMatrices = new Float32Array(16 * (this.bones.length + 1)), this.isUsingTextureForMatrices && (this._transformMatrixTexture && this._transformMatrixTexture.dispose(), this._transformMatrixTexture = _S.CreateRGBATexture(this._transformMatrices, 4 * (this.bones.length + 1), 1, this._scene, !1, !1, 1, 1))), this._computeTransformMatrices(this._transformMatrices, null), this.isUsingTextureForMatrices && this._transformMatrixTexture && this._transformMatrixTexture.update(this._transformMatrices)
					}
				this._isDirty = !1
			}
			beginAnimation(e, t, i, s) {
				const n = this.getAnimationRange(e);
				return n ? this._scene.beginAnimation(this, n.from, n.to, t, i, s) : null
			}
			_getHighestAnimationFrame() {
				let e = 0;
				for (let t = 0, i = this.bones.length; t < i; t++)
					if (this.bones[t].animations[0]) {
						const i = this.bones[t].animations[0].getHighestFrame();
						e < i && (e = i)
					} return e
			}
			_registerMeshWithPoseMatrix(e) {
				this._meshesWithPoseMatrix.push(e)
			}
			set animationPropertiesOverride(e) {
				this._animationPropertiesOverride = e
			}
			getChildren() {
				return this.bones.filter((e => !e.getParent()))
			}
			toString(e) {
				let t = `Name: ${this.name}, nBones: ${this.bones.length}`;
				if (t += `, nAnimationRanges: ${this._ranges?Object.keys(this._ranges).length:"none"}`, e) {
					t += ", Ranges: {";
					let e = !0;
					for (const i in this._ranges) e && (t += ", ", e = !1), t += i;
					t += "}"
				}
				return t
			}
			static Parse(t, i) {
				const s = new e(t.name, t.id, i);
				let n;
				for (t.dimensionsAtRest && (s.dimensionsAtRest = Lc.FromArray(t.dimensionsAtRest)), s.needInitialSkinMatrix = t.needInitialSkinMatrix, n = 0; n < t.bones.length; n++) {
					const e = t.bones[n],
						i = t.bones[n].index;
					let a = null;
					e.parentBoneIndex > -1 && (a = s.bones[e.parentBoneIndex]);
					const r = e.rest ? Hc.FromArray(e.rest) : null,
						o = new mS(e.name, s, a, Hc.FromArray(e.matrix), r, null, i);
					void 0 !== e.id && null !== e.id && (o.id = e.id), e.length && (o.length = e.length), e.metadata && (o.metadata = e.metadata), e.animation && o.animations.push(Wg.Parse(e.animation)), void 0 !== e.linkedTransformNodeId && null !== e.linkedTransformNodeId && (s._hasWaitingData = !0, o._waitingTransformNodeId = e.linkedTransformNodeId)
				}
				if (t.ranges)
					for (n = 0; n < t.ranges.length; n++) {
						const e = t.ranges[n];
						s.createAnimationRange(e.name, e.from, e.to)
					}
				return s
			}
			deleteAnimationRange(e, t = !0) {
				for (let i = 0, s = this.bones.length; i < s; i++) this.bones[i].animations[0] && this.bones[i].animations[0].deleteRange(e, t);
				this._ranges[e] = null
			}
			getAnimationRanges() {
				const e = [];
				let t;
				for (t in this._ranges) e.push(this._ranges[t]);
				return e
			}
			sortBones() {
				const e = [],
					t = new Array(this.bones.length);
				for (let i = 0; i < this.bones.length; i++) this._sortBones(i, e, t);
				this.bones = e
			}
			getScene() {
				return this._scene
			}
			_sortBones(e, t, i) {
				if (i[e]) return;
				i[e] = !0;
				const s = this.bones[e];
				if (!s) return;
				void 0 === s._index && (s._index = e);
				const n = s.getParent();
				n && this._sortBones(this.bones.indexOf(n), t, i), t.push(s)
			}
			returnToRest() {
				for (const e of this.bones) - 1 !== e._index && e.returnToRest()
			}
			enableBlending(e = .01) {
				this.bones.forEach((t => {
					t.animations.forEach((t => {
						t.enableBlending = !0, t.blendingSpeed = e
					}))
				}))
			}
			computeAbsoluteMatrices(e = !1) {
				(this._absoluteTransformIsDirty || e) && (this.bones[0].computeAbsoluteMatrices(), this._absoluteTransformIsDirty = !1)
			}
			copyAnimationRange(e, t, i = !1) {
				if (this._ranges[t] || !e.getAnimationRange(t)) return !1;
				let s = !0;
				const n = this._getHighestAnimationFrame() + 1,
					a = {},
					r = e.bones;
				let o, l;
				for (l = 0, o = r.length; l < o; l++) a[r[l].name] = r[l];
				this.bones.length !== r.length && (Qc.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${r.length}`), s = !1);
				const h = i && this.dimensionsAtRest && e.dimensionsAtRest ? this.dimensionsAtRest.divide(e.dimensionsAtRest) : null;
				for (l = 0, o = this.bones.length; l < o; l++) {
					const e = this.bones[l].name,
						r = a[e];
					r ? s = s && this.bones[l].copyAnimationRange(r, t, n, i, h) : (Qc.Warn("copyAnimationRange: not same rig, missing source bone " + e), s = !1)
				}
				const c = e.getAnimationRange(t);
				return c && (this._ranges[t] = new Og(t, c.from + n, c.to + n)), s
			}
			get isUsingTextureForMatrices() {
				return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones
			}
			getTransformMatrices(e) {
				if (this.needInitialSkinMatrix) {
					if (!e) throw new Error("getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided");
					return e._bonesTransformMatrices || this.prepare(!0), e._bonesTransformMatrices
				}
				return this._transformMatrices && !this._isDirty || this.prepare(!this._transformMatrices), this._transformMatrices
			}
			set useTextureToStoreBoneMatrices(e) {
				this._useTextureToStoreBoneMatrices = e, this._markAsDirty()
			}
		},
		vS = class {
			constructor(e, t, i, s, n, a, r, o, l = null, h = null) {
				this.idx = 0, this.id = 0, this.color = new wc(1, 1, 1, 1), this.position = Lc.Zero(), this.rotation = Lc.Zero(), this.scaling = Lc.One(), this.uvs = new Bc(0, 0, 1, 1), this.velocity = Lc.Zero(), this.pivot = Lc.Zero(), this.translateFromPivot = !1, this.alive = !0, this.isVisible = !0, this._pos = 0, this._ind = 0, this.shapeId = 0, this.idxInShape = 0, this._stillInvisible = !1, this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.parentId = null, this.materialIndex = null, this.props = null, this.cullingStrategy = jd.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, this._globalPosition = Lc.Zero(), this.idx = e, this.id = t, this._pos = i, this._ind = s, this._model = n, this.shapeId = a, this.idxInShape = r, this._sps = o, l && (this._modelBoundingInfo = l, this._boundingInfo = new yu(l.minimum, l.maximum)), null !== h && (this.materialIndex = h)
			}
			set quaternion(e) {
				this.rotationQuaternion = e
			}
			copyToRef(e) {
				return e.position.copyFrom(this.position), e.rotation.copyFrom(this.rotation), this.rotationQuaternion && (e.rotationQuaternion ? e.rotationQuaternion.copyFrom(this.rotationQuaternion) : e.rotationQuaternion = this.rotationQuaternion.clone()), e.scaling.copyFrom(this.scaling), this.color && (e.color ? e.color.copyFrom(this.color) : e.color = this.color.clone()), e.uvs.copyFrom(this.uvs), e.velocity.copyFrom(this.velocity), e.pivot.copyFrom(this.pivot), e.translateFromPivot = this.translateFromPivot, e.alive = this.alive, e.isVisible = this.isVisible, e.parentId = this.parentId, e.cullingStrategy = this.cullingStrategy, null !== this.materialIndex && (e.materialIndex = this.materialIndex), this
			}
			get scale() {
				return this.scaling
			}
			set scale(e) {
				this.scaling = e
			}
			intersectsMesh(e) {
				return !(!this._boundingInfo || !e.hasBoundingInfo) && (this._sps._bSphereOnly ? fu.Intersects(this._boundingInfo.boundingSphere, e.getBoundingInfo().boundingSphere) : this._boundingInfo.intersects(e.getBoundingInfo(), !1))
			}
			isInFrustum(e) {
				return null !== this._boundingInfo && this._boundingInfo.isInFrustum(e, this.cullingStrategy)
			}
			getRotationMatrix(e) {
				let t;
				if (this.rotationQuaternion) t = this.rotationQuaternion;
				else {
					t = Vc.uk[0];
					const e = this.rotation;
					Gc.RotationYawPitchRollToRef(e.y, e.x, e.z, t)
				}
				t.toRotationMatrix(e)
			}
			getBoundingInfo() {
				return this._boundingInfo
			}
			get quaternion() {
				return this.rotationQuaternion
			}
			get hasBoundingInfo() {
				return null !== this._boundingInfo
			}
		},
		yS = class {
			set shapeID(e) {
				this.shapeId = e
			}
			get shapeID() {
				return this.shapeId
			}
			constructor(e, t, i, s, n, a, r, o, l) {
				this._indicesLength = 0, this.shapeId = e, this._shape = t, this._indices = i, this._indicesLength = i.length, this._shapeUV = a, this._shapeColors = n, this._normals = s, this._positionFunction = r, this._vertexFunction = o, this._material = l
			}
		},
		SS = class {
			constructor(e, t, i, s) {
				this.idx = 0, this.ind = 0, this.indicesLength = 0, this.sqDistance = 0, this.materialIndex = 0, this.idx = e, this.ind = t, this.indicesLength = i, this.materialIndex = s
			}
		},
		ES = class {
			set z(e) {
				this.position.z = e
			}
			get z() {
				return this.position.z
			}
			constructor() {
				this.position = Lc.Zero(), this.color = new wc(1, 1, 1, 1), this.uv = Fc.Zero()
			}
			get y() {
				return this.position.y
			}
			set x(e) {
				this.position.x = e
			}
			get x() {
				return this.position.x
			}
			set y(e) {
				this.position.y = e
			}
		},
		AS = class {
			beforeUpdateParticles(e, t, i) {}
			setMultiMaterial(e) {
				this._materials = this._filterUniqueMaterialId(e), this._setMaterialIndexesById(), this._multimaterial && this._multimaterial.dispose(), this._multimaterial = new kf(this.name + "MultiMaterial", this._scene);
				for (let e = 0; e < this._materials.length; e++) this._multimaterial.subMaterials.push(this._materials[e]);
				this.computeSubMeshes(), this.mesh.material = this._multimaterial
			}
			set multimaterial(e) {
				this._multimaterial = e
			}
			get depthSortParticles() {
				return this._depthSortParticles
			}
			getParticlesByShapeId(e) {
				const t = [];
				return this.getParticlesByShapeIdToRef(e, t), t
			}
			get materials() {
				return this._materials
			}
			_uvsToShapeUV(e) {
				const t = [];
				if (e)
					for (let i = 0; i < e.length; i++) t.push(e[i]);
				return t
			}
			get multimaterial() {
				return this._multimaterial
			}
			set computeParticleColor(e) {
				this._computeParticleColor = e
			}
			_insertNewParticle(e, t, i, s, n, a, r, o, l, h, c) {
				const u = this._positions.length,
					m = this._indices.length,
					d = this._meshBuilder(this._index, m, s, this._positions, n, this._indices, a, this._uvs, r, this._colors, o, this._normals, e, t, c, i);
				let f = null;
				return this._updatable && (f = this._addParticle(this.nbParticles, this._lastParticleId, u, m, i, this._shapeCounter, t, l, h), f.position.copyFrom(d.position), f.rotation.copyFrom(d.rotation), d.rotationQuaternion && (f.rotationQuaternion ? f.rotationQuaternion.copyFrom(d.rotationQuaternion) : f.rotationQuaternion = d.rotationQuaternion.clone()), d.color && (f.color ? f.color.copyFrom(d.color) : f.color = d.color.clone()), f.scaling.copyFrom(d.scaling), f.uvs.copyFrom(d.uvs), null !== d.materialIndex && (f.materialIndex = d.materialIndex), this.expandable && (this._idxOfId[f.id] = f.idx)), h || (this._index += s.length, this.nbParticles++, this._lastParticleId++), f
			}
			constructor(e, t, i) {
				this.particles = new Array, this.nbParticles = 0, this.billboard = !1, this.recomputeNormals = !1, this.counter = 0, this.vars = {}, this._bSphereOnly = !1, this._bSphereRadiusFactor = 1, this._positions = new Array, this._indices = new Array, this._normals = new Array, this._colors = new Array, this._uvs = new Array, this._index = 0, this._updatable = !0, this._pickable = !1, this._isVisibilityBoxLocked = !1, this._alwaysVisible = !1, this._depthSort = !1, this._expandable = !1, this._shapeCounter = 0, this._copy = new vS(0, 0, 0, 0, null, 0, 0, this), this._color = new wc(0, 0, 0, 0), this._computeParticleColor = !0, this._computeParticleTexture = !0, this._computeParticleRotation = !0, this._computeParticleVertex = !1, this._computeBoundingBox = !1, this._autoFixFaceOrientation = !1, this._depthSortParticles = !0, this._mustUnrotateFixedNormals = !1, this._particlesIntersect = !1, this._needs32Bits = !1, this._isNotBuilt = !0, this._lastParticleId = 0, this._idxOfId = [], this._multimaterialEnabled = !1, this._useModelMaterial = !1, this._depthSortFunction = (e, t) => t.sqDistance - e.sqDistance, this._materialSortFunction = (e, t) => e.materialIndex - t.materialIndex, this._autoUpdateSubMeshes = !1, this._recomputeInvisibles = !1, this.name = e, this._scene = t || Dc.LastCreatedScene, this._camera = t.activeCamera, this._pickable = !!i && i.isPickable, this._depthSort = !!i && i.enableDepthSort, this._multimaterialEnabled = !!i && i.enableMultiMaterial, this._useModelMaterial = !!i && i.useModelMaterial, this._multimaterialEnabled = !!this._useModelMaterial || this._multimaterialEnabled, this._expandable = !!i && i.expandable, this._particlesIntersect = !!i && i.particleIntersection, this._bSphereOnly = !!i && i.boundingSphereOnly, this._bSphereRadiusFactor = i && i.bSphereRadiusFactor ? i.bSphereRadiusFactor : 1, this._computeBoundingBox = !!i?.computeBoundingBox && i.computeBoundingBox, this._autoFixFaceOrientation = !!i?.autoFixFaceOrientation && i.autoFixFaceOrientation, i && void 0 !== i.updatable ? this._updatable = i.updatable : this._updatable = !0, this._pickable && (this.pickedBySubMesh = [
					[]
				], this.pickedParticles = this.pickedBySubMesh[0]), (this._depthSort || this._multimaterialEnabled) && (this.depthSortedParticles = []), this._multimaterialEnabled && (this._multimaterial = new kf(this.name + "MultiMaterial", this._scene), this._materials = [], this._materialIndexesById = {}), this._tmpVertex = new ES
			}
			get computeParticleTexture() {
				return this._computeParticleTexture
			}
			get multimaterialEnabled() {
				return this._multimaterialEnabled
			}
			updateParticle(e) {
				return e
			}
			set autoUpdateSubMeshes(e) {
				this._autoUpdateSubMeshes = e
			}
			set depthSortParticles(e) {
				this._depthSortParticles = e
			}
			dispose() {
				this.mesh.dispose(), this.vars = null, this._positions = null, this._indices = null, this._normals = null, this._uvs = null, this._colors = null, this._indices32 = null, this._positions32 = null, this._normals32 = null, this._fixedNormal32 = null, this._uvs32 = null, this._colors32 = null, this.pickedParticles = null, this.pickedBySubMesh = null, this._materials = null, this._materialIndexes = null, this._indicesByMaterial = null, this._idxOfId = null
			}
			setVisibilityBox(e) {
				const t = e / 2;
				this.mesh.buildBoundingInfo(new Lc(-t, -t, -t), new Lc(t, t, t))
			}
			get computeParticleColor() {
				return this._computeParticleColor
			}
			set computeBoundingBox(e) {
				this._computeBoundingBox = e
			}
			get isAlwaysVisible() {
				return this._alwaysVisible
			}
			addShape(e, t, i) {
				const s = e.getVerticesData(eu.PositionKind),
					n = e.getIndices(),
					a = e.getVerticesData(eu.UVKind),
					r = e.getVerticesData(eu.ColorKind),
					o = e.getVerticesData(eu.NormalKind);
				this.recomputeNormals = !o;
				const l = Array.from(n),
					h = o ? Array.from(o) : [],
					c = r ? Array.from(r) : [],
					u = i && i.storage ? i.storage : null;
				let m = null;
				this._particlesIntersect && (m = e.getBoundingInfo());
				const d = this._posToShape(s),
					f = this._uvsToShapeUV(a),
					p = i ? i.positionFunction : null,
					_ = i ? i.vertexFunction : null;
				let g = null;
				this._useModelMaterial && (g = e.material ? e.material : this._setDefaultMaterial());
				const v = new yS(this._shapeCounter, d, l, h, c, f, p, _, g);
				for (let e = 0; e < t; e++) this._insertNewParticle(this.nbParticles, e, v, d, n, a, r, o, m, u, i);
				return this._shapeCounter++, this._isNotBuilt = !0, this._shapeCounter - 1
			}
			_sortParticlesByMaterial() {
				const e = [0];
				this._indicesByMaterial = e;
				const t = [];
				this._materialIndexes = t;
				const i = this.depthSortedParticles;
				i.sort(this._materialSortFunction);
				const s = i.length,
					n = this._indices32,
					a = this._indices;
				let r = 0,
					o = 0,
					l = 0,
					h = i[0].materialIndex;
				t.push(h), this._pickable && (this.pickedBySubMesh = [
					[]
				], this.pickedParticles = this.pickedBySubMesh[0]);
				for (let c = 0; c < s; c++) {
					const s = i[c],
						u = s.indicesLength,
						m = s.ind;
					s.materialIndex !== h && (h = s.materialIndex, e.push(l), t.push(h), this._pickable && (r++, this.pickedBySubMesh[r] = [], o = 0));
					let d = 0;
					for (let e = 0; e < u; e++) {
						if (n[l] = a[m + e], this._pickable) {
							if (0 == e % 3) {
								const e = this.pickedBySubMesh[r][o];
								e ? (e.idx = s.idx, e.faceId = d) : this.pickedBySubMesh[r][o] = {
									idx: s.idx,
									faceId: d
								}, o++, d++
							}
						}
						l++
					}
				}
				return e.push(n.length), this._updatable && this.mesh.updateIndices(n), this
			}
			_addParticle(e, t, i, s, n, a, r, o = null, l = null) {
				const h = new vS(e, t, i, s, n, a, r, this, o);
				return (l || this.particles).push(h), h
			}
			getParticleById(e) {
				const t = this.particles[e];
				if (t && t.id == e) return t;
				const i = this.particles,
					s = this._idxOfId[e];
				if (void 0 !== s) return i[s];
				let n = 0;
				const a = this.nbParticles;
				for (; n < a;) {
					const t = i[n];
					if (t.id == e) return t;
					n++
				}
				return null
			}
			get computeParticleVertex() {
				return this._computeParticleVertex
			}
			getParticlesByShapeIdToRef(e, t) {
				t.length = 0;
				for (let i = 0; i < this.nbParticles; i++) {
					const s = this.particles[i];
					s.shapeId == e && t.push(s)
				}
				return this
			}
			insertParticlesFromArray(e) {
				if (!this._expandable) return this;
				let t = 0,
					i = e[0].shapeId;
				const s = e.length;
				for (let n = 0; n < s; n++) {
					const s = e[n],
						a = s._model,
						r = a._shape,
						o = a._indices,
						l = a._shapeUV,
						h = a._shapeColors,
						c = a._normals,
						u = !c;
					this.recomputeNormals = u || this.recomputeNormals;
					const m = s.getBoundingInfo(),
						d = this._insertNewParticle(this.nbParticles, t, a, r, o, l, h, c, m, null, null);
					s.copyToRef(d), t++, i != s.shapeId && (i = s.shapeId, t = 0)
				}
				return this._isNotBuilt = !0, this
			}
			set computeParticleTexture(e) {
				this._computeParticleTexture = e
			}
			refreshVisibleSize() {
				return this._isVisibilityBoxLocked || this.mesh.refreshBoundingInfo(), this
			}
			get computeParticleRotation() {
				return this._computeParticleRotation
			}
			get autoUpdateSubMeshes() {
				return this._autoUpdateSubMeshes
			}
			set computeParticleVertex(e) {
				this._computeParticleVertex = e
			}
			initParticles() {}
			_resetCopy() {
				const e = this._copy;
				e.position.setAll(0), e.rotation.setAll(0), e.rotationQuaternion = null, e.scaling.setAll(1), e.uvs.copyFromFloats(0, 0, 1, 1), e.color = null, e.translateFromPivot = !1, e.shapeId = 0, e.materialIndex = null
			}
			_unrotateFixedNormals() {
				let e = 0,
					t = 0;
				const i = Vc.Vector3[0],
					s = Vc.uk[0],
					n = Vc.Matrix[0];
				for (let a = 0; a < this.particles.length; a++) {
					const r = this.particles[a],
						o = r._model._shape;
					if (r.rotationQuaternion) r.rotationQuaternion.conjugateToRef(s);
					else {
						const e = r.rotation;
						Gc.RotationYawPitchRollToRef(e.y, e.x, e.z, s), s.conjugateInPlace()
					}
					s.toRotationMatrix(n);
					for (let s = 0; s < o.length; s++) t = e + 3 * s, Lc.TransformNormalFromFloatsToRef(this._normals32[t], this._normals32[t + 1], this._normals32[t + 2], n, i), i.toArray(this._fixedNormal32, t);
					e = t + 3
				}
			}
			setParticles(e = 0, t = this.nbParticles - 1, i = !0) {
				if (!this._updatable || this._isNotBuilt) return this;
				this.beforeUpdateParticles(e, t, i);
				const s = Vc.Matrix[0],
					n = Vc.Matrix[1],
					a = this.mesh,
					r = this._colors32,
					o = this._positions32,
					l = this._normals32,
					h = this._uvs32,
					c = this._indices32,
					u = this._indices,
					m = this._fixedNormal32,
					d = this._depthSort && this._depthSortParticles,
					f = Vc.Vector3,
					p = f[5].copyFromFloats(1, 0, 0),
					_ = f[6].copyFromFloats(0, 1, 0),
					g = f[7].copyFromFloats(0, 0, 1),
					v = f[8].setAll(Number.MAX_VALUE),
					y = f[9].setAll(-Number.MAX_VALUE),
					S = f[10].setAll(0),
					E = this._tmpVertex,
					A = E.position,
					b = E.color,
					x = E.uv;
				if ((this.billboard || this._depthSort) && (this.mesh.computeWorldMatrix(!0), this.mesh._worldMatrix.invertToRef(n)), this.billboard) {
					const e = f[0];
					this._camera.getDirectionToRef(zd.Z, e), Lc.TransformNormalToRef(e, n, g), g.normalize();
					const t = this._camera.getViewMatrix(!0);
					Lc.TransformNormalFromFloatsToRef(t.m[1], t.m[5], t.m[9], n, _), Lc.CrossToRef(_, g, p), _.normalize(), p.normalize()
				}
				this._depthSort && Lc.TransformCoordinatesToRef(this._camera.globalPosition, n, S), Hc.IdentityToRef(s);
				let M = 0,
					C = 0,
					T = 0,
					w = 0,
					R = 0,
					N = 0,
					I = 0;
				if (this.mesh.isFacetDataEnabled && (this._computeBoundingBox = !0), t = t >= this.nbParticles ? this.nbParticles - 1 : t, this._computeBoundingBox && (0 != e || t != this.nbParticles - 1)) {
					const e = this.mesh.getBoundingInfo();
					e && (v.copyFrom(e.minimum), y.copyFrom(e.maximum))
				}
				C = this.particles[e]._pos;
				const P = C / 3 | 0;
				w = 4 * P, N = 2 * P;
				for (let i = e; i <= t; i++) {
					const e = this.particles[i];
					this.updateParticle(e);
					const t = e._model._shape,
						n = e._model._shapeUV,
						c = e._rotationMatrix,
						u = e.position,
						P = e.rotation,
						k = e.scaling,
						D = e._globalPosition;
					if (d) {
						const t = this.depthSortedParticles[i];
						t.idx = e.idx, t.ind = e._ind, t.indicesLength = e._model._indicesLength, t.sqDistance = Lc.DistanceSquared(e.position, S)
					}
					if (e.alive && (!e._stillInvisible || e.isVisible || this._recomputeInvisibles)) {
						if (e.isVisible) {
							e._stillInvisible = !1;
							const i = f[12];
							e.pivot.multiplyToRef(k, i), this.billboard && (P.x = 0, P.y = 0), (this._computeParticleRotation || this.billboard) && e.getRotationMatrix(s);
							if (null !== e.parentId) {
								const t = this.getParticleById(e.parentId);
								if (t) {
									const e = t._rotationMatrix,
										i = t._globalPosition,
										n = u.x * e[1] + u.y * e[4] + u.z * e[7],
										a = u.x * e[0] + u.y * e[3] + u.z * e[6],
										r = u.x * e[2] + u.y * e[5] + u.z * e[8];
									if (D.x = i.x + a, D.y = i.y + n, D.z = i.z + r, this._computeParticleRotation || this.billboard) {
										const t = s.m;
										c[0] = t[0] * e[0] + t[1] * e[3] + t[2] * e[6], c[1] = t[0] * e[1] + t[1] * e[4] + t[2] * e[7], c[2] = t[0] * e[2] + t[1] * e[5] + t[2] * e[8], c[3] = t[4] * e[0] + t[5] * e[3] + t[6] * e[6], c[4] = t[4] * e[1] + t[5] * e[4] + t[6] * e[7], c[5] = t[4] * e[2] + t[5] * e[5] + t[6] * e[8], c[6] = t[8] * e[0] + t[9] * e[3] + t[10] * e[6], c[7] = t[8] * e[1] + t[9] * e[4] + t[10] * e[7], c[8] = t[8] * e[2] + t[9] * e[5] + t[10] * e[8]
									}
								} else e.parentId = null
							} else if (D.x = u.x, D.y = u.y, D.z = u.z, this._computeParticleRotation || this.billboard) {
								const e = s.m;
								c[0] = e[0], c[1] = e[1], c[2] = e[2], c[3] = e[4], c[4] = e[5], c[5] = e[6], c[6] = e[8], c[7] = e[9], c[8] = e[10]
							}
							const a = f[11];
							for (e.translateFromPivot ? a.setAll(0) : a.copyFrom(i), I = 0; I < t.length; I++) {
								M = C + 3 * I, T = w + 4 * I, R = N + 2 * I;
								const s = 2 * I,
									r = s + 1;
								A.copyFrom(t[I]), this._computeParticleColor && e.color && b.copyFrom(e.color), this._computeParticleTexture && x.copyFromFloats(n[s], n[r]), this._computeParticleVertex && this.updateParticleVertex(e, E, I);
								const u = A.x * k.x - i.x,
									d = A.y * k.y - i.y,
									f = A.z * k.z - i.z;
								let S = u * c[0] + d * c[3] + f * c[6],
									P = u * c[1] + d * c[4] + f * c[7],
									O = u * c[2] + d * c[5] + f * c[8];
								S += a.x, P += a.y, O += a.z;
								const F = o[M] = D.x + p.x * S + _.x * P + g.x * O,
									L = o[M + 1] = D.y + p.y * S + _.y * P + g.y * O,
									B = o[M + 2] = D.z + p.z * S + _.z * P + g.z * O;
								if (this._computeBoundingBox && (v.minimizeInPlaceFromFloats(F, L, B), y.maximizeInPlaceFromFloats(F, L, B)), !this._computeParticleVertex) {
									const e = m[M],
										t = m[M + 1],
										i = m[M + 2],
										s = e * c[0] + t * c[3] + i * c[6],
										n = e * c[1] + t * c[4] + i * c[7],
										a = e * c[2] + t * c[5] + i * c[8];
									l[M] = p.x * s + _.x * n + g.x * a, l[M + 1] = p.y * s + _.y * n + g.y * a, l[M + 2] = p.z * s + _.z * n + g.z * a
								}
								if (this._computeParticleColor && e.color) {
									const e = this._colors32;
									e[T] = b.r, e[T + 1] = b.g, e[T + 2] = b.b, e[T + 3] = b.a
								}
								if (this._computeParticleTexture) {
									const t = e.uvs;
									h[R] = x.x * (t.z - t.x) + t.x, h[R + 1] = x.y * (t.w - t.y) + t.y
								}
							}
						} else
							for (e._stillInvisible = !0, I = 0; I < t.length; I++) {
								if (M = C + 3 * I, T = w + 4 * I, R = N + 2 * I, o[M] = o[M + 1] = o[M + 2] = 0, l[M] = l[M + 1] = l[M + 2] = 0, this._computeParticleColor && e.color) {
									const t = e.color;
									r[T] = t.r, r[T + 1] = t.g, r[T + 2] = t.b, r[T + 3] = t.a
								}
								if (this._computeParticleTexture) {
									const t = e.uvs;
									h[R] = n[2 * I] * (t.z - t.x) + t.x, h[R + 1] = n[2 * I + 1] * (t.w - t.y) + t.y
								}
							}
						if (this._particlesIntersect) {
							const t = e.getBoundingInfo(),
								i = t.boundingBox,
								s = t.boundingSphere,
								n = e._modelBoundingInfo;
							if (!this._bSphereOnly) {
								const e = n.boundingBox.vectors,
									t = f[1],
									s = f[2];
								t.setAll(Number.MAX_VALUE), s.setAll(-Number.MAX_VALUE);
								for (let i = 0; i < 8; i++) {
									const n = e[i].x * k.x,
										a = e[i].y * k.y,
										r = e[i].z * k.z,
										o = n * c[0] + a * c[3] + r * c[6],
										l = n * c[1] + a * c[4] + r * c[7],
										h = n * c[2] + a * c[5] + r * c[8],
										m = u.x + p.x * o + _.x * l + g.x * h,
										d = u.y + p.y * o + _.y * l + g.y * h,
										f = u.z + p.z * o + _.z * l + g.z * h;
									t.minimizeInPlaceFromFloats(m, d, f), s.maximizeInPlaceFromFloats(m, d, f)
								}
								i.reConstruct(t, s, a._worldMatrix)
							}
							const r = n.minimum.multiplyToRef(k, f[1]),
								o = n.maximum.multiplyToRef(k, f[2]),
								l = o.addToRef(r, f[3]).scaleInPlace(.5).addInPlace(D),
								h = o.subtractToRef(r, f[4]).scaleInPlace(.5 * this._bSphereRadiusFactor),
								m = l.subtractToRef(h, f[1]),
								d = l.addToRef(h, f[2]);
							s.reConstruct(m, d, a._worldMatrix)
						}
						C = M + 3, w = T + 4, N = R + 2
					} else I = t.length, C += 3 * I, w += 4 * I, N += 2 * I
				}
				if (i) {
					if (this._computeParticleColor) {
						const e = a.getVertexBuffer(eu.ColorKind);
						e && !a.isPickable ? e.updateDirectly(r, 0) : a.updateVerticesData(eu.ColorKind, r, !1, !1)
					}
					if (this._computeParticleTexture) {
						const e = a.getVertexBuffer(eu.UVKind);
						e && !a.isPickable ? e.updateDirectly(h, 0) : a.updateVerticesData(eu.UVKind, h, !1, !1)
					}
					const e = a.getVertexBuffer(eu.PositionKind);
					if (e && !a.isPickable ? e.updateDirectly(o, 0) : a.updateVerticesData(eu.PositionKind, o, !1, !1), !a.areNormalsFrozen || a.isFacetDataEnabled) {
						if (this._computeParticleVertex || a.isFacetDataEnabled) {
							const e = a.isFacetDataEnabled ? a.getFacetDataParameters() : null;
							Mu.ComputeNormals(o, c, l, e);
							for (let e = 0; e < l.length; e++) m[e] = l[e]
						}
						if (!a.areNormalsFrozen) {
							const e = a.getVertexBuffer(eu.NormalKind);
							e && !a.isPickable ? e.updateDirectly(l, 0) : a.updateVerticesData(eu.NormalKind, l, !1, !1)
						}
					}
					if (d) {
						const e = this.depthSortedParticles;
						e.sort(this._depthSortFunction);
						const t = e.length;
						let i = 0,
							s = 0;
						for (let n = 0; n < t; n++) {
							const t = e[n],
								a = t.indicesLength,
								r = t.ind;
							for (let e = 0; e < a; e++)
								if (c[i] = u[r + e], i++, this._pickable) {
									if (0 == e % 3) {
										const e = this.pickedParticles[s];
										e.idx = t.idx, e.faceId = s, s++
									}
								}
						}
					}
					if (this._autoFixFaceOrientation) {
						let e = 0;
						for (let t = 0; t < this.particles.length; t++) {
							const i = d ? this.particles[this.depthSortedParticles[t].idx] : this.particles[t];
							if (i.scale.x * i.scale.y * i.scale.z < 0)
								for (let t = 0; t < i._model._indicesLength; t += 3) {
									const s = u[i._ind + t];
									c[e + t] = u[i._ind + t + 1], c[e + t + 1] = s
								}
							e += i._model._indicesLength
						}
					}(d || this._autoFixFaceOrientation) && a.updateIndices(c)
				}
				return this._computeBoundingBox && (a.hasBoundingInfo ? a.getBoundingInfo().reConstruct(v, y, a._worldMatrix) : a.buildBoundingInfo(v, y, a._worldMatrix)), this._autoUpdateSubMeshes && this.computeSubMeshes(), this._recomputeInvisibles = !1, this.afterUpdateParticles(e, t, i), this
			}
			set computeParticleRotation(e) {
				this._computeParticleRotation = e
			}
			buildMesh() {
				if (!this._isNotBuilt && this.mesh) return this.mesh;
				if (0 === this.nbParticles && !this.mesh) {
					const e = ey("", {
						radius: 1,
						tessellation: 3
					}, this._scene);
					this.addShape(e, 1), e.dispose()
				}
				if (this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices), this._positions32 = new Float32Array(this._positions), this._uvs32 = new Float32Array(this._uvs), this._colors32 = new Float32Array(this._colors), !this.mesh) {
					const e = new Vf(this.name, this._scene);
					this.mesh = e
				}!this._updatable && this._multimaterialEnabled && this._sortParticlesByMaterial(), this.recomputeNormals && Mu.ComputeNormals(this._positions32, this._indices32, this._normals), this._normals32 = new Float32Array(this._normals), this._fixedNormal32 = new Float32Array(this._normals), this._mustUnrotateFixedNormals && this._unrotateFixedNormals();
				const e = new Mu;
				if (e.indices = this._depthSort ? this._indices : this._indices32, e.set(this._positions32, eu.PositionKind), e.set(this._normals32, eu.NormalKind), this._uvs32.length > 0 && e.set(this._uvs32, eu.UVKind), this._colors32.length > 0 && e.set(this._colors32, eu.ColorKind), e.applyToMesh(this.mesh, this._updatable), this.mesh.isPickable = this._pickable, this._pickable) {
					let e = 0;
					for (let t = 0; t < this.nbParticles; t++) {
						const i = this.particles[t],
							s = i._model._indicesLength;
						for (let t = 0; t < s; t++) {
							if (0 == t % 3) {
								const t = {
									idx: i.idx,
									faceId: e
								};
								this.pickedParticles[e] = t, e++
							}
						}
					}
				}
				return this._multimaterialEnabled && this.setMultiMaterial(this._materials), this._expandable || (this._depthSort || this._multimaterialEnabled || this._autoFixFaceOrientation || (this._indices = null), this._positions = null, this._normals = null, this._uvs = null, this._colors = null, this._updatable || (this.particles.length = 0)), this._isNotBuilt = !1, this.recomputeNormals = !1, this._recomputeInvisibles = !0, this.mesh
			}
			updateParticleVertex(e, t, i) {
				return this
			}
			digest(e, t) {
				let i = t && t.facetNb || 1,
					s = t && t.number || 0,
					n = t && t.delta || 0;
				const a = e.getVerticesData(eu.PositionKind),
					r = e.getIndices(),
					o = e.getVerticesData(this._getUVKind(e, t?.uvKind ?? 0)),
					l = e.getVerticesData(eu.ColorKind),
					h = e.getVerticesData(eu.NormalKind),
					c = t && t.storage ? t.storage : null;
				let u = 0;
				const m = r.length / 3;
				s ? (s = s > m ? m : s, i = Math.round(m / s), n = 0) : i = i > m ? m : i;
				const d = [],
					f = [],
					p = [],
					_ = [],
					g = [],
					v = Lc.Zero(),
					y = i;
				for (; u < m;) {
					i = y + Math.floor((1 + n) * Math.random()), u > m - i && (i = m - u), d.length = 0, f.length = 0, p.length = 0, _.length = 0, g.length = 0;
					let t = 0;
					for (let e = 3 * u; e < 3 * (u + i); e++) {
						p.push(t);
						const i = r[e],
							s = 3 * i;
						if (d.push(a[s], a[s + 1], a[s + 2]), f.push(h[s], h[s + 1], h[s + 2]), o) {
							const e = 2 * i;
							_.push(o[e], o[e + 1])
						}
						if (l) {
							const e = 4 * i;
							g.push(l[e], l[e + 1], l[e + 2], l[e + 3])
						}
						t++
					}
					let s = this.nbParticles;
					const S = this._posToShape(d),
						E = this._uvsToShapeUV(_),
						A = p.slice(),
						b = g.slice(),
						x = f.slice();
					let M;
					for (v.copyFromFloats(0, 0, 0), M = 0; M < S.length; M++) v.addInPlace(S[M]);
					v.scaleInPlace(1 / S.length);
					const C = new Lc(1 / 0, 1 / 0, 1 / 0),
						T = new Lc(-1 / 0, -1 / 0, -1 / 0);
					for (M = 0; M < S.length; M++) S[M].subtractInPlace(v), C.minimizeInPlaceFromFloats(S[M].x, S[M].y, S[M].z), T.maximizeInPlaceFromFloats(S[M].x, S[M].y, S[M].z);
					let w;
					this._particlesIntersect && (w = new yu(C, T));
					let R = null;
					this._useModelMaterial && (R = e.material ? e.material : this._setDefaultMaterial());
					const N = new yS(this._shapeCounter, S, A, x, b, E, null, null, R),
						I = this._positions.length,
						P = this._indices.length;
					this._meshBuilder(this._index, P, S, this._positions, A, this._indices, _, this._uvs, b, this._colors, x, this._normals, s, 0, null, N), this._addParticle(s, this._lastParticleId, I, P, N, this._shapeCounter, 0, w, c), this.particles[this.nbParticles].position.addInPlace(v), c || (this._index += S.length, s++, this.nbParticles++, this._lastParticleId++), this._shapeCounter++, u += i
				}
				return this._isNotBuilt = !0, this
			}
			_setDefaultMaterial() {
				return this._defaultMaterial || (this._defaultMaterial = new Wv(this.name + "DefaultMaterial", this._scene)), this._defaultMaterial
			}
			_rebuildParticle(e, t = !1) {
				this._resetCopy();
				const i = this._copy;
				e._model._positionFunction && e._model._positionFunction(i, e.idx, e.idxInShape);
				const s = Vc.Matrix[0],
					n = Vc.Vector3[0],
					a = Vc.Vector3[1],
					r = Vc.Vector3[2],
					o = Vc.Vector3[3];
				i.getRotationMatrix(s), e.pivot.multiplyToRef(e.scaling, o), i.translateFromPivot ? r.copyFromFloats(0, 0, 0) : r.copyFrom(o);
				const l = e._model._shape;
				for (let t = 0; t < l.length; t++) n.copyFrom(l[t]), e._model._vertexFunction && e._model._vertexFunction(i, n, t), n.multiplyInPlace(i.scaling).subtractInPlace(o), Lc.TransformCoordinatesToRef(n, s, a), a.addInPlace(r).addInPlace(i.position).toArray(this._positions32, e._pos + 3 * t);
				t && (e.position.setAll(0), e.rotation.setAll(0), e.rotationQuaternion = null, e.scaling.setAll(1), e.uvs.setAll(0), e.pivot.setAll(0), e.translateFromPivot = !1, e.parentId = null)
			}
			computeSubMeshes() {
				if (!this.mesh || !this._multimaterialEnabled) return this;
				const e = this.depthSortedParticles;
				if (this.particles.length > 0)
					for (let t = 0; t < this.particles.length; t++) {
						const i = this.particles[t];
						i.materialIndex || (i.materialIndex = 0);
						const s = e[t];
						s.materialIndex = i.materialIndex, s.ind = i._ind, s.indicesLength = i._model._indicesLength, s.idx = i.idx
					}
				this._sortParticlesByMaterial();
				const t = this._indicesByMaterial,
					i = this._materialIndexes,
					s = this.mesh;
				s.subMeshes = [];
				const n = s.getTotalVertices();
				for (let e = 0; e < i.length; e++) {
					const a = t[e],
						r = t[e + 1] - a,
						o = i[e];
					new bu(o, 0, n, a, r, s)
				}
				return this
			}
			set isAlwaysVisible(e) {
				this._alwaysVisible = e, this.mesh.alwaysSelectAsActiveMesh = e
			}
			_meshBuilder(e, t, i, s, n, a, r, o, l, h, c, u, m, d, f, p) {
				let _, g = 0,
					v = 0,
					y = 0;
				this._resetCopy();
				const S = this._copy,
					E = !(!f || !f.storage);
				if (S.idx = m, S.idxInShape = d, S.shapeId = p.shapeId, this._useModelMaterial) {
					const e = p._material.ik,
						t = this._materialIndexesById;
					Object.prototype.hasOwnProperty.call(t, e) || (t[e] = this._materials.length, this._materials.push(p._material));
					const i = t[e];
					S.materialIndex = i
				}
				if (f && f.positionFunction && (f.positionFunction(S, m, d), this._mustUnrotateFixedNormals = !0), E) return S;
				const A = Vc.Matrix[0],
					b = this._tmpVertex,
					x = b.position,
					M = b.color,
					C = b.uv,
					T = Vc.Vector3[1],
					w = Vc.Vector3[2],
					R = Vc.Vector3[3];
				Hc.IdentityToRef(A), S.getRotationMatrix(A), S.pivot.multiplyToRef(S.scaling, R), S.translateFromPivot ? w.setAll(0) : w.copyFrom(R);
				const N = f && f.vertexFunction;
				for (_ = 0; _ < i.length; _++) {
					if (x.copyFrom(i[_]), S.color && M.copyFrom(S.color), r && C.copyFromFloats(r[g], r[g + 1]), N && f.vertexFunction(S, b, _), x.multiplyInPlace(S.scaling).subtractInPlace(R), Lc.TransformCoordinatesToRef(x, A, T), T.addInPlace(w).addInPlace(S.position), s.push(T.x, T.y, T.z), r) {
						const e = S.uvs;
						o.push((e.z - e.x) * C.x + e.x, (e.w - e.y) * C.y + e.y), g += 2
					}
					if (S.color) this._color.copyFrom(M);
					else {
						const e = this._color;
						l && void 0 !== l[v] ? (e.r = l[v], e.g = l[v + 1], e.b = l[v + 2], e.a = l[v + 3]) : (e.r = 1, e.g = 1, e.b = 1, e.a = 1)
					}
					h.push(this._color.r, this._color.g, this._color.b, this._color.a), v += 4, !this.recomputeNormals && c && (Lc.TransformNormalFromFloatsToRef(c[y], c[y + 1], c[y + 2], A, x), u.push(x.x, x.y, x.z), y += 3)
				}
				for (_ = 0; _ < n.length; _++) {
					const t = e + n[_];
					a.push(t), t > 65535 && (this._needs32Bits = !0)
				}
				if (this._depthSort || this._multimaterialEnabled) {
					const e = null !== S.materialIndex ? S.materialIndex : 0;
					this.depthSortedParticles.push(new SS(m, t, n.length, e))
				}
				return S
			}
			removeParticles(e, t) {
				const i = t - e + 1;
				if (!this._expandable || i <= 0 || i >= this.nbParticles || !this._updatable) return [];
				const s = this.particles,
					n = this.nbParticles;
				if (t < n - 1) {
					const i = t + 1,
						a = s[i]._pos - s[e]._pos,
						r = s[i]._ind - s[e]._ind;
					for (let e = i; e < n; e++) {
						const t = s[e];
						t._pos -= a, t._ind -= r
					}
				}
				const a = s.splice(e, i);
				this._positions.length = 0, this._indices.length = 0, this._colors.length = 0, this._uvs.length = 0, this._normals.length = 0, this._index = 0, this._idxOfId.length = 0, (this._depthSort || this._multimaterialEnabled) && (this.depthSortedParticles = []);
				let r = 0;
				const o = s.length;
				for (let e = 0; e < o; e++) {
					const t = s[e],
						i = t._model,
						n = i._shape,
						a = i._indices,
						o = i._normals,
						l = i._shapeColors,
						h = i._shapeUV;
					t.idx = e, this._idxOfId[t.id] = e, this._meshBuilder(this._index, r, n, this._positions, a, this._indices, h, this._uvs, l, this._colors, o, this._normals, t.idx, t.idxInShape, null, i), this._index += n.length, r += a.length
				}
				return this.nbParticles -= i, this._isNotBuilt = !0, a
			}
			pickedParticle(e) {
				if (e.hit) {
					const t = e.subMeshId,
						i = e.faceId - this.mesh.subMeshes[t].indexStart / 3,
						s = this.pickedBySubMesh;
					if (s[t] && s[t][i]) return s[t][i]
				}
				return null
			}
			rebuildMesh(e = !1) {
				for (let t = 0; t < this.particles.length; t++) this._rebuildParticle(this.particles[t], e);
				return this.mesh.updateVerticesData(eu.PositionKind, this._positions32, !1, !1), this
			}
			get isVisibilityBoxLocked() {
				return this._isVisibilityBoxLocked
			}
			get expandable() {
				return this._expandable
			}
			recycleParticle(e) {
				return e
			}
			_getUVKind(e, t) {
				return -1 === t && (e.material?.diffuseTexture ? t = e.material.diffuseTexture.coordinatesIndex : e.material?.albedoTexture && (t = e.material.albedoTexture.coordinatesIndex)), "uv" + (t ? t + 1 : "")
			}
			_setMaterialIndexesById() {
				this._materialIndexesById = {};
				for (let e = 0; e < this._materials.length; e++) {
					const t = this._materials[e].ik;
					this._materialIndexesById[t] = e
				}
			}
			afterUpdateParticles(e, t, i) {}
			set isVisibilityBoxLocked(e) {
				this._isVisibilityBoxLocked = e;
				this.mesh.getBoundingInfo().isLocked = e
			}
			_posToShape(e) {
				const t = [];
				for (let i = 0; i < e.length; i += 3) t.push(Lc.FromArray(e, i));
				return t
			}
			_filterUniqueMaterialId(e) {
				return e.filter((function(e, t, i) {
					return i.indexOf(e) === t
				}))
			}
			get computeBoundingBox() {
				return this._computeBoundingBox
			}
			get useModelMaterial() {
				return this._useModelMaterial
			}
		},
		bS = class {
			_preparePath(e, t = 0) {
				const i = this._animation.targetPropertyPath;
				if (i.length > 1) {
					let s = e;
					for (let e = 0; e < i.length - 1; e++) {
						const t = i[e];
						if (s = s[t], void 0 === s) throw new Error(`Invalid property (${t}) in property path (${i.join(".")})`)
					}
					this._targetPath = i[i.length - 1], this._activeTargets[t] = s
				} else this._targetPath = i[0], this._activeTargets[t] = e;
				if (void 0 === this._activeTargets[t][this._targetPath]) throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)
			}
			get currentFrame() {
				return this._currentFrame
			}
			get targetPath() {
				return this._targetPath
			}
			get target() {
				return this._currentActiveTarget
			}
			get animation() {
				return this._animation
			}
			_prepareForSpeedRatioChange(e) {
				const t = this._previousElapsedTime * (this._animation.framePerSecond * e) / 1e3;
				this._absoluteFrameOffset = this._previousAbsoluteFrame - t
			}
			get currentValue() {
				return this._currentValue
			}
			goToFrame(e, t = -1) {
				const i = this._animation.getKeys();
				e < i[0].frame ? e = i[0].frame : e > i[i.length - 1].frame && (e = i[i.length - 1].frame);
				const s = this._events;
				if (s.length)
					for (let t = 0; t < s.length; t++) s[t].onlyOnce || (s[t].isDone = s[t].frame < e);
				this._currentFrame = e;
				const n = this._animation._interpolate(e, this._animationState);
				this.setValue(n, t)
			}
			setValue(e, t) {
				if (this._targetIsArray)
					for (let i = 0; i < this._target.length; i++) {
						const s = this._target[i];
						this._setValue(s, this._activeTargets[i], e, t, i)
					} else this._setValue(this._target, this._directTarget, e, t, 0)
			}
			_getOriginalValues(e = 0) {
				let t;
				const i = this._activeTargets[e];
				t = i.getLocalMatrix && "_matrix" === this._targetPath ? i.getLocalMatrix() : i[this._targetPath], t && t.clone ? this._originalValue[e] = t.clone() : this._originalValue[e] = t
			}
			get weight() {
				return this._weight
			}
			isStopped() {
				return this._stopped
			}
			animate(e, t, i, s, n, a = -1) {
				const r = this._animation,
					o = r.targetPropertyPath;
				if (!o || o.length < 1) return this._stopped = !0, !1;
				let l = !0;
				(t < this._minFrame || t > this._maxFrame) && (t = this._minFrame), (i < this._minFrame || i > this._maxFrame) && (i = this._maxFrame);
				const h = i - t;
				let c, u = e * (r.framePerSecond * n) / 1e3 + this._absoluteFrameOffset,
					m = 0,
					d = !1;
				const f = s && this._animationState.loopMode === Wg.ANIMATIONLOOPMODE_YOYO;
				if (f) {
					const e = (u - t) / h,
						i = Math.sin(e * Math.PI);
					u = Math.abs(i) * h + t;
					const s = i >= 0 ? 1 : -1;
					this._yoyoDirection !== s && (d = !0), this._yoyoDirection = s
				}
				if (this._previousElapsedTime = e, this._previousAbsoluteFrame = u, !s && i >= t && (u >= h && n > 0 || u <= 0 && n < 0)) l = !1, m = r._getKeyValue(this._maxValue);
				else if (!s && t >= i && (u <= h && n < 0 || u >= 0 && n > 0)) l = !1, m = r._getKeyValue(this._minValue);
				else if (this._animationState.loopMode !== Wg.ANIMATIONLOOPMODE_CYCLE) {
					const e = i.toString() + t.toString();
					if (!this._offsetsCache[e]) {
						this._animationState.repeatCount = 0, this._animationState.loopMode = Wg.ANIMATIONLOOPMODE_CYCLE;
						const s = r._interpolate(t, this._animationState),
							n = r._interpolate(i, this._animationState);
						switch (this._animationState.loopMode = this._getCorrectLoopMode(), r.dataType) {
							case Wg.ANIMATIONTYPE_FLOAT:
								this._offsetsCache[e] = n - s;
								break;
							case Wg.ANIMATIONTYPE_QUATERNION:
							case Wg.ANIMATIONTYPE_VECTOR3:
							case Wg.ANIMATIONTYPE_VECTOR2:
							case Wg.ANIMATIONTYPE_SIZE:
							case Wg.ANIMATIONTYPE_COLOR3:
								this._offsetsCache[e] = n.subtract(s)
						}
						this._highLimitsCache[e] = n
					}
					m = this._highLimitsCache[e], c = this._offsetsCache[e]
				}
				if (void 0 === c) switch (r.dataType) {
					case Wg.ANIMATIONTYPE_FLOAT:
						c = 0;
						break;
					case Wg.ANIMATIONTYPE_QUATERNION:
						c = Fg;
						break;
					case Wg.ANIMATIONTYPE_VECTOR3:
						c = Lg;
						break;
					case Wg.ANIMATIONTYPE_VECTOR2:
						c = Bg;
						break;
					case Wg.ANIMATIONTYPE_SIZE:
						c = Gg;
						break;
					case Wg.ANIMATIONTYPE_COLOR3:
						c = Hg;
						break;
					case Wg.ANIMATIONTYPE_COLOR4:
						c = Ug
				}
				let p;
				if (this._host && this._host.syncRoot) {
					const e = this._host.syncRoot;
					p = t + h * ((e.masterFrame - e.fromFrame) / (e.toFrame - e.fromFrame))
				} else p = u > 0 && t > i || u < 0 && t < i ? l && 0 !== h ? i + u % h : t : l && 0 !== h ? t + u % h : i;
				const _ = this._events;
				if (!f && (n > 0 && this.currentFrame > p || n < 0 && this.currentFrame < p) || f && d) {
					this._onLoop();
					for (let e = 0; e < _.length; e++) _[e].onlyOnce || (_[e].isDone = !1);
					this._animationState.key = n > 0 ? 0 : r.getKeys().length - 1
				}
				this._currentFrame = p, this._animationState.repeatCount = 0 === h ? 0 : u / h | 0, this._animationState.highLimitValue = m, this._animationState.offsetValue = c;
				const g = r._interpolate(p, this._animationState);
				if (this.setValue(g, a), _.length)
					for (let e = 0; e < _.length; e++)
						if (h >= 0 && p >= _[e].frame && _[e].frame >= t || h < 0 && p <= _[e].frame && _[e].frame <= t) {
							const t = _[e];
							t.isDone || (t.onlyOnce && (_.splice(e, 1), e--), t.isDone = !0, t.action(p))
						} return l || (this._stopped = !0), l
			}
			_setValue(e, t, i, s, n) {
				if (this._currentActiveTarget = t, this._weight = s, this._enableBlending && this._blendingFactor <= 1) {
					if (!this._originalBlendValue) {
						const e = t[this._targetPath];
						e.clone ? this._originalBlendValue = e.clone() : this._originalBlendValue = e
					}
					this._originalBlendValue.m ? Wg.AllowMatrixDecomposeForInterpolation ? this._currentValue ? Hc.DecomposeLerpToRef(this._originalBlendValue, i, this._blendingFactor, this._currentValue) : this._currentValue = Hc.DecomposeLerp(this._originalBlendValue, i, this._blendingFactor) : this._currentValue ? Hc.LerpToRef(this._originalBlendValue, i, this._blendingFactor, this._currentValue) : this._currentValue = Hc.Lerp(this._originalBlendValue, i, this._blendingFactor) : this._currentValue = Wg._UniversalLerp(this._originalBlendValue, i, this._blendingFactor);
					const s = e && e.animationPropertiesOverride ? e.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;
					this._blendingFactor += s
				} else this._currentValue ? this._currentValue.copyFrom ? this._currentValue.copyFrom(i) : this._currentValue = i : this._currentValue = i?.clone ? i.clone() : i; - 1 !== s ? this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[n]) : this._animationState.loopMode === Wg.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT ? this._currentValue.addToRef ? this._currentValue.addToRef(this._originalValue[n], t[this._targetPath]) : t[this._targetPath] = this._originalValue[n] + this._currentValue : t[this._targetPath] = this._currentValue, e.markAsDirty && e.markAsDirty(this._animation.targetProperty)
			}
			_getCorrectLoopMode() {
				return this._target && this._target.animationPropertiesOverride ? this._target.animationPropertiesOverride.loopMode : this._animation.loopMode
			}
			dispose() {
				const e = this._animation.runtimeAnimations.indexOf(this);
				e > -1 && this._animation.runtimeAnimations.splice(e, 1)
			}
			reset(e = !1) {
				if (e)
					if (this._target instanceof Array) {
						let e = 0;
						for (const t of this._target) void 0 !== this._originalValue[e] && this._setValue(t, this._activeTargets[e], this._originalValue[e], -1, e), e++
					} else void 0 !== this._originalValue[0] && this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);
				this._offsetsCache = {}, this._highLimitsCache = {}, this._currentFrame = 0, this._blendingFactor = 0;
				for (let e = 0; e < this._events.length; e++) this._events[e].isDone = !1
			}
			constructor(e, t, i, s) {
				if (this._events = new Array, this._currentFrame = 0, this._originalValue = new Array, this._originalBlendValue = null, this._offsetsCache = {}, this._highLimitsCache = {}, this._stopped = !1, this._blendingFactor = 0, this._currentValue = null, this._currentActiveTarget = null, this._directTarget = null, this._targetPath = "", this._weight = 1, this._absoluteFrameOffset = 0, this._previousElapsedTime = 0, this._yoyoDirection = 1, this._previousAbsoluteFrame = 0, this._targetIsArray = !1, this._animation = t, this._target = e, this._scene = i, this._host = s, this._activeTargets = [], t._runtimeAnimations.push(this), this._animationState = {
						key: 0,
						repeatCount: 0,
						loopMode: this._getCorrectLoopMode()
					}, this._animation.dataType === Wg.ANIMATIONTYPE_MATRIX && (this._animationState.workValue = Hc.Zero()), this._keys = this._animation.getKeys(), this._minFrame = this._keys[0].frame, this._maxFrame = this._keys[this._keys.length - 1].frame, this._minValue = this._keys[0].value, this._maxValue = this._keys[this._keys.length - 1].value, 0 !== this._minFrame) {
					const e = {
						frame: 0,
						value: this._minValue
					};
					this._keys.splice(0, 0, e)
				}
				if (this._target instanceof Array) {
					let e = 0;
					for (const t of this._target) this._preparePath(t, e), this._getOriginalValues(e), e++;
					this._targetIsArray = !0
				} else this._preparePath(this._target), this._getOriginalValues(), this._targetIsArray = !1, this._directTarget = this._activeTargets[0];
				const n = t.getEvents();
				n && n.length > 0 && n.forEach((e => {
					this._events.push(e._clone())
				})), this._enableBlending = e && e.animationPropertiesOverride ? e.animationPropertiesOverride.enableBlending : this._animation.enableBlending
			}
			get isAdditive() {
				return this._host && this._host.isAdditive
			}
		},
		xS = class {
			get paused() {
				return this._paused
			}
			enableBlending(e) {
				const t = this._runtimeAnimations;
				for (let i = 0; i < t.length; i++) t[i].animation.enableBlending = !0, t[i].animation.blendingSpeed = e
			}
			get masterFrame() {
				return 0 === this._runtimeAnimations.length ? 0 : this._runtimeAnimations[0].currentFrame
			}
			get elapsedTime() {
				return null === this._localDelayOffset ? 0 : this._scene._animationTime - this._localDelayOffset
			}
			set speedRatio(e) {
				for (let t = 0; t < this._runtimeAnimations.length; t++) {
					this._runtimeAnimations[t]._prepareForSpeedRatioChange(e)
				}
				this._speedRatio = e, null !== this._goToFrame && this.goToFrame(this._goToFrame)
			}
			syncWith(e) {
				if (this._syncRoot = e, e) {
					const e = this._scene._activeAnimatables.indexOf(this);
					e > -1 && (this._scene._activeAnimatables.splice(e, 1), this._scene._activeAnimatables.push(this))
				}
				return this
			}
			waitAsync() {
				return new Promise((e => {
					this.onAnimationEndObservable.add((() => {
						e(this)
					}), void 0, void 0, this, !0)
				}))
			}
			_raiseOnAnimationEnd() {
				this.onAnimationEnd && this.onAnimationEnd(), this.onAnimationEndObservable.notifyObservers(this)
			}
			getRuntimeAnimationByTargetProperty(e) {
				const t = this._runtimeAnimations;
				for (let i = 0; i < t.length; i++)
					if (t[i].animation.targetProperty === e) return t[i];
				return null
			}
			disableBlending() {
				const e = this._runtimeAnimations;
				for (let t = 0; t < e.length; t++) e[t].animation.enableBlending = !1
			}
			appendAnimations(e, t) {
				for (let i = 0; i < t.length; i++) {
					const s = t[i],
						n = new bS(e, s, this._scene, this);
					n._onLoop = () => {
						this.onAnimationLoopObservable.notifyObservers(this), this.onAnimationLoop && this.onAnimationLoop()
					}, this._runtimeAnimations.push(n)
				}
			}
			get weight() {
				return this._weight
			}
			constructor(e, t, i = 0, s = 100, n = !1, a = 1, r, o, l, h = !1, c = 0) {
				this.target = t, this.fromFrame = i, this.toFrame = s, this.loopAnimation = n, this.onAnimationEnd = r, this.onAnimationLoop = l, this.isAdditive = h, this.playOrder = c, this._localDelayOffset = null, this._pausedDelay = null, this._manualJumpDelay = null, this._runtimeAnimations = new Array, this._paused = !1, this._speedRatio = 1, this._weight = -1, this._syncRoot = null, this._frameToSyncFromJump = null, this._goToFrame = null, this.disposeOnEnd = !0, this.animationStarted = !1, this.onAnimationEndObservable = new kc, this.onAnimationLoopObservable = new kc, this._scene = e, o && this.appendAnimations(t, o), this._speedRatio = a, e._activeAnimatables.push(this)
			}
			stop(e, t, i = !1, s = !1) {
				if (e || t) {
					const n = this._scene._activeAnimatables.indexOf(this);
					if (n > -1) {
						const a = this._runtimeAnimations;
						for (let i = a.length - 1; i >= 0; i--) {
							const s = a[i];
							e && s.animation.name != e || (t && !t(s.target) || (s.dispose(), a.splice(i, 1)))
						}
						0 == a.length && (i || this._scene._activeAnimatables.splice(n, 1), s || this._raiseOnAnimationEnd())
					}
				} else {
					const e = this._scene._activeAnimatables.indexOf(this);
					if (e > -1) {
						i || this._scene._activeAnimatables.splice(e, 1);
						const t = this._runtimeAnimations;
						for (let e = 0; e < t.length; e++) t[e].dispose();
						this._runtimeAnimations.length = 0, s || this._raiseOnAnimationEnd()
					}
				}
			}
			getAnimations() {
				return this._runtimeAnimations
			}
			pause() {
				this._paused || (this._paused = !0)
			}
			get speedRatio() {
				return this._speedRatio
			}
			getAnimationByTargetProperty(e) {
				const t = this._runtimeAnimations;
				for (let i = 0; i < t.length; i++)
					if (t[i].animation.targetProperty === e) return t[i].animation;
				return null
			}
			_animate(e) {
				if (this._paused) return this.animationStarted = !1, null === this._pausedDelay && (this._pausedDelay = e), !0;
				if (null === this._localDelayOffset ? (this._localDelayOffset = e, this._pausedDelay = null) : null !== this._pausedDelay && (this._localDelayOffset += e - this._pausedDelay, this._pausedDelay = null), null !== this._manualJumpDelay && (this._localDelayOffset += this._manualJumpDelay, this._manualJumpDelay = null, this._frameToSyncFromJump = null), this._goToFrame = null, 0 === this._weight) return !0;
				let t = !1;
				const i = this._runtimeAnimations;
				let s;
				for (s = 0; s < i.length; s++) {
					const n = i[s].animate(e - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);
					t = t || n
				}
				if (this.animationStarted = t, !t) {
					if (this.disposeOnEnd)
						for (s = this._scene._activeAnimatables.indexOf(this), this._scene._activeAnimatables.splice(s, 1), s = 0; s < i.length; s++) i[s].dispose();
					this._raiseOnAnimationEnd(), this.disposeOnEnd && (this.onAnimationEnd = null, this.onAnimationLoop = null, this.onAnimationLoopObservable.clear(), this.onAnimationEndObservable.clear())
				}
				return t
			}
			restart() {
				this._paused = !1
			}
			reset() {
				const e = this._runtimeAnimations;
				for (let t = 0; t < e.length; t++) e[t].reset(!0);
				this._localDelayOffset = null, this._pausedDelay = null
			}
			get syncRoot() {
				return this._syncRoot
			}
			set weight(e) {
				this._weight = -1 !== e ? Math.min(Math.max(e, 0), 1) : -1
			}
			goToFrame(e) {
				const t = this._runtimeAnimations;
				if (t[0]) {
					const i = t[0].animation.framePerSecond;
					this._frameToSyncFromJump = this._frameToSyncFromJump ?? t[0].currentFrame;
					const s = 0 === this.speedRatio ? 0 : (e - this._frameToSyncFromJump) / i * 1e3 / this.speedRatio;
					this._manualJumpDelay = -s
				}
				for (let i = 0; i < t.length; i++) t[i].goToFrame(e, this._weight);
				this._goToFrame = e
			}
		};
	bg.prototype._animate = function(e) {
		if (!this.animationsEnabled) return;
		const t = Pu.Now;
		if (!this._animationTimeLast) {
			if (this._pendingData.length > 0) return;
			this._animationTimeLast = t
		}
		this.deltaTime = void 0 !== e ? e : this.useConstantAnimationDeltaTime ? 16 : (t - this._animationTimeLast) * this.animationTimeScale, this._animationTimeLast = t;
		const i = this._activeAnimatables;
		if (0 === i.length) return;
		this._animationTime += this.deltaTime;
		const s = this._animationTime;
		for (let e = 0; e < i.length; e++) {
			const t = i[e];
			!t._animate(s) && t.disposeOnEnd && e--
		}
		this._processLateAnimationBindings()
	}, bg.prototype.sortActiveAnimatables = function() {
		this._activeAnimatables.sort(((e, t) => e.playOrder - t.playOrder))
	}, bg.prototype.beginWeightedAnimation = function(e, t, i, s = 1, n, a = 1, r, o, l, h, c = !1) {
		const u = this.beginAnimation(e, t, i, n, a, r, o, !1, l, h, c);
		return u.weight = s, u
	}, bg.prototype.beginAnimation = function(e, t, i, s, n = 1, a, r, o = !0, l, h, c = !1) {
		t > i && n > 0 && (n *= -1), o && this.stopAnimation(e, void 0, l), r || (r = new xS(this, e, t, i, s, n, a, void 0, h, c));
		const u = !l || l(e);
		if (e.animations && u && r.appendAnimations(e, e.animations), e.getAnimatables) {
			const c = e.getAnimatables();
			for (let e = 0; e < c.length; e++) this.beginAnimation(c[e], t, i, s, n, a, r, o, l, h)
		}
		return r.reset(), r
	}, bg.prototype.beginHierarchyAnimation = function(e, t, i, s, n, a = 1, r, o, l = !0, h, c, u = !1) {
		const m = e.getDescendants(t),
			d = [];
		d.push(this.beginAnimation(e, i, s, n, a, r, o, l, h, void 0, u));
		for (const e of m) d.push(this.beginAnimation(e, i, s, n, a, r, o, l, h, void 0, u));
		return d
	}, bg.prototype.beginDirectAnimation = function(e, t, i, s, n, a, r, o, l = !1) {
		if (void 0 === a && (a = 1), i > s && a > 0) a *= -1;
		else if (s > i && a < 0) {
			const e = s;
			s = i, i = e
		}
		return new xS(this, e, i, s, n, a, r, t, o, l)
	}, bg.prototype.beginDirectHierarchyAnimation = function(e, t, i, s, n, a, r, o, l, h = !1) {
		const c = e.getDescendants(t),
			u = [];
		u.push(this.beginDirectAnimation(e, i, s, n, a, r, o, l, h));
		for (const e of c) u.push(this.beginDirectAnimation(e, i, s, n, a, r, o, l, h));
		return u
	}, bg.prototype.getAnimatableByTarget = function(e) {
		for (let t = 0; t < this._activeAnimatables.length; t++)
			if (this._activeAnimatables[t].target === e) return this._activeAnimatables[t];
		return null
	}, bg.prototype.getAllAnimatablesByTarget = function(e) {
		const t = [];
		for (let i = 0; i < this._activeAnimatables.length; i++) this._activeAnimatables[i].target === e && t.push(this._activeAnimatables[i]);
		return t
	}, bg.prototype.stopAnimation = function(e, t, i) {
		const s = this.getAllAnimatablesByTarget(e);
		for (const e of s) e.stop(t, i)
	}, bg.prototype.stopAllAnimations = function() {
		if (this._activeAnimatables) {
			for (let e = 0; e < this._activeAnimatables.length; e++) this._activeAnimatables[e].stop(void 0, void 0, !0);
			this._activeAnimatables.length = 0
		}
		for (const e of this.animationGroups) e.stop()
	}, bg.prototype._registerTargetForLateAnimationBinding = function(e, t) {
		const i = e.target;
		this._registeredForLateAnimationBindings.pushNoDuplicate(i), i._lateAnimationHolders || (i._lateAnimationHolders = {}), i._lateAnimationHolders[e.targetPath] || (i._lateAnimationHolders[e.targetPath] = {
			totalWeight: 0,
			totalAdditiveWeight: 0,
			animations: [],
			additiveAnimations: [],
			originalValue: t
		}), e.isAdditive ? (i._lateAnimationHolders[e.targetPath].additiveAnimations.push(e), i._lateAnimationHolders[e.targetPath].totalAdditiveWeight += e.weight) : (i._lateAnimationHolders[e.targetPath].animations.push(e), i._lateAnimationHolders[e.targetPath].totalWeight += e.weight)
	}, bg.prototype._processLateAnimationBindingsForMatrices = function(e) {
		if (0 === e.totalWeight && 0 === e.totalAdditiveWeight) return e.originalValue;
		let t = 1;
		const i = Vc.Vector3[0],
			s = Vc.Vector3[1],
			n = Vc.uk[0];
		let a = 0;
		const r = e.animations[0],
			o = e.originalValue;
		let l = 1,
			h = !1;
		if (e.totalWeight < 1) l = 1 - e.totalWeight, o.decompose(s, n, i);
		else {
			if (a = 1, t = e.totalWeight, l = r.weight / t, 1 == l) {
				if (!e.totalAdditiveWeight) return r.currentValue;
				h = !0
			}
			r.currentValue.decompose(s, n, i)
		}
		if (!h) {
			s.scaleInPlace(l), i.scaleInPlace(l), n.scaleInPlace(l);
			for (let r = a; r < e.animations.length; r++) {
				const a = e.animations[r];
				if (0 === a.weight) continue;
				l = a.weight / t;
				const o = Vc.Vector3[2],
					h = Vc.Vector3[3],
					c = Vc.uk[1];
				a.currentValue.decompose(h, c, o), h.scaleAndAddToRef(l, s), c.scaleAndAddToRef(Gc.Dot(n, c) > 0 ? l : -l, n), o.scaleAndAddToRef(l, i)
			}
			n.normalize()
		}
		for (let t = 0; t < e.additiveAnimations.length; t++) {
			const a = e.additiveAnimations[t];
			if (0 === a.weight) continue;
			const r = Vc.Vector3[2],
				o = Vc.Vector3[3],
				l = Vc.uk[1];
			a.currentValue.decompose(o, l, r), o.multiplyToRef(s, o), Lc.LerpToRef(s, o, a.weight, s), n.multiplyToRef(l, l), Gc.SlerpToRef(n, l, a.weight, n), r.scaleAndAddToRef(a.weight, i)
		}
		const c = r ? r._animationState.workValue : Vc.Matrix[0].clone();
		return Hc.ComposeToRef(s, n, i, c), c
	}, bg.prototype._processLateAnimationBindingsForQuaternions = function(e, t) {
		if (0 === e.totalWeight && 0 === e.totalAdditiveWeight) return t;
		const i = e.animations[0],
			s = e.originalValue;
		let n = t;
		if (0 === e.totalWeight && e.totalAdditiveWeight > 0) n.copyFrom(s);
		else if (1 === e.animations.length) {
			if (Gc.SlerpToRef(s, i.currentValue, Math.min(1, e.totalWeight), n), 0 === e.totalAdditiveWeight) return n
		} else if (e.animations.length > 1) {
			let i, a, r = 1;
			if (e.totalWeight < 1) {
				const t = 1 - e.totalWeight;
				i = [], a = [], i.push(s), a.push(t)
			} else {
				if (2 === e.animations.length && (Gc.SlerpToRef(e.animations[0].currentValue, e.animations[1].currentValue, e.animations[1].weight / e.totalWeight, t), 0 === e.totalAdditiveWeight)) return t;
				i = [], a = [], r = e.totalWeight
			}
			for (let t = 0; t < e.animations.length; t++) {
				const s = e.animations[t];
				i.push(s.currentValue), a.push(s.weight / r)
			}
			let o = 0;
			for (let e = 0; e < i.length;) e ? (o += a[e], Gc.SlerpToRef(n, i[e], a[e] / o, n), e++) : (Gc.SlerpToRef(i[e], i[e + 1], a[e + 1] / (a[e] + a[e + 1]), t), n = t, o = a[e] + a[e + 1], e += 2)
		}
		for (let t = 0; t < e.additiveAnimations.length; t++) {
			const i = e.additiveAnimations[t];
			0 !== i.weight && (n.multiplyToRef(i.currentValue, Vc.uk[0]), Gc.SlerpToRef(n, Vc.uk[0], i.weight, n))
		}
		return n
	}, bg.prototype._processLateAnimationBindings = function() {
		if (this._registeredForLateAnimationBindings.length) {
			for (let e = 0; e < this._registeredForLateAnimationBindings.length; e++) {
				const t = this._registeredForLateAnimationBindings.data[e];
				for (const e in t._lateAnimationHolders) {
					const i = t._lateAnimationHolders[e],
						s = i.animations[0],
						n = i.originalValue;
					if (null == n) continue;
					const a = Wg.AllowMatrixDecomposeForInterpolation && n.m;
					let r = t[e];
					if (a) r = this._processLateAnimationBindingsForMatrices(i);
					else {
						if (void 0 !== n.w) r = this._processLateAnimationBindingsForQuaternions(i, r || Gc.Identity());
						else {
							let e = 0,
								t = 1;
							const a = s && s._animationState.loopMode === Wg.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;
							if (i.totalWeight < 1) r = a ? n.clone ? n.clone() : n : s && n.scale ? n.scale(1 - i.totalWeight) : s ? n * (1 - i.totalWeight) : n.clone ? n.clone() : n;
							else if (s) {
								t = i.totalWeight;
								const o = s.weight / t;
								r = 1 !== o ? s.currentValue.scale ? s.currentValue.scale(o) : s.currentValue * o : s.currentValue, a && (r.addToRef ? r.addToRef(n, r) : r += n), e = 1
							}
							for (let s = e; s < i.animations.length; s++) {
								const e = i.animations[s],
									n = e.weight / t;
								n && (e.currentValue.scaleAndAddToRef ? e.currentValue.scaleAndAddToRef(n, r) : r += e.currentValue * n)
							}
							for (let e = 0; e < i.additiveAnimations.length; e++) {
								const t = i.additiveAnimations[e],
									s = t.weight;
								s && (t.currentValue.scaleAndAddToRef ? t.currentValue.scaleAndAddToRef(s, r) : r += t.currentValue * s)
							}
						}
					}
					t[e] = r
				}
				t._lateAnimationHolders = {}
			}
			this._registeredForLateAnimationBindings.reset()
		}
	}, mS.prototype.copyAnimationRange = function(e, t, i, s = !1, n = null) {
		0 === this.animations.length && (this.animations.push(new Wg(this.name, "_matrix", e.animations[0].framePerSecond, Wg.ANIMATIONTYPE_MATRIX, 0)), this.animations[0].setKeys([]));
		const a = e.animations[0].getRange(t);
		if (!a) return !1;
		const r = a.from,
			o = a.to,
			l = e.animations[0].getKeys(),
			h = e.length,
			c = e.getParent(),
			u = this.getParent(),
			m = s && c && h && this.length && h !== this.length,
			d = m && u && c ? u.length / c.length : 1,
			f = s && !u && n && (1 !== n.x || 1 !== n.y || 1 !== n.z),
			p = this.animations[0].getKeys();
		let _, g, v;
		for (let e = 0, t = l.length; e < t; e++) _ = l[e], _.frame >= r && _.frame <= o && (s ? (v = _.value.clone(), m ? (g = v.getTranslation(), v.setTranslation(g.scaleInPlace(d))) : f && n ? (g = v.getTranslation(), v.setTranslation(g.multiplyInPlace(n))) : v = _.value) : v = _.value, p.push({
			frame: _.frame + i,
			value: v
		}));
		return this.animations[0].createRange(t, r + i, o + i), !0
	}, Dr(), Hr();
	var MS = class e {
		setMaterialForRendering(e, t) {
			this._depthMap.setMaterialForRendering(e, t)
		}
		get shaderLanguage() {
			return this._shaderLanguage
		}
		dispose() {
			const e = [];
			for (const t in this._scene._depthRenderer) {
				this._scene._depthRenderer[t] === this && e.push(t)
			}
			if (e.length > 0) {
				this._depthMap.dispose();
				for (const t of e) delete this._scene._depthRenderer[t]
			}
		}
		constructor(t, i = 1, s = null, n = !1, a = Np.TRILINEAR_SAMPLINGMODE, r = !1, o) {
			this._shaderLanguage = 0, this.enabled = !0, this.forceDepthWriteTransparentMeshes = !1, this.useOnlyInActiveCamera = !1, this.reverseCulling = !1, this._shadersLoaded = !1, this._scene = t, this._storeNonLinearDepth = n, this._storeCameraSpaceZ = r, this.isPacked = 0 === i, this.isPacked ? this.clearColor = new wc(1, 1, 1, 1) : this.clearColor = new wc(r ? 1e8 : 1, 0, 0, 1), this._initShaderSourceAsync(), e._SceneComponentInitialization(this._scene);
			const l = t.getEngine();
			this._camera = s, a !== Np.NEAREST_SAMPLINGMODE && (1 !== i || l._caps.textureFloatLinearFiltering || (a = Np.NEAREST_SAMPLINGMODE), 2 !== i || l._caps.textureHalfFloatLinearFiltering || (a = Np.NEAREST_SAMPLINGMODE));
			const h = this.isPacked || !l._features.supportExtendedTextureFormats ? 5 : 6;
			this._depthMap = new r_(o ?? "DepthRenderer", {
				width: l.getRenderWidth(),
				height: l.getRenderHeight()
			}, this._scene, !1, !0, i, !1, a, void 0, void 0, void 0, h), this._depthMap.wrapU = Np.CLAMP_ADDRESSMODE, this._depthMap.wrapV = Np.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.Tk = null, this._depthMap.noPrePassRenderer = !0, this._depthMap.activeCamera = this._camera, this._depthMap.ignoreCameraViewport = !0, this._depthMap.useCameraPostProcesses = !1, this._depthMap.onClearObservable.add((e => {
				e.clear(this.clearColor, !0, !0, !0)
			})), this._depthMap.onBeforeBindObservable.add((() => {
				l._debugPushGroup?.("depth renderer", 1)
			})), this._depthMap.onAfterUnbindObservable.add((() => {
				l._debugPopGroup?.(1)
			})), this._depthMap.customIsReadyFunction = (e, t, i) => {
				if ((i || 0 === t) && e.subMeshes)
					for (let t = 0; t < e.subMeshes.length; ++t) {
						const i = e.subMeshes[t],
							s = i.getRenderingMesh(),
							n = s._getInstancesRenderList(i._id, !!i.getReplacementMesh()),
							a = l.getCaps().instancedArrays && (null !== n.visibleInstances[i._id] && void 0 !== n.visibleInstances[i._id] || s.hasThinInstances);
						if (!this.isReady(i, a)) return !1
					}
				return !0
			};
			const c = e => {
				const t = e.getRenderingMesh(),
					i = e.getEffectiveMesh(),
					s = this._scene,
					n = s.getEngine(),
					a = e.getMaterial();
				if (i._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !a || i.infiniteDistance || a.disableDepthWrite || 0 === e.verticesCount || e._renderId === s.getRenderId()) return;
				const r = i._getWorldMatrixDeterminant() < 0;
				let o = a._getEffectiveOrientation(t);
				r && (o = 0 === o ? 1 : 0);
				const l = 0 === o;
				n.setState(a.backFaceCulling, 0, !1, l, this.reverseCulling ? !a.cullBackFaces : a.cullBackFaces);
				const h = t._getInstancesRenderList(e._id, !!e.getReplacementMesh());
				if (h.mustReturn) return;
				const c = n.getCaps().instancedArrays && (null !== h.visibleInstances[e._id] && void 0 !== h.visibleInstances[e._id] || t.hasThinInstances),
					u = this._camera || s.activeCamera;
				if (this.isReady(e, c) && u) {
					e._renderId = s.getRenderId();
					const r = i._internalAbstractMeshDataInfo._materialForRenderPass?.[n.currentRenderPassId];
					let o = e._getDrawWrapper();
					!o && r && (o = r._getDrawWrapper());
					const l = u.mode === Sd.ORTHOGRAPHIC_CAMERA;
					if (!o) return;
					const m = o.effect;
					let d, f;
					if (n.enableEffect(o), c || t._bind(e, m, a.fillMode), r ? r.bindForSubMesh(i.getWorldMatrix(), i, e) : (m.setMatrix("viewProjection", s.getTransformMatrix()), m.setMatrix("world", i.getWorldMatrix()), this._storeCameraSpaceZ && m.setMatrix("view", s.getViewMatrix())), l ? (d = !n.useReverseDepthBuffer && n.isNDCHalfZRange ? 0 : 1, f = n.useReverseDepthBuffer && n.isNDCHalfZRange ? 0 : 1) : (d = n.useReverseDepthBuffer && n.isNDCHalfZRange ? u.minZ : n.isNDCHalfZRange ? 0 : u.minZ, f = n.useReverseDepthBuffer && n.isNDCHalfZRange ? 0 : u.maxZ), m.setFloat2("depthValues", d, d + f), !r) {
						if (a.needAlphaTesting()) {
							const e = a.getAlphaTestTexture();
							e && (m.setTexture("diffuseSampler", e), m.setMatrix("diffuseMatrix", e.getTextureMatrix()))
						}
						if (t.useBones && t.computeBonesUsingShaders && t.skeleton) {
							const e = t.skeleton;
							if (e.isUsingTextureForMatrices) {
								const i = e.getTransformMatrixTexture(t);
								if (!i) return;
								m.setTexture("boneSampler", i), m.setFloat("boneTextureWidth", 4 * (e.bones.length + 1))
							} else m.setMatrices("mBones", e.getTransformMatrices(t))
						}
						Qd(m, a, s), lf(t, m), t.morphTargetManager && t.morphTargetManager.isUsingTextureForTargets && t.morphTargetManager._bind(m), a.pointsCloud && m.setFloat("pointSize", a.pointSize)
					}
					t._processRendering(i, e, m, a.fillMode, h, c, ((e, t) => m.setMatrix("world", t)))
				}
			};
			this._depthMap.customRenderFunction = (e, t, i, s) => {
				let n;
				if (s.length)
					for (n = 0; n < s.length; n++) c(s.data[n]);
				for (n = 0; n < e.length; n++) c(e.data[n]);
				for (n = 0; n < t.length; n++) c(t.data[n]);
				if (this.forceDepthWriteTransparentMeshes)
					for (n = 0; n < i.length; n++) c(i.data[n]);
				else
					for (n = 0; n < i.length; n++) i.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1
			}
		}
		isReady(e, t) {
			if (!this._shadersLoaded) return !1;
			const i = this._scene.getEngine(),
				s = e.getMesh(),
				n = s.getScene(),
				a = s._internalAbstractMeshDataInfo._materialForRenderPass?.[i.currentRenderPassId];
			if (a) return a.isReadyForSubMesh(s, e, t);
			const r = e.getMaterial();
			if (!r || r.disableDepthWrite) return !1;
			const o = [],
				l = [eu.PositionKind];
			if (r && r.needAlphaTesting() && r.getAlphaTestTexture() && (o.push("#define ALPHATEST"), s.isVerticesDataPresent(eu.UVKind) && (l.push(eu.UVKind), o.push("#define UV1")), s.isVerticesDataPresent(eu.UV2Kind) && (l.push(eu.UV2Kind), o.push("#define UV2"))), s.useBones && s.computeBonesUsingShaders) {
				l.push(eu.MatricesIndicesKind), l.push(eu.MatricesWeightsKind), s.numBoneInfluencers > 4 && (l.push(eu.MatricesIndicesExtraKind), l.push(eu.MatricesWeightsExtraKind)), o.push("#define NUM_BONE_INFLUENCERS " + s.numBoneInfluencers), o.push("#define BonesPerMesh " + (s.skeleton ? s.skeleton.bones.length + 1 : 0));
				const t = e.getRenderingMesh().skeleton;
				t?.isUsingTextureForMatrices && o.push("#define BONETEXTURE")
			} else o.push("#define NUM_BONE_INFLUENCERS 0");
			const h = s.morphTargetManager;
			let c = 0;
			h && (c = h.numMaxInfluencers || h.numInfluencers, c > 0 && (o.push("#define MORPHTARGETS"), o.push("#define NUM_MORPH_INFLUENCERS " + c), h.isUsingTextureForTargets && o.push("#define MORPHTARGETS_TEXTURE"), af(l, s, c))), r.pointsCloud && o.push("#define POINTSIZE"), t && (o.push("#define INSTANCES"), of(l), e.getRenderingMesh().hasThinInstances && o.push("#define THIN_INSTANCES")), this._storeNonLinearDepth && o.push("#define NONLINEARDEPTH"), this._storeCameraSpaceZ && o.push("#define STORE_CAMERASPACE_Z"), this.isPacked && o.push("#define PACKED"), qd(r, n, o);
			const u = e._getDrawWrapper(void 0, !0),
				m = u.defines,
				d = o.join("\n");
			if (m !== d) {
				const e = ["world", "mBones", "boneTextureWidth", "pointSize", "viewProjection", "view", "diffuseMatrix", "depthValues", "morphTargetInfluences", "morphTargetCount", "morphTargetTextureInfo", "morphTargetTextureIndices"];
				Jd(e), u.setEffect(i.createEffect("depth", l, e, ["diffuseSampler", "morphTargets", "boneSampler"], d, void 0, void 0, void 0, {
					maxSimultaneousMorphTargets: c
				}, this._shaderLanguage), d)
			}
			return u.effect.isReady()
		}
		getDepthMap() {
			return this._depthMap
		}
		async _initShaderSourceAsync(t = !1) {
			!this._scene.getEngine().isWebGPU || t || e.ForceGLSL ? await Promise.all([Promise.resolve().then((() => (Hr(), Fr))), Promise.resolve().then((() => (Dr(), Nr)))]) : (this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (Xr(), Ur))), Promise.resolve().then((() => (Jr(), Yr)))])), this._shadersLoaded = !0
		}
	};
	MS.ForceGLSL = !1, MS._SceneComponentInitialization = e => {
		throw ic("DepthRendererSceneComponent")
	}, h();
	e.ShadersStore.minmaxReduxPixelShader = "varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n";
	var CS = class {
			get refreshRate() {
				return this._sourceTexture ? this._sourceTexture.refreshRate : -1
			}
			dispose(e = !0) {
				if (e && (this.onAfterReductionPerformed.clear(), this._onContextRestoredObserver && (this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)), this.deactivate(), this._reductionSteps) {
					for (let e = 0; e < this._reductionSteps.length; ++e) this._reductionSteps[e].dispose();
					this._reductionSteps = null
				}
				this._postProcessManager && e && this._postProcessManager.dispose(), this._sourceTexture = null
			}
			constructor(e) {
				this.onAfterReductionPerformed = new kc, this._forceFullscreenViewport = !0, this._activated = !1, this._camera = e, this._postProcessManager = new Kp(e.getScene()), this._onContextRestoredObserver = e.getEngine().onContextRestoredObservable.add((() => {
					this._postProcessManager._rebuild()
				}))
			}
			set refreshRate(e) {
				this._sourceTexture && (this._sourceTexture.refreshRate = e)
			}
			setSourceTexture(e, t, i = 2, s = !0) {
				if (e === this._sourceTexture) return;
				this.dispose(!1), this._sourceTexture = e, this._reductionSteps = [], this._forceFullscreenViewport = s;
				const n = this._camera.getScene(),
					a = new Bp("Initial reduction phase", "minmaxRedux", ["texSize"], ["sourceTexture"], 1, null, 1, n.getEngine(), !1, "#define INITIAL" + (t ? "\n#define DEPTH_REDUX" : ""), i, void 0, void 0, void 0, 7);
				a.autoClear = !1, a.forceFullscreenViewport = s;
				let r = this._sourceTexture.getRenderWidth(),
					o = this._sourceTexture.getRenderHeight();
				a.onApply = ((e, t) => i => {
					i.setTexture("sourceTexture", this._sourceTexture), i.setFloat2("texSize", e, t)
				})(r, o), this._reductionSteps.push(a);
				let l = 1;
				for (; r > 1 || o > 1;) {
					r = Math.max(Math.round(r / 2), 1), o = Math.max(Math.round(o / 2), 1);
					const e = new Bp("Reduction phase " + l, "minmaxRedux", ["texSize"], null, {
						width: r,
						height: o
					}, null, 1, n.getEngine(), !1, "#define " + (1 == r && 1 == o ? "LAST" : 1 == r || 1 == o ? "ONEBEFORELAST" : "MAIN"), i, void 0, void 0, void 0, 7);
					if (e.autoClear = !1, e.forceFullscreenViewport = s, e.onApply = ((e, t) => i => {
							1 == e || 1 == t ? i.setInt2("texSize", e, t) : i.setFloat2("texSize", e, t)
						})(r, o), this._reductionSteps.push(e), l++, 1 == r && 1 == o) {
						const t = (e, t, i) => {
							const s = new Float32Array(4 * e * t),
								a = {
									min: 0,
									max: 0
								};
							return () => {
								n.getEngine()._readTexturePixels(i.inputTexture.texture, e, t, -1, 0, s, !1), a.min = s[0], a.max = s[1], this.onAfterReductionPerformed.notifyObservers(a)
							}
						};
						e.onAfterRenderObservable.add(t(r, o, e))
					}
				}
			}
			activate() {
				!this._onAfterUnbindObserver && this._sourceTexture && (this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add((() => {
					const e = this._camera.getScene().getEngine();
					e._debugPushGroup?.("min max reduction", 1), this._reductionSteps[0].activate(this._camera), this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport), e.unBindFramebuffer(this._reductionSteps[0].inputTexture, !1), e._debugPopGroup?.(1)
				})), this._activated = !0)
			}
			deactivate() {
				this._onAfterUnbindObserver && this._sourceTexture && (this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = null, this._activated = !1)
			}
			get sourceTexture() {
				return this._sourceTexture
			}
			get activated() {
				return this._activated
			}
		},
		TS = class extends CS {
			constructor(e) {
				super(e)
			}
			dispose(e = !0) {
				if (super.dispose(e), this._depthRenderer && e) {
					const e = this._depthRenderer.getDepthMap().getScene();
					e && delete e._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null
				}
			}
			deactivate() {
				super.deactivate(), this._depthRenderer && (this._depthRenderer.enabled = !1)
			}
			setSourceTexture(e, t, i = 2, s = !0) {
				super.setSourceTexture(e, t, i, s)
			}
			activate() {
				this._depthRenderer && (this._depthRenderer.enabled = !0), super.activate()
			}
			setDepthRenderer(e = null, t = 2, i = !0) {
				const s = this._camera.getScene();
				this._depthRenderer && (delete s._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null), null === e && (s._depthRenderer || (s._depthRenderer = {}), (e = this._depthRenderer = new MS(s, t, this._camera, !1, 1)).enabled = !1, this._depthRendererId = "minmax" + this._camera.id, s._depthRenderer[this._depthRendererId] = e), super.setSourceTexture(e.getDepthMap(), !0, t, i)
			}
			get depthRenderer() {
				return this._depthRenderer
			}
		},
		wS = Lc.Up(),
		RS = Lc.Zero(),
		NS = new Lc,
		IS = new Lc,
		PS = new Hc,
		kS = class e extends Rg {
			_bindCustomEffectForRenderSubMeshForShadowMap(e, t) {
				t.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer))
			}
			getCascadeMaxExtents(e) {
				return e >= 0 && e < this._numCascades ? this._cascadeMaxExtents[e] : null
			}
			_validateFilter(e) {
				return e === Rg.FILTER_NONE || e === Rg.FILTER_PCF || e === Rg.FILTER_PCSS ? e : (Qc.Error('Unsupported filter "' + e + '"!'), Rg.FILTER_NONE)
			}
			_recreateSceneUBOs() {
				if (this._disposeSceneUBOs(), this._sceneUBOs)
					for (let e = 0; e < this._numCascades; ++e) this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))
			}
			set shadowMaxZ(e) {
				const t = this._getCamera();
				t ? this._shadowMaxZ === e || e < t.minZ || e > t.maxZ && 0 !== t.maxZ || (this._shadowMaxZ = e, this._light._markMeshesAsLightDirty(), this._breaksAreDirty = !0) : this._shadowMaxZ = e
			}
			serialize() {
				const e = super.serialize(),
					t = this.getShadowMap();
				if (!t) return e;
				if (e.numCascades = this._numCascades, e.debug = this._debug, e.stabilizeCascades = this.stabilizeCascades, e.lambda = this._lambda, e.cascadeBlendPercentage = this.cascadeBlendPercentage, e.depthClamp = this._depthClamp, e.autoCalcDepthBounds = this.autoCalcDepthBounds, e.shadowMaxZ = this._shadowMaxZ, e.penumbraDarkness = this.penumbraDarkness, e.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo, e.minDistance = this.minDistance, e.maxDistance = this.maxDistance, e.Tk = [], t.Tk)
					for (let i = 0; i < t.Tk.length; i++) {
						const s = t.Tk[i];
						e.Tk.push(s.id)
					}
				return e
			}
			get autoCalcDepthBounds() {
				return this._autoCalcDepthBounds
			}
			prepareDefines(e, t) {
				super.prepareDefines(e, t);
				const i = this._scene,
					s = this._light;
				if (!i.shadowsEnabled || !s.shadowEnabled) return;
				e["SHADOWCSM" + t] = !0, e["SHADOWCSMDEBUG" + t] = this.debug, e["SHADOWCSMNUM_CASCADES" + t] = this.numCascades, e["SHADOWCSM_RIGHTHANDED" + t] = i.useRightHandedSystem;
				const n = this._getCamera();
				n && this._shadowMaxZ <= (n.maxZ || this._shadowMaxZ) && (e["SHADOWCSMUSESHADOWMAXZ" + t] = !0), 0 === this.cascadeBlendPercentage && (e["SHADOWCSMNOBLEND" + t] = !0)
			}
			get autoCalcDepthBoundsRefreshRate() {
				return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1
			}
			getCascadeMinExtents(e) {
				return e >= 0 && e < this._numCascades ? this._cascadeMinExtents[e] : null
			}
			static get IsSupported() {
				const e = Dc.LastCreatedEngine;
				return !!e && e._features.supportCSM
			}
			_createTargetRenderTexture() {
				const e = this._scene.getEngine(),
					t = {
						width: this._mapSize,
						height: this._mapSize,
						layers: this.numCascades
					};
				this._shadowMap = new r_(this._light.name + "_CSMShadowMap", t, this._scene, !1, !0, this._textureType, !1, void 0, !1, !1, void 0, this._useRedTextureType ? 6 : 5), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0, void 0, void 0, void 0, `DepthStencilForCSMShadowGenerator-${this._light.name}`), this._shadowMap.noPrePassRenderer = !0
			}
			setDepthRenderer(e) {
				this._depthRenderer = e, this._depthReducer && this._depthReducer.setDepthRenderer(this._depthRenderer)
			}
			set autoCalcDepthBoundsRefreshRate(e) {
				this._depthReducer?.depthRenderer && (this._depthReducer.depthRenderer.getDepthMap().refreshRate = e)
			}
			_splitFrustum() {
				const e = this._getCamera();
				if (!e) return;
				const t = e.minZ,
					i = e.maxZ || this._shadowMaxZ,
					s = i - t,
					n = this._minDistance,
					a = t + n * s,
					r = t + (this._shadowMaxZ < i && this._shadowMaxZ >= t ? Math.min((this._shadowMaxZ - t) / (i - t), this._maxDistance) : this._maxDistance) * s,
					o = r - a,
					l = r / a;
				for (let e = 0; e < this._cascades.length; ++e) {
					const i = (e + 1) / this._numCascades,
						r = a * l ** i,
						h = a + o * i,
						c = this._lambda * (r - h) + h;
					this._cascades[e].prevBreakDistance = 0 === e ? n : this._cascades[e - 1].breakDistance, this._cascades[e].breakDistance = (c - t) / s, this._viewSpaceFrustumsZ[e] = c, this._frustumLengths[e] = (this._cascades[e].breakDistance - this._cascades[e].prevBreakDistance) * s
				}
				this._breaksAreDirty = !1
			}
			get lambda() {
				return this._lambda
			}
			get cascadeBlendPercentage() {
				return this._cascadeBlendPercentage
			}
			bindShadowLight(e, t) {
				const i = this._light;
				if (!this._scene.shadowsEnabled || !i.shadowEnabled) return;
				const s = this._getCamera();
				if (!s) return;
				const n = this.getShadowMap();
				if (!n) return;
				const a = n.getSize().width;
				if (t.setMatrices("lightMatrix" + e, this._transformMatricesAsArray), t.setArray("viewFrustumZ" + e, this._viewSpaceFrustumsZ), t.setFloat("cascadeBlendFactor" + e, 0 === this.cascadeBlendPercentage ? 1e4 : 1 / this.cascadeBlendPercentage), t.setArray("frustumLengths" + e, this._frustumLengths), this._filter === Rg.FILTER_PCF) t.setDepthStencilTexture("shadowTexture" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
				else if (this._filter === Rg.FILTER_PCSS) {
					for (let e = 0; e < this._numCascades; ++e) this._lightSizeUVCorrection[2 * e + 0] = 0 === e ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[e].x - this._cascadeMinExtents[e].x), this._lightSizeUVCorrection[2 * e + 1] = 0 === e ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[e].y - this._cascadeMinExtents[e].y), this._depthCorrection[e] = 0 === e ? 1 : (this._cascadeMaxExtents[e].z - this._cascadeMinExtents[e].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
					t.setDepthStencilTexture("shadowTexture" + e, n), t.setTexture("depthTexture" + e, n), t.setArray2("lightSizeUVCorrection" + e, this._lightSizeUVCorrection), t.setArray("depthCorrection" + e, this._depthCorrection), t.setFloat("penumbraDarkness" + e, this.penumbraDarkness), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / a, this._contactHardeningLightSizeUVRatio * a, this.frustumEdgeFalloff, e)
				} else t.setTexture("shadowTexture" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
				i._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(s), this.getLight().getDepthMinZ(s) + this.getLight().getDepthMaxZ(s), e)
			}
			get depthClamp() {
				return this._depthClamp
			}
			get numCascades() {
				return this._numCascades
			}
			set depthClamp(e) {
				this._depthClamp = e
			}
			set shadowCastersBoundingInfo(e) {
				this._shadowCastersBoundingInfo = e
			}
			get maxDistance() {
				return this._maxDistance
			}
			get freezeShadowCastersBoundingInfo() {
				return this._freezeShadowCastersBoundingInfo
			}
			get shadowMaxZ() {
				return this._getCamera() ? this._shadowMaxZ : 0
			}
			_computeFrustumInWorldSpace(t) {
				const i = this._getCamera();
				if (!i) return;
				const s = this._cascades[t].prevBreakDistance,
					n = this._cascades[t].breakDistance,
					a = this._scene.getEngine().isNDCHalfZRange;
				i.getViewMatrix();
				const r = 0 === i.maxZ,
					o = i.maxZ;
				r && (i.maxZ = this._shadowMaxZ, i.getProjectionMatrix(!0));
				const l = Hc.Invert(i.getTransformationMatrix());
				r && (i.maxZ = o, i.getProjectionMatrix(!0));
				const h = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
				for (let i = 0; i < e._FrustumCornersNDCSpace.length; ++i) NS.copyFrom(e._FrustumCornersNDCSpace[(i + h) % e._FrustumCornersNDCSpace.length]), a && -1 === NS.z && (NS.z = 0), Lc.TransformCoordinatesToRef(NS, l, this._frustumCornersWorldSpace[t][i]);
				for (let i = 0; i < e._FrustumCornersNDCSpace.length / 2; ++i) NS.copyFrom(this._frustumCornersWorldSpace[t][i + 4]).subtractInPlace(this._frustumCornersWorldSpace[t][i]), IS.copyFrom(NS).scaleInPlace(s), NS.scaleInPlace(n), NS.addInPlace(this._frustumCornersWorldSpace[t][i]), this._frustumCornersWorldSpace[t][i + 4].copyFrom(NS), this._frustumCornersWorldSpace[t][i].addInPlace(IS)
			}
			get minDistance() {
				return this._minDistance
			}
			get shadowCastersBoundingInfo() {
				return this._shadowCastersBoundingInfo
			}
			_computeMatrices() {
				const e = this._scene;
				if (!this._getCamera()) return;
				Lc.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection), 1 === Math.abs(Lc.Dot(this._lightDirection, Lc.Up())) && (this._lightDirection.z = 1e-13), this._cachedDirection.copyFrom(this._lightDirection);
				const t = e.getEngine().useReverseDepthBuffer;
				for (let i = 0; i < this._numCascades; ++i) {
					this._computeFrustumInWorldSpace(i), this._computeCascadeFrustum(i), this._cascadeMaxExtents[i].subtractToRef(this._cascadeMinExtents[i], NS), this._frustumCenter[i].addToRef(this._lightDirection.scale(this._cascadeMinExtents[i].z), this._shadowCameraPos[i]), Hc.LookAtLHToRef(this._shadowCameraPos[i], this._frustumCenter[i], wS, this._viewMatrices[i]);
					let s = 0,
						n = NS.z;
					const a = this._shadowCastersBoundingInfo;
					a.update(this._viewMatrices[i]), n = Math.min(n, a.boundingBox.maximumWorld.z), s = this._depthClamp && this.filter !== Rg.FILTER_PCSS ? Math.max(s, a.boundingBox.minimumWorld.z) : Math.min(s, a.boundingBox.minimumWorld.z), Hc.OrthoOffCenterLHToRef(this._cascadeMinExtents[i].x, this._cascadeMaxExtents[i].x, this._cascadeMinExtents[i].y, this._cascadeMaxExtents[i].y, t ? n : s, t ? s : n, this._projectionMatrices[i], e.getEngine().isNDCHalfZRange), this._cascadeMinExtents[i].z = s, this._cascadeMaxExtents[i].z = n, this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i], this._transformMatrices[i]), Lc.TransformCoordinatesToRef(RS, this._transformMatrices[i], NS), NS.scaleInPlace(this._mapSize / 2), IS.copyFromFloats(Math.round(NS.x), Math.round(NS.y), Math.round(NS.z)), IS.subtractInPlace(NS).scaleInPlace(2 / this._mapSize), Hc.TranslationToRef(IS.x, IS.y, 0, PS), this._projectionMatrices[i].multiplyToRef(PS, this._projectionMatrices[i]), this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i], this._transformMatrices[i]), this._transformMatrices[i].copyToArray(this._transformMatricesAsArray, 16 * i)
				}
			}
			getClassName() {
				return e.CLASSNAME
			}
			set freezeShadowCastersBoundingInfo(e) {
				this._freezeShadowCastersBoundingInfoObservable && e && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), this._freezeShadowCastersBoundingInfoObservable || e || (this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add((() => this._computeShadowCastersBoundingInfo()))), this._freezeShadowCastersBoundingInfo = e, e && this._computeShadowCastersBoundingInfo()
			}
			_computeCascadeFrustum(e) {
				this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), this._frustumCenter[e].copyFromFloats(0, 0, 0);
				if (this._getCamera()) {
					for (let t = 0; t < this._frustumCornersWorldSpace[e].length; ++t) this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][t]);
					if (this._frustumCenter[e].scaleInPlace(1 / this._frustumCornersWorldSpace[e].length), this.stabilizeCascades) {
						let t = 0;
						for (let i = 0; i < this._frustumCornersWorldSpace[e].length; ++i) {
							const s = this._frustumCornersWorldSpace[e][i].subtractToRef(this._frustumCenter[e], NS).length();
							t = Math.max(t, s)
						}
						t = Math.ceil(16 * t) / 16, this._cascadeMaxExtents[e].copyFromFloats(t, t, t), this._cascadeMinExtents[e].copyFromFloats(-t, -t, -t)
					} else {
						const t = this._frustumCenter[e];
						this._frustumCenter[e].addToRef(this._lightDirection, NS), Hc.LookAtLHToRef(t, NS, wS, PS);
						for (let t = 0; t < this._frustumCornersWorldSpace[e].length; ++t) Lc.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][t], PS, NS), this._cascadeMinExtents[e].minimizeInPlace(NS), this._cascadeMaxExtents[e].maximizeInPlace(NS)
					}
				}
			}
			dispose() {
				super.dispose(), this._freezeShadowCastersBoundingInfoObservable && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), this._depthReducer && (this._depthReducer.dispose(), this._depthReducer = null)
			}
			getCascadeTransformMatrix(e) {
				return e >= 0 && e < this._numCascades ? this._transformMatrices[e] : null
			}
			constructor(t, i, s, n, a = !0) {
				e.IsSupported ? (super(t, i, s, n, a), this.usePercentageCloserFiltering = !0) : Qc.Error("CascadedShadowMap is not supported by the current engine.")
			}
			set debug(e) {
				this._debug = e, this._light._markMeshesAsLightDirty()
			}
			setMinMaxDistance(e, t) {
				this._minDistance === e && this._maxDistance === t || (e > t && (e = 0, t = 1), e < 0 && (e = 0), t > 1 && (t = 1), this._minDistance = e, this._maxDistance = t, this._breaksAreDirty = !0)
			}
			set numCascades(t) {
				(t = Math.min(Math.max(t, e.MIN_CASCADES_COUNT), e.MAX_CASCADES_COUNT)) !== this._numCascades && (this._numCascades = t, this.recreateShadowMap(), this._recreateSceneUBOs())
			}
			set autoCalcDepthBounds(e) {
				const t = this._getCamera();
				if (t) {
					if (this._autoCalcDepthBounds = e, !e) return this._depthReducer && this._depthReducer.deactivate(), void this.setMinMaxDistance(0, 1);
					this._depthReducer || (this._depthReducer = new TS(t), this._depthReducer.onAfterReductionPerformed.add((e => {
						let t = e.min,
							i = e.max;
						t >= i && (t = 0, i = 1), t == this._minDistance && i == this._maxDistance || this.setMinMaxDistance(t, i)
					})), this._depthReducer.setDepthRenderer(this._depthRenderer)), this._depthReducer.activate()
				}
			}
			getTransformMatrix() {
				return this.getCascadeTransformMatrix(0)
			}
			get debug() {
				return this._debug
			}
			_initializeShadowMap() {
				if (super._initializeShadowMap(), null === this._shadowMap) return;
				this._transformMatricesAsArray = new Float32Array(16 * this._numCascades), this._viewSpaceFrustumsZ = new Array(this._numCascades), this._frustumLengths = new Array(this._numCascades), this._lightSizeUVCorrection = new Array(2 * this._numCascades), this._depthCorrection = new Array(this._numCascades), this._cascades = [], this._viewMatrices = [], this._projectionMatrices = [], this._transformMatrices = [], this._cascadeMinExtents = [], this._cascadeMaxExtents = [], this._frustumCenter = [], this._shadowCameraPos = [], this._frustumCornersWorldSpace = [];
				for (let t = 0; t < this._numCascades; ++t) {
					this._cascades[t] = {
						prevBreakDistance: 0,
						breakDistance: 0
					}, this._viewMatrices[t] = Hc.Zero(), this._projectionMatrices[t] = Hc.Zero(), this._transformMatrices[t] = Hc.Zero(), this._cascadeMinExtents[t] = new Lc, this._cascadeMaxExtents[t] = new Lc, this._frustumCenter[t] = new Lc, this._shadowCameraPos[t] = new Lc, this._frustumCornersWorldSpace[t] = new Array(e._FrustumCornersNDCSpace.length);
					for (let i = 0; i < e._FrustumCornersNDCSpace.length; ++i) this._frustumCornersWorldSpace[t][i] = new Lc
				}
				const t = this._scene.getEngine();
				this._shadowMap.onBeforeBindObservable.clear(), this._shadowMap.onBeforeRenderObservable.clear(), this._shadowMap.onBeforeRenderObservable.add((e => {
					this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[e]), this._currentLayer = e, this._filter === Rg.FILTER_PCF && t.setColorWrite(!1), this._scene.setTransformMatrix(this.getCascadeViewMatrix(e), this.getCascadeProjectionMatrix(e)), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo())
				})), this._shadowMap.onBeforeBindObservable.add((() => {
					this._currentSceneUBO = this._scene.getSceneUniformBuffer(), t._debugPushGroup?.(`cascaded shadow map generation for pass id ${t.currentRenderPassId}`, 1), this._breaksAreDirty && this._splitFrustum(), this._computeMatrices()
				})), this._splitFrustum()
			}
			_initializeGenerator() {
				this.penumbraDarkness = this.penumbraDarkness ?? 1, this._numCascades = this._numCascades ?? e.DEFAULT_CASCADES_COUNT, this.stabilizeCascades = this.stabilizeCascades ?? !1, this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null, this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? !1, this._scbiMin = this._scbiMin ?? new Lc(0, 0, 0), this._scbiMax = this._scbiMax ?? new Lc(0, 0, 0), this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new yu(new Lc(0, 0, 0), new Lc(0, 0, 0)), this._breaksAreDirty = this._breaksAreDirty ?? !0, this._minDistance = this._minDistance ?? 0, this._maxDistance = this._maxDistance ?? 1, this._currentLayer = this._currentLayer ?? 0, this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 1e4, this._debug = this._debug ?? !1, this._depthClamp = this._depthClamp ?? !0, this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? .1, this._lambda = this._lambda ?? .5, this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? !1, this._recreateSceneUBOs(), super._initializeGenerator()
			}
			_computeShadowCastersBoundingInfo() {
				if (this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), this._shadowMap && this._shadowMap.Tk) {
					const e = this._shadowMap.Tk;
					for (let t = 0; t < e.length; t++) {
						const i = e[t];
						if (!i) continue;
						const s = i.getBoundingInfo().boundingBox;
						this._scbiMin.minimizeInPlace(s.minimumWorld), this._scbiMax.maximizeInPlace(s.maximumWorld)
					}
					const t = this._scene.meshes;
					for (let e = 0; e < t.length; e++) {
						const i = t[e];
						if (!(i && i.isVisible && i.isEnabled && i.receiveShadows)) continue;
						const s = i.getBoundingInfo().boundingBox;
						this._scbiMin.minimizeInPlace(s.minimumWorld), this._scbiMax.maximizeInPlace(s.maximumWorld)
					}
				}
				this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax)
			}
			getCascadeProjectionMatrix(e) {
				return e >= 0 && e < this._numCascades ? this._projectionMatrices[e] : null
			}
			set cascadeBlendPercentage(e) {
				this._cascadeBlendPercentage = e, this._light._markMeshesAsLightDirty()
			}
			static Parse(t, i) {
				const s = Rg.Parse(t, i, ((t, i, s) => new e(t, i, void 0, s)));
				return void 0 !== t.numCascades && (s.numCascades = t.numCascades), void 0 !== t.debug && (s.debug = t.debug), void 0 !== t.stabilizeCascades && (s.stabilizeCascades = t.stabilizeCascades), void 0 !== t.lambda && (s.lambda = t.lambda), void 0 !== t.cascadeBlendPercentage && (s.cascadeBlendPercentage = t.cascadeBlendPercentage), void 0 !== t.depthClamp && (s.depthClamp = t.depthClamp), void 0 !== t.autoCalcDepthBounds && (s.autoCalcDepthBounds = t.autoCalcDepthBounds), void 0 !== t.shadowMaxZ && (s.shadowMaxZ = t.shadowMaxZ), void 0 !== t.penumbraDarkness && (s.penumbraDarkness = t.penumbraDarkness), void 0 !== t.freezeShadowCastersBoundingInfo && (s.freezeShadowCastersBoundingInfo = t.freezeShadowCastersBoundingInfo), void 0 !== t.minDistance && void 0 !== t.maxDistance && s.setMinMaxDistance(t.minDistance, t.maxDistance), s
			}
			set lambda(e) {
				const t = Math.min(Math.max(e, 0), 1);
				this._lambda != t && (this._lambda = t, this._breaksAreDirty = !0)
			}
			_isReadyCustomDefines(e) {
				e.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== Rg.FILTER_PCSS ? "1" : "0"))
			}
			getCascadeViewMatrix(e) {
				return e >= 0 && e < this._numCascades ? this._viewMatrices[e] : null
			}
			splitFrustum() {
				this._breaksAreDirty = !0
			}
		};
	kS._FrustumCornersNDCSpace = [new Lc(-1, 1, -1), new Lc(1, 1, -1), new Lc(1, -1, -1), new Lc(-1, -1, -1), new Lc(-1, 1, 1), new Lc(1, 1, 1), new Lc(1, -1, 1), new Lc(-1, -1, 1)], kS.CLASSNAME = "CascadedShadowGenerator", kS.DEFAULT_CASCADES_COUNT = 4, kS.MIN_CASCADES_COUNT = 2, kS.MAX_CASCADES_COUNT = 4, kS._SceneComponentInitialization = e => {
		throw ic("ShadowGeneratorSceneComponent")
	}, O_.AddParser(Df.NAME_SHADOWGENERATOR, ((e, t) => {
		if (void 0 !== e.shadowGenerators && null !== e.shadowGenerators)
			for (let i = 0, s = e.shadowGenerators.length; i < s; i++) {
				const s = e.shadowGenerators[i];
				s.className === kS.CLASSNAME ? kS.Parse(s, t) : Rg.Parse(s, t)
			}
	}));
	var DS, OS, FS = class {
		_gatherRenderTargets(e) {
			const t = this.scene;
			if (this.scene.shadowsEnabled)
				for (let i = 0; i < t.lights.length; i++) {
					const s = t.lights[i],
						n = s.getShadowGenerators();
					if (s.isEnabled() && s.shadowEnabled && n) {
						const i = n.values();
						for (let s = i.next(); !0 !== s.done; s = i.next()) {
							const i = s.value.getShadowMap(); - 1 !== t.textures.indexOf(i) && e.push(i)
						}
					}
				}
		}
		constructor(e) {
			this.name = Df.NAME_SHADOWGENERATOR, this.scene = e
		}
		serialize(e) {
			e.shadowGenerators = [];
			const t = this.scene.lights;
			for (const i of t) {
				const t = i.getShadowGenerators();
				if (t) {
					const i = t.values();
					for (let t = i.next(); !0 !== t.done; t = i.next()) {
						const i = t.value;
						e.shadowGenerators.push(i.serialize())
					}
				}
			}
		}
		register() {
			this.scene._gatherRenderTargetsStage.registerStep(Df.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets)
		}
		addFromContainer(e) {}
		dispose() {}
		rebuild() {}
		removeFromContainer(e, t) {}
	};
	Rg._SceneComponentInitialization = e => {
		let t = e._getComponent(Df.NAME_SHADOWGENERATOR);
		t || (t = new FS(e), e._addComponent(t))
	}, (OS = DS || (DS = {}))[OS.Clean = 0] = "Clean", OS[OS.Stop = 1] = "Stop", OS[OS.Sync = 2] = "Sync", OS[OS.NoSync = 3] = "NoSync";
	var LS = new kc,
		BS = {},
		GS = !1;

	function HS() {
		return BS[".babylon"]
	}

	function US(e) {
		const t = BS[e];
		return t || (Qc.Warn("Unable to find a plugin to load " + e + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"), HS())
	}

	function VS(e, t, i) {
		let s = "Unable to load from " + (e.rawData ? "binary data" : e.url);
		return t ? s += `: ${t}` : i && (s += `: ${i}`), s
	}

	function WS(e, t, i, s, n, a, r, o, l) {
		const h = "data:" === (c = e.url).substr(0, 5) ? c.substr(5) : null;
		var c;
		if (e.rawData && !r) throw "When using ArrayBufferView to load data the file extension must be provided.";
		const u = r ? US(r) : h ? function(e) {
			for (const t in BS) {
				const i = BS[t].plugin;
				if (i.canDirectLoad && i.canDirectLoad(e)) return BS[t]
			}
			return HS()
		}(e.url) : function(e) {
			const t = e.indexOf("?"); - 1 !== t && (e = e.substring(0, t));
			const i = e.lastIndexOf(".");
			return US(e.substring(i, e.length).toLowerCase())
		}(e.url);
		if (!1 === l?.[u.plugin.name]?.enabled) throw new Error(`The '${u.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);
		if (e.rawData && !u.isBinary) throw "Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";
		const m = u.plugin.createPlugin?.(l ?? {}) ?? u.plugin;
		if (!m) throw `The loader plugin corresponding to the '${r}' file type has not been found. If using es6, please import the plugin you wish to use before.`;
		if (LS.notifyObservers(m), h && (m.canDirectLoad && m.canDirectLoad(e.url) || !Ym(e.url))) {
			if (m.directLoad) {
				const e = m.directLoad(t, h);
				e instanceof Promise ? e.then((e => {
					i(m, e)
				})).catch((e => {
					n("Error in directLoad of _loadData: " + e, e)
				})) : i(m, e)
			} else i(m, h);
			return m
		}
		const d = u.isBinary,
			f = (e, s) => {
				t.isDisposed ? n("Scene has been disposed") : i(m, e, s)
			};
		let p = null,
			_ = !1;
		m.onDisposeObservable?.add((() => {
			_ = !0, p && (p.abort(), p = null), a()
		}));
		const g = () => {
				if (_) return;
				const i = (e, t) => {
					n(e?.statusText, t)
				};
				if (!m.loadFile && e.rawData) throw "Plugin does not support loading ArrayBufferView.";
				p = m.loadFile ? m.loadFile(t, e.rawData || e.file || e.url, e.rootUrl, f, s, d, i, o) : t._loadFile(e.file || e.url, f, s, !0, d, i)
			},
			v = t.getEngine();
		let y = v.enableOfflineSupport;
		if (y) {
			let i = !1;
			for (const s of t.disableOfflineSupportExceptionRules)
				if (s.test(e.url)) {
					i = !0;
					break
				} y = !i
		}
		return y && Fd.OfflineProviderFactory ? t.offlineProvider = Fd.OfflineProviderFactory(e.url, g, v.disableManifestCheck) : g(), m
	}

	function zS(e, t) {
		let i, s, n = null,
			a = null;
		if (t)
			if (t.name) i = `file:${t.name}`, s = t.name, n = t;
			else if (ArrayBuffer.isView(t)) i = "", s = rd(), a = t;
		else if (t.startsWith("data:")) i = t, s = "";
		else if (e) {
			const n = t;
			if ("/" === n.substr(0, 1)) return dd.Error("Wrong sceneFilename parameter"), null;
			i = e + n, s = n
		} else i = t, s = dd.GetFilename(t), e = dd.GetFolderPath(t);
		else i = e, s = dd.GetFilename(e), e = dd.GetFolderPath(e);
		return {
			url: i,
			rootUrl: e,
			name: s,
			file: n,
			rawData: a
		}
	}

	function XS(e) {
		if ("string" == typeof e.extensions) {
			const t = e.extensions;
			BS[t.toLowerCase()] = {
				plugin: e,
				isBinary: !1
			}
		} else {
			const t = e.extensions;
			Object.keys(t).forEach((i => {
				BS[i.toLowerCase()] = {
					plugin: e,
					isBinary: t[i].isBinary
				}
			}))
		}
	}

	function YS(e, t, i = "", s = Dc.LastCreatedScene, n = null, a = null, r = null, o = null, l = "", h = {}) {
		if (!s) return Qc.Error("No scene available to import mesh to"), null;
		const c = zS(t, i);
		if (!c) return null;
		const u = {};
		s.addPendingData(u);
		const m = () => {
				s.removePendingData(u)
			},
			d = (e, t) => {
				const i = VS(c, e, t);
				r ? r(s, i, new uu(i, ou, t)) : Qc.Error(i), m()
			},
			f = a ? e => {
				try {
					a(e)
				} catch (e) {
					d("Error in onProgress callback: " + e, e)
				}
			} : void 0,
			p = (e, t, i, a, r, o, l, h) => {
				if (s.importedMeshesFiles.push(c.url), n) try {
					n(e, t, i, a, r, o, l, h)
				} catch (e) {
					d("Error in onSuccess callback: " + e, e)
				}
				s.removePendingData(u)
			};
		return WS(c, s, ((t, i, n) => {
			if (t.rewriteRootURL && (c.rootUrl = t.rewriteRootURL(c.rootUrl, n)), t.importMesh) {
				const n = [],
					a = [],
					r = [];
				if (!t.importMesh(e, s, i, c.rootUrl, n, a, r, d)) return;
				s.loadingPluginName = t.name, p(n, a, r, [], [], [], [], [])
			} else {
				t.importMeshAsync(e, s, i, c.rootUrl, f, c.name).then((e => {
					s.loadingPluginName = t.name, p(e.meshes, e.particleSystems, e.skeletons, e.animationGroups, e.transformNodes, e.geometries, e.lights, e.spriteManagers)
				})).catch((e => {
					d(e.message, e)
				}))
			}
		}), f, d, m, o, l, h)
	}

	function jS(e, t = "", i = Dc.LastCreatedEngine, s = null, n = null, a = null, r = null, o = "", l = {}) {
		return i ? KS(e, t, new bg(i), s, n, a, r, o, l) : (dd.Error("No engine available"), null)
	}

	function KS(e, t = "", i = Dc.LastCreatedScene, s = null, n = null, a = null, r = null, o = "", l = {}) {
		if (!i) return Qc.Error("No scene available to append to"), null;
		const h = zS(e, t);
		if (!h) return null;
		const c = {};
		i.addPendingData(c);
		const u = () => {
			i.removePendingData(c)
		};
		Ed.ShowLoadingScreen && !GS && (GS = !0, i.getEngine().displayLoadingUI(), i.executeWhenReady((() => {
			i.getEngine().hideLoadingUI(), GS = !1
		})));
		const m = (e, t) => {
				const s = VS(h, e, t);
				a ? a(i, s, new uu(s, ou, t)) : Qc.Error(s), u()
			},
			d = n ? e => {
				try {
					n(e)
				} catch (e) {
					m("Error in onProgress callback", e)
				}
			} : void 0,
			f = () => {
				if (s) try {
					s(i)
				} catch (e) {
					m("Error in onSuccess callback", e)
				}
				i.removePendingData(c)
			};
		return WS(h, i, ((e, t) => {
			if (e.load) {
				if (!e.load(i, t, h.rootUrl, m)) return;
				i.loadingPluginName = e.name, f()
			} else {
				e.loadAsync(i, t, h.rootUrl, d, h.name).then((() => {
					i.loadingPluginName = e.name, f()
				})).catch((e => {
					m(e.message, e)
				}))
			}
		}), d, m, u, r, o, l)
	}

	function $S(e, t = "", i = Dc.LastCreatedScene, s = null, n = null, a = null, r = null, o = "", l = {}) {
		if (!i) return Qc.Error("No scene available to load asset container to"), null;
		const h = zS(e, t);
		if (!h) return null;
		const c = {};
		i.addPendingData(c);
		const u = () => {
				i.removePendingData(c)
			},
			m = (e, t) => {
				const s = VS(h, e, t);
				a ? a(i, s, new uu(s, ou, t)) : Qc.Error(s), u()
			},
			d = n ? e => {
				try {
					n(e)
				} catch (e) {
					m("Error in onProgress callback", e)
				}
			} : void 0,
			f = e => {
				if (s) try {
					s(e)
				} catch (e) {
					m("Error in onSuccess callback", e)
				}
				i.removePendingData(c)
			};
		return WS(h, i, ((e, t) => {
			if (e.loadAssetContainer) {
				const s = e.loadAssetContainer(i, t, h.rootUrl, m);
				if (!s) return;
				s.populateRootNodes(), i.loadingPluginName = e.name, f(s)
			} else if (e.loadAssetContainerAsync) {
				e.loadAssetContainerAsync(i, t, h.rootUrl, d, h.name).then((t => {
					t.populateRootNodes(), i.loadingPluginName = e.name, f(t)
				})).catch((e => {
					m(e.message, e)
				}))
			} else m("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")
		}), d, m, u, r, o, l)
	}

	function JS(e, t = "", i = Dc.LastCreatedScene, s = !0, n = 0, a = null, r = null, o = null, l = null, h = null, c = "", u = {}) {
		if (!i) return void Qc.Error("No scene available to load animations to");
		if (s) {
			for (const e of i.animatables) e.reset();
			i.stopAllAnimations(), i.animationGroups.slice().forEach((e => {
				e.dispose()
			}));
			i.getNodes().forEach((e => {
				e.animations && (e.animations = [])
			}))
		} else switch (n) {
			case 0:
				i.animationGroups.slice().forEach((e => {
					e.dispose()
				}));
				break;
			case 1:
				i.animationGroups.forEach((e => {
					e.stop()
				}));
				break;
			case 2:
				i.animationGroups.forEach((e => {
					e.reset(), e.restart()
				}));
				break;
			case 3:
				break;
			default:
				return void Qc.Error("Unknown animation group loading mode value '" + n + "'")
		}
		const m = i.animatables.length;
		$S(e, t, i, (e => {
			e.mergeAnimationsTo(i, i.animatables.slice(m), a), e.dispose(), i.onAnimationFileImportedObservable.notifyObservers(i), r && r(i)
		}), o, l, h, c, u)
	}
	var qS = class {
		static ImportMesh(e, t, i, s, n, a, r, o, l) {
			return YS(e, t, i, s, n, a, r, o, l)
		}
		static Append(e, t, i, s, n, a, r, o) {
			return KS(e, t, i, s, n, a, r, o)
		}
		static get CleanBoneMatrixWeights() {
			return Ed.CleanBoneMatrixWeights
		}
		static ImportMeshAsync(e, t, i, s, n, a, r) {
			return function(e, t, i, s, n, a, r, o) {
				return new Promise(((l, h) => {
					YS(e, t, i, s, ((e, t, i, s, n, a, r, o) => {
						l({
							meshes: e,
							particleSystems: t,
							skeletons: i,
							animationGroups: s,
							transformNodes: n,
							geometries: a,
							lights: r,
							spriteManagers: o
						})
					}), n, ((e, t, i) => {
						h(i || new Error(t))
					}), a, r, o)
				}))
			}(e, t, i, s, n, a, r)
		}
		static set loggingLevel(e) {
			Ed.loggingLevel = e
		}
		static Load(e, t, i, s, n, a, r, o) {
			return jS(e, t, i, s, n, a, r, o)
		}
		static ImportAnimationsAsync(e, t, i, s, n, a, r, o, l, h, c) {
			return function(e, t, i, s, n, a, r, o, l, h) {
				return new Promise(((c, u) => {
					JS(e, t, i, s, n, a, (e => {
						c(e)
					}), r, ((e, t, i) => {
						u(i || new Error(t))
					}), o, l, h)
				}))
			}(e, t, i, s, n, a, o, h, c)
		}
		static set ForceFullSceneLoadingForIncremental(e) {
			Ed.ForceFullSceneLoadingForIncremental = e
		}
		static GetDefaultPlugin() {
			return HS()
		}
		static ImportAnimations(e, t, i, s, n, a, r, o, l, h, c) {
			JS(e, t, i, s, n, a, r, o, l, h, c)
		}
		static IsPluginForExtensionAvailable(e) {
			return function(e) {
				return !!BS[e]
			}(e)
		}
		static LoadAssetContainer(e, t, i, s, n, a, r, o) {
			return $S(e, t, i, s, n, a, r, o)
		}
		static set ShowLoadingScreen(e) {
			Ed.ShowLoadingScreen = e
		}
		static LoadAssetContainerAsync(e, t, i, s, n, a) {
			return function(e, t, i, s, n, a, r) {
				return new Promise(((o, l) => {
					$S(e, t, i, (e => {
						o(e)
					}), s, ((e, t, i) => {
						l(i || new Error(t))
					}), n, a, r)
				}))
			}(e, t, i, s, n, a)
		}
		static get loggingLevel() {
			return Ed.loggingLevel
		}
		static get ShowLoadingScreen() {
			return Ed.ShowLoadingScreen
		}
		static RegisterPlugin(e) {
			XS(e)
		}
		static LoadAsync(e, t, i, s, n, a) {
			return function(e, t, i, s, n, a, r) {
				return new Promise(((o, l) => {
					jS(e, t, i, (e => {
						o(e)
					}), s, ((e, t, i) => {
						l(i || new Error(t))
					}), n, a, r)
				}))
			}(e, t, i, s, n, a)
		}
		static set CleanBoneMatrixWeights(e) {
			Ed.CleanBoneMatrixWeights = e
		}
		static GetPluginForExtension(e) {
			return US(e).plugin
		}
		static AppendAsync(e, t, i, s, n, a) {
			return function(e, t, i, s, n, a, r) {
				return new Promise(((o, l) => {
					KS(e, t, i, (e => {
						o(e)
					}), s, ((e, t, i) => {
						l(i || new Error(t))
					}), n, a, r)
				}))
			}(e, t, i, s, n, a)
		}
		static get ForceFullSceneLoadingForIncremental() {
			return Ed.ForceFullSceneLoadingForIncremental
		}
	};
	qS.NO_LOGGING = 0, qS.MINIMAL_LOGGING = 1, qS.SUMMARY_LOGGING = 2, qS.DETAILED_LOGGING = 3, qS.OnPluginActivatedObservable = LS;
	var QS = class extends O_ {},
		ZS = class {
			dispose() {
				this.rootNodes.slice(0).forEach((e => {
					e.dispose()
				})), this.rootNodes.length = 0, this.skeletons.slice(0).forEach((e => {
					e.dispose()
				})), this.skeletons.length = 0, this.animationGroups.slice(0).forEach((e => {
					e.dispose()
				})), this.animationGroups.length = 0
			}
			constructor() {
				this.rootNodes = [], this.skeletons = [], this.animationGroups = []
			}
		},
		eE = class extends O_ {
			moveAllFromScene(e) {
				this._wasAddedToScene = !1, void 0 === e && (e = new QS);
				for (const t in this) Object.prototype.hasOwnProperty.call(this, t) && (this[t] = this[t] || ("_environmentTexture" === t ? null : []), this._moveAssets(this.scene[t], this[t], e[t]));
				this.environmentTexture = this.scene.environmentTexture, this.removeAllFromScene()
			}
			addAllToScene() {
				if (!this._wasAddedToScene) {
					this._isValidHierarchy() || dd.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid."), this._wasAddedToScene = !0, this.addToScene(null), this.environmentTexture && (this.scene.environmentTexture = this.environmentTexture);
					for (const e of this.scene._serializableComponents) e.addFromContainer(this);
					this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null
				}
			}
			addAllAssetsToContainer(e) {
				if (!e) return;
				const t = [],
					i = new Set;
				for (t.push(e); t.length > 0;) {
					const e = t.pop();
					if (e instanceof Vf ? (e.geometry && -1 === this.geometries.indexOf(e.geometry) && this.geometries.push(e.geometry), this.meshes.push(e)) : e instanceof Jc ? this.transformNodes.push(e) : e instanceof xg ? this.lights.push(e) : e instanceof Sd && this.cameras.push(e), e instanceof jd) {
						if (e.material && -1 === this.materials.indexOf(e.material)) {
							this.materials.push(e.material);
							for (const t of e.material.getActiveTextures()) - 1 === this.textures.indexOf(t) && this.textures.push(t)
						}
						e.skeleton && -1 === this.skeletons.indexOf(e.skeleton) && this.skeletons.push(e.skeleton), e.morphTargetManager && -1 === this.morphTargetManagers.indexOf(e.morphTargetManager) && this.morphTargetManagers.push(e.morphTargetManager)
					}
					for (const s of e.getChildren()) i.has(s) || t.push(s);
					i.add(e)
				}
				this.populateRootNodes()
			}
			_topologicalSort(e) {
				const t = new Map;
				for (const i of e) t.set(i.ik, i);
				const i = {
					dependsOn: new Map,
					dependedBy: new Map
				};
				for (const t of e) {
					const e = t.ik;
					i.dependsOn.set(e, new Set), i.dependedBy.set(e, new Set)
				}
				for (const s of e) {
					const e = s.ik,
						n = i.dependsOn.get(e);
					if (s instanceof Sy) {
						const a = s.wk;
						t.has(a.ik) && (n.add(a.ik), i.dependedBy.get(a.ik).add(e))
					}
					const a = i.dependedBy.get(e);
					for (const n of s.getDescendants()) {
						const s = n.ik;
						if (t.has(s)) {
							a.add(s);
							i.dependsOn.get(s).add(e)
						}
					}
				}
				const s = [],
					n = [];
				for (const s of e) {
					const e = s.ik;
					0 === i.dependsOn.get(e).size && (n.push(s), t.delete(e))
				}
				const a = n;
				for (; a.length > 0;) {
					const e = a.shift();
					s.push(e);
					const n = i.dependedBy.get(e.ik);
					for (const s of Array.from(n.values())) {
						const n = i.dependsOn.get(s);
						n.delete(e.ik), 0 === n.size && t.get(s) && (a.push(t.get(s)), t.delete(s))
					}
				}
				return t.size > 0 && (Qc.Error("SceneSerializer._topologicalSort: There were unvisited nodes:"), t.forEach((e => Qc.Error(e.name)))), s
			}
			removeFromScene(e = null) {
				this.cameras.forEach((t => {
					e && !e(t) || this.scene.removeCamera(t)
				})), this.lights.forEach((t => {
					e && !e(t) || this.scene.removeLight(t)
				})), this.meshes.forEach((t => {
					e && !e(t) || this.scene.removeMesh(t, !0)
				})), this.skeletons.forEach((t => {
					e && !e(t) || this.scene.removeSkeleton(t)
				})), this.animations.forEach((t => {
					e && !e(t) || this.scene.removeAnimation(t)
				})), this.animationGroups.forEach((t => {
					e && !e(t) || this.scene.removeAnimationGroup(t)
				})), this.multiMaterials.forEach((t => {
					e && !e(t) || this.scene.removeMultiMaterial(t)
				})), this.materials.forEach((t => {
					e && !e(t) || this.scene.removeMaterial(t)
				})), this.morphTargetManagers.forEach((t => {
					e && !e(t) || this.scene.removeMorphTargetManager(t)
				})), this.geometries.forEach((t => {
					e && !e(t) || this.scene.removeGeometry(t)
				})), this.transformNodes.forEach((t => {
					e && !e(t) || this.scene.removeTransformNode(t)
				})), this.actionManagers.forEach((t => {
					e && !e(t) || this.scene.removeActionManager(t)
				})), this.textures.forEach((t => {
					e && !e(t) || this.scene.removeTexture(t)
				})), this.reflectionProbes.forEach((t => {
					e && !e(t) || this.scene.removeReflectionProbe(t)
				}))
			}
			_isNodeInContainer(e) {
				return e instanceof jd && -1 !== this.meshes.indexOf(e) || (e instanceof Jc && -1 !== this.transformNodes.indexOf(e) || (e instanceof xg && -1 !== this.lights.indexOf(e) || e instanceof Sd && -1 !== this.cameras.indexOf(e)))
			}
			_addNodeAndDescendantsToList(e, t, i, s) {
				if (i && (!s || s(i)) && !t.has(i.ik)) {
					e.push(i), t.add(i.ik);
					for (const n of i.getDescendants(!0)) this._addNodeAndDescendantsToList(e, t, n, s)
				}
			}
			_moveAssets(e, t, i) {
				if (e && t)
					for (const s of e) {
						let e = !0;
						if (i)
							for (const t of i)
								if (s === t) {
									e = !1;
									break
								} e && (t.push(s), s._parentContainer = this)
					}
			}
			mergeAnimationsTo(e = Dc.LastCreatedScene, t, i = null) {
				if (!e) return Qc.Error("No scene available to merge animations to"), [];
				const s = i || (t => {
					let i = null;
					const s = t.animations.length ? t.animations[0].targetProperty : "",
						n = t.name.split(".").join("").split("_primitive")[0];
					switch (s) {
						case "position":
						case "rotationQuaternion":
							i = e.getTransformNodeByName(t.name) || e.getTransformNodeByName(n);
							break;
						case "influence":
							i = e.getMorphTargetByName(t.name) || e.getMorphTargetByName(n);
							break;
						default:
							i = e.getNodeByName(t.name) || e.getNodeByName(n)
					}
					return i
				});
				this.getNodes().forEach((e => {
					const t = s(e);
					if (null !== t) {
						for (const i of e.animations) {
							const e = t.animations.filter((e => e.targetProperty === i.targetProperty));
							for (const i of e) {
								const e = t.animations.indexOf(i, 0);
								e > -1 && t.animations.splice(e, 1)
							}
						}
						t.animations = t.animations.concat(e.animations)
					}
				}));
				const n = [];
				return this.animationGroups.slice().forEach((e => {
					n.push(e.clone(e.name, s)), e.animatables.forEach((e => {
						e.stop()
					}))
				})), t.forEach((t => {
					const i = s(t.target);
					i && (e.beginAnimation(i, t.fromFrame, t.toFrame, t.loopAnimation, t.speedRatio, t.onAnimationEnd ? t.onAnimationEnd : void 0, void 0, !0, void 0, t.onAnimationLoop ? t.onAnimationLoop : void 0), e.stopAnimation(t.target))
				})), n
			}
			instantiateModelsToScene(e, t = !1, i) {
				this._isValidHierarchy() || dd.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
				const s = {},
					n = {},
					a = new ZS,
					r = [],
					o = [],
					l = {
						doNotInstantiate: !0,
						...i
					},
					h = [],
					c = new Set;
				for (const e of this.transformNodes) null === e.parent && this._addNodeAndDescendantsToList(h, c, e, l.predicate);
				for (const e of this.meshes) null === e.parent && this._addNodeAndDescendantsToList(h, c, e, l.predicate);
				const u = this._topologicalSort(h),
					m = (i, r) => {
						if (((t, i) => {
								if (s[t.ik] = i.ik, n[i.ik] = i, e && (i.name = e(t.name)), i instanceof Vf) {
									const e = i;
									if (e.morphTargetManager) {
										const i = t.morphTargetManager;
										e.morphTargetManager = i.clone();
										for (let t = 0; t < i.numTargets; t++) {
											const a = i.getTarget(t),
												r = e.morphTargetManager.getTarget(t);
											s[a.ik] = r.ik, n[r.ik] = r
										}
									}
								}
							})(i, r), i.parent) {
							const e = s[i.parent.ik],
								t = n[e];
							r.parent = t || i.parent
						}
						if (r.position && i.position && r.position.copyFrom(i.position), r.rotationQuaternion && i.rotationQuaternion && r.rotationQuaternion.copyFrom(i.rotationQuaternion), r.rotation && i.rotation && r.rotation.copyFrom(i.rotation), r.scaling && i.scaling && r.scaling.copyFrom(i.scaling), r.material) {
							const a = r;
							if (a.material)
								if (t) {
									const t = i.material;
									if (-1 === o.indexOf(t)) {
										let i = t.clone(e ? e(t.name) : "Clone of " + t.name);
										if (o.push(t), s[t.ik] = i.ik, n[i.ik] = i, "MultiMaterial" === t.getClassName()) {
											const a = t;
											for (const t of a.subMaterials) t && (i = t.clone(e ? e(t.name) : "Clone of " + t.name), o.push(t), s[t.ik] = i.ik, n[i.ik] = i);
											a.subMaterials = a.subMaterials.map((e => e && n[s[e.ik]]))
										}
									}
									"InstancedMesh" !== a.getClassName() && (a.material = n[s[t.ik]])
								} else "MultiMaterial" === a.material.getClassName() ? -1 === this.scene.multiMaterials.indexOf(a.material) && this.scene.addMultiMaterial(a.material) : -1 === this.scene.materials.indexOf(a.material) && this.scene.addMaterial(a.material)
						}
						null === r.parent && a.rootNodes.push(r)
					};
				return u.forEach((e => {
					if ("InstancedMesh" === e.getClassName()) {
						const t = e,
							i = t.wk,
							a = s[i.ik],
							r = ("number" == typeof a ? n[a] : i).createInstance(t.name);
						m(t, r)
					} else {
						let t = !0;
						"TransformNode" === e.getClassName() || "Node" === e.getClassName() || e.skeleton || !e.getTotalVertices || 0 === e.getTotalVertices() ? t = !1 : l.doNotInstantiate && (t = "function" == typeof l.doNotInstantiate ? !l.doNotInstantiate(e) : !l.doNotInstantiate);
						const i = t ? e.createInstance(`instance of ${e.name}`) : e.clone(`Clone of ${e.name}`, null, !0);
						if (!i) throw new Error(`Could not clone or instantiate node on Asset Container ${e.name}`);
						m(e, i)
					}
				})), this.skeletons.forEach((t => {
					if (l.predicate && !l.predicate(t)) return;
					const i = t.clone(e ? e(t.name) : "Clone of " + t.name);
					for (const e of this.meshes)
						if (e.skeleton === t && !e.isAnInstance) {
							const t = n[s[e.ik]];
							if (!t || t.isAnInstance) continue;
							if (t.skeleton = i, -1 !== r.indexOf(i)) continue;
							r.push(i);
							for (const e of i.bones) e._linkedTransformNode && (e._linkedTransformNode = n[s[e._linkedTransformNode.ik]])
						} a.skeletons.push(i)
				})), this.animationGroups.forEach((t => {
					if (l.predicate && !l.predicate(t)) return;
					const i = t.clone(e ? e(t.name) : "Clone of " + t.name, (e => n[s[e.ik]] || e));
					a.animationGroups.push(i)
				})), a
			}
			removeAllFromScene() {
				this._isValidHierarchy() || dd.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid."), this._wasAddedToScene = !1, this.removeFromScene(null), this.environmentTexture === this.scene.environmentTexture && (this.scene.environmentTexture = null);
				for (const e of this.scene._serializableComponents) e.removeFromContainer(this)
			}
			constructor(e) {
				super(), this._wasAddedToScene = !1, (e = e || Dc.LastCreatedScene) && (this.scene = e, this.sounds = [], this.effectLayers = [], this.layers = [], this.lensFlareSystems = [], this.proceduralTextures = [], this.reflectionProbes = [], e.onDisposeObservable.add((() => {
					this._wasAddedToScene || this.dispose()
				})), this._onContextRestoredObserver = e.getEngine().onContextRestoredObservable.add((() => {
					for (const e of this.geometries) e._rebuild();
					for (const e of this.meshes) e._rebuild();
					for (const e of this.particleSystems) e.rebuild();
					for (const e of this.textures) e._rebuild()
				})))
			}
			_isValidHierarchy() {
				for (const e of this.meshes)
					if (e.parent && !this._isNodeInContainer(e.parent)) return Qc.Warn(`Node ${e.name} has a parent that is not in the container.`), !1;
				for (const e of this.transformNodes)
					if (e.parent && !this._isNodeInContainer(e.parent)) return Qc.Warn(`Node ${e.name} has a parent that is not in the container.`), !1;
				for (const e of this.lights)
					if (e.parent && !this._isNodeInContainer(e.parent)) return Qc.Warn(`Node ${e.name} has a parent that is not in the container.`), !1;
				for (const e of this.cameras)
					if (e.parent && !this._isNodeInContainer(e.parent)) return Qc.Warn(`Node ${e.name} has a parent that is not in the container.`), !1;
				return !0
			}
			createRootMesh() {
				const e = new Vf("assetContainerRootMesh", this.scene);
				return this.meshes.forEach((t => {
					t.parent || e.addChild(t)
				})), this.meshes.unshift(e), e
			}
			dispose() {
				this.cameras.slice(0).forEach((e => {
					e.dispose()
				})), this.cameras.length = 0, this.lights.slice(0).forEach((e => {
					e.dispose()
				})), this.lights.length = 0, this.meshes.slice(0).forEach((e => {
					e.dispose()
				})), this.meshes.length = 0, this.skeletons.slice(0).forEach((e => {
					e.dispose()
				})), this.skeletons.length = 0, this.animationGroups.slice(0).forEach((e => {
					e.dispose()
				})), this.animationGroups.length = 0, this.multiMaterials.slice(0).forEach((e => {
					e.dispose()
				})), this.multiMaterials.length = 0, this.materials.slice(0).forEach((e => {
					e.dispose()
				})), this.materials.length = 0, this.geometries.slice(0).forEach((e => {
					e.dispose()
				})), this.geometries.length = 0, this.transformNodes.slice(0).forEach((e => {
					e.dispose()
				})), this.transformNodes.length = 0, this.actionManagers.slice(0).forEach((e => {
					e.dispose()
				})), this.actionManagers.length = 0, this.textures.slice(0).forEach((e => {
					e.dispose()
				})), this.textures.length = 0, this.reflectionProbes.slice(0).forEach((e => {
					e.dispose()
				})), this.reflectionProbes.length = 0, this.morphTargetManagers.slice(0).forEach((e => {
					e.dispose()
				})), this.morphTargetManagers.length = 0, this.environmentTexture && (this.environmentTexture.dispose(), this.environmentTexture = null);
				for (const e of this.scene._serializableComponents) e.removeFromContainer(this, !0);
				this._onContextRestoredObserver && (this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)
			}
			addToScene(e = null) {
				const t = [];
				this.cameras.forEach((i => {
					e && !e(i) || (this.scene.addCamera(i), t.push(i))
				})), this.lights.forEach((i => {
					e && !e(i) || (this.scene.addLight(i), t.push(i))
				})), this.meshes.forEach((i => {
					e && !e(i) || (this.scene.addMesh(i), t.push(i))
				})), this.skeletons.forEach((t => {
					e && !e(t) || this.scene.addSkeleton(t)
				})), this.animations.forEach((t => {
					e && !e(t) || this.scene.addAnimation(t)
				})), this.animationGroups.forEach((t => {
					e && !e(t) || this.scene.addAnimationGroup(t)
				})), this.multiMaterials.forEach((t => {
					e && !e(t) || this.scene.addMultiMaterial(t)
				})), this.materials.forEach((t => {
					e && !e(t) || this.scene.addMaterial(t)
				})), this.morphTargetManagers.forEach((t => {
					e && !e(t) || this.scene.addMorphTargetManager(t)
				})), this.geometries.forEach((t => {
					e && !e(t) || this.scene.addGeometry(t)
				})), this.transformNodes.forEach((i => {
					e && !e(i) || (this.scene.addTransformNode(i), t.push(i))
				})), this.actionManagers.forEach((t => {
					e && !e(t) || this.scene.addActionManager(t)
				})), this.textures.forEach((t => {
					e && !e(t) || this.scene.addTexture(t)
				})), this.reflectionProbes.forEach((t => {
					e && !e(t) || this.scene.addReflectionProbe(t)
				}));
				for (const e of t) e.parent && -1 === this.scene.getNodes().indexOf(e.parent) && (e.setParent ? e.setParent(null) : e.parent = null)
			}
			populateRootNodes() {
				this.rootNodes.length = 0, this.meshes.forEach((e => {
					e.parent || -1 !== this.rootNodes.indexOf(e) || this.rootNodes.push(e)
				})), this.transformNodes.forEach((e => {
					e.parent || -1 !== this.rootNodes.indexOf(e) || this.rootNodes.push(e)
				})), this.lights.forEach((e => {
					e.parent || -1 !== this.rootNodes.indexOf(e) || this.rootNodes.push(e)
				})), this.cameras.forEach((e => {
					e.parent || -1 !== this.rootNodes.indexOf(e) || this.rootNodes.push(e)
				}))
			}
		},
		tE = class {
			readUint32() {
				const e = this._dataView.getUint32(this._dataByteOffset, !0);
				return this._dataByteOffset += 4, this.byteOffset += 4, e
			}
			readString(e) {
				return (e => {
					if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
					let t = "";
					for (let i = 0; i < e.byteLength; i++) t += String.fromCharCode(e[i]);
					return t
				})(this.readUint8Array(e))
			}
			constructor(e) {
				this.byteOffset = 0, this.buffer = e
			}
			readUint8Array(e) {
				const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, e);
				return this._dataByteOffset += e, this.byteOffset += e, t
			}
			loadAsync(e) {
				return this.buffer.readAsync(this.byteOffset, e).then((e => {
					this._dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), this._dataByteOffset = 0
				}))
			}
			skipBytes(e) {
				this._dataByteOffset += e, this.byteOffset += e
			}
		};

	function iE(e, t, i, s) {
		const n = {
			externalResourceFunction: s
		};
		return i && (n.uri = "file:" === t ? i : t + i), ArrayBuffer.isView(e) ? GLTFValidator.validateBytes(e, n) : GLTFValidator.validateString(e, n)
	}

	function sE() {
		const e = [];
		onmessage = t => {
			const i = t.data;
			switch (i.id) {
				case "init":
					importScripts(i.url);
					break;
				case "validate":
					iE(i.data, i.rootUrl, i.fileName, (t => new Promise(((i, s) => {
						const n = e.length;
						e.push({
							resolve: i,
							reject: s
						}), postMessage({
							id: "getExternalResource",
							index: n,
							uri: t
						})
					})))).then((e => {
						postMessage({
							id: "validate.resolve",
							value: e
						})
					}), (e => {
						postMessage({
							id: "validate.reject",
							reason: e
						})
					}));
					break;
				case "getExternalResource.resolve":
					e[i.index].resolve(i.value);
					break;
				case "getExternalResource.reject":
					e[i.index].reject(i.reason)
			}
		}
	}
	var nE = class {
		static ValidateAsync(e, t, i, s) {
			return "function" == typeof Worker ? new Promise(((n, a) => {
				const r = `${iE}(${sE})()`,
					o = URL.createObjectURL(new Blob([r], {
						type: "application/javascript"
					})),
					l = new Worker(o),
					h = e => {
						l.removeEventListener("error", h), l.removeEventListener("message", c), a(e)
					},
					c = e => {
						const t = e.data;
						switch (t.id) {
							case "getExternalResource":
								s(t.uri).then((e => {
									l.postMessage({
										id: "getExternalResource.resolve",
										index: t.index,
										value: e
									}, [e.buffer])
								}), (e => {
									l.postMessage({
										id: "getExternalResource.reject",
										index: t.index,
										reason: e
									})
								}));
								break;
							case "validate.resolve":
								l.removeEventListener("error", h), l.removeEventListener("message", c), n(t.value), l.terminate();
								break;
							case "validate.reject":
								l.removeEventListener("error", h), l.removeEventListener("message", c), a(t.reason), l.terminate()
						}
					};
				if (l.addEventListener("error", h), l.addEventListener("message", c), l.postMessage({
						id: "init",
						url: dd.GetBabylonScriptURL(this.Configuration.url)
					}), ArrayBuffer.isView(e)) {
					const s = e.slice();
					l.postMessage({
						id: "validate",
						data: s,
						rootUrl: t,
						fileName: i
					}, [s.buffer])
				} else l.postMessage({
					id: "validate",
					data: e,
					rootUrl: t,
					fileName: i
				})
			})) : (this._LoadScriptPromise || (this._LoadScriptPromise = dd.LoadBabylonScriptAsync(this.Configuration.url)), this._LoadScriptPromise.then((() => iE(e, t, i, s))))
		}
	};
	nE.Configuration = {
		url: `${dd._DefaultCdnUrl}/gltf_validator.js`
	};
	var aE, rE, oE, lE, hE, cE, uE = "gltf";

	function mE(e, t, i) {
		try {
			return Promise.resolve(new Uint8Array(e, t, i))
		} catch (e) {
			return Promise.reject(e)
		}
	}(rE = aE || (aE = {}))[rE.AUTO = 0] = "AUTO", rE[rE.FORCE_RIGHT_HANDED = 1] = "FORCE_RIGHT_HANDED", (lE = oE || (oE = {}))[lE.NONE = 0] = "NONE", lE[lE.FIRST = 1] = "FIRST", lE[lE.ALL = 2] = "ALL", (cE = hE || (hE = {}))[cE.LOADING = 0] = "LOADING", cE[cE.READY = 1] = "READY", cE[cE.COMPLETE = 2] = "COMPLETE";
	var dE, fE, pE, _E, gE, vE, yE, SE, EE, AE, bE, xE, ME, CE, TE, wE, RE = class {
			constructor() {
				this.coordinateSystemMode = aE.AUTO, this.animationStartMode = oE.FIRST, this.loadNodeAnimations = !0, this.loadSkins = !0, this.loadMorphTargets = !0, this.compileMaterials = !1, this.useClipPlane = !1, this.compileShadowGenerators = !1, this.transparencyAsCoverage = !1, this.useRangeRequests = !1, this.createInstances = !0, this.alwaysComputeBoundingBox = !1, this.loadAllMaterials = !1, this.loadOnlyMaterials = !1, this.skipMaterials = !1, this.useSRGBBuffers = !0, this.targetFps = 60, this.alwaysComputeSkeletonRootNode = !1, this.preprocessUrlAsync = e => Promise.resolve(e), this.extensionOptions = {}
			}
			copyFrom(e) {
				if (e) {
					const t = t => {
						const i = t;
						this[i] = e[i] ?? this[i]
					};
					for (const e in this) t(e);
					for (const e of ["onParsed", "onMeshLoaded", "onSkinLoaded", "onTextureLoaded", "onMaterialLoaded", "onCameraLoaded"]) t(e)
				}
			}
		},
		NE = class e extends RE {
			set loggingEnabled(e) {
				this._loggingEnabled !== e && (this._loggingEnabled = e, this._loggingEnabled ? this._log = this._logEnabled : this._log = this._logDisabled)
			}
			set onValidated(e) {
				this._onValidatedObserver && this.onValidatedObservable.remove(this._onValidatedObserver), this._onValidatedObserver = this.onValidatedObservable.add(e)
			}
			_unpackBinaryV1Async(e, t) {
				const i = e.readUint32(),
					s = e.readUint32();
				if (0 !== s) throw new Error(`Unexpected content format: ${s}`);
				const n = t - e.byteOffset,
					a = {
						json: this._parseJson(e.readString(i)),
						bin: null
					};
				if (0 !== n) {
					const t = e.byteOffset;
					a.bin = {
						readAsync: (i, s) => e.buffer.readAsync(t + i, s),
						byteLength: n
					}
				}
				return Promise.resolve(a)
			}
			loadAssetContainerAsync(e, t, i, s, n) {
				return Promise.resolve().then((() => {
					this.onParsedObservable.notifyObservers(t), this.onParsedObservable.clear(), this._log(`Loading ${n||""}`), this._loader = this._getLoader(t);
					const a = new eE(e),
						r = [];
					this.onMaterialLoadedObservable.add((e => {
						r.push(e)
					}));
					const o = [];
					this.onTextureLoadedObservable.add((e => {
						o.push(e)
					}));
					const l = [];
					this.onCameraLoadedObservable.add((e => {
						l.push(e)
					}));
					const h = [];
					return this.onMeshLoadedObservable.add((e => {
						e.morphTargetManager && h.push(e.morphTargetManager)
					})), this._loader.importMeshAsync(null, e, a, t, i, s, n).then((e => (Array.prototype.push.apply(a.geometries, e.geometries), Array.prototype.push.apply(a.meshes, e.meshes), Array.prototype.push.apply(a.particleSystems, e.particleSystems), Array.prototype.push.apply(a.skeletons, e.skeletons), Array.prototype.push.apply(a.animationGroups, e.animationGroups), Array.prototype.push.apply(a.materials, r), Array.prototype.push.apply(a.textures, o), Array.prototype.push.apply(a.lights, e.lights), Array.prototype.push.apply(a.transformNodes, e.transformNodes), Array.prototype.push.apply(a.cameras, l), Array.prototype.push.apply(a.morphTargetManagers, h), a)))
				}))
			}
			static _compareVersion(e, t) {
				return e.major > t.major ? 1 : e.major < t.major ? -1 : e.minor > t.minor ? 1 : e.minor < t.minor ? -1 : 0
			}
			_logEnabled(t) {
				const i = e._logSpaces.substr(0, 2 * this._logIndentLevel);
				Qc.Log(`${i}${t}`)
			}
			loadAsync(e, t, i, s, n) {
				return Promise.resolve().then((() => (this.onParsedObservable.notifyObservers(t), this.onParsedObservable.clear(), this._log(`Loading ${n||""}`), this._loader = this._getLoader(t), this._loader.loadAsync(e, t, i, s, n))))
			}
			constructor(e) {
				super(), this.onParsedObservable = new kc, this.onMeshLoadedObservable = new kc, this.onSkinLoadedObservable = new kc, this.onTextureLoadedObservable = new kc, this.onMaterialLoadedObservable = new kc, this.onCameraLoadedObservable = new kc, this.onCompleteObservable = new kc, this.onErrorObservable = new kc, this.onDisposeObservable = new kc, this.onExtensionLoadedObservable = new kc, this.validate = !1, this.onValidatedObservable = new kc, this._loader = null, this._state = null, this._requests = new Array, this.name = uE, this.extensions = {
					".gltf": {
						isBinary: !1
					},
					".glb": {
						isBinary: !0
					}
				}, this.onLoaderStateChangedObservable = new kc, this._logIndentLevel = 0, this._loggingEnabled = !1, this._log = this._logDisabled, this._capturePerformanceCounters = !1, this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled, this.copyFrom(e)
			}
			whenCompleteAsync() {
				return new Promise(((e, t) => {
					this.onCompleteObservable.addOnce((() => {
						e()
					})), this.onErrorObservable.addOnce((e => {
						t(e)
					}))
				}))
			}
			_setState(e) {
				this._state !== e && (this._state = e, this.onLoaderStateChangedObservable.notifyObservers(this._state), this._log(hE[this._state]))
			}
			_unpackBinaryV2Async(e, t) {
				const i = 1313821514,
					s = 5130562,
					n = e.readUint32();
				if (e.readUint32() !== i) throw new Error("First chunk format is not JSON");
				return e.byteOffset + n === t ? e.loadAsync(n).then((() => ({
					json: this._parseJson(e.readString(n)),
					bin: null
				}))) : e.loadAsync(n + 8).then((() => {
					const a = {
							json: this._parseJson(e.readString(n)),
							bin: null
						},
						r = () => {
							const n = e.readUint32();
							switch (e.readUint32()) {
								case i:
									throw new Error("Unexpected JSON chunk");
								case s: {
									const t = e.byteOffset;
									a.bin = {
										readAsync: (i, s) => e.buffer.readAsync(t + i, s),
										byteLength: n
									}, e.skipBytes(n);
									break
								}
								default:
									e.skipBytes(n)
							}
							return e.byteOffset !== t ? e.loadAsync(8).then(r) : Promise.resolve(a)
						};
					return r()
				}))
			}
			dispose() {
				this._loader && (this._loader.dispose(), this._loader = null);
				for (const e of this._requests) e.abort();
				this._requests.length = 0, delete this._progressCallback, this.preprocessUrlAsync = e => Promise.resolve(e), this.onMeshLoadedObservable.clear(), this.onSkinLoadedObservable.clear(), this.onTextureLoadedObservable.clear(), this.onMaterialLoadedObservable.clear(), this.onCameraLoadedObservable.clear(), this.onCompleteObservable.clear(), this.onExtensionLoadedObservable.clear(), this.onDisposeObservable.notifyObservers(void 0), this.onDisposeObservable.clear()
			}
			_unpackBinaryAsync(e) {
				return this._startPerformanceCounter("Unpack Binary"), e.loadAsync(20).then((() => {
					const t = e.readUint32();
					if (1179937895 !== t) throw new uu("Unexpected magic: " + t, ru);
					const i = e.readUint32();
					this.loggingEnabled && this._log(`Binary version: ${i}`);
					const s = e.readUint32();
					let n;
					switch (this.useRangeRequests || s === e.buffer.byteLength || Qc.Warn(`Length in header does not match actual data length: ${s} != ${e.buffer.byteLength}`), i) {
						case 1:
							n = this._unpackBinaryV1Async(e, s);
							break;
						case 2:
							n = this._unpackBinaryV2Async(e, s);
							break;
						default:
							throw new Error("Unsupported version: " + i)
					}
					return this._endPerformanceCounter("Unpack Binary"), n
				}))
			}
			set onComplete(e) {
				this._onCompleteObserver && this.onCompleteObservable.remove(this._onCompleteObserver), this._onCompleteObserver = this.onCompleteObservable.add(e)
			}
			set onCameraLoaded(e) {
				this._onCameraLoadedObserver && this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver), this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(e)
			}
			set onSkinLoaded(e) {
				this._onSkinLoadedObserver && this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver), this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((t => e(t.node, t.skinnedNode)))
			}
			set onParsed(e) {
				this._onParsedObserver && this.onParsedObservable.remove(this._onParsedObserver), this._onParsedObserver = this.onParsedObservable.add(e)
			}
			_logDisabled(e) {}
			loadFile(e, t, i, s, n, a, r, o) {
				if (ArrayBuffer.isView(t)) return this._loadBinary(e, t, i, s, r, o), null;
				this._progressCallback = n;
				const l = t.name || dd.GetFilename(t);
				if (a) {
					if (this.useRangeRequests) {
						this.validate && Qc.Warn("glTF validation is not supported when range requests are enabled");
						const i = {
								abort: () => {},
								onCompleteObservable: new kc
							},
							n = {
								readAsync: (i, s) => new Promise(((n, a) => {
									this._loadFile(e, t, (e => {
										n(new Uint8Array(e))
									}), !0, (e => {
										a(e)
									}), (e => {
										e.setRequestHeader("Range", `bytes=${i}-${i+s-1}`)
									}))
								})),
								byteLength: 0
							};
						return this._unpackBinaryAsync(new tE(n)).then((e => {
							i.onCompleteObservable.notifyObservers(i), s(e)
						}), r ? e => r(void 0, e) : void 0), i
					}
					return this._loadFile(e, t, (t => {
						this._validate(e, new Uint8Array(t, 0, t.byteLength), i, l), this._unpackBinaryAsync(new tE({
							readAsync: (e, i) => mE(t, e, i),
							byteLength: t.byteLength
						})).then((e => {
							s(e)
						}), r ? e => r(void 0, e) : void 0)
					}), !0, r)
				}
				return this._loadFile(e, t, (t => {
					try {
						this._validate(e, t, i, l), s({
							json: this._parseJson(t)
						})
					} catch {
						r && r()
					}
				}), !1, r)
			}
			_loadBinary(e, t, i, s, n, a) {
				this._validate(e, new Uint8Array(t.buffer, t.byteOffset, t.byteLength), i, a), this._unpackBinaryAsync(new tE({
					readAsync: (e, i) => function(e, t, i) {
						try {
							if (t < 0 || t >= e.byteLength) throw new RangeError("Offset is out of range.");
							if (t + i > e.byteLength) throw new RangeError("Length is out of range.");
							return Promise.resolve(new Uint8Array(e.buffer, e.byteOffset + t, i))
						} catch (e) {
							return Promise.reject(e)
						}
					}(t, e, i),
					byteLength: t.byteLength
				})).then((e => {
					s(e)
				}), n ? e => n(void 0, e) : void 0)
			}
			importMeshAsync(e, t, i, s, n, a) {
				return Promise.resolve().then((() => (this.onParsedObservable.notifyObservers(i), this.onParsedObservable.clear(), this._log(`Loading ${a||""}`), this._loader = this._getLoader(i), this._loader.importMeshAsync(e, t, null, i, s, n, a))))
			}
			set onError(e) {
				this._onErrorObserver && this.onErrorObservable.remove(this._onErrorObserver), this._onErrorObserver = this.onErrorObservable.add(e)
			}
			_loadFile(e, t, i, s, n, a) {
				const r = e._loadFile(t, i, (e => {
					this._onProgress(e, r)
				}), !0, s, n, a);
				return r.onCompleteObservable.add((() => {
					r._lengthComputable = !0, r._total = r._loaded
				})), this._requests.push(r), r
			}
			_logClose() {
				--this._logIndentLevel
			}
			_logOpen(e) {
				this._log(e), this._logIndentLevel++
			}
			set onMaterialLoaded(e) {
				this._onMaterialLoadedObserver && this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver), this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(e)
			}
			_startPerformanceCounterEnabled(e) {
				dd.StartPerformanceCounter(e)
			}
			set onDispose(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			}
			createPlugin(t) {
				return new e(t[uE])
			}
			set capturePerformanceCounters(e) {
				this._capturePerformanceCounters !== e && (this._capturePerformanceCounters = e, this._capturePerformanceCounters ? (this._startPerformanceCounter = this._startPerformanceCounterEnabled, this._endPerformanceCounter = this._endPerformanceCounterEnabled) : (this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled))
			}
			get capturePerformanceCounters() {
				return this._capturePerformanceCounters
			}
			get loggingEnabled() {
				return this._loggingEnabled
			}
			_endPerformanceCounterEnabled(e) {
				dd.EndPerformanceCounter(e)
			}
			_validate(e, t, i = "", s = "") {
				this.validate && (this._startPerformanceCounter("Validate JSON"), nE.ValidateAsync(t, i, s, (t => this.preprocessUrlAsync(i + t).then((t => e._loadFileAsync(t, void 0, !0, !0).then((e => new Uint8Array(e, 0, e.byteLength))))))).then((e => {
					this._endPerformanceCounter("Validate JSON"), this.onValidatedObservable.notifyObservers(e), this.onValidatedObservable.clear()
				}), (e => {
					this._endPerformanceCounter("Validate JSON"), dd.Warn(`Failed to validate: ${e.message}`), this.onValidatedObservable.clear()
				})))
			}
			_endPerformanceCounterDisabled(e) {}
			directLoad(t, i) {
				if (i.startsWith("base64," + e._MagicBase64Encoded) || i.startsWith(";base64," + e._MagicBase64Encoded) || i.startsWith("application/octet-stream;base64," + e._MagicBase64Encoded) || i.startsWith("model/gltf-binary;base64," + e._MagicBase64Encoded)) {
					const e = Km(i);
					return this._validate(t, new Uint8Array(e, 0, e.byteLength)), this._unpackBinaryAsync(new tE({
						readAsync: (t, i) => mE(e, t, i),
						byteLength: e.byteLength
					}))
				}
				return this._validate(t, i), Promise.resolve({
					json: this._parseJson(i)
				})
			}
			_parseJson(e) {
				this._startPerformanceCounter("Parse JSON"), this._log(`JSON length: ${e.length}`);
				const t = JSON.parse(e);
				return this._endPerformanceCounter("Parse JSON"), t
			}
			static _parseVersion(e) {
				if ("1.0" === e || "1.0.1" === e) return {
					major: 1,
					minor: 0
				};
				const t = (e + "").match(/^(\d+)\.(\d+)/);
				return t ? {
					major: parseInt(t[1]),
					minor: parseInt(t[2])
				} : null
			}
			get loaderState() {
				return this._state
			}
			set onMeshLoaded(e) {
				this._onMeshLoadedObserver && this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver), this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(e)
			}
			_startPerformanceCounterDisabled(e) {}
			canDirectLoad(t) {
				return -1 !== t.indexOf("asset") && -1 !== t.indexOf("version") || t.startsWith("data:base64," + e._MagicBase64Encoded) || t.startsWith("data:;base64," + e._MagicBase64Encoded) || t.startsWith("data:application/octet-stream;base64," + e._MagicBase64Encoded) || t.startsWith("data:model/gltf-binary;base64," + e._MagicBase64Encoded)
			}
			_getLoader(t) {
				const i = t.json.asset || {};
				this._log(`Asset version: ${i.version}`), i.minVersion && this._log(`Asset minimum version: ${i.minVersion}`), i.generator && this._log(`Asset generator: ${i.generator}`);
				const s = e._parseVersion(i.version);
				if (!s) throw new Error("Invalid version: " + i.version);
				if (void 0 !== i.minVersion) {
					const t = e._parseVersion(i.minVersion);
					if (!t) throw new Error("Invalid minimum version: " + i.minVersion);
					if (e._compareVersion(t, {
							major: 2,
							minor: 0
						}) > 0) throw new Error("Incompatible minimum version: " + i.minVersion)
				}
				const n = {
					1: e._CreateGLTF1Loader,
					2: e._CreateGLTF2Loader
				} [s.major];
				if (!n) throw new Error("Unsupported version: " + i.version);
				return n(this)
			}
			set onTextureLoaded(e) {
				this._onTextureLoadedObserver && this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver), this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(e)
			}
			_onProgress(e, t) {
				if (!this._progressCallback) return;
				t._lengthComputable = e.lengthComputable, t._loaded = e.loaded, t._total = e.total;
				let i = !0,
					s = 0,
					n = 0;
				for (const e of this._requests) {
					if (void 0 === e._lengthComputable || void 0 === e._loaded || void 0 === e._total) return;
					i = i && e._lengthComputable, s += e._loaded, n += e._total
				}
				this._progressCallback({
					lengthComputable: i,
					loaded: s,
					total: i ? n : 0
				})
			}
			set onExtensionLoaded(e) {
				this._onExtensionLoadedObserver && this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver), this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(e)
			}
		};
	NE.IncrementalLoading = !0, NE.HomogeneousCoordinates = !1, NE._MagicBase64Encoded = "Z2xURg", NE._logSpaces = "                                ", XS(new NE), (fE = dE || (dE = {}))[fE.BYTE = 5120] = "BYTE", fE[fE.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", fE[fE.SHORT = 5122] = "SHORT", fE[fE.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", fE[fE.FLOAT = 5126] = "FLOAT", (_E = pE || (pE = {}))[_E.FRAGMENT = 35632] = "FRAGMENT", _E[_E.VERTEX = 35633] = "VERTEX", (vE = gE || (gE = {}))[vE.BYTE = 5120] = "BYTE", vE[vE.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", vE[vE.SHORT = 5122] = "SHORT", vE[vE.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", vE[vE.INT = 5124] = "INT", vE[vE.UNSIGNED_INT = 5125] = "UNSIGNED_INT", vE[vE.FLOAT = 5126] = "FLOAT", vE[vE.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", vE[vE.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", vE[vE.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", vE[vE.INT_VEC2 = 35667] = "INT_VEC2", vE[vE.INT_VEC3 = 35668] = "INT_VEC3", vE[vE.INT_VEC4 = 35669] = "INT_VEC4", vE[vE.BOOL = 35670] = "BOOL", vE[vE.BOOL_VEC2 = 35671] = "BOOL_VEC2", vE[vE.BOOL_VEC3 = 35672] = "BOOL_VEC3", vE[vE.BOOL_VEC4 = 35673] = "BOOL_VEC4", vE[vE.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", vE[vE.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", vE[vE.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", vE[vE.SAMPLER_2D = 35678] = "SAMPLER_2D", (SE = yE || (yE = {}))[SE.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", SE[SE.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", SE[SE.REPEAT = 10497] = "REPEAT", (AE = EE || (EE = {}))[AE.NEAREST = 9728] = "NEAREST", AE[AE.LINEAR = 9728] = "LINEAR", AE[AE.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", AE[AE.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", AE[AE.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", AE[AE.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", (xE = bE || (bE = {}))[xE.ALPHA = 6406] = "ALPHA", xE[xE.RGB = 6407] = "RGB", xE[xE.RGBA = 6408] = "RGBA", xE[xE.LUMINANCE = 6409] = "LUMINANCE", xE[xE.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", (CE = ME || (ME = {}))[CE.FRONT = 1028] = "FRONT", CE[CE.BACK = 1029] = "BACK", CE[CE.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", (wE = TE || (TE = {}))[wE.ZERO = 0] = "ZERO", wE[wE.ONE = 1] = "ONE", wE[wE.SRC_COLOR = 768] = "SRC_COLOR", wE[wE.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", wE[wE.DST_COLOR = 774] = "DST_COLOR", wE[wE.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", wE[wE.SRC_ALPHA = 770] = "SRC_ALPHA", wE[wE.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", wE[wE.DST_ALPHA = 772] = "DST_ALPHA", wE[wE.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", wE[wE.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", wE[wE.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", wE[wE.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", wE[wE.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", wE[wE.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", jc.AddNodeConstructor("Light_Type_0", ((e, t) => () => new IE(e, Lc.Zero(), t)));
	var IE = class extends Cg {
		getClassName() {
			return "PointLight"
		}
		getShadowDirection(e) {
			if (this.direction) return super.getShadowDirection(e);
			switch (e) {
				case 0:
					return new Lc(1, 0, 0);
				case 1:
					return new Lc(-1, 0, 0);
				case 2:
					return new Lc(0, -1, 0);
				case 3:
					return new Lc(0, 1, 0);
				case 4:
					return new Lc(0, 0, 1);
				case 5:
					return new Lc(0, 0, -1)
			}
			return Lc.Zero()
		}
		constructor(e, t, i) {
			super(e, i), this._shadowAngle = Math.PI / 2, this.position = t
		}
		_setDefaultShadowProjectionMatrix(e, t, i) {
			const s = this.getScene().activeCamera;
			if (!s) return;
			const n = void 0 !== this.shadowMinZ ? this.shadowMinZ : s.minZ,
				a = void 0 !== this.shadowMaxZ ? this.shadowMaxZ : s.maxZ,
				r = this.getScene().getEngine().useReverseDepthBuffer;
			Hc.PerspectiveFovLHToRef(this.shadowAngle, 1, r ? a : n, r ? n : a, e, !0, this._scene.getEngine().isNDCHalfZRange, void 0, r)
		}
		set shadowAngle(e) {
			this._shadowAngle = e, this.forceProjectionMatrixCompute()
		}
		get direction() {
			return this._direction
		}
		get shadowAngle() {
			return this._shadowAngle
		}
		set direction(e) {
			const t = this.needCube();
			if (this._direction = e, this.needCube() !== t && this._shadowGenerators) {
				const e = this._shadowGenerators.values();
				for (let t = e.next(); !0 !== t.done; t = e.next()) {
					t.value.recreateShadowMap()
				}
			}
		}
		needCube() {
			return !this.direction
		}
		prepareLightSpecificDefines(e, t) {
			e["POINTLIGHT" + t] = !0
		}
		_buildUniformLayout() {
			this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightFalloff", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create()
		}
		transferToNodeMaterialEffect(e, t) {
			return this.computeTransformedInformation() ? e.setFloat3(t, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z) : e.setFloat3(t, this.position.x, this.position.y, this.position.z), this
		}
		transferToEffect(e, t) {
			return this.computeTransformedInformation() ? this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, t) : this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, 0, t), this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, t), this
		}
		getTypeID() {
			return xg.LIGHTTYPEID_POINTLIGHT
		}
	};
	Gh([Xh()], IE.prototype, "shadowAngle", null), cc("BABYLON.PointLight", IE), jc.AddNodeConstructor("Light_Type_2", ((e, t) => () => new PE(e, Lc.Zero(), Lc.Zero(), 0, 0, t)));
	var PE = class e extends Cg {
		getTypeID() {
			return xg.LIGHTTYPEID_SPOTLIGHT
		}
		_setDirection(e) {
			super._setDirection(e), this._projectionTextureViewLightDirty = !0
		}
		get angle() {
			return this._angle
		}
		set angle(e) {
			this._angle = e, this._cosHalfAngle = Math.cos(.5 * e), this._projectionTextureProjectionLightDirty = !0, this.forceProjectionMatrixCompute(), this._computeAngleValues()
		}
		transferTexturesToEffect(e, t) {
			return this.projectionTexture && this.projectionTexture.isReady() && (this._projectionTextureViewLightDirty && this._computeProjectionTextureViewLightMatrix(), this._projectionTextureProjectionLightDirty && this._computeProjectionTextureProjectionLightMatrix(), this._projectionTextureDirty && this._computeProjectionTextureMatrix(), e.setMatrix("textureProjectionMatrix" + t, this._projectionTextureMatrix), e.setTexture("projectionLightTexture" + t, this.projectionTexture)), this
		}
		_computeProjectionTextureProjectionLightMatrix() {
			this._projectionTextureProjectionLightDirty = !1, this._projectionTextureDirty = !0;
			const e = this.projectionTextureLightFar,
				t = this.projectionTextureLightNear,
				i = e / (e - t),
				s = -i * t,
				n = 1 / Math.tan(this._angle / 2);
			Hc.FromValuesToRef(n / 1, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 1, 0, 0, s, 0, this._projectionTextureProjectionLightMatrix)
		}
		_computeProjectionTextureViewLightMatrix() {
			this._projectionTextureViewLightDirty = !1, this._projectionTextureDirty = !0, this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector), Hc.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix)
		}
		transferToEffect(e, t) {
			let i;
			return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, t), i = Lc.Normalize(this.transformedDirection)) : (this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, this.exponent, t), i = Lc.Normalize(this.direction)), this._uniformBuffer.updateFloat4("vLightDirection", i.x, i.y, i.z, this._cosHalfAngle, t), this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, t), this
		}
		set projectionTexture(t) {
			this._projectionTexture !== t && (this._projectionTexture = t, this._projectionTextureDirty = !0, this._projectionTexture && !this._projectionTexture.isReady() && (e._IsProceduralTexture(this._projectionTexture) ? this._projectionTexture.getEffect().executeWhenCompiled((() => {
				this._markMeshesAsLightDirty()
			})) : e._IsTexture(this._projectionTexture) && this._projectionTexture.onLoadObservable.addOnce((() => {
				this._markMeshesAsLightDirty()
			}))))
		}
		get projectionTextureProjectionLightMatrix() {
			return this._projectionTextureProjectionLightMatrix
		}
		get projectionTexture() {
			return this._projectionTexture
		}
		set projectionTextureLightFar(e) {
			this._projectionTextureLightFar = e, this._projectionTextureProjectionLightDirty = !0
		}
		get projectionTextureUpDirection() {
			return this._projectionTextureUpDirection
		}
		get projectionTextureLightNear() {
			return this._projectionTextureLightNear
		}
		prepareLightSpecificDefines(e, t) {
			e["SPOTLIGHT" + t] = !0, e["PROJECTEDLIGHTTEXTURE" + t] = !(!this.projectionTexture || !this.projectionTexture.isReady())
		}
		constructor(e, t, i, s, n, a) {
			super(e, a), this._innerAngle = 0, this._projectionTextureMatrix = Hc.Zero(), this._projectionTextureLightNear = 1e-6, this._projectionTextureLightFar = 1e3, this._projectionTextureUpDirection = Lc.Up(), this._projectionTextureViewLightDirty = !0, this._projectionTextureProjectionLightDirty = !0, this._projectionTextureDirty = !0, this._projectionTextureViewTargetVector = Lc.Zero(), this._projectionTextureViewLightMatrix = Hc.Zero(), this._projectionTextureProjectionLightMatrix = Hc.Zero(), this._projectionTextureScalingMatrix = Hc.FromValues(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, .5, 0, .5, .5, .5, 1), this.position = t, this.direction = i, this.angle = s, this.exponent = n
		}
		get projectionTextureMatrix() {
			return this._projectionTextureMatrix
		}
		_buildUniformLayout() {
			this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightDirection", 3), this._uniformBuffer.addUniform("vLightFalloff", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create()
		}
		_computeAngleValues() {
			this._lightAngleScale = 1 / Math.max(.001, Math.cos(.5 * this._innerAngle) - this._cosHalfAngle), this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale
		}
		get projectionTextureLightFar() {
			return this._projectionTextureLightFar
		}
		_computeProjectionTextureMatrix() {
			if (this._projectionTextureDirty = !1, this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix), this._projectionTexture instanceof Np) {
				const e = this._projectionTexture.uScale / 2,
					t = this._projectionTexture.vScale / 2;
				Hc.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, .5, 0, .5, .5, .5, 1, this._projectionTextureScalingMatrix)
			}
			this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix)
		}
		dispose() {
			super.dispose(), this._projectionTexture && this._projectionTexture.dispose()
		}
		static _IsTexture(e) {
			return void 0 !== e.onLoadObservable
		}
		set innerAngle(e) {
			this._innerAngle = e, this._computeAngleValues()
		}
		getDepthMinZ(e) {
			const t = this._scene.getEngine(),
				i = void 0 !== this.shadowMinZ ? this.shadowMinZ : e.minZ;
			return t.useReverseDepthBuffer && t.isNDCHalfZRange ? i : this._scene.getEngine().isNDCHalfZRange ? 0 : i
		}
		getDepthMaxZ(e) {
			const t = this._scene.getEngine(),
				i = void 0 !== this.shadowMaxZ ? this.shadowMaxZ : e.maxZ;
			return t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : i
		}
		_setPosition(e) {
			super._setPosition(e), this._projectionTextureViewLightDirty = !0
		}
		set shadowAngleScale(e) {
			this._shadowAngleScale = e, this.forceProjectionMatrixCompute()
		}
		set projectionTextureUpDirection(e) {
			this._projectionTextureUpDirection = e, this._projectionTextureProjectionLightDirty = !0
		}
		transferToNodeMaterialEffect(e, t) {
			let i;
			return i = this.computeTransformedInformation() ? Lc.Normalize(this.transformedDirection) : Lc.Normalize(this.direction), this.getScene().useRightHandedSystem ? e.setFloat3(t, -i.x, -i.y, -i.z) : e.setFloat3(t, i.x, i.y, i.z), this
		}
		set projectionTextureLightNear(e) {
			this._projectionTextureLightNear = e, this._projectionTextureProjectionLightDirty = !0
		}
		set projectionTextureProjectionLightMatrix(e) {
			this._projectionTextureProjectionLightMatrix = e, this._projectionTextureProjectionLightDirty = !1, this._projectionTextureDirty = !0
		}
		static _IsProceduralTexture(e) {
			return void 0 !== e.onGeneratedObservable
		}
		_setDefaultShadowProjectionMatrix(e, t, i) {
			const s = this.getScene().activeCamera;
			if (!s) return;
			this._shadowAngleScale = this._shadowAngleScale || 1;
			const n = this._shadowAngleScale * this._angle,
				a = void 0 !== this.shadowMinZ ? this.shadowMinZ : s.minZ,
				r = void 0 !== this.shadowMaxZ ? this.shadowMaxZ : s.maxZ,
				o = this.getScene().getEngine().useReverseDepthBuffer;
			Hc.PerspectiveFovLHToRef(n, 1, o ? r : a, o ? a : r, e, !0, this._scene.getEngine().isNDCHalfZRange, void 0, o)
		}
		getClassName() {
			return "SpotLight"
		}
		get shadowAngleScale() {
			return this._shadowAngleScale
		}
		get innerAngle() {
			return this._innerAngle
		}
	};
	Gh([Xh()], PE.prototype, "angle", null), Gh([Xh()], PE.prototype, "innerAngle", null), Gh([Xh()], PE.prototype, "shadowAngleScale", null), Gh([Xh()], PE.prototype, "exponent", void 0), Gh([Xh()], PE.prototype, "projectionTextureLightNear", null), Gh([Xh()], PE.prototype, "projectionTextureLightFar", null), Gh([Xh()], PE.prototype, "projectionTextureUpDirection", null), Gh([Yh("projectedLightTexture")], PE.prototype, "_projectionTexture", void 0), cc("BABYLON.SpotLight", PE);
	var kE, DE, OE = class e {
		static GetTextureFilterMode(e) {
			switch (e) {
				case EE.LINEAR:
				case EE.LINEAR_MIPMAP_NEAREST:
				case EE.LINEAR_MIPMAP_LINEAR:
					return Np.TRILINEAR_SAMPLINGMODE;
				case EE.NEAREST:
				case EE.NEAREST_MIPMAP_NEAREST:
					return Np.NEAREST_SAMPLINGMODE;
				default:
					return Np.BILINEAR_SAMPLINGMODE
			}
		}
		static SetMatrix(e, t, i, s, n) {
			let a = null;
			if ("MODEL" === i.semantic ? a = t.getWorldMatrix() : "PROJECTION" === i.semantic ? a = e.getProjectionMatrix() : "VIEW" === i.semantic ? a = e.getViewMatrix() : "MODELVIEWINVERSETRANSPOSE" === i.semantic ? a = Hc.Transpose(t.getWorldMatrix().multiply(e.getViewMatrix()).invert()) : "MODELVIEW" === i.semantic ? a = t.getWorldMatrix().multiply(e.getViewMatrix()) : "MODELVIEWPROJECTION" === i.semantic ? a = t.getWorldMatrix().multiply(e.getTransformMatrix()) : "MODELINVERSE" === i.semantic ? a = t.getWorldMatrix().invert() : "VIEWINVERSE" === i.semantic ? a = e.getViewMatrix().invert() : "PROJECTIONINVERSE" === i.semantic ? a = e.getProjectionMatrix().invert() : "MODELVIEWINVERSE" === i.semantic ? a = t.getWorldMatrix().multiply(e.getViewMatrix()).invert() : "MODELVIEWPROJECTIONINVERSE" === i.semantic ? a = t.getWorldMatrix().multiply(e.getTransformMatrix()).invert() : "MODELINVERSETRANSPOSE" === i.semantic && (a = Hc.Transpose(t.getWorldMatrix().invert())), a) switch (i.type) {
				case gE.FLOAT_MAT2:
					n.setMatrix2x2(s, Hc.GetAsMatrix2x2(a));
					break;
				case gE.FLOAT_MAT3:
					n.setMatrix3x3(s, Hc.GetAsMatrix3x3(a));
					break;
				case gE.FLOAT_MAT4:
					n.setMatrix(s, a)
			}
		}
		static GetWrapMode(e) {
			switch (e) {
				case yE.CLAMP_TO_EDGE:
					return Np.CLAMP_ADDRESSMODE;
				case yE.MIRRORED_REPEAT:
					return Np.MIRROR_ADDRESSMODE;
				case yE.REPEAT:
				default:
					return Np.WRAP_ADDRESSMODE
			}
		}
		static SetUniform(e, t, i, s) {
			switch (s) {
				case gE.FLOAT:
					return e.setFloat(t, i), !0;
				case gE.FLOAT_VEC2:
					return e.setVector2(t, Fc.FromArray(i)), !0;
				case gE.FLOAT_VEC3:
					return e.setVector3(t, Lc.FromArray(i)), !0;
				case gE.FLOAT_VEC4:
					return e.setVector4(t, Bc.FromArray(i)), !0;
				default:
					return !1
			}
		}
		static GetBufferFromAccessor(t, i) {
			const s = t.bufferViews[i.bufferView],
				n = i.count * e.GetByteStrideFromType(i);
			return e.GetBufferFromBufferView(t, s, i.byteOffset, n, i.componentType)
		}
		static GetBufferFromBufferView(e, t, i, s, n) {
			i = t.byteOffset + i;
			const a = e.loadedBufferViews[t.buffer];
			if (i + s > a.byteLength) throw new Error("Buffer access is out of range");
			const r = a.buffer;
			switch (i += a.byteOffset, n) {
				case dE.BYTE:
					return new Int8Array(r, i, s);
				case dE.UNSIGNED_BYTE:
					return new Uint8Array(r, i, s);
				case dE.SHORT:
					return new Int16Array(r, i, s);
				case dE.UNSIGNED_SHORT:
					return new Uint16Array(r, i, s);
				default:
					return new Float32Array(r, i, s)
			}
		}
		static GetDefaultMaterial(t) {
			if (!e._DefaultMaterial) {
				xm.ShadersStore.GLTFDefaultMaterialVertexShader = ["precision highp float;", "", "uniform mat4 worldView;", "uniform mat4 projection;", "", "attribute vec3 position;", "", "void main(void)", "{", "    gl_Position = projection * worldView * vec4(position, 1.0);", "}"].join("\n"), xm.ShadersStore.GLTFDefaultMaterialPixelShader = ["precision highp float;", "", "uniform vec4 u_emission;", "", "void main(void)", "{", "    gl_FragColor = u_emission;", "}"].join("\n");
				const i = {
						vertex: "GLTFDefaultMaterial",
						fragment: "GLTFDefaultMaterial"
					},
					s = {
						attributes: ["position"],
						uniforms: ["worldView", "projection", "u_emission"],
						samplers: new Array,
						needAlphaBlending: !1
					};
				e._DefaultMaterial = new Ay("GLTFDefaultMaterial", t, i, s), e._DefaultMaterial.setColor4("u_emission", new wc(.5, .5, .5, 1))
			}
			return e._DefaultMaterial
		}
		static GetByteStrideFromType(e) {
			switch (e.type) {
				case "VEC2":
					return 2;
				case "VEC3":
					return 3;
				case "VEC4":
				case "MAT2":
					return 4;
				case "MAT3":
					return 9;
				case "MAT4":
					return 16;
				default:
					return 1
			}
		}
		static DecodeBufferToText(e) {
			let t = "";
			const i = e.byteLength;
			for (let s = 0; s < i; ++s) t += String.fromCharCode(e[s]);
			return t
		}
	};
	OE._DefaultMaterial = null, (DE = kE || (kE = {}))[DE.IDENTIFIER = 1] = "IDENTIFIER", DE[DE.UNKNOWN = 2] = "UNKNOWN", DE[DE.END_OF_INPUT = 3] = "END_OF_INPUT";
	var FE = class {
			read() {
				return this._toParse[this._pos++]
			}
			peek() {
				return this._toParse[this._pos]
			}
			getNextToken() {
				if (this.isEnd()) return kE.END_OF_INPUT;
				if (this.currentString = this.read(), this.currentToken = kE.UNKNOWN, "_" === this.currentString || this.isLetterOrDigitPattern.test(this.currentString))
					for (this.currentToken = kE.IDENTIFIER, this.currentIdentifier = this.currentString; !this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || "_" === this.currentString);) this.currentIdentifier += this.currentString, this.forward();
				return this.currentToken
			}
			isEnd() {
				return this._pos >= this._maxPos
			}
			forward() {
				this._pos++
			}
			constructor(e) {
				this._pos = 0, this.currentToken = kE.UNKNOWN, this.currentIdentifier = "", this.currentString = "", this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/, this._toParse = e, this._maxPos = e.length
			}
		},
		LE = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"],
		BE = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"],
		GE = ["translation", "rotation", "scale"],
		HE = ["position", "rotationQuaternion", "scaling"],
		UE = (e, t, i) => {
			for (const s in e) {
				const n = e[s];
				i[t][s] = n
			}
		},
		VE = e => {
			if (e)
				for (let t = 0; t < e.length / 2; t++) e[2 * t + 1] = 1 - e[2 * t + 1]
		},
		WE = e => {
			if ("NORMAL" === e.semantic) return "normal";
			if ("POSITION" === e.semantic) return "position";
			if ("JOINT" === e.semantic) return "matricesIndices";
			if ("WEIGHT" === e.semantic) return "matricesWeights";
			if ("COLOR" === e.semantic) return "color";
			if (e.semantic && -1 !== e.semantic.indexOf("TEXCOORD_")) {
				const t = Number(e.semantic.split("_")[1]);
				return "uv" + (0 === t ? "" : t + 1)
			}
			return null
		},
		zE = e => {
			let t = null;
			if (e.translation || e.rotation || e.scale) {
				const i = Lc.FromArray(e.scale || [1, 1, 1]),
					s = Gc.FromArray(e.rotation || [0, 0, 0, 1]),
					n = Lc.FromArray(e.translation || [0, 0, 0]);
				t = Hc.Compose(i, s, n)
			} else t = Hc.FromArray(e.matrix);
			return t
		},
		XE = (e, t, i, s) => {
			for (let e = 0; e < s.bones.length; e++)
				if (s.bones[e].name === i) return s.bones[e];
			const n = e.nodes;
			for (const a in n) {
				const r = n[a];
				if (!r.jointName) continue;
				const o = r.children;
				for (let n = 0; n < o.length; n++) {
					const l = e.nodes[o[n]];
					if (l.jointName && l.jointName === i) {
						const i = zE(r),
							n = new mS(r.name || "", s, XE(e, t, r.jointName, s), i);
						return n.id = a, n
					}
				}
			}
			return null
		},
		YE = (e, t) => {
			for (let i = 0; i < e.length; i++) {
				const s = e[i];
				for (let e = 0; e < s.node.children.length; e++) {
					if (s.node.children[e] === t) return s.bone
				}
			}
			return null
		},
		jE = (e, t) => {
			const i = e.nodes;
			let s = i[t];
			if (s) return {
				node: s,
				id: t
			};
			for (const e in i)
				if (s = i[e], s.jointName === t) return {
					node: s,
					id: e
				};
			return null
		},
		KE = (e, t) => {
			for (let i = 0; i < e.jointNames.length; i++)
				if (e.jointNames[i] === t) return !0;
			return !1
		},
		$E = (e, t, i, s) => {
			if (s || (s = new gS(t.name || "", "", e.scene)), !t.babylonSkeleton) return s;
			const n = [],
				a = [];
			((e, t, i, s) => {
				for (const n in e.nodes) {
					const a = e.nodes[n],
						r = n;
					if (!a.jointName || KE(i, a.jointName)) continue;
					const o = zE(a),
						l = new mS(a.name || "", t, null, o);
					l.id = r, s.push({
						bone: l,
						node: a,
						id: r
					})
				}
				for (let e = 0; e < s.length; e++) {
					const t = s[e],
						i = t.node.children;
					for (let e = 0; e < i.length; e++) {
						let n = null;
						for (let t = 0; t < s.length; t++)
							if (s[t].id === i[e]) {
								n = s[t];
								break
							} n && (n.bone._parent = t.bone, t.bone.children.push(n.bone))
					}
				}
			})(e, s, t, n), s.bones = [];
			for (let i = 0; i < t.jointNames.length; i++) {
				const r = jE(e, t.jointNames[i]);
				if (!r) continue;
				const o = r.node;
				if (!o) {
					dd.Warn("Joint named " + t.jointNames[i] + " does not exist");
					continue
				}
				const l = r.id,
					h = e.scene.getBoneById(l);
				if (h) {
					s.bones.push(h);
					continue
				}
				let c = !1,
					u = null;
				for (let n = 0; n < i; n++) {
					const i = jE(e, t.jointNames[n]);
					if (!i) continue;
					const a = i.node;
					if (!a) {
						dd.Warn("Joint named " + t.jointNames[n] + " does not exist when looking for parent");
						continue
					}
					const r = a.children;
					if (r) {
						c = !1;
						for (let i = 0; i < r.length; i++)
							if (r[i] === l) {
								u = XE(e, t, t.jointNames[n], s), c = !0;
								break
							} if (c) break
					}
				}
				const m = zE(o);
				!u && n.length > 0 && (u = YE(n, l), u && -1 === a.indexOf(u) && a.push(u));
				new mS(o.jointName || "", s, u, m).id = l
			}
			const r = s.bones;
			s.bones = [];
			for (let i = 0; i < t.jointNames.length; i++) {
				const n = jE(e, t.jointNames[i]);
				if (n)
					for (let e = 0; e < r.length; e++)
						if (r[e].id === n.id) {
							s.bones.push(r[e]);
							break
						}
			}
			s.prepare();
			for (let e = 0; e < a.length; e++) s.bones.push(a[e]);
			return s
		},
		JE = (e, t, i, s, n) => {
			if (n || (e.scene._blockEntityCollection = !!e.assetContainer, (n = new Vf(t.name || "", e.scene))._parentContainer = e.assetContainer, e.scene._blockEntityCollection = !1, n.id = s), !t.babylonNode) return n;
			const a = [];
			let r = null;
			const o = [],
				l = [],
				h = [],
				c = [];
			for (let t = 0; t < i.length; t++) {
				const s = i[t],
					n = e.meshes[s];
				if (n)
					for (let t = 0; t < n.primitives.length; t++) {
						const i = new Mu,
							s = n.primitives[t];
						s.mode;
						const u = s.attributes;
						let m = null,
							d = null;
						for (const t in u)
							if (m = e.accessors[u[t]], d = OE.GetBufferFromAccessor(e, m), "NORMAL" === t) i.normals = new Float32Array(d.length), i.normals.set(d);
							else if ("POSITION" === t) {
							if (NE.HomogeneousCoordinates) {
								i.positions = new Float32Array(d.length - d.length / 4);
								for (let e = 0; e < d.length; e += 4) i.positions[e] = d[e], i.positions[e + 1] = d[e + 1], i.positions[e + 2] = d[e + 2]
							} else i.positions = new Float32Array(d.length), i.positions.set(d);
							l.push(i.positions.length)
						} else if (-1 !== t.indexOf("TEXCOORD_")) {
							const e = Number(t.split("_")[1]),
								s = eu.UVKind + (0 === e ? "" : e + 1),
								n = new Float32Array(d.length);
							n.set(d), VE(n), i.set(n, s)
						} else "JOINT" === t ? (i.matricesIndices = new Float32Array(d.length), i.matricesIndices.set(d)) : "WEIGHT" === t ? (i.matricesWeights = new Float32Array(d.length), i.matricesWeights.set(d)) : "COLOR" === t && (i.colors = new Float32Array(d.length), i.colors.set(d));
						if (m = e.accessors[s.indices], m) d = OE.GetBufferFromAccessor(e, m), i.indices = new Int32Array(d.length), i.indices.set(d), c.push(i.indices.length);
						else {
							const e = [];
							for (let t = 0; t < i.positions.length / 3; t++) e.push(t);
							i.indices = new Int32Array(e), c.push(i.indices.length)
						}
						r ? r.merge(i) : r = i;
						const f = e.scene.getMaterialById(s.material);
						a.push(null === f ? OE.GetDefaultMaterial(e.scene) : f), o.push(0 === o.length ? 0 : o[o.length - 1] + l[l.length - 2]), h.push(0 === h.length ? 0 : h[h.length - 1] + c[c.length - 2])
					}
			}
			let u;
			e.scene._blockEntityCollection = !!e.assetContainer, a.length > 1 ? (u = new kf("multimat" + s, e.scene), u.subMaterials = a) : u = new Wv("multimat" + s, e.scene), 1 === a.length && (u = a[0]), u._parentContainer = e.assetContainer, n.material || (n.material = u), new bd(s, e.scene, r, !1, n), n.computeWorldMatrix(!0), e.scene._blockEntityCollection = !1, n.subMeshes = [];
			let m = 0;
			for (let t = 0; t < i.length; t++) {
				const s = i[t],
					a = e.meshes[s];
				if (a)
					for (let e = 0; e < a.primitives.length; e++) a.primitives[e].mode, bu.AddToMesh(m, o[m], l[m], h[m], c[m], n, n, !0), m++
			}
			return n
		},
		qE = (e, t, i, s) => {
			e.position && (e.position = t), (e.rotationQuaternion || e.rotation) && (e.rotationQuaternion = i), e.scaling && (e.scaling = s)
		},
		QE = (e, t, i) => {
			let s = null;
			if (e.importOnlyMeshes && (t.skin || t.meshes) && e.importMeshesNames && e.importMeshesNames.length > 0 && -1 === e.importMeshesNames.indexOf(t.name || "")) return null;
			if (t.skin) {
				if (t.meshes) {
					const n = e.skins[t.skin],
						a = JE(e, t, t.meshes, i, t.babylonNode);
					a.skeleton = e.scene.getLastSkeletonById(t.skin), null === a.skeleton && (a.skeleton = $E(e, n, 0, n.babylonSkeleton), n.babylonSkeleton || (n.babylonSkeleton = a.skeleton)), s = a
				}
			} else if (t.meshes) {
				s = JE(e, t, t.mesh ? [t.mesh] : t.meshes, i, t.babylonNode)
			} else if (!t.light || t.babylonNode || e.importOnlyMeshes) {
				if (t.camera && !t.babylonNode && !e.importOnlyMeshes) {
					const i = e.cameras[t.camera];
					if (i) {
						if (e.scene._blockEntityCollection = !!e.assetContainer, "orthographic" === i.type) {
							const i = new lv(t.camera, Lc.Zero(), e.scene, !1);
							i.name = t.name || "", i.mode = Sd.ORTHOGRAPHIC_CAMERA, i.attachControl(), s = i, i._parentContainer = e.assetContainer
						} else if ("perspective" === i.type) {
							const n = i[i.type],
								a = new lv(t.camera, Lc.Zero(), e.scene, !1);
							a.name = t.name || "", a.attachControl(), n.aspectRatio || (n.aspectRatio = e.scene.getEngine().getRenderWidth() / e.scene.getEngine().getRenderHeight()), n.znear && n.zfar && (a.maxZ = n.zfar, a.minZ = n.znear), s = a, a._parentContainer = e.assetContainer
						}
						e.scene._blockEntityCollection = !1
					}
				}
			} else {
				const i = e.lights[t.light];
				if (i)
					if ("ambient" === i.type) {
						const n = i[i.type],
							a = new Mg(t.light, Lc.Zero(), e.scene);
						a.name = t.name || "", n.color && (a.diffuse = Tc.FromArray(n.color)), s = a
					} else if ("directional" === i.type) {
					const n = i[i.type],
						a = new Tg(t.light, Lc.Zero(), e.scene);
					a.name = t.name || "", n.color && (a.diffuse = Tc.FromArray(n.color)), s = a
				} else if ("point" === i.type) {
					const n = i[i.type],
						a = new IE(t.light, Lc.Zero(), e.scene);
					a.name = t.name || "", n.color && (a.diffuse = Tc.FromArray(n.color)), s = a
				} else if ("spot" === i.type) {
					const n = i[i.type],
						a = new PE(t.light, Lc.Zero(), Lc.Zero(), 0, 0, e.scene);
					a.name = t.name || "", n.color && (a.diffuse = Tc.FromArray(n.color)), n.fallOfAngle && (a.angle = n.fallOfAngle), n.fallOffExponent && (a.exponent = n.fallOffExponent), s = a
				}
			}
			if (!t.jointName) {
				if (t.babylonNode) return t.babylonNode;
				if (null === s) {
					e.scene._blockEntityCollection = !!e.assetContainer;
					const i = new Vf(t.name || "", e.scene);
					i._parentContainer = e.assetContainer, e.scene._blockEntityCollection = !1, t.babylonNode = i, s = i
				}
			}
			if (null !== s) {
				if (t.matrix && s instanceof Vf)((e, t) => {
					if (t.matrix) {
						const i = new Lc(0, 0, 0),
							s = new Gc,
							n = new Lc(0, 0, 0);
						Hc.FromArray(t.matrix).decompose(n, s, i), qE(e, i, s, n)
					} else t.translation && t.rotation && t.scale && qE(e, Lc.FromArray(t.translation), Gc.FromArray(t.rotation), Lc.FromArray(t.scale));
					e.computeWorldMatrix(!0)
				})(s, t);
				else {
					const e = t.translation || [0, 0, 0],
						i = t.rotation || [0, 0, 0, 1],
						n = t.scale || [1, 1, 1];
					qE(s, Lc.FromArray(e), Gc.FromArray(i), Lc.FromArray(n))
				}
				s.updateCache(!0), t.babylonNode = s
			}
			return s
		},
		ZE = (e, t, i, s = !1) => {
			const n = e.nodes[t];
			let a = null;
			if (s = !(e.importOnlyMeshes && !s && e.importMeshesNames) || (-1 !== e.importMeshesNames.indexOf(n.name || "") || 0 === e.importMeshesNames.length), !n.jointName && s && (a = QE(e, n, t), null !== a && (a.id = t, a.parent = i)), n.children)
				for (let t = 0; t < n.children.length; t++) ZE(e, n.children[t], a, s)
		},
		eA = e => {
			let t = e.currentScene;
			if (t)
				for (let i = 0; i < t.nodes.length; i++) ZE(e, t.nodes[i], null);
			else
				for (const i in e.scenes) {
					t = e.scenes[i];
					for (let i = 0; i < t.nodes.length; i++) ZE(e, t.nodes[i], null)
				}(e => {
					for (const t in e.animations) {
						const i = e.animations[t];
						if (!i.channels || !i.samplers) continue;
						let s = null;
						for (let n = 0; n < i.channels.length; n++) {
							const a = i.channels[n],
								r = i.samplers[a.sampler];
							if (!r) continue;
							let o = null,
								l = null;
							i.parameters ? (o = i.parameters[r.input], l = i.parameters[r.output]) : (o = r.input, l = r.output);
							const h = OE.GetBufferFromAccessor(e, e.accessors[o]),
								c = OE.GetBufferFromAccessor(e, e.accessors[l]),
								u = a.target.id;
							let m = e.scene.getNodeById(u);
							if (null === m && (m = e.scene.getNodeByName(u)), null === m) {
								dd.Warn("Creating animation named " + t + ". But cannot find node named " + u + " to attach to");
								continue
							}
							const d = m instanceof mS;
							let f = a.target.path;
							const p = GE.indexOf(f); - 1 !== p && (f = HE[p]);
							let _ = Wg.ANIMATIONTYPE_MATRIX;
							d || ("rotationQuaternion" === f ? (_ = Wg.ANIMATIONTYPE_QUATERNION, m.rotationQuaternion = new Gc) : _ = Wg.ANIMATIONTYPE_VECTOR3);
							let g = null;
							const v = [];
							let y = 0,
								S = !1;
							d && s && s.getKeys().length === h.length && (g = s, S = !0), S || (e.scene._blockEntityCollection = !!e.assetContainer, g = new Wg(t, d ? "_matrix" : f, 1, _, Wg.ANIMATIONLOOPMODE_CYCLE), e.scene._blockEntityCollection = !1);
							for (let e = 0; e < h.length; e++) {
								let t = null;
								if ("rotationQuaternion" === f ? (t = Gc.FromArray([c[y], c[y + 1], c[y + 2], c[y + 3]]), y += 4) : (t = Lc.FromArray([c[y], c[y + 1], c[y + 2]]), y += 3), d) {
									const i = m;
									let n = Lc.Zero(),
										a = new Gc,
										r = Lc.Zero(),
										o = i.getBaseMatrix();
									S && s && (o = s.getKeys()[e].value), o.decompose(r, a, n), "position" === f ? n = t : "rotationQuaternion" === f ? a = t : r = t, t = Hc.Compose(r, a, n)
								}
								S ? s && (s.getKeys()[e].value = t) : v.push({
									frame: h[e],
									value: t
								})
							}!S && g && (g.setKeys(v), m.animations.push(g)), s = g, e.scene.stopAnimation(m), e.scene.beginAnimation(m, 0, h[h.length - 1], !0, 1)
						}
					}
				})(e);
			for (let t = 0; t < e.scene.skeletons.length; t++) {
				const i = e.scene.skeletons[t];
				e.scene.beginAnimation(i, 0, Number.MAX_VALUE, !0, 1)
			}
		},
		tA = (e, t, i, s, n, a) => r => {
			((e, t, i, s, n) => {
				const a = s.values || i.parameters,
					r = i.uniforms;
				for (const i in n) {
					const o = n[i],
						l = o.type;
					let h = a[r[i]];
					if (void 0 === h && (h = o.value), !h) continue;
					const c = e => i => {
						o.value && e && (t.setTexture(e, i), delete n[e])
					};
					l === gE.SAMPLER_2D ? rA.LoadTextureAsync(e, s.values ? h : o.value, c(i), (() => c(null))) : o.value && OE.SetUniform(t, i, s.values ? h : o.value, l) && delete n[i]
				}
			})(e, t, i, s, n), t.onBind = r => {
				((e, t, i, s, n, a, r) => {
					const o = a.values || n.parameters;
					for (const r in i) {
						const l = i[r],
							h = l.type;
						if (h === gE.FLOAT_MAT2 || h === gE.FLOAT_MAT3 || h === gE.FLOAT_MAT4)
							if (!l.semantic || l.source || l.node) {
								if (l.semantic && (l.source || l.node)) {
									let e = t.scene.getNodeByName(l.source || l.node || "");
									if (null === e && (e = t.scene.getNodeById(l.source || l.node || "")), null === e) continue;
									OE.SetMatrix(t.scene, e, l, r, s.getEffect())
								}
							} else OE.SetMatrix(t.scene, e, l, r, s.getEffect());
						else {
							const e = o[n.uniforms[r]];
							if (!e) continue;
							if (h === gE.SAMPLER_2D) {
								const i = t.textures[a.values ? e : l.value].babylonTexture;
								if (null == i) continue;
								s.getEffect().setTexture(r, i)
							} else OE.SetUniform(s.getEffect(), r, e, h)
						}
					}
					r(s)
				})(r, e, n, t, i, s, a)
			}
		},
		iA = (e, t, i) => {
			for (const s in t.uniforms) {
				const n = t.uniforms[s],
					a = t.parameters[n];
				if (e.currentIdentifier === s && a.semantic && !a.source && !a.node) {
					const e = LE.indexOf(a.semantic);
					if (-1 !== e) return delete i[s], BE[e]
				}
			}
			return e.currentIdentifier
		},
		sA = e => {
			for (const t in e.materials) rA.LoadMaterialAsync(e, t, (() => {}), (() => {}))
		},
		nA = class {
			static CreateRuntime(e, t, i) {
				const s = {
					extensions: {},
					accessors: {},
					buffers: {},
					bufferViews: {},
					meshes: {},
					lights: {},
					cameras: {},
					nodes: {},
					images: {},
					textures: {},
					shaders: {},
					programs: {},
					samplers: {},
					techniques: {},
					materials: {},
					animations: {},
					skins: {},
					extensionsUsed: [],
					scenes: {},
					buffersCount: 0,
					shaderscount: 0,
					scene: t,
					rootUrl: i,
					loadedBufferCount: 0,
					loadedBufferViews: {},
					loadedShaderCount: 0,
					importOnlyMeshes: !1,
					dummyNodes: [],
					assetContainer: null
				};
				return e.extensions && UE(e.extensions, "extensions", s), e.extensionsUsed && UE(e.extensionsUsed, "extensionsUsed", s), e.buffers && ((e, t) => {
					for (const i in e) {
						const s = e[i];
						t.buffers[i] = s, t.buffersCount++
					}
				})(e.buffers, s), e.bufferViews && UE(e.bufferViews, "bufferViews", s), e.accessors && UE(e.accessors, "accessors", s), e.meshes && UE(e.meshes, "meshes", s), e.lights && UE(e.lights, "lights", s), e.cameras && UE(e.cameras, "cameras", s), e.nodes && UE(e.nodes, "nodes", s), e.images && UE(e.images, "images", s), e.textures && UE(e.textures, "textures", s), e.shaders && ((e, t) => {
					for (const i in e) {
						const s = e[i];
						t.shaders[i] = s, t.shaderscount++
					}
				})(e.shaders, s), e.programs && UE(e.programs, "programs", s), e.samplers && UE(e.samplers, "samplers", s), e.techniques && UE(e.techniques, "techniques", s), e.materials && UE(e.materials, "materials", s), e.animations && UE(e.animations, "animations", s), e.skins && UE(e.skins, "skins", s), e.scenes && (s.scenes = e.scenes), e.scene && e.scenes && (s.currentScene = e.scenes[e.scene]), s
			}
			static LoadMaterialAsync(e, t, i, s) {
				const n = e.materials[t];
				if (!n.technique) return void(s && s("No technique found."));
				const a = e.techniques[n.technique];
				if (!a) {
					e.scene._blockEntityCollection = !!e.assetContainer;
					const s = new Wv(t, e.scene);
					return s._parentContainer = e.assetContainer, e.scene._blockEntityCollection = !1, s.diffuseColor = new Tc(.5, .5, .5), s.sideOrientation = Pf.CounterClockWiseSideOrientation, void i(s)
				}
				const r = e.programs[a.program],
					o = a.states,
					l = xm.ShadersStore[r.vertexShader + "VertexShader"],
					h = xm.ShadersStore[r.fragmentShader + "PixelShader"];
				let c = "",
					u = "";
				const m = new FE(l),
					d = new FE(h),
					f = {},
					p = [],
					_ = [],
					g = [];
				for (const e in a.uniforms) {
					const t = a.uniforms[e],
						i = a.parameters[t];
					if (f[e] = i, !i.semantic || i.node || i.source) i.type === gE.SAMPLER_2D ? g.push(e) : p.push(e);
					else {
						const t = LE.indexOf(i.semantic); - 1 !== t ? (p.push(BE[t]), delete f[e]) : p.push(e)
					}
				}
				for (const e in a.attributes) {
					const t = a.attributes[e],
						i = a.parameters[t];
					if (i.semantic) {
						const e = WE(i);
						e && _.push(e)
					}
				}
				for (; !m.isEnd() && m.getNextToken();) {
					if (m.currentToken !== kE.IDENTIFIER) {
						c += m.currentString;
						continue
					}
					let e = !1;
					for (const t in a.attributes) {
						const i = a.attributes[t],
							s = a.parameters[i];
						if (m.currentIdentifier === t && s.semantic) {
							c += WE(s), e = !0;
							break
						}
					}
					e || (c += iA(m, a, f))
				}
				for (; !d.isEnd() && d.getNextToken();) {
					d.currentToken === kE.IDENTIFIER ? u += iA(d, a, f) : u += d.currentString
				}
				const v = {
						vertex: r.vertexShader + t,
						fragment: r.fragmentShader + t
					},
					y = {
						attributes: _,
						uniforms: p,
						samplers: g,
						needAlphaBlending: o && o.enable && -1 !== o.enable.indexOf(3042)
					};
				xm.ShadersStore[r.vertexShader + t + "VertexShader"] = c, xm.ShadersStore[r.fragmentShader + t + "PixelShader"] = u;
				const S = new Ay(t, e.scene, v, y);
				if (S.onError = ((e, t, i) => (s, n) => {
						t.dispose(!0), i("Cannot compile program named " + e.name + ". Error: " + n + ". Default material will be applied")
					})(r, S, s), S.onCompiled = tA(e, S, a, n, f, i), S.sideOrientation = Pf.CounterClockWiseSideOrientation, o && o.functions) {
					const e = o.functions;
					e.cullFace && e.cullFace[0] !== ME.BACK && (S.backFaceCulling = !1);
					const t = e.blendFuncSeparate;
					t && (t[0] === TE.SRC_ALPHA && t[1] === TE.ONE_MINUS_SRC_ALPHA && t[2] === TE.ONE && t[3] === TE.ONE ? S.alphaMode = Jv.ALPHA_COMBINE : t[0] === TE.ONE && t[1] === TE.ONE && t[2] === TE.ZERO && t[3] === TE.ONE ? S.alphaMode = Jv.ALPHA_ONEONE : t[0] === TE.SRC_ALPHA && t[1] === TE.ONE && t[2] === TE.ZERO && t[3] === TE.ONE ? S.alphaMode = Jv.ALPHA_ADD : t[0] === TE.ZERO && t[1] === TE.ONE_MINUS_SRC_COLOR && t[2] === TE.ONE && t[3] === TE.ONE ? S.alphaMode = Jv.ALPHA_SUBTRACT : t[0] === TE.DST_COLOR && t[1] === TE.ZERO && t[2] === TE.ONE && t[3] === TE.ONE ? S.alphaMode = Jv.ALPHA_MULTIPLY : t[0] === TE.SRC_ALPHA && t[1] === TE.ONE_MINUS_SRC_COLOR && t[2] === TE.ONE && t[3] === TE.ONE && (S.alphaMode = Jv.ALPHA_MAXIMIZED))
				}
			}
			static CreateTextureAsync(e, t, i, s) {
				const n = e.textures[t];
				if (n.babylonTexture) return void s(n.babylonTexture);
				const a = e.samplers[n.sampler],
					r = a.minFilter === EE.NEAREST_MIPMAP_NEAREST || a.minFilter === EE.NEAREST_MIPMAP_LINEAR || a.minFilter === EE.LINEAR_MIPMAP_NEAREST || a.minFilter === EE.LINEAR_MIPMAP_LINEAR,
					o = Np.BILINEAR_SAMPLINGMODE,
					l = null == i ? new Blob : new Blob([i]),
					h = URL.createObjectURL(l),
					c = () => URL.revokeObjectURL(h),
					u = new Np(h, e.scene, !r, !0, o, c, c);
				void 0 !== a.wrapS && (u.wrapU = OE.GetWrapMode(a.wrapS)), void 0 !== a.wrapT && (u.wrapV = OE.GetWrapMode(a.wrapT)), u.name = t, n.babylonTexture = u, s(u)
			}
			static LoadBufferAsync(e, t, i, s, n) {
				const a = e.buffers[t];
				dd.IsBase64(a.uri) ? setTimeout((() => i(new Uint8Array(dd.DecodeBase64(a.uri))))) : dd.LoadFile(e.rootUrl + a.uri, (e => i(new Uint8Array(e))), n, void 0, !0, (e => {
					e && s(e.status + " " + e.statusText)
				}))
			}
			static LoadTextureBufferAsync(e, t, i, s) {
				const n = e.textures[t];
				if (!n || !n.source) return void s("");
				if (n.babylonTexture) return void i(null);
				const a = e.images[n.source];
				dd.IsBase64(a.uri) ? setTimeout((() => i(new Uint8Array(dd.DecodeBase64(a.uri))))) : dd.LoadFile(e.rootUrl + a.uri, (e => i(new Uint8Array(e))), void 0, void 0, !0, (e => {
					e && s(e.status + " " + e.statusText)
				}))
			}
			static LoadShaderStringAsync(e, t, i, s) {
				const n = e.shaders[t];
				if (dd.IsBase64(n.uri)) {
					const e = atob(n.uri.split(",")[1]);
					i && i(e)
				} else dd.LoadFile(e.rootUrl + n.uri, i, void 0, void 0, !1, (e => {
					e && s && s(e.status + " " + e.statusText)
				}))
			}
		},
		aA = class e {
			static RegisterExtension(t) {
				e.Extensions[t.name] ? dd.Error('Tool with the same name "' + t.name + '" already exists') : e.Extensions[t.name] = t
			}
			_loadShadersAsync(e, t) {
				let i = !1;
				const s = (i, s) => {
					rA.LoadShaderStringAsync(e, i, (n => {
						n instanceof ArrayBuffer || (e.loadedShaderCount++, n && (xm.ShadersStore[i + (s.type === pE.VERTEX ? "VertexShader" : "PixelShader")] = n), e.loadedShaderCount === e.shaderscount && t())
					}), (() => {
						dd.Error("Error when loading shader program named " + i + " located at " + s.uri)
					}))
				};
				for (const t in e.shaders) {
					i = !0;
					const n = e.shaders[t];
					n ? s.bind(this, t, n)() : dd.Error("No shader named: " + t)
				}
				i || t()
			}
			_loadBuffersAsync(e, t) {
				let i = !1;
				const s = (i, s) => {
					rA.LoadBufferAsync(e, i, (n => {
						e.loadedBufferCount++, n && (n.byteLength != e.buffers[i].byteLength && dd.Error("Buffer named " + i + " is length " + n.byteLength + ". Expected: " + s.byteLength), e.loadedBufferViews[i] = n), e.loadedBufferCount === e.buffersCount && t()
					}), (() => {
						dd.Error("Error when loading buffer named " + i + " located at " + s.uri)
					}))
				};
				for (const t in e.buffers) {
					i = !0;
					const n = e.buffers[t];
					n ? s.bind(this, t, n)() : dd.Error("No buffer named: " + t)
				}
				i || t()
			}
			_importMeshAsync(e, t, i, s, n, a, r, o) {
				return t.useRightHandedSystem = !0, rA.LoadRuntimeAsync(t, i, s, (t => {
					t.assetContainer = n, t.importOnlyMeshes = !0, "" === e ? t.importMeshesNames = [] : "string" == typeof e ? t.importMeshesNames = [e] : !e || e instanceof Array ? (t.importMeshesNames = [], dd.Warn("Argument meshesNames must be of type string or string[]")) : t.importMeshesNames = [e], this._createNodes(t);
					const i = [],
						s = [];
					for (const e in t.nodes) {
						const s = t.nodes[e];
						s.babylonNode instanceof jd && i.push(s.babylonNode)
					}
					for (const e in t.skins) {
						const i = t.skins[e];
						i.babylonSkeleton instanceof gS && s.push(i.babylonSkeleton)
					}
					this._loadBuffersAsync(t, (() => {
						this._loadShadersAsync(t, (() => {
							sA(t), eA(t), !NE.IncrementalLoading && a && a(i, s)
						}))
					})), NE.IncrementalLoading && a && a(i, s)
				}), o), !0
			}
			dispose() {}
			importMeshAsync(e, t, i, s, n, a) {
				return new Promise(((r, o) => {
					this._importMeshAsync(e, t, s, n, i, ((e, t) => {
						r({
							meshes: e,
							particleSystems: [],
							skeletons: t,
							animationGroups: [],
							lights: [],
							transformNodes: [],
							geometries: [],
							spriteManagers: []
						})
					}), a, (e => {
						o(new Error(e))
					}))
				}))
			}
			_loadAsync(e, t, i, s, n, a) {
				e.useRightHandedSystem = !0, rA.LoadRuntimeAsync(e, t, i, (e => {
					rA.LoadRuntimeExtensionsAsync(e, (() => {
						this._createNodes(e), this._loadBuffersAsync(e, (() => {
							this._loadShadersAsync(e, (() => {
								sA(e), eA(e), NE.IncrementalLoading || s()
							}))
						})), NE.IncrementalLoading && s()
					}), a)
				}), a)
			}
			loadAsync(e, t, i, s) {
				return new Promise(((n, a) => {
					this._loadAsync(e, t, i, (() => {
						n()
					}), s, (e => {
						a(new Error(e))
					}))
				}))
			}
			_createNodes(e) {
				let t = e.currentScene;
				if (t)
					for (let i = 0; i < t.nodes.length; i++) ZE(e, t.nodes[i], null);
				else
					for (const i in e.scenes) {
						t = e.scenes[i];
						for (let i = 0; i < t.nodes.length; i++) ZE(e, t.nodes[i], null)
					}
			}
		};
	aA.Extensions = {};
	var rA = class e {
		loadRuntimeAsync(e, t, i, s, n) {
			return !1
		}
		static LoadTextureAsync(t, i, s, n) {
			e._LoadTextureBufferAsync(t, i, (a => {
				a && e._CreateTextureAsync(t, i, a, s, n)
			}), n)
		}
		createTextureAsync(e, t, i, s, n) {
			return !1
		}
		loadBufferAsync(e, t, i, s, n) {
			return !1
		}
		static LoadMaterialAsync(t, i, s, n) {
			e._ApplyExtensions((e => e.loadMaterialAsync(t, i, s, n)), (() => {
				nA.LoadMaterialAsync(t, i, s, n)
			}))
		}
		static LoadBufferAsync(t, i, s, n, a) {
			e._ApplyExtensions((e => e.loadBufferAsync(t, i, s, n, a)), (() => {
				nA.LoadBufferAsync(t, i, s, n, a)
			}))
		}
		static LoadRuntimeExtensionsAsync(t, i, s) {
			e._ApplyExtensions((e => e.loadRuntimeExtensionsAsync(t, i, s)), (() => {
				setTimeout((() => {
					i()
				}))
			}))
		}
		static _ApplyExtensions(e, t) {
			for (const t in aA.Extensions) {
				if (e(aA.Extensions[t])) return
			}
			t()
		}
		loadRuntimeExtensionsAsync(e, t, i) {
			return !1
		}
		constructor(e) {
			this._name = e
		}
		get name() {
			return this._name
		}
		static _LoadTextureBufferAsync(t, i, s, n) {
			e._ApplyExtensions((e => e.loadTextureBufferAsync(t, i, s, n)), (() => {
				nA.LoadTextureBufferAsync(t, i, s, n)
			}))
		}
		loadTextureBufferAsync(e, t, i, s) {
			return !1
		}
		static LoadRuntimeAsync(t, i, s, n, a) {
			e._ApplyExtensions((e => e.loadRuntimeAsync(t, i, s, n, a)), (() => {
				setTimeout((() => {
					n && n(nA.CreateRuntime(i.json, t, s))
				}))
			}))
		}
		static LoadShaderStringAsync(t, i, s, n) {
			e._ApplyExtensions((e => e.loadShaderStringAsync(t, i, s, n)), (() => {
				nA.LoadShaderStringAsync(t, i, s, n)
			}))
		}
		loadShaderStringAsync(e, t, i, s) {
			return !1
		}
		static _CreateTextureAsync(t, i, s, n, a) {
			e._ApplyExtensions((e => e.createTextureAsync(t, i, s, n, a)), (() => {
				nA.CreateTextureAsync(t, i, s, n)
			}))
		}
		loadMaterialAsync(e, t, i, s) {
			return !1
		}
	};
	NE._CreateGLTF1Loader = () => new aA;
	aA.RegisterExtension(new class extends rA {
		loadBufferAsync(e, t, i, s) {
			return -1 !== e.extensionsUsed.indexOf(this.name) && ("binary_glTF" === t && (this._bin.readAsync(0, this._bin.byteLength).then(i, (e => s(e.message))), !0))
		}
		loadTextureBufferAsync(e, t, i) {
			const s = e.textures[t],
				n = e.images[s.source];
			if (!n.extensions || !(this.name in n.extensions)) return !1;
			const a = n.extensions[this.name],
				r = e.bufferViews[a.bufferView];
			return i(OE.GetBufferFromBufferView(e, r, 0, r.byteLength, dE.UNSIGNED_BYTE)), !0
		}
		loadRuntimeAsync(e, t, i, s) {
			const n = t.json.extensionsUsed;
			return !(!n || -1 === n.indexOf(this.name) || !t.bin) && (this._bin = t.bin, s(nA.CreateRuntime(t.json, e, i)), !0)
		}
		loadShaderStringAsync(e, t, i) {
			const s = e.shaders[t];
			if (!s.extensions || !(this.name in s.extensions)) return !1;
			const n = s.extensions[this.name],
				a = e.bufferViews[n.bufferView],
				r = OE.GetBufferFromBufferView(e, a, 0, a.byteLength, dE.UNSIGNED_BYTE);
			return setTimeout((() => {
				const e = OE.DecodeBufferToText(r);
				i(e)
			})), !0
		}
		constructor() {
			super("KHR_binary_glTF")
		}
	});
	aA.RegisterExtension(new class extends rA {
		loadRuntimeExtensionsAsync(e) {
			if (!e.extensions) return !1;
			const t = e.extensions[this.name];
			if (!t) return !1;
			const i = t.lights;
			if (i)
				for (const t in i) {
					const s = i[t];
					switch (s.type) {
						case "ambient": {
							const t = new Mg(s.name, new Lc(0, 1, 0), e.scene),
								i = s.ambient;
							i && (t.diffuse = Tc.FromArray(i.color || [1, 1, 1]));
							break
						}
						case "point": {
							const t = new IE(s.name, new Lc(10, 10, 10), e.scene),
								i = s.point;
							i && (t.diffuse = Tc.FromArray(i.color || [1, 1, 1]));
							break
						}
						case "directional": {
							const t = new Tg(s.name, new Lc(0, -1, 0), e.scene),
								i = s.directional;
							i && (t.diffuse = Tc.FromArray(i.color || [1, 1, 1]));
							break
						}
						case "spot": {
							const t = s.spot;
							if (t) {
								new PE(s.name, new Lc(0, 10, 0), new Lc(0, -1, 0), t.fallOffAngle || Math.PI, t.fallOffExponent || 0, e.scene).diffuse = Tc.FromArray(t.color || [1, 1, 1])
							}
							break
						}
						default:
							dd.Warn('GLTF Material Common extension: light type "' + s.type + "\u201d not supported")
					}
				}
			return !1
		}
		constructor() {
			super("KHR_materials_common")
		}
		_loadTexture(e, t, i, s, n) {
			nA.LoadTextureBufferAsync(e, t, (n => {
				nA.CreateTextureAsync(e, t, n, (e => i[s] = e))
			}), n)
		}
		loadMaterialAsync(e, t, i, s) {
			const n = e.materials[t];
			if (!n || !n.extensions) return !1;
			const a = n.extensions[this.name];
			if (!a) return !1;
			const r = new Wv(t, e.scene);
			return r.sideOrientation = Pf.CounterClockWiseSideOrientation, "CONSTANT" === a.technique && (r.disableLighting = !0), r.backFaceCulling = void 0 !== a.doubleSided && !a.doubleSided, r.alpha = void 0 === a.values.transparency ? 1 : a.values.transparency, r.specularPower = void 0 === a.values.shininess ? 0 : a.values.shininess, "string" == typeof a.values.ambient ? this._loadTexture(e, a.values.ambient, r, "ambientTexture", s) : r.ambientColor = Tc.FromArray(a.values.ambient || [0, 0, 0]), "string" == typeof a.values.diffuse ? this._loadTexture(e, a.values.diffuse, r, "diffuseTexture", s) : r.diffuseColor = Tc.FromArray(a.values.diffuse || [0, 0, 0]), "string" == typeof a.values.emission ? this._loadTexture(e, a.values.emission, r, "emissiveTexture", s) : r.emissiveColor = Tc.FromArray(a.values.emission || [0, 0, 0]), "string" == typeof a.values.specular ? this._loadTexture(e, a.values.specular, r, "specularTexture", s) : r.specularColor = Tc.FromArray(a.values.specular || [0, 0, 0]), !0
		}
	});
	var oA = class {
			get resolve() {
				return this._resolve
			}
			constructor() {
				this.promise = new Promise(((e, t) => {
					this._resolve = e, this._reject = t
				}))
			}
			get reject() {
				return this._reject
			}
		},
		lA = class {
			serialize() {
				const e = {};
				return e.animation = this.animation.serialize(), e.targetId = this.target.id, e
			}
			getClassName() {
				return "TargetedAnimation"
			}
		},
		hA = class e {
			get enableBlending() {
				return this._enableBlending
			}
			setWeightForAllAnimatables(e) {
				for (let t = 0; t < this._animatables.length; t++) {
					this._animatables[t].weight = e
				}
				return this
			}
			set weight(e) {
				this._weight !== e && (this._weight = e, this.setWeightForAllAnimatables(this._weight))
			}
			get children() {
				return this._targetedAnimations
			}
			set blendingSpeed(e) {
				if (this._blendingSpeed !== e && (this._blendingSpeed = e, null !== e))
					for (let t = 0; t < this._targetedAnimations.length; ++t) this._targetedAnimations[t].animation.blendingSpeed = e
			}
			get isAdditive() {
				return this._isAdditive
			}
			removeUnmaskedAnimations() {
				if (this.mask && !this.mask.disabled) {
					for (let e = 0; e < this._animatables.length; ++e) {
						const t = this._animatables[e];
						this.mask.retainsTarget(t.target.name) || (t.stop(), this._animatables.splice(e, 1), --e)
					}
					for (let e = 0; e < this._targetedAnimations.length; e++) {
						const t = this._targetedAnimations[e];
						this.mask.retainsTarget(t.target.name) || (this._targetedAnimations.splice(e, 1), --e)
					}
				}
			}
			normalize(e = null, t = null) {
				null == e && (e = this._from), null == t && (t = this._to);
				for (let i = 0; i < this._targetedAnimations.length; i++) {
					const s = this._targetedAnimations[i].animation.getKeys(),
						n = s[0],
						a = s[s.length - 1];
					if (n.frame > e) {
						const t = {
							frame: e,
							value: n.value,
							inTangent: n.inTangent,
							outTangent: n.outTangent,
							interpolation: n.interpolation
						};
						s.splice(0, 0, t)
					}
					if (a.frame < t) {
						const e = {
							frame: t,
							value: a.value,
							inTangent: a.inTangent,
							outTangent: a.outTangent,
							interpolation: a.interpolation
						};
						s.push(e)
					}
				}
				return this._from = e, this._to = t, this
			}
			clone(t, i, s = !1) {
				const n = new e(t || this.name, this._scene, this._weight, this._playOrder);
				n._from = this.from, n._to = this.to, n._speedRatio = this.speedRatio, n._loopAnimation = this.loopAnimation, n._isAdditive = this.isAdditive, n._enableBlending = this.enableBlending, n._blendingSpeed = this.blendingSpeed, n.metadata = this.metadata, n.mask = this.mask;
				for (const e of this._targetedAnimations) n.addTargetedAnimation(s ? e.animation.clone() : e.animation, i ? i(e.target) : e.target);
				return n
			}
			_checkAnimationGroupEnded(e, t = !1) {
				const i = this._animatables.indexOf(e);
				i > -1 && this._animatables.splice(i, 1), 0 === this._animatables.length && (this._isStarted = !1, t || this.onAnimationGroupEndObservable.notifyObservers(this))
			}
			get isPlaying() {
				return this._isStarted && !this._isPaused
			}
			play(e) {
				return this.isStarted && this._animatables.length && !this._shouldStart ? (void 0 !== e && (this.loopAnimation = e), this.restart()) : (this.stop(), this.start(e, this._speedRatio)), this
			}
			get playOrder() {
				return this._playOrder
			}
			set mask(e) {
				this._mask !== e && (this._mask = e, this.syncWithMask(!0))
			}
			reset() {
				if (!this._isStarted) return this.play(), this.goToFrame(0), this.stop(!0), this;
				for (let e = 0; e < this._animatables.length; e++) {
					this._animatables[e].reset()
				}
				return this
			}
			getLength(e, t) {
				e = e ?? this._from;
				return ((t = t ?? this._to) - e) / (this.targetedAnimations[0].animation.framePerSecond * this._speedRatio)
			}
			removeTargetedAnimation(e) {
				for (let t = this._targetedAnimations.length - 1; t > -1; t--) {
					this._targetedAnimations[t].animation === e && this._targetedAnimations.splice(t, 1)
				}
			}
			toString(e) {
				let t = "Name: " + this.name;
				return t += ", type: " + this.getClassName(), e && (t += ", from: " + this._from, t += ", to: " + this._to, t += ", isStarted: " + this._isStarted, t += ", speedRatio: " + this._speedRatio, t += ", targetedAnimations length: " + this._targetedAnimations.length, t += ", animatables length: " + this._animatables), t
			}
			get blendingSpeed() {
				return this._blendingSpeed
			}
			static ClipFramesInPlace(t, i, s, n) {
				return e.ClipInPlace(t, i, s, n, !0)
			}
			set speedRatio(e) {
				if (this._speedRatio !== e) {
					this._speedRatio = e;
					for (let e = 0; e < this._animatables.length; e++) {
						this._animatables[e].speedRatio = this._speedRatio
					}
				}
			}
			static ClipKeys(t, i, s, n, a) {
				const r = t.clone(n || t.name);
				return e.ClipKeysInPlace(r, i, s, a)
			}
			set enableBlending(e) {
				if (this._enableBlending !== e && (this._enableBlending = e, null !== e))
					for (let t = 0; t < this._targetedAnimations.length; ++t) this._targetedAnimations[t].animation.enableBlending = e
			}
			constructor(e, t = null, i = -1, s = 0) {
				this.name = e, this._targetedAnimations = new Array, this._animatables = new Array, this._from = Number.MAX_VALUE, this._to = -Number.MAX_VALUE, this._speedRatio = 1, this._loopAnimation = !1, this._isAdditive = !1, this._weight = -1, this._playOrder = 0, this._enableBlending = null, this._blendingSpeed = null, this._numActiveAnimatables = 0, this._shouldStart = !0, this._parentContainer = null, this.onAnimationEndObservable = new kc, this.onAnimationLoopObservable = new kc, this.onAnimationGroupLoopObservable = new kc, this.onAnimationGroupEndObservable = new kc, this.onAnimationGroupPauseObservable = new kc, this.onAnimationGroupPlayObservable = new kc, this.metadata = null, this._mask = null, this._animationLoopFlags = [], this._scene = t || Dc.LastCreatedScene, this._weight = i, this._playOrder = s, this.ik = this._scene.getUniqueId(), this._scene.addAnimationGroup(this)
			}
			dispose() {
				this.isStarted && this.stop(), this._targetedAnimations.length = 0, this._animatables.length = 0;
				const e = this._scene.animationGroups.indexOf(this);
				if (e > -1 && this._scene.animationGroups.splice(e, 1), this._parentContainer) {
					const e = this._parentContainer.animationGroups.indexOf(this);
					e > -1 && this._parentContainer.animationGroups.splice(e, 1), this._parentContainer = null
				}
				this.onAnimationEndObservable.clear(), this.onAnimationGroupEndObservable.clear(), this.onAnimationGroupPauseObservable.clear(), this.onAnimationGroupPlayObservable.clear(), this.onAnimationLoopObservable.clear(), this.onAnimationGroupLoopObservable.clear()
			}
			getCurrentFrame() {
				return this.animatables[0]?.masterFrame || 0
			}
			syncAllAnimationsWith(e) {
				for (let t = 0; t < this._animatables.length; t++) {
					this._animatables[t].syncWith(e)
				}
				return this
			}
			set isAdditive(e) {
				if (this._isAdditive !== e) {
					this._isAdditive = e;
					for (let e = 0; e < this._animatables.length; e++) {
						this._animatables[e].isAdditive = this._isAdditive
					}
				}
			}
			serialize() {
				const e = {};
				e.name = this.name, e.from = this.from, e.to = this.to, e.speedRatio = this.speedRatio, e.loopAnimation = this.loopAnimation, e.isAdditive = this.isAdditive, e.weight = this.weight, e.playOrder = this.playOrder, e.enableBlending = this.enableBlending, e.blendingSpeed = this.blendingSpeed, e.targetedAnimations = [];
				for (let t = 0; t < this.targetedAnimations.length; t++) {
					const i = this.targetedAnimations[t];
					e.targetedAnimations[t] = i.serialize()
				}
				return nc && nc.HasTags(this) && (e.tags = nc.GetTags(this)), this.metadata && (e.metadata = this.metadata), e
			}
			get animatables() {
				return this._animatables
			}
			goToFrame(e) {
				if (!this._isStarted) return this;
				for (let t = 0; t < this._animatables.length; t++) {
					this._animatables[t].goToFrame(e)
				}
				return this
			}
			syncWithMask(e = !1) {
				if (this.mask || e) {
					this._numActiveAnimatables = 0;
					for (let e = 0; e < this._animatables.length; ++e) {
						const t = this._animatables[e];
						!this.mask || this.mask.disabled || this.mask.retainsTarget(t.target.name) ? (this._numActiveAnimatables++, t.paused && t.restart()) : t.paused || t.pause()
					}
				} else this._numActiveAnimatables = this._targetedAnimations.length
			}
			get targetedAnimations() {
				return this._targetedAnimations
			}
			static ClipFrames(t, i, s, n, a) {
				const r = t.clone(n || t.name);
				return e.ClipFramesInPlace(r, i, s, a)
			}
			getClassName() {
				return "AnimationGroup"
			}
			get loopAnimation() {
				return this._loopAnimation
			}
			restart() {
				if (!this._isStarted) return this;
				for (let e = 0; e < this._animatables.length; e++) {
					this._animatables[e].restart()
				}
				return this.syncWithMask(), this.onAnimationGroupPlayObservable.notifyObservers(this), this._isPaused = !1, this
			}
			set to(e) {
				if (this._to !== e) {
					this._to = e;
					for (let e = 0; e < this._animatables.length; e++) {
						this._animatables[e].toFrame = this._to
					}
				}
			}
			get to() {
				return this._to
			}
			stop(e = !1) {
				if (!this._isStarted) return this;
				const t = this._animatables.slice();
				for (let i = 0; i < t.length; i++) t[i].stop(void 0, void 0, !0, e);
				let i = 0;
				for (let t = 0; t < this._scene._activeAnimatables.length; t++) {
					const s = this._scene._activeAnimatables[t];
					s._runtimeAnimations.length > 0 ? this._scene._activeAnimatables[i++] = s : e && this._checkAnimationGroupEnded(s, e)
				}
				return this._scene._activeAnimatables.length = i, this._isStarted = !1, this
			}
			get weight() {
				return this._weight
			}
			start(e = !1, t = 1, i, s, n) {
				if (this._isStarted || 0 === this._targetedAnimations.length) return this;
				this._loopAnimation = e, this._shouldStart = !1, this._animationLoopCount = 0, this._animationLoopFlags.length = 0;
				for (let a = 0; a < this._targetedAnimations.length; a++) {
					const r = this._targetedAnimations[a],
						o = this._scene.beginDirectAnimation(r.target, [r.animation], void 0 !== i ? i : this._from, void 0 !== s ? s : this._to, e, t, void 0, void 0, void 0 !== n ? n : this._isAdditive);
					o.weight = this._weight, o.playOrder = this._playOrder, o.onAnimationEnd = () => {
						this.onAnimationEndObservable.notifyObservers(r), this._checkAnimationGroupEnded(o)
					}, this._processLoop(o, r, a), this._animatables.push(o)
				}
				return this.syncWithMask(), this._scene.sortActiveAnimatables(), this._speedRatio = t, this._isStarted = !0, this._isPaused = !1, this.onAnimationGroupPlayObservable.notifyObservers(this), this
			}
			set playOrder(e) {
				if (this._playOrder !== e && (this._playOrder = e, this._animatables.length > 0)) {
					for (let e = 0; e < this._animatables.length; e++) this._animatables[e].playOrder = this._playOrder;
					this._scene.sortActiveAnimatables()
				}
			}
			static ClipInPlace(e, t, i, s, n = !1) {
				let a = Number.MAX_VALUE,
					r = -Number.MAX_VALUE;
				const o = e.targetedAnimations;
				for (let e = 0; e < o.length; e++) {
					const l = o[e],
						h = s ? l.animation : l.animation.clone();
					n && (h.createKeyForFrame(t), h.createKeyForFrame(i));
					const c = h.getKeys(),
						u = [];
					let m = Number.MAX_VALUE;
					for (let e = 0; e < c.length; e++) {
						const s = c[e];
						if (!n && e >= t && e <= i || n && s.frame >= t && s.frame <= i) {
							const e = {
								frame: s.frame,
								value: s.value.clone ? s.value.clone() : s.value,
								inTangent: s.inTangent,
								outTangent: s.outTangent,
								interpolation: s.interpolation,
								lockedTangent: s.lockedTangent
							};
							m === Number.MAX_VALUE && (m = e.frame), e.frame -= m, u.push(e)
						}
					}
					0 !== u.length ? (a > u[0].frame && (a = u[0].frame), r < u[u.length - 1].frame && (r = u[u.length - 1].frame), h.setKeys(u, !0), l.animation = h) : (o.splice(e, 1), e--)
				}
				return e._from = a, e._to = r, e
			}
			get mask() {
				return this._mask
			}
			static MakeAnimationAdditive(e, t, i, s = !1, n) {
				let a;
				a = "object" == typeof t ? t : {
					referenceFrame: t,
					range: i,
					cloneOriginalAnimationGroup: s,
					clonedAnimationName: n
				};
				let r = e;
				a.cloneOriginalAnimationGroup && (r = e.clone(a.clonedAnimationGroupName || r.name));
				const o = r.targetedAnimations;
				for (let e = 0; e < o.length; e++) {
					const t = o[e];
					t.animation = Wg.MakeAnimationAdditive(t.animation, a)
				}
				if (r.isAdditive = !0, a.clipKeys) {
					let e = Number.MAX_VALUE,
						t = -Number.MAX_VALUE;
					const i = r.targetedAnimations;
					for (let s = 0; s < i.length; s++) {
						const n = i[s].animation.getKeys();
						e > n[0].frame && (e = n[0].frame), t < n[n.length - 1].frame && (t = n[n.length - 1].frame)
					}
					r._from = e, r._to = t
				}
				return r
			}
			static ClipKeysInPlace(t, i, s, n) {
				return e.ClipInPlace(t, i, s, n, !1)
			}
			_processLoop(e, t, i) {
				e.onAnimationLoop = () => {
					this.onAnimationLoopObservable.notifyObservers(t), this._animationLoopFlags[i] || (this._animationLoopFlags[i] = !0, this._animationLoopCount++, this._animationLoopCount === this._numActiveAnimatables && (this.onAnimationGroupLoopObservable.notifyObservers(this), this._animationLoopCount = 0, this._animationLoopFlags.length = 0))
				}
			}
			set loopAnimation(e) {
				if (this._loopAnimation !== e) {
					this._loopAnimation = e;
					for (let e = 0; e < this._animatables.length; e++) {
						this._animatables[e].loopAnimation = this._loopAnimation
					}
				}
			}
			static MergeAnimationGroups(t, i = !0, s = !1, n) {
				if (0 === t.length) return null;
				n = n ?? t[0].weight;
				let a = Number.MAX_VALUE,
					r = -Number.MAX_VALUE;
				if (s)
					for (const e of t) e.from < a && (a = e.from), e.to > r && (r = e.to);
				const o = new e(t[0].name + "_merged", t[0]._scene, n);
				for (const e of t) {
					s && e.normalize(a, r);
					for (const t of e.targetedAnimations) o.addTargetedAnimation(t.animation, t.target);
					i && e.dispose()
				}
				return o
			}
			get speedRatio() {
				return this._speedRatio
			}
			get from() {
				return this._from
			}
			pause() {
				if (!this._isStarted) return this;
				this._isPaused = !0;
				for (let e = 0; e < this._animatables.length; e++) {
					this._animatables[e].pause()
				}
				return this.onAnimationGroupPauseObservable.notifyObservers(this), this
			}
			set from(e) {
				if (this._from !== e) {
					this._from = e;
					for (let e = 0; e < this._animatables.length; e++) {
						this._animatables[e].fromFrame = this._from
					}
				}
			}
			addTargetedAnimation(e, t) {
				const i = new lA;
				i.animation = e, i.target = t;
				const s = e.getKeys();
				return this._from > s[0].frame && (this._from = s[0].frame), this._to < s[s.length - 1].frame && (this._to = s[s.length - 1].frame), null !== this._enableBlending && (e.enableBlending = this._enableBlending), null !== this._blendingSpeed && (e.blendingSpeed = this._blendingSpeed), this._targetedAnimations.push(i), this._shouldStart = !0, i
			}
			static Parse(t, i) {
				const s = new e(t.name, i, t.weight, t.playOrder);
				for (let e = 0; e < t.targetedAnimations.length; e++) {
					const n = t.targetedAnimations[e],
						a = Wg.Parse(n.animation),
						r = n.targetId;
					if ("influence" === n.animation.property) {
						const e = i.getMorphTargetById(r);
						e && s.addTargetedAnimation(a, e)
					} else {
						const e = i.getNodeById(r);
						null != e && s.addTargetedAnimation(a, e)
					}
				}
				return nc && nc.AddTagsTo(s, t.tags), null !== t.from && null !== t.to && s.normalize(t.from, t.to), void 0 !== t.speedRatio && (s._speedRatio = t.speedRatio), void 0 !== t.loopAnimation && (s._loopAnimation = t.loopAnimation), void 0 !== t.isAdditive && (s._isAdditive = t.isAdditive), void 0 !== t.weight && (s._weight = t.weight), void 0 !== t.playOrder && (s._playOrder = t.playOrder), void 0 !== t.enableBlending && (s._enableBlending = t.enableBlending), void 0 !== t.blendingSpeed && (s._blendingSpeed = t.blendingSpeed), void 0 !== t.metadata && (s.metadata = t.metadata), s
			}
			get isStarted() {
				return this._isStarted
			}
		},
		cA = class {
			static EncodeTextureToRGBD(e, t, i = 0) {
				return function(e, t, i, s, n, a, r, o) {
					const l = t.getEngine();
					return t.isReady = !1, n = n ?? t.samplingMode, s = s ?? t.type, a = a ?? t.format, r = r ?? t.width, o = o ?? t.height, -1 === s && (s = 0), new Promise((h => {
						const c = new Bp("postprocess", e, null, null, 1, null, n, l, !1, void 0, s, void 0, null, !1, a);
						c.externalTextureSamplerBinding = !0;
						const u = l.createRenderTargetTexture({
							width: r,
							height: o
						}, {
							generateDepthBuffer: !1,
							generateMipMaps: !1,
							generateStencilBuffer: !1,
							samplingMode: n,
							type: s,
							format: a
						});
						c.onEffectCreatedObservable.addOnce((e => {
							e.executeWhenCompiled((() => {
								c.onApply = e => {
									e._bindTexture("textureSampler", t), e.setFloat2("scale", 1, 1)
								}, i.postProcessManager.directRender([c], u, !0), l.restoreDefaultFramebuffer(), l._releaseTexture(t), c && c.dispose(), u._swapAndDie(t), t.type = s, t.format = 5, t.isReady = !0, h(t)
							}))
						}))
					}))
				}("rgbdEncode", e, t, i, 1, 5)
			}
			static ExpandRGBDTexture(e) {
				const t = e._texture;
				if (!t || !e.isRGBD) return;
				const i = t.getEngine(),
					s = i.getCaps(),
					n = t.isReady;
				let a = !1;
				s.textureHalfFloatRender && s.textureHalfFloatLinearFiltering ? (a = !0, t.type = 2) : s.textureFloatRender && s.textureFloatLinearFiltering && (a = !0, t.type = 1), a && (t.isReady = !1, t._isRGBD = !1, t.invertY = !1);
				const r = async () => {
					const s = i.isWebGPU,
						n = s ? 1 : 0;
					t.isReady = !1, this._ShaderImported || (this._ShaderImported = !0, s ? await Promise.all([Promise.resolve().then((() => (to(), qr))), Promise.resolve().then((() => (ro(), io)))]) : await Promise.all([Promise.resolve().then((() => (uo(), oo))), Promise.resolve().then((() => (go(), mo)))]));
					const a = new Bp("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, i, !1, void 0, t.type, void 0, null, !1, void 0, n);
					a.externalTextureSamplerBinding = !0;
					const r = i.createRenderTargetTexture(t.width, {
						generateDepthBuffer: !1,
						generateMipMaps: !1,
						generateStencilBuffer: !1,
						samplingMode: t.samplingMode,
						type: t.type,
						format: 5
					});
					a.onEffectCreatedObservable.addOnce((s => {
						s.executeWhenCompiled((() => {
							a.onApply = e => {
								e._bindTexture("textureSampler", t), e.setFloat2("scale", 1, 1)
							}, e.getScene().postProcessManager.directRender([a], r, !0), i.restoreDefaultFramebuffer(), i._releaseTexture(t), a && a.dispose(), r._swapAndDie(t), t.isReady = !0
						}))
					}))
				};
				a && (n ? r() : e.onLoadObservable.addOnce(r))
			}
		};
	cA._ShaderImported = !1;
	var uA = 0,
		mA = e => {
			if (!e.environmentBRDFTexture) {
				const t = e.useDelayedTextureLoading;
				e.useDelayedTextureLoading = !1;
				const i = e._blockEntityCollection;
				e._blockEntityCollection = !1;
				const s = Np.CreateFromBase64String("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==", "EnvironmentBRDFTexture" + uA++, e, !0, !1, Np.BILINEAR_SAMPLINGMODE);
				e._blockEntityCollection = i;
				const n = e.getEngine().getLoadedTexturesCache(),
					a = n.indexOf(s.getInternalTexture()); - 1 !== a && n.splice(a, 1), s.isRGBD = !0, s.wrapU = Np.CLAMP_ADDRESSMODE, s.wrapV = Np.CLAMP_ADDRESSMODE, e.environmentBRDFTexture = s, e.useDelayedTextureLoading = t, cA.ExpandRGBDTexture(s);
				const r = e.getEngine().onContextRestoredObservable.add((() => {
					s.isRGBD = !0;
					const t = e.onBeforeRenderObservable.add((() => {
						s.isReady() && (e.onBeforeRenderObservable.remove(t), cA.ExpandRGBDTexture(s))
					}))
				}));
				e.onDisposeObservable.add((() => {
					e.getEngine().onContextRestoredObservable.remove(r)
				}))
			}
			return e.environmentBRDFTexture
		},
		dA = class extends ip {
			constructor() {
				super(...arguments), this.BRDF_V_HEIGHT_CORRELATED = !1, this.MS_BRDF_ENERGY_CONSERVATION = !1, this.SPHERICAL_HARMONICS = !1, this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = !1
			}
		},
		fA = class e extends Bv {
			prepareDefines(e) {
				e.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated, e.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated, e.SPHERICAL_HARMONICS = this._useSphericalHarmonics, e.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation
			}
			isCompatible() {
				return !0
			}
			constructor(t, i = !0) {
				super(t, "PBRBRDF", 90, new dA, i), this._useEnergyConservation = e.DEFAULT_USE_ENERGY_CONSERVATION, this.useEnergyConservation = e.DEFAULT_USE_ENERGY_CONSERVATION, this._useSmithVisibilityHeightCorrelated = e.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED, this.useSmithVisibilityHeightCorrelated = e.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED, this._useSphericalHarmonics = e.DEFAULT_USE_SPHERICAL_HARMONICS, this.useSphericalHarmonics = e.DEFAULT_USE_SPHERICAL_HARMONICS, this._useSpecularGlossinessInputEnergyConservation = e.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION, this.useSpecularGlossinessInputEnergyConservation = e.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION, this._internalMarkAllSubMeshesAsMiscDirty = t._dirtyCallbacks[16], this._enable(!0)
			}
			getClassName() {
				return "PBRBRDFConfiguration"
			}
			_markAllSubMeshesAsMiscDirty() {
				this._internalMarkAllSubMeshesAsMiscDirty()
			}
		};
	fA.DEFAULT_USE_ENERGY_CONSERVATION = !0, fA.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = !0, fA.DEFAULT_USE_SPHERICAL_HARMONICS = !0, fA.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = !0, Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], fA.prototype, "useEnergyConservation", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], fA.prototype, "useSmithVisibilityHeightCorrelated", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], fA.prototype, "useSphericalHarmonics", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], fA.prototype, "useSpecularGlossinessInputEnergyConservation", void 0), wp.prototype.forceSphericalPolynomialsRecompute = function() {
		this._texture && (this._texture._sphericalPolynomial = null, this._texture._sphericalPolynomialPromise = null, this._texture._sphericalPolynomialComputed = !1)
	}, Object.defineProperty(wp.prototype, "sphericalPolynomial", {
		get: function() {
			if (this._texture) {
				if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) return this._texture._sphericalPolynomial;
				if (this._texture.isReady) return this._texture._sphericalPolynomialPromise || (this._texture._sphericalPolynomialPromise = gv.ConvertCubeMapTextureToSphericalPolynomial(this), null === this._texture._sphericalPolynomialPromise ? this._texture._sphericalPolynomialComputed = !0 : this._texture._sphericalPolynomialPromise.then((e => {
					this._texture._sphericalPolynomial = e, this._texture._sphericalPolynomialComputed = !0
				}))), null
			}
			return null
		},
		set: function(e) {
			this._texture && (this._texture._sphericalPolynomial = e)
		},
		enumerable: !0,
		configurable: !0
	});
	var pA = class extends ip {
			constructor() {
				super(...arguments), this.CLEARCOAT = !1, this.CLEARCOAT_DEFAULTIOR = !1, this.CLEARCOAT_TEXTURE = !1, this.CLEARCOAT_TEXTURE_ROUGHNESS = !1, this.CLEARCOAT_TEXTUREDIRECTUV = 0, this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0, this.CLEARCOAT_BUMP = !1, this.CLEARCOAT_BUMPDIRECTUV = 0, this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = !1, this.CLEARCOAT_REMAP_F0 = !1, this.CLEARCOAT_TINT = !1, this.CLEARCOAT_TINT_TEXTURE = !1, this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0, this.CLEARCOAT_TINT_GAMMATEXTURE = !1
			}
		},
		_A = class e extends Bv {
			getSamplers(e) {
				e.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler")
			}
			isReadyForSubMesh(e, t, i) {
				if (!this._isEnabled) return !0;
				const s = this._material._disableBumpMap;
				if (e._areTexturesDirty && t.texturesEnabled) {
					if (this._texture && kv.ClearCoatTextureEnabled && !this._texture.isReadyOrNotBlocking()) return !1;
					if (this._textureRoughness && kv.ClearCoatTextureEnabled && !this._textureRoughness.isReadyOrNotBlocking()) return !1;
					if (i.getCaps().standardDerivatives && this._bumpTexture && kv.ClearCoatBumpTextureEnabled && !s && !this._bumpTexture.isReady()) return !1;
					if (this._isTintEnabled && this._tintTexture && kv.ClearCoatTintTextureEnabled && !this._tintTexture.isReadyOrNotBlocking()) return !1
				}
				return !0
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vClearCoatParams",
						size: 2,
						type: "vec2"
					}, {
						name: "vClearCoatRefractionParams",
						size: 4,
						type: "vec4"
					}, {
						name: "vClearCoatInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "clearCoatMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "clearCoatRoughnessMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "vClearCoatBumpInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "vClearCoatTangentSpaceParams",
						size: 2,
						type: "vec2"
					}, {
						name: "clearCoatBumpMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "vClearCoatTintParams",
						size: 4,
						type: "vec4"
					}, {
						name: "clearCoatColorAtDistance",
						size: 1,
						type: "float"
					}, {
						name: "vClearCoatTintInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "clearCoatTintMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			hasTexture(e) {
				return this._texture === e || (this._textureRoughness === e || (this._bumpTexture === e || this._tintTexture === e))
			}
			getClassName() {
				return "PBRClearCoatConfiguration"
			}
			prepareDefinesBeforeAttributes(t, i) {
				this._isEnabled ? (t.CLEARCOAT = !0, t.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture, t.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange, t._areTexturesDirty && i.texturesEnabled && (this._texture && kv.ClearCoatTextureEnabled ? cf(this._texture, t, "CLEARCOAT_TEXTURE") : t.CLEARCOAT_TEXTURE = !1, this._textureRoughness && kv.ClearCoatTextureEnabled ? cf(this._textureRoughness, t, "CLEARCOAT_TEXTURE_ROUGHNESS") : t.CLEARCOAT_TEXTURE_ROUGHNESS = !1, this._bumpTexture && kv.ClearCoatBumpTextureEnabled ? cf(this._bumpTexture, t, "CLEARCOAT_BUMP") : t.CLEARCOAT_BUMP = !1, t.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === e._DefaultIndexOfRefraction, this._isTintEnabled ? (t.CLEARCOAT_TINT = !0, this._tintTexture && kv.ClearCoatTintTextureEnabled ? (cf(this._tintTexture, t, "CLEARCOAT_TINT_TEXTURE"), t.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace) : t.CLEARCOAT_TINT_TEXTURE = !1) : (t.CLEARCOAT_TINT = !1, t.CLEARCOAT_TINT_TEXTURE = !1))) : (t.CLEARCOAT = !1, t.CLEARCOAT_TEXTURE = !1, t.CLEARCOAT_TEXTURE_ROUGHNESS = !1, t.CLEARCOAT_BUMP = !1, t.CLEARCOAT_TINT = !1, t.CLEARCOAT_TINT_TEXTURE = !1, t.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = !1, t.CLEARCOAT_DEFAULTIOR = !1, t.CLEARCOAT_TEXTUREDIRECTUV = 0, t.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0, t.CLEARCOAT_BUMPDIRECTUV = 0, t.CLEARCOAT_REMAP_F0 = !1, t.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0, t.CLEARCOAT_TINT_GAMMATEXTURE = !1)
			}
			bindForSubMesh(e, t, i, s) {
				if (!this._isEnabled) return;
				const n = s.materialDefines,
					a = this._material.isFrozen,
					r = this._material._disableBumpMap,
					o = this._material._invertNormalMapX,
					l = this._material._invertNormalMapY;
				if (!e.useUbo || !a || !e.isSync) {
					(this._texture || this._textureRoughness) && kv.ClearCoatTextureEnabled && (e.updateFloat4("vClearCoatInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0), this._texture && uf(this._texture, e, "clearCoat"), this._textureRoughness && !n.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && uf(this._textureRoughness, e, "clearCoatRoughness")), this._bumpTexture && i.getCaps().standardDerivatives && kv.ClearCoatTextureEnabled && !r && (e.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level), uf(this._bumpTexture, e, "clearCoatBump"), t._mirroredCameraPosition ? e.updateFloat2("vClearCoatTangentSpaceParams", o ? 1 : -1, l ? 1 : -1) : e.updateFloat2("vClearCoatTangentSpaceParams", o ? -1 : 1, l ? -1 : 1)), this._tintTexture && kv.ClearCoatTintTextureEnabled && (e.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level), uf(this._tintTexture, e, "clearCoatTint")), e.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
					const s = 1 - this._indexOfRefraction,
						a = 1 + this._indexOfRefraction,
						h = Math.pow(-s / a, 2),
						c = 1 / this._indexOfRefraction;
					e.updateFloat4("vClearCoatRefractionParams", h, c, s, a), this._isTintEnabled && (e.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness)), e.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance)))
				}
				t.texturesEnabled && (this._texture && kv.ClearCoatTextureEnabled && e.setTexture("clearCoatSampler", this._texture), this._textureRoughness && !n.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && kv.ClearCoatTextureEnabled && e.setTexture("clearCoatRoughnessSampler", this._textureRoughness), this._bumpTexture && i.getCaps().standardDerivatives && kv.ClearCoatBumpTextureEnabled && !r && e.setTexture("clearCoatBumpSampler", this._bumpTexture), this._isTintEnabled && this._tintTexture && kv.ClearCoatTintTextureEnabled && e.setTexture("clearCoatTintSampler", this._tintTexture))
			}
			getAnimatables(e) {
				this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture), this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0 && e.push(this._textureRoughness), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0 && e.push(this._tintTexture)
			}
			addFallbacks(e, t, i) {
				return e.CLEARCOAT_BUMP && t.addFallback(i++, "CLEARCOAT_BUMP"), e.CLEARCOAT_TINT && t.addFallback(i++, "CLEARCOAT_TINT"), e.CLEARCOAT && t.addFallback(i++, "CLEARCOAT"), i
			}
			dispose(e) {
				e && (this._texture?.dispose(), this._textureRoughness?.dispose(), this._bumpTexture?.dispose(), this._tintTexture?.dispose())
			}
			isCompatible() {
				return !0
			}
			getActiveTextures(e) {
				this._texture && e.push(this._texture), this._textureRoughness && e.push(this._textureRoughness), this._bumpTexture && e.push(this._bumpTexture), this._tintTexture && e.push(this._tintTexture)
			}
			constructor(t, i = !0) {
				super(t, "PBRClearCoat", 100, new pA, i), this._isEnabled = !1, this.isEnabled = !1, this.intensity = 1, this.roughness = 0, this._indexOfRefraction = e._DefaultIndexOfRefraction, this.indexOfRefraction = e._DefaultIndexOfRefraction, this._texture = null, this.texture = null, this._useRoughnessFromMainTexture = !0, this.useRoughnessFromMainTexture = !0, this._textureRoughness = null, this.textureRoughness = null, this._remapF0OnInterfaceChange = !0, this.remapF0OnInterfaceChange = !0, this._bumpTexture = null, this.bumpTexture = null, this._isTintEnabled = !1, this.isTintEnabled = !1, this.tintColor = Tc.White(), this.tintColorAtDistance = 1, this.tintThickness = 1, this._tintTexture = null, this.tintTexture = null, this._internalMarkAllSubMeshesAsTexturesDirty = t._dirtyCallbacks[1]
			}
		};
	_A._DefaultIndexOfRefraction = 1.5, Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "isEnabled", void 0), Gh([Xh()], _A.prototype, "intensity", void 0), Gh([Xh()], _A.prototype, "roughness", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "indexOfRefraction", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "texture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "useRoughnessFromMainTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "textureRoughness", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "remapF0OnInterfaceChange", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "bumpTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "isTintEnabled", void 0), Gh([jh()], _A.prototype, "tintColor", void 0), Gh([Xh()], _A.prototype, "tintColorAtDistance", void 0), Gh([Xh()], _A.prototype, "tintThickness", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], _A.prototype, "tintTexture", void 0);
	var gA = class extends ip {
			constructor() {
				super(...arguments), this.IRIDESCENCE = !1, this.IRIDESCENCE_TEXTURE = !1, this.IRIDESCENCE_TEXTUREDIRECTUV = 0, this.IRIDESCENCE_THICKNESS_TEXTURE = !1, this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0
			}
		},
		vA = class e extends Bv {
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vIridescenceParams",
						size: 4,
						type: "vec4"
					}, {
						name: "vIridescenceInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "iridescenceMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "iridescenceThicknessMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			getClassName() {
				return "PBRIridescenceConfiguration"
			}
			getSamplers(e) {
				e.push("iridescenceSampler", "iridescenceThicknessSampler")
			}
			constructor(t, i = !0) {
				super(t, "PBRIridescence", 110, new gA, i), this._isEnabled = !1, this.isEnabled = !1, this.intensity = 1, this.minimumThickness = e._DefaultMinimumThickness, this.maximumThickness = e._DefaultMaximumThickness, this.indexOfRefraction = e._DefaultIndexOfRefraction, this._texture = null, this.texture = null, this._thicknessTexture = null, this.thicknessTexture = null, this._internalMarkAllSubMeshesAsTexturesDirty = t._dirtyCallbacks[1]
			}
			getAnimatables(e) {
				this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture), this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0 && e.push(this._thicknessTexture)
			}
			prepareDefinesBeforeAttributes(e, t) {
				this._isEnabled ? (e.IRIDESCENCE = !0, e._areTexturesDirty && t.texturesEnabled && (this._texture && kv.IridescenceTextureEnabled ? cf(this._texture, e, "IRIDESCENCE_TEXTURE") : e.IRIDESCENCE_TEXTURE = !1, this._thicknessTexture && kv.IridescenceTextureEnabled ? cf(this._thicknessTexture, e, "IRIDESCENCE_THICKNESS_TEXTURE") : e.IRIDESCENCE_THICKNESS_TEXTURE = !1)) : (e.IRIDESCENCE = !1, e.IRIDESCENCE_TEXTURE = !1, e.IRIDESCENCE_THICKNESS_TEXTURE = !1, e.IRIDESCENCE_TEXTUREDIRECTUV = 0, e.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0)
			}
			getActiveTextures(e) {
				this._texture && e.push(this._texture), this._thicknessTexture && e.push(this._thicknessTexture)
			}
			isReadyForSubMesh(e, t) {
				if (!this._isEnabled) return !0;
				if (e._areTexturesDirty && t.texturesEnabled) {
					if (this._texture && kv.IridescenceTextureEnabled && !this._texture.isReadyOrNotBlocking()) return !1;
					if (this._thicknessTexture && kv.IridescenceTextureEnabled && !this._thicknessTexture.isReadyOrNotBlocking()) return !1
				}
				return !0
			}
			hasTexture(e) {
				return this._texture === e || this._thicknessTexture === e
			}
			bindForSubMesh(e, t) {
				if (!this._isEnabled) return;
				const i = this._material.isFrozen;
				e.useUbo && i && e.isSync || ((this._texture || this._thicknessTexture) && kv.IridescenceTextureEnabled && (e.updateFloat4("vIridescenceInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._thicknessTexture?.coordinatesIndex ?? 0, this._thicknessTexture?.level ?? 0), this._texture && uf(this._texture, e, "iridescence"), this._thicknessTexture && uf(this._thicknessTexture, e, "iridescenceThickness")), e.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness)), t.texturesEnabled && (this._texture && kv.IridescenceTextureEnabled && e.setTexture("iridescenceSampler", this._texture), this._thicknessTexture && kv.IridescenceTextureEnabled && e.setTexture("iridescenceThicknessSampler", this._thicknessTexture))
			}
			addFallbacks(e, t, i) {
				return e.IRIDESCENCE && t.addFallback(i++, "IRIDESCENCE"), i
			}
			isCompatible() {
				return !0
			}
			dispose(e) {
				e && (this._texture?.dispose(), this._thicknessTexture?.dispose())
			}
		};
	vA._DefaultMinimumThickness = 100, vA._DefaultMaximumThickness = 400, vA._DefaultIndexOfRefraction = 1.3, Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], vA.prototype, "isEnabled", void 0), Gh([Xh()], vA.prototype, "intensity", void 0), Gh([Xh()], vA.prototype, "minimumThickness", void 0), Gh([Xh()], vA.prototype, "maximumThickness", void 0), Gh([Xh()], vA.prototype, "indexOfRefraction", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], vA.prototype, "texture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], vA.prototype, "thicknessTexture", void 0);
	var yA = class extends ip {
			constructor() {
				super(...arguments), this.ANISOTROPIC = !1, this.ANISOTROPIC_TEXTURE = !1, this.ANISOTROPIC_TEXTUREDIRECTUV = 0, this.ANISOTROPIC_LEGACY = !1, this.MAINUV1 = !1
			}
		},
		SA = class extends Bv {
			getAnimatables(e) {
				this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture)
			}
			constructor(e, t = !0) {
				super(e, "PBRAnisotropic", 110, new yA, t), this._isEnabled = !1, this.isEnabled = !1, this.intensity = 1, this.direction = new Fc(1, 0), this._texture = null, this.texture = null, this._legacy = !1, this.legacy = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1], this._internalMarkAllSubMeshesAsMiscDirty = e._dirtyCallbacks[16]
			}
			parse(e, t, i) {
				super.parse(e, t, i), void 0 === e.legacy && (this.legacy = !0)
			}
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vAnisotropy",
						size: 3,
						type: "vec3"
					}, {
						name: "vAnisotropyInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "anisotropyMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			hasTexture(e) {
				return this._texture === e
			}
			get angle() {
				return Math.atan2(this.direction.y, this.direction.x)
			}
			_markAllSubMeshesAsMiscDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsMiscDirty()
			}
			isReadyForSubMesh(e, t) {
				return !this._isEnabled || !(e._areTexturesDirty && t.texturesEnabled && this._texture && kv.AnisotropicTextureEnabled && !this._texture.isReadyOrNotBlocking())
			}
			isCompatible() {
				return !0
			}
			getActiveTextures(e) {
				this._texture && e.push(this._texture)
			}
			getSamplers(e) {
				e.push("anisotropySampler")
			}
			getClassName() {
				return "PBRAnisotropicConfiguration"
			}
			prepareDefinesBeforeAttributes(e, t, i) {
				this._isEnabled ? (e.ANISOTROPIC = this._isEnabled, this._isEnabled && !i.isVerticesDataPresent(eu.TangentKind) && (e._needUVs = !0, e.MAINUV1 = !0), e._areTexturesDirty && t.texturesEnabled && (this._texture && kv.AnisotropicTextureEnabled ? cf(this._texture, e, "ANISOTROPIC_TEXTURE") : e.ANISOTROPIC_TEXTURE = !1), e._areMiscDirty && (e.ANISOTROPIC_LEGACY = this._legacy)) : (e.ANISOTROPIC = !1, e.ANISOTROPIC_TEXTURE = !1, e.ANISOTROPIC_TEXTUREDIRECTUV = 0, e.ANISOTROPIC_LEGACY = !1)
			}
			set angle(e) {
				this.direction.x = Math.cos(e), this.direction.y = Math.sin(e)
			}
			dispose(e) {
				e && this._texture && this._texture.dispose()
			}
			addFallbacks(e, t, i) {
				return e.ANISOTROPIC && t.addFallback(i++, "ANISOTROPIC"), i
			}
			bindForSubMesh(e, t) {
				if (!this._isEnabled) return;
				const i = this._material.isFrozen;
				e.useUbo && i && e.isSync || (this._texture && kv.AnisotropicTextureEnabled && (e.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level), uf(this._texture, e, "anisotropy")), e.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity)), t.texturesEnabled && this._texture && kv.AnisotropicTextureEnabled && e.setTexture("anisotropySampler", this._texture)
			}
		};
	Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], SA.prototype, "isEnabled", void 0), Gh([Xh()], SA.prototype, "intensity", void 0), Gh([$h()], SA.prototype, "direction", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], SA.prototype, "texture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], SA.prototype, "legacy", void 0);
	var EA = class extends ip {
			constructor() {
				super(...arguments), this.SHEEN = !1, this.SHEEN_TEXTURE = !1, this.SHEEN_GAMMATEXTURE = !1, this.SHEEN_TEXTURE_ROUGHNESS = !1, this.SHEEN_TEXTUREDIRECTUV = 0, this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0, this.SHEEN_LINKWITHALBEDO = !1, this.SHEEN_ROUGHNESS = !1, this.SHEEN_ALBEDOSCALING = !1, this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = !1
			}
		},
		AA = class extends Bv {
			getSamplers(e) {
				e.push("sheenSampler", "sheenRoughnessSampler")
			}
			bindForSubMesh(e, t, i, s) {
				if (!this._isEnabled) return;
				const n = s.materialDefines,
					a = this._material.isFrozen;
				e.useUbo && a && e.isSync || ((this._texture || this._textureRoughness) && kv.SheenTextureEnabled && (e.updateFloat4("vSheenInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0), this._texture && uf(this._texture, e, "sheen"), this._textureRoughness && !n.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && uf(this._textureRoughness, e, "sheenRoughness")), e.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity), null !== this._roughness && e.updateFloat("vSheenRoughness", this._roughness)), t.texturesEnabled && (this._texture && kv.SheenTextureEnabled && e.setTexture("sheenSampler", this._texture), this._textureRoughness && !n.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && kv.SheenTextureEnabled && e.setTexture("sheenRoughnessSampler", this._textureRoughness))
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vSheenColor",
						size: 4,
						type: "vec4"
					}, {
						name: "vSheenRoughness",
						size: 1,
						type: "float"
					}, {
						name: "vSheenInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "sheenMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "sheenRoughnessMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			isCompatible() {
				return !0
			}
			constructor(e, t = !0) {
				super(e, "Sheen", 120, new EA, t), this._isEnabled = !1, this.isEnabled = !1, this._linkSheenWithAlbedo = !1, this.linkSheenWithAlbedo = !1, this.intensity = 1, this.color = Tc.White(), this._texture = null, this.texture = null, this._useRoughnessFromMainTexture = !0, this.useRoughnessFromMainTexture = !0, this._roughness = null, this.roughness = null, this._textureRoughness = null, this.textureRoughness = null, this._albedoScaling = !1, this.albedoScaling = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1]
			}
			getActiveTextures(e) {
				this._texture && e.push(this._texture), this._textureRoughness && e.push(this._textureRoughness)
			}
			hasTexture(e) {
				return this._texture === e || this._textureRoughness === e
			}
			prepareDefinesBeforeAttributes(e, t) {
				this._isEnabled ? (e.SHEEN = !0, e.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo, e.SHEEN_ROUGHNESS = null !== this._roughness, e.SHEEN_ALBEDOSCALING = this._albedoScaling, e.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture, e._areTexturesDirty && t.texturesEnabled && (this._texture && kv.SheenTextureEnabled ? (cf(this._texture, e, "SHEEN_TEXTURE"), e.SHEEN_GAMMATEXTURE = this._texture.gammaSpace) : e.SHEEN_TEXTURE = !1, this._textureRoughness && kv.SheenTextureEnabled ? cf(this._textureRoughness, e, "SHEEN_TEXTURE_ROUGHNESS") : e.SHEEN_TEXTURE_ROUGHNESS = !1)) : (e.SHEEN = !1, e.SHEEN_TEXTURE = !1, e.SHEEN_TEXTURE_ROUGHNESS = !1, e.SHEEN_LINKWITHALBEDO = !1, e.SHEEN_ROUGHNESS = !1, e.SHEEN_ALBEDOSCALING = !1, e.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = !1, e.SHEEN_GAMMATEXTURE = !1, e.SHEEN_TEXTUREDIRECTUV = 0, e.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0)
			}
			getAnimatables(e) {
				this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture), this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0 && e.push(this._textureRoughness)
			}
			addFallbacks(e, t, i) {
				return e.SHEEN && t.addFallback(i++, "SHEEN"), i
			}
			dispose(e) {
				e && (this._texture?.dispose(), this._textureRoughness?.dispose())
			}
			getClassName() {
				return "PBRSheenConfiguration"
			}
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			isReadyForSubMesh(e, t) {
				if (!this._isEnabled) return !0;
				if (e._areTexturesDirty && t.texturesEnabled) {
					if (this._texture && kv.SheenTextureEnabled && !this._texture.isReadyOrNotBlocking()) return !1;
					if (this._textureRoughness && kv.SheenTextureEnabled && !this._textureRoughness.isReadyOrNotBlocking()) return !1
				}
				return !0
			}
		};
	Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "isEnabled", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "linkSheenWithAlbedo", void 0), Gh([Xh()], AA.prototype, "intensity", void 0), Gh([jh()], AA.prototype, "color", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "texture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "useRoughnessFromMainTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "roughness", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "textureRoughness", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], AA.prototype, "albedoScaling", void 0);
	var bA = class extends ip {
			constructor() {
				super(...arguments), this.SUBSURFACE = !1, this.SS_REFRACTION = !1, this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = !1, this.SS_TRANSLUCENCY = !1, this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = !1, this.SS_SCATTERING = !1, this.SS_DISPERSION = !1, this.SS_THICKNESSANDMASK_TEXTURE = !1, this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0, this.SS_HAS_THICKNESS = !1, this.SS_REFRACTIONINTENSITY_TEXTURE = !1, this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0, this.SS_TRANSLUCENCYINTENSITY_TEXTURE = !1, this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0, this.SS_TRANSLUCENCYCOLOR_TEXTURE = !1, this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0, this.SS_REFRACTIONMAP_3D = !1, this.SS_REFRACTIONMAP_OPPOSITEZ = !1, this.SS_LODINREFRACTIONALPHA = !1, this.SS_GAMMAREFRACTION = !1, this.SS_RGBDREFRACTION = !1, this.SS_LINEARSPECULARREFRACTION = !1, this.SS_LINKREFRACTIONTOTRANSPARENCY = !1, this.SS_ALBEDOFORREFRACTIONTINT = !1, this.SS_ALBEDOFORTRANSLUCENCYTINT = !1, this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = !1, this.SS_USE_THICKNESS_AS_DEPTH = !1, this.SS_USE_GLTF_TEXTURES = !1
			}
		},
		xA = class extends Bv {
			_markAllSubMeshesAsTexturesDirty() {
				this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled), this._internalMarkAllSubMeshesAsTexturesDirty()
			}
			get scatteringDiffusionProfile() {
				return this._scene.subSurfaceConfiguration ? this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex] : null
			}
			get disableAlphaBlending() {
				return this._isRefractionEnabled && this._linkRefractionWithTransparency
			}
			getUniforms() {
				return {
					ubo: [{
						name: "vRefractionMicrosurfaceInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "vRefractionFilteringInfo",
						size: 2,
						type: "vec2"
					}, {
						name: "vTranslucencyIntensityInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "vRefractionInfos",
						size: 4,
						type: "vec4"
					}, {
						name: "refractionMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "vThicknessInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "vRefractionIntensityInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "thicknessMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "refractionIntensityMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "translucencyIntensityMatrix",
						size: 16,
						type: "mat4"
					}, {
						name: "vThicknessParam",
						size: 2,
						type: "vec2"
					}, {
						name: "vDiffusionDistance",
						size: 3,
						type: "vec3"
					}, {
						name: "vTintColor",
						size: 4,
						type: "vec4"
					}, {
						name: "vSubSurfaceIntensity",
						size: 3,
						type: "vec3"
					}, {
						name: "vRefractionPosition",
						size: 3,
						type: "vec3"
					}, {
						name: "vRefractionSize",
						size: 3,
						type: "vec3"
					}, {
						name: "scatteringDiffusionProfile",
						size: 1,
						type: "float"
					}, {
						name: "dispersion",
						size: 1,
						type: "float"
					}, {
						name: "vTranslucencyColor",
						size: 4,
						type: "vec4"
					}, {
						name: "vTranslucencyColorInfos",
						size: 2,
						type: "vec2"
					}, {
						name: "translucencyColorMatrix",
						size: 16,
						type: "mat4"
					}]
				}
			}
			getSamplers(e) {
				e.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler")
			}
			_getRefractionTexture(e) {
				return this._refractionTexture ? this._refractionTexture : this._isRefractionEnabled ? e.environmentTexture : null
			}
			addFallbacks(e, t, i) {
				return e.SS_SCATTERING && t.addFallback(i++, "SS_SCATTERING"), e.SS_TRANSLUCENCY && t.addFallback(i++, "SS_TRANSLUCENCY"), i
			}
			get volumeIndexOfRefraction() {
				return this._volumeIndexOfRefraction >= 1 ? this._volumeIndexOfRefraction : this._indexOfRefraction
			}
			hasRenderTargetTextures() {
				return !!(kv.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget)
			}
			hardBindForSubMesh(e, t, i, s) {
				if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled)
					if (0 === this.maximumThickness && 0 === this.minimumThickness) e.updateFloat2("vThicknessParam", 0, 0);
					else {
						s.getRenderingMesh().getWorldMatrix().decompose(Vc.Vector3[0]);
						const t = Math.max(Math.abs(Vc.Vector3[0].x), Math.abs(Vc.Vector3[0].y), Math.abs(Vc.Vector3[0].z));
						e.updateFloat2("vThicknessParam", this.minimumThickness * t, (this.maximumThickness - this.minimumThickness) * t)
					}
			}
			hasTexture(e) {
				return this._thicknessTexture === e || (this._refractionTexture === e || (this._refractionIntensityTexture === e || (this._translucencyIntensityTexture === e || this._translucencyColorTexture === e)))
			}
			getActiveTextures(e) {
				this._thicknessTexture && e.push(this._thicknessTexture), this._refractionTexture && e.push(this._refractionTexture), this._translucencyColorTexture && e.push(this._translucencyColorTexture), this._translucencyIntensityTexture && e.push(this._translucencyIntensityTexture)
			}
			_markScenePrePassDirty() {
				this._internalMarkAllSubMeshesAsTexturesDirty(), this._internalMarkScenePrePassDirty()
			}
			isReadyForSubMesh(e, t) {
				if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) return !0;
				if (e._areTexturesDirty && t.texturesEnabled) {
					if (this._thicknessTexture && kv.ThicknessTextureEnabled && !this._thicknessTexture.isReadyOrNotBlocking()) return !1;
					if (this._translucencyColorTexture && kv.TranslucencyColorTextureEnabled && !this._translucencyColorTexture.isReadyOrNotBlocking()) return !1;
					if (this._translucencyIntensityTexture && kv.TranslucencyIntensityTextureEnabled && !this._translucencyIntensityTexture.isReadyOrNotBlocking()) return !1;
					const e = this._getRefractionTexture(t);
					if (e && kv.RefractionTextureEnabled && !e.isReadyOrNotBlocking()) return !1
				}
				return !0
			}
			isCompatible() {
				return !0
			}
			constructor(e, t = !0) {
				super(e, "PBRSubSurface", 130, new bA, t), this._isRefractionEnabled = !1, this.isRefractionEnabled = !1, this._isTranslucencyEnabled = !1, this.isTranslucencyEnabled = !1, this._isDispersionEnabled = !1, this.isDispersionEnabled = !1, this._isScatteringEnabled = !1, this.isScatteringEnabled = !1, this._scatteringDiffusionProfileIndex = 0, this.refractionIntensity = 1, this.translucencyIntensity = 1, this.useAlbedoToTintRefraction = !1, this.useAlbedoToTintTranslucency = !1, this._thicknessTexture = null, this.thicknessTexture = null, this._refractionTexture = null, this.refractionTexture = null, this._indexOfRefraction = 1.5, this.indexOfRefraction = 1.5, this._volumeIndexOfRefraction = -1, this._invertRefractionY = !1, this.invertRefractionY = !1, this._linkRefractionWithTransparency = !1, this.linkRefractionWithTransparency = !1, this.minimumThickness = 0, this.maximumThickness = 1, this.useThicknessAsDepth = !1, this.tintColor = Tc.White(), this.tintColorAtDistance = 1, this.dispersion = 0, this.diffusionDistance = Tc.White(), this._useMaskFromThicknessTexture = !1, this.useMaskFromThicknessTexture = !1, this._refractionIntensityTexture = null, this.refractionIntensityTexture = null, this._translucencyIntensityTexture = null, this.translucencyIntensityTexture = null, this.translucencyColor = null, this._translucencyColorTexture = null, this.translucencyColorTexture = null, this._useGltfStyleTextures = !0, this.useGltfStyleTextures = !0, this._scene = e.getScene(), this.registerForExtraEvents = !0, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1], this._internalMarkScenePrePassDirty = e._dirtyCallbacks[32]
			}
			set scatteringDiffusionProfile(e) {
				this._scene.enableSubSurfaceForPrePass() && e && (this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(e))
			}
			dispose(e) {
				e && (this._thicknessTexture && this._thicknessTexture.dispose(), this._refractionTexture && this._refractionTexture.dispose(), this._translucencyColorTexture && this._translucencyColorTexture.dispose(), this._translucencyIntensityTexture && this._translucencyIntensityTexture.dispose())
			}
			getAnimatables(e) {
				this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0 && e.push(this._thicknessTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture), this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0 && e.push(this._translucencyColorTexture), this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0 && e.push(this._translucencyIntensityTexture)
			}
			fillRenderTargetTextures(e) {
				kv.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && e.push(this._refractionTexture)
			}
			getClassName() {
				return "PBRSubSurfaceConfiguration"
			}
			set volumeIndexOfRefraction(e) {
				this._volumeIndexOfRefraction = e >= 1 ? e : -1
			}
			bindForSubMesh(e, t, i, s) {
				if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) return;
				const n = s.materialDefines,
					a = this._material.isFrozen,
					r = this._material.realTimeFiltering,
					o = n.LODBASEDMICROSFURACE,
					l = this._getRefractionTexture(t);
				if (!e.useUbo || !a || !e.isSync) {
					if (this._thicknessTexture && kv.ThicknessTextureEnabled && (e.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level), uf(this._thicknessTexture, e, "thickness")), this._refractionIntensityTexture && kv.RefractionIntensityTextureEnabled && n.SS_REFRACTIONINTENSITY_TEXTURE && (e.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level), uf(this._refractionIntensityTexture, e, "refractionIntensity")), this._translucencyColorTexture && kv.TranslucencyColorTextureEnabled && n.SS_TRANSLUCENCYCOLOR_TEXTURE && (e.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level), uf(this._translucencyColorTexture, e, "translucencyColor")), this._translucencyIntensityTexture && kv.TranslucencyIntensityTextureEnabled && n.SS_TRANSLUCENCYINTENSITY_TEXTURE && (e.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level), uf(this._translucencyIntensityTexture, e, "translucencyIntensity")), l && kv.RefractionTextureEnabled) {
						e.updateMatrix("refractionMatrix", l.getRefractionTextureMatrix());
						let t = 1;
						l.isCube || l.depth && (t = l.depth);
						const i = l.getSize().width,
							s = this.volumeIndexOfRefraction;
						if (e.updateFloat4("vRefractionInfos", l.level, 1 / s, t, this._invertRefractionY ? -1 : 1), e.updateFloat4("vRefractionMicrosurfaceInfos", i, l.lodGenerationScale, l.lodGenerationOffset, 1 / this.indexOfRefraction), r && e.updateFloat2("vRefractionFilteringInfo", i, Ac.Log2(i)), l.boundingBoxSize) {
							const t = l;
							e.updateVector3("vRefractionPosition", t.boundingBoxPosition), e.updateVector3("vRefractionSize", t.boundingBoxSize)
						}
					}
					this._isScatteringEnabled && e.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex), e.updateColor3("vDiffusionDistance", this.diffusionDistance), e.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance)), e.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0), e.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0), e.updateFloat("dispersion", this.dispersion)
				}
				t.texturesEnabled && (this._thicknessTexture && kv.ThicknessTextureEnabled && e.setTexture("thicknessSampler", this._thicknessTexture), this._refractionIntensityTexture && kv.RefractionIntensityTextureEnabled && n.SS_REFRACTIONINTENSITY_TEXTURE && e.setTexture("refractionIntensitySampler", this._refractionIntensityTexture), this._translucencyIntensityTexture && kv.TranslucencyIntensityTextureEnabled && n.SS_TRANSLUCENCYINTENSITY_TEXTURE && e.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture), this._translucencyColorTexture && kv.TranslucencyColorTextureEnabled && n.SS_TRANSLUCENCYCOLOR_TEXTURE && e.setTexture("translucencyColorSampler", this._translucencyColorTexture), l && kv.RefractionTextureEnabled && (o ? e.setTexture("refractionSampler", l) : (e.setTexture("refractionSampler", l._lodTextureMid || l), e.setTexture("refractionSamplerLow", l._lodTextureLow || l), e.setTexture("refractionSamplerHigh", l._lodTextureHigh || l))))
			}
			prepareDefinesBeforeAttributes(e, t) {
				if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) return e.SUBSURFACE = !1, e.SS_DISPERSION = !1, e.SS_TRANSLUCENCY = !1, e.SS_SCATTERING = !1, e.SS_REFRACTION = !1, e.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = !1, e.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = !1, e.SS_THICKNESSANDMASK_TEXTURE = !1, e.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0, e.SS_HAS_THICKNESS = !1, e.SS_REFRACTIONINTENSITY_TEXTURE = !1, e.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0, e.SS_TRANSLUCENCYINTENSITY_TEXTURE = !1, e.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0, e.SS_REFRACTIONMAP_3D = !1, e.SS_REFRACTIONMAP_OPPOSITEZ = !1, e.SS_LODINREFRACTIONALPHA = !1, e.SS_GAMMAREFRACTION = !1, e.SS_RGBDREFRACTION = !1, e.SS_LINEARSPECULARREFRACTION = !1, e.SS_LINKREFRACTIONTOTRANSPARENCY = !1, e.SS_ALBEDOFORREFRACTIONTINT = !1, e.SS_ALBEDOFORTRANSLUCENCYTINT = !1, e.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = !1, e.SS_USE_THICKNESS_AS_DEPTH = !1, e.SS_USE_GLTF_TEXTURES = !1, e.SS_TRANSLUCENCYCOLOR_TEXTURE = !1, void(e.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0);
				if (e._areTexturesDirty) {
					if (e.SUBSURFACE = !0, e.SS_DISPERSION = this._isDispersionEnabled, e.SS_TRANSLUCENCY = this._isTranslucencyEnabled, e.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = !1, e.SS_SCATTERING = this._isScatteringEnabled, e.SS_THICKNESSANDMASK_TEXTURE = !1, e.SS_REFRACTIONINTENSITY_TEXTURE = !1, e.SS_TRANSLUCENCYINTENSITY_TEXTURE = !1, e.SS_HAS_THICKNESS = !1, e.SS_USE_GLTF_TEXTURES = !1, e.SS_REFRACTION = !1, e.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = !1, e.SS_REFRACTIONMAP_3D = !1, e.SS_GAMMAREFRACTION = !1, e.SS_RGBDREFRACTION = !1, e.SS_LINEARSPECULARREFRACTION = !1, e.SS_REFRACTIONMAP_OPPOSITEZ = !1, e.SS_LODINREFRACTIONALPHA = !1, e.SS_LINKREFRACTIONTOTRANSPARENCY = !1, e.SS_ALBEDOFORREFRACTIONTINT = !1, e.SS_ALBEDOFORTRANSLUCENCYTINT = !1, e.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = !1, e.SS_USE_THICKNESS_AS_DEPTH = !1, e.SS_TRANSLUCENCYCOLOR_TEXTURE = !1, e._areTexturesDirty && t.texturesEnabled && (this._thicknessTexture && kv.ThicknessTextureEnabled && cf(this._thicknessTexture, e, "SS_THICKNESSANDMASK_TEXTURE"), this._refractionIntensityTexture && kv.RefractionIntensityTextureEnabled && cf(this._refractionIntensityTexture, e, "SS_REFRACTIONINTENSITY_TEXTURE"), this._translucencyIntensityTexture && kv.TranslucencyIntensityTextureEnabled && cf(this._translucencyIntensityTexture, e, "SS_TRANSLUCENCYINTENSITY_TEXTURE"), this._translucencyColorTexture && kv.TranslucencyColorTextureEnabled && cf(this._translucencyColorTexture, e, "SS_TRANSLUCENCYCOLOR_TEXTURE")), e.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness != 0, e.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures, e.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture, e.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture, this._isRefractionEnabled && t.texturesEnabled) {
						const i = this._getRefractionTexture(t);
						i && kv.RefractionTextureEnabled && (e.SS_REFRACTION = !0, e.SS_REFRACTIONMAP_3D = i.isCube, e.SS_GAMMAREFRACTION = i.gammaSpace, e.SS_RGBDREFRACTION = i.isRGBD, e.SS_LINEARSPECULARREFRACTION = i.linearSpecularLOD, e.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && i.isCube ? !i.invertZ : i.invertZ, e.SS_LODINREFRACTIONALPHA = i.lodLevelInAlpha, e.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency, e.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction, e.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = i.isCube && i.boundingBoxSize, e.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth)
					}
					this._isTranslucencyEnabled && (e.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency)
				}
			}
		};
	Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "isRefractionEnabled", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "isTranslucencyEnabled", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "isDispersionEnabled", void 0), Gh([Xh(), zh("_markScenePrePassDirty")], xA.prototype, "isScatteringEnabled", void 0), Gh([Xh()], xA.prototype, "_scatteringDiffusionProfileIndex", void 0), Gh([Xh()], xA.prototype, "refractionIntensity", void 0), Gh([Xh()], xA.prototype, "translucencyIntensity", void 0), Gh([Xh()], xA.prototype, "useAlbedoToTintRefraction", void 0), Gh([Xh()], xA.prototype, "useAlbedoToTintTranslucency", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "thicknessTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "refractionTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "indexOfRefraction", void 0), Gh([Xh()], xA.prototype, "_volumeIndexOfRefraction", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "volumeIndexOfRefraction", null), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "invertRefractionY", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "linkRefractionWithTransparency", void 0), Gh([Xh()], xA.prototype, "minimumThickness", void 0), Gh([Xh()], xA.prototype, "maximumThickness", void 0), Gh([Xh()], xA.prototype, "useThicknessAsDepth", void 0), Gh([jh()], xA.prototype, "tintColor", void 0), Gh([Xh()], xA.prototype, "tintColorAtDistance", void 0), Gh([Xh()], xA.prototype, "dispersion", void 0), Gh([jh()], xA.prototype, "diffusionDistance", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "useMaskFromThicknessTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "refractionIntensityTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "translucencyIntensityTexture", void 0), Gh([jh()], xA.prototype, "translucencyColor", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "translucencyColorTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], xA.prototype, "useGltfStyleTextures", void 0);
	var MA = {
			effect: null,
			subMesh: null
		},
		CA = class extends ip {
			constructor(e) {
				super(e), this.PBR = !0, this.NUM_SAMPLES = "0", this.REALTIME_FILTERING = !1, this.MAINUV1 = !1, this.MAINUV2 = !1, this.MAINUV3 = !1, this.MAINUV4 = !1, this.MAINUV5 = !1, this.MAINUV6 = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.ALBEDO = !1, this.GAMMAALBEDO = !1, this.ALBEDODIRECTUV = 0, this.VERTEXCOLOR = !1, this.BAKED_VERTEX_ANIMATION_TEXTURE = !1, this.AMBIENT = !1, this.AMBIENTDIRECTUV = 0, this.AMBIENTINGRAYSCALE = !1, this.OPACITY = !1, this.VERTEXALPHA = !1, this.OPACITYDIRECTUV = 0, this.OPACITYRGB = !1, this.ALPHATEST = !1, this.DEPTHPREPASS = !1, this.ALPHABLEND = !1, this.ALPHAFROMALBEDO = !1, this.ALPHATESTVALUE = "0.5", this.SPECULAROVERALPHA = !1, this.RADIANCEOVERALPHA = !1, this.ALPHAFRESNEL = !1, this.LINEARALPHAFRESNEL = !1, this.PREMULTIPLYALPHA = !1, this.EMISSIVE = !1, this.EMISSIVEDIRECTUV = 0, this.GAMMAEMISSIVE = !1, this.REFLECTIVITY = !1, this.REFLECTIVITY_GAMMA = !1, this.REFLECTIVITYDIRECTUV = 0, this.SPECULARTERM = !1, this.MICROSURFACEFROMREFLECTIVITYMAP = !1, this.MICROSURFACEAUTOMATIC = !1, this.LODBASEDMICROSFURACE = !1, this.MICROSURFACEMAP = !1, this.MICROSURFACEMAPDIRECTUV = 0, this.METALLICWORKFLOW = !1, this.ROUGHNESSSTOREINMETALMAPALPHA = !1, this.ROUGHNESSSTOREINMETALMAPGREEN = !1, this.METALLNESSSTOREINMETALMAPBLUE = !1, this.AOSTOREINMETALMAPRED = !1, this.METALLIC_REFLECTANCE = !1, this.METALLIC_REFLECTANCE_GAMMA = !1, this.METALLIC_REFLECTANCEDIRECTUV = 0, this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = !1, this.REFLECTANCE = !1, this.REFLECTANCE_GAMMA = !1, this.REFLECTANCEDIRECTUV = 0, this.ENVIRONMENTBRDF = !1, this.ENVIRONMENTBRDF_RGBD = !1, this.NORMAL = !1, this.TANGENT = !1, this.BUMP = !1, this.BUMPDIRECTUV = 0, this.OBJECTSPACE_NORMALMAP = !1, this.PARALLAX = !1, this.PARALLAX_RHS = !1, this.PARALLAXOCCLUSION = !1, this.NORMALXYSCALE = !0, this.LIGHTMAP = !1, this.LIGHTMAPDIRECTUV = 0, this.USELIGHTMAPASSHADOWMAP = !1, this.GAMMALIGHTMAP = !1, this.RGBDLIGHTMAP = !1, this.REFLECTION = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, this.INVERTCUBICMAP = !1, this.USESPHERICALFROMREFLECTIONMAP = !1, this.USEIRRADIANCEMAP = !1, this.USESPHERICALINVERTEX = !1, this.REFLECTIONMAP_OPPOSITEZ = !1, this.LODINREFLECTIONALPHA = !1, this.GAMMAREFLECTION = !1, this.RGBDREFLECTION = !1, this.LINEARSPECULARREFLECTION = !1, this.RADIANCEOCCLUSION = !1, this.HORIZONOCCLUSION = !1, this.INSTANCES = !1, this.THIN_INSTANCES = !1, this.INSTANCESCOLOR = !1, this.PREPASS = !1, this.PREPASS_IRRADIANCE = !1, this.PREPASS_IRRADIANCE_INDEX = -1, this.PREPASS_ALBEDO_SQRT = !1, this.PREPASS_ALBEDO_SQRT_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_NORMAL_WORLDSPACE = !1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_VELOCITY = !1, this.PREPASS_VELOCITY_INDEX = -1, this.PREPASS_REFLECTIVITY = !1, this.PREPASS_REFLECTIVITY_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.BONES_VELOCITY_ENABLED = !1, this.NONUNIFORMSCALING = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = 0, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.EXPOSURE = !1, this.MULTIVIEW = !1, this.ORDER_INDEPENDENT_TRANSPARENCY = !1, this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, this.USEPHYSICALLIGHTFALLOFF = !1, this.USEGLTFLIGHTFALLOFF = !1, this.TWOSIDEDLIGHTING = !1, this.SHADOWFLOAT = !1, this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.POINTSIZE = !1, this.FOG = !1, this.LOGARITHMICDEPTH = !1, this.CAMERA_ORTHOGRAPHIC = !1, this.CAMERA_PERSPECTIVE = !1, this.FORCENORMALFORWARD = !1, this.SPECULARAA = !1, this.UNLIT = !1, this.DECAL_AFTER_DETAIL = !1, this.DEBUGMODE = 0, this.rebuild()
			}
			reset() {
				super.reset(), this.ALPHATESTVALUE = "0.5", this.PBR = !0, this.NORMALXYSCALE = !0
			}
		},
		TA = class e extends $f {
			get canRenderToMRT() {
				return !0
			}
			_getReflectionTexture() {
				return this._reflectionTexture ? this._reflectionTexture : this.getScene().environmentTexture
			}
			_prepareDefines(t, i, s = null, n = null, a = !1) {
				const r = this.getScene(),
					o = r.getEngine();
				Ef(r, t, i, !0, this._maxSimultaneousLights, this._disableLighting), i._needNormals = !0, Cf(r, i);
				const l = this.needAlphaBlendingForMesh(t) && this.getScene().useOrderIndependentTransparency;
				if (wf(r, i, this.canRenderToMRT && !l), Tf(r, i, l), i.METALLICWORKFLOW = this.isMetallicWorkflow(), i._areTexturesDirty) {
					i._needUVs = !1;
					for (let e = 1; e <= 6; ++e) i["MAINUV" + e] = !1;
					if (r.texturesEnabled) {
						i.ALBEDODIRECTUV = 0, i.AMBIENTDIRECTUV = 0, i.OPACITYDIRECTUV = 0, i.EMISSIVEDIRECTUV = 0, i.REFLECTIVITYDIRECTUV = 0, i.MICROSURFACEMAPDIRECTUV = 0, i.METALLIC_REFLECTANCEDIRECTUV = 0, i.REFLECTANCEDIRECTUV = 0, i.BUMPDIRECTUV = 0, i.LIGHTMAPDIRECTUV = 0, o.getCaps().textureLOD && (i.LODBASEDMICROSFURACE = !0), this._albedoTexture && kv.DiffuseTextureEnabled ? (cf(this._albedoTexture, i, "ALBEDO"), i.GAMMAALBEDO = this._albedoTexture.gammaSpace) : i.ALBEDO = !1, this._ambientTexture && kv.AmbientTextureEnabled ? (cf(this._ambientTexture, i, "AMBIENT"), i.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale) : i.AMBIENT = !1, this._opacityTexture && kv.OpacityTextureEnabled ? (cf(this._opacityTexture, i, "OPACITY"), i.OPACITYRGB = this._opacityTexture.getAlphaFromRGB) : i.OPACITY = !1;
						const e = this._getReflectionTexture();
						if (e && kv.ReflectionTextureEnabled) {
							switch (i.REFLECTION = !0, i.GAMMAREFLECTION = e.gammaSpace, i.RGBDREFLECTION = e.isRGBD, i.LODINREFLECTIONALPHA = e.lodLevelInAlpha, i.LINEARSPECULARREFLECTION = e.linearSpecularLOD, this.realTimeFiltering && this.realTimeFilteringQuality > 0 ? (i.NUM_SAMPLES = "" + this.realTimeFilteringQuality, o._features.needTypeSuffixInShaderConstants && (i.NUM_SAMPLES = i.NUM_SAMPLES + "u"), i.REALTIME_FILTERING = !0) : i.REALTIME_FILTERING = !1, i.INVERTCUBICMAP = e.coordinatesMode === Np.INVCUBIC_MODE, i.REFLECTIONMAP_3D = e.isCube, i.REFLECTIONMAP_OPPOSITEZ = i.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !e.invertZ : e.invertZ, i.REFLECTIONMAP_CUBIC = !1, i.REFLECTIONMAP_EXPLICIT = !1, i.REFLECTIONMAP_PLANAR = !1, i.REFLECTIONMAP_PROJECTION = !1, i.REFLECTIONMAP_SKYBOX = !1, i.REFLECTIONMAP_SPHERICAL = !1, i.REFLECTIONMAP_EQUIRECTANGULAR = !1, i.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, i.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, e.coordinatesMode) {
								case Np.EXPLICIT_MODE:
									i.REFLECTIONMAP_EXPLICIT = !0;
									break;
								case Np.PLANAR_MODE:
									i.REFLECTIONMAP_PLANAR = !0;
									break;
								case Np.PROJECTION_MODE:
									i.REFLECTIONMAP_PROJECTION = !0;
									break;
								case Np.SKYBOX_MODE:
									i.REFLECTIONMAP_SKYBOX = !0;
									break;
								case Np.SPHERICAL_MODE:
									i.REFLECTIONMAP_SPHERICAL = !0;
									break;
								case Np.EQUIRECTANGULAR_MODE:
									i.REFLECTIONMAP_EQUIRECTANGULAR = !0;
									break;
								case Np.FIXED_EQUIRECTANGULAR_MODE:
									i.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !0;
									break;
								case Np.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
									i.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !0;
									break;
								case Np.CUBIC_MODE:
								case Np.INVCUBIC_MODE:
								default:
									i.REFLECTIONMAP_CUBIC = !0, i.USE_LOCAL_REFLECTIONMAP_CUBIC = !!e.boundingBoxSize
							}
							e.coordinatesMode !== Np.SKYBOX_MODE && (e.irradianceTexture ? (i.USEIRRADIANCEMAP = !0, i.USESPHERICALFROMREFLECTIONMAP = !1) : e.isCube && (i.USESPHERICALFROMREFLECTIONMAP = !0, i.USEIRRADIANCEMAP = !1, this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || o.getCaps().maxVaryingVectors <= 8 ? i.USESPHERICALINVERTEX = !1 : i.USESPHERICALINVERTEX = !0))
						} else i.REFLECTION = !1, i.REFLECTIONMAP_3D = !1, i.REFLECTIONMAP_SPHERICAL = !1, i.REFLECTIONMAP_PLANAR = !1, i.REFLECTIONMAP_CUBIC = !1, i.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, i.REFLECTIONMAP_PROJECTION = !1, i.REFLECTIONMAP_SKYBOX = !1, i.REFLECTIONMAP_EXPLICIT = !1, i.REFLECTIONMAP_EQUIRECTANGULAR = !1, i.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, i.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, i.INVERTCUBICMAP = !1, i.USESPHERICALFROMREFLECTIONMAP = !1, i.USEIRRADIANCEMAP = !1, i.USESPHERICALINVERTEX = !1, i.REFLECTIONMAP_OPPOSITEZ = !1, i.LODINREFLECTIONALPHA = !1, i.GAMMAREFLECTION = !1, i.RGBDREFLECTION = !1, i.LINEARSPECULARREFLECTION = !1;
						this._lightmapTexture && kv.LightmapTextureEnabled ? (cf(this._lightmapTexture, i, "LIGHTMAP"), i.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, i.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace, i.RGBDLIGHTMAP = this._lightmapTexture.isRGBD) : i.LIGHTMAP = !1, this._emissiveTexture && kv.EmissiveTextureEnabled ? (cf(this._emissiveTexture, i, "EMISSIVE"), i.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace) : i.EMISSIVE = !1, kv.SpecularTextureEnabled ? (this._metallicTexture ? (cf(this._metallicTexture, i, "REFLECTIVITY"), i.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha, i.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen, i.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue, i.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed, i.REFLECTIVITY_GAMMA = !1) : this._reflectivityTexture ? (cf(this._reflectivityTexture, i, "REFLECTIVITY"), i.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha, i.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap, i.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace) : i.REFLECTIVITY = !1, this._metallicReflectanceTexture || this._reflectanceTexture ? (i.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture, this._metallicReflectanceTexture ? (cf(this._metallicReflectanceTexture, i, "METALLIC_REFLECTANCE"), i.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace) : i.METALLIC_REFLECTANCE = !1, this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture) ? (cf(this._reflectanceTexture, i, "REFLECTANCE"), i.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace) : i.REFLECTANCE = !1) : (i.METALLIC_REFLECTANCE = !1, i.REFLECTANCE = !1), this._microSurfaceTexture ? cf(this._microSurfaceTexture, i, "MICROSURFACEMAP") : i.MICROSURFACEMAP = !1) : (i.REFLECTIVITY = !1, i.MICROSURFACEMAP = !1), o.getCaps().standardDerivatives && this._bumpTexture && kv.BumpTextureEnabled && !this._disableBumpMap ? (cf(this._bumpTexture, i, "BUMP"), this._useParallax && this._albedoTexture && kv.DiffuseTextureEnabled ? (i.PARALLAX = !0, i.PARALLAX_RHS = r.useRightHandedSystem, i.PARALLAXOCCLUSION = !!this._useParallaxOcclusion) : i.PARALLAX = !1, i.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap) : (i.BUMP = !1, i.PARALLAX = !1, i.PARALLAX_RHS = !1, i.PARALLAXOCCLUSION = !1, i.OBJECTSPACE_NORMALMAP = !1), this._environmentBRDFTexture && kv.ReflectionTextureEnabled ? (i.ENVIRONMENTBRDF = !0, i.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD) : (i.ENVIRONMENTBRDF = !1, i.ENVIRONMENTBRDF_RGBD = !1), this._shouldUseAlphaFromAlbedoTexture() ? i.ALPHAFROMALBEDO = !0 : i.ALPHAFROMALBEDO = !1
					}
					i.SPECULAROVERALPHA = this._useSpecularOverAlpha, this._lightFalloff === e.LIGHTFALLOFF_STANDARD ? (i.USEPHYSICALLIGHTFALLOFF = !1, i.USEGLTFLIGHTFALLOFF = !1) : this._lightFalloff === e.LIGHTFALLOFF_GLTF ? (i.USEPHYSICALLIGHTFALLOFF = !1, i.USEGLTFLIGHTFALLOFF = !0) : (i.USEPHYSICALLIGHTFALLOFF = !0, i.USEGLTFLIGHTFALLOFF = !1), i.RADIANCEOVERALPHA = this._useRadianceOverAlpha, !this.backFaceCulling && this._twoSidedLighting ? i.TWOSIDEDLIGHTING = !0 : i.TWOSIDEDLIGHTING = !1, i.SPECULARAA = o.getCaps().standardDerivatives && this._enableSpecularAntiAliasing
				}(i._areTexturesDirty || i._areMiscDirty) && (i.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff%1==0?".":""}`, i.PREMULTIPLYALPHA = 7 === this.alphaMode || 8 === this.alphaMode, i.ALPHABLEND = this.needAlphaBlendingForMesh(t), i.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel, i.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel), i._areImageProcessingDirty && this._imageProcessingConfiguration && this._imageProcessingConfiguration.prepareDefines(i), i.FORCENORMALFORWARD = this._forceNormalForward, i.RADIANCEOCCLUSION = this._useRadianceOcclusion, i.HORIZONOCCLUSION = this._useHorizonOcclusion, i._areMiscDirty && (Sf(t, r, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(t) || this._forceAlphaTest, i, this._applyDecalMapAfterDetailMap), i.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !t.isVerticesDataPresent(eu.NormalKind), i.DEBUGMODE = this._debugMode), bf(r, o, this, i, !!s, n, a), this._eventInfo.defines = i, this._eventInfo.mesh = t, this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo), Mf(t, i, !0, !0, !0, this._transparencyMode !== e.PBRMATERIAL_OPAQUE), this._callbackPluginEventPrepareDefines(this._eventInfo)
			}
			set realTimeFiltering(e) {
				this._realTimeFiltering = e, this.markAsDirty(1)
			}
			getActiveTextures() {
				const e = super.getActiveTextures();
				return this._albedoTexture && e.push(this._albedoTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._reflectivityTexture && e.push(this._reflectivityTexture), this._metallicTexture && e.push(this._metallicTexture), this._metallicReflectanceTexture && e.push(this._metallicReflectanceTexture), this._reflectanceTexture && e.push(this._reflectanceTexture), this._microSurfaceTexture && e.push(this._microSurfaceTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), e
			}
			needAlphaBlending() {
				return !this._disableAlphaBlending && (this.alpha < 1 || null != this._opacityTexture || this._shouldUseAlphaFromAlbedoTexture())
			}
			isReadyForSubMesh(e, t, i) {
				if (!this._shadersLoaded) return !1;
				this._uniformBufferLayoutBuilt || this.buildUniformLayout();
				const s = t._drawWrapper;
				if (s.effect && this.isFrozen && s._wasPreviouslyReady && s._wasPreviouslyUsingInstances === i) return !0;
				t.materialDefines || (this._callbackPluginEventGeneric(4, this._eventInfo), t.materialDefines = new CA(this._eventInfo.defineNames));
				const n = t.materialDefines;
				if (this._isReadyForSubMesh(t)) return !0;
				const a = this.getScene(),
					r = a.getEngine();
				if (n._areTexturesDirty && (this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, a.texturesEnabled)) {
					if (this._albedoTexture && kv.DiffuseTextureEnabled && !this._albedoTexture.isReadyOrNotBlocking()) return !1;
					if (this._ambientTexture && kv.AmbientTextureEnabled && !this._ambientTexture.isReadyOrNotBlocking()) return !1;
					if (this._opacityTexture && kv.OpacityTextureEnabled && !this._opacityTexture.isReadyOrNotBlocking()) return !1;
					const e = this._getReflectionTexture();
					if (e && kv.ReflectionTextureEnabled) {
						if (!e.isReadyOrNotBlocking()) return !1;
						if (e.irradianceTexture) {
							if (!e.irradianceTexture.isReadyOrNotBlocking()) return !1
						} else if (!e.sphericalPolynomial && e.getInternalTexture()?._sphericalPolynomialPromise) return !1
					}
					if (this._lightmapTexture && kv.LightmapTextureEnabled && !this._lightmapTexture.isReadyOrNotBlocking()) return !1;
					if (this._emissiveTexture && kv.EmissiveTextureEnabled && !this._emissiveTexture.isReadyOrNotBlocking()) return !1;
					if (kv.SpecularTextureEnabled) {
						if (this._metallicTexture) {
							if (!this._metallicTexture.isReadyOrNotBlocking()) return !1
						} else if (this._reflectivityTexture && !this._reflectivityTexture.isReadyOrNotBlocking()) return !1;
						if (this._metallicReflectanceTexture && !this._metallicReflectanceTexture.isReadyOrNotBlocking()) return !1;
						if (this._reflectanceTexture && !this._reflectanceTexture.isReadyOrNotBlocking()) return !1;
						if (this._microSurfaceTexture && !this._microSurfaceTexture.isReadyOrNotBlocking()) return !1
					}
					if (r.getCaps().standardDerivatives && this._bumpTexture && kv.BumpTextureEnabled && !this._disableBumpMap && !this._bumpTexture.isReady()) return !1;
					if (this._environmentBRDFTexture && kv.ReflectionTextureEnabled && !this._environmentBRDFTexture.isReady()) return !1
				}
				if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = n, this._eventInfo.subMesh = t, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh) return !1;
				if (n._areImageProcessingDirty && this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) return !1;
				r.getCaps().standardDerivatives || e.isVerticesDataPresent(eu.NormalKind) || (e.createNormals(!0), Qc.Warn("PBRMaterial: Normals have been created for the mesh: " + e.name));
				const o = t.effect,
					l = n._areLightsDisposed;
				let h = this._prepareEffect(e, n, this.onCompiled, this.onError, i, null, t.getRenderingMesh().hasThinInstances),
					c = !1;
				if (h)
					if (this._onEffectCreatedObservable && (MA.effect = h, MA.subMesh = t, this._onEffectCreatedObservable.notifyObservers(MA)), this.allowShaderHotSwapping && o && !h.isReady()) {
						if (h = o, n.markAsUnprocessed(), c = this.isFrozen, l) return n._areLightsDisposed = !0, !1
					} else a.resetCachedMaterial(), t.setEffect(h, n, this._materialContext);
				return !(!t.effect || !t.effect.isReady()) && (n._renderId = a.getRenderId(), s._wasPreviouslyReady = !c, s._wasPreviouslyUsingInstances = !!i, this._checkScenePerformancePriority(), !0)
			}
			set realTimeFilteringQuality(e) {
				this._realTimeFilteringQuality = e, this.markAsDirty(1)
			}
			get isPrePassCapable() {
				return !this.disableDepthWrite
			}
			getClassName() {
				return "PBRBaseMaterial"
			}
			async _initShaderSourceAsync(t = !1) {
				const i = this.getScene().getEngine();
				!i.isWebGPU || t || e.ForceGLSL ? await Promise.all([Promise.resolve().then((() => (gl(), dl))), Promise.resolve().then((() => (eh(), Zl)))]) : (this._uniformBuffer && this._uniformBuffer.dispose(), this._uniformBuffer = new Bd(i, void 0, void 0, this.name, !0), this._shaderLanguage = 1, await Promise.all([Promise.resolve().then((() => (xo(), So))), Promise.resolve().then((() => (hl(), al)))])), this._shadersLoaded = !0
			}
			getAnimatables() {
				const e = super.getAnimatables();
				return this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0 && e.push(this._albedoTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture), this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0 ? e.push(this._metallicTexture) : this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0 && e.push(this._reflectivityTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture), this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0 && e.push(this._metallicReflectanceTexture), this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0 && e.push(this._reflectanceTexture), this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0 && e.push(this._microSurfaceTexture), e
			}
			bindForSubMesh(e, t, i) {
				const s = this.getScene(),
					n = i.materialDefines;
				if (!n) return;
				const a = i.effect;
				if (!a) return;
				this._activeEffect = a, t.getMeshUniformBuffer().bindToEffect(a, "Mesh"), t.transferToEffect(e);
				const r = s.getEngine();
				this._uniformBuffer.bindToEffect(a, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, s, t, e, this.isFrozen), this._eventInfo.subMesh = i, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), n.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));
				const o = this._mustRebind(s, a, i, t.visibility);
				df(t, this._activeEffect, this.prePassConfiguration);
				let l = null;
				const h = this._uniformBuffer;
				if (o) {
					if (this.bindViewProjection(a), l = this._getReflectionTexture(), !h.useUbo || !this.isFrozen || !h.isSync || i._drawWrapper._forceRebindOnNextCall) {
						if (s.texturesEnabled) {
							if (this._albedoTexture && kv.DiffuseTextureEnabled && (h.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level), uf(this._albedoTexture, h, "albedo")), this._ambientTexture && kv.AmbientTextureEnabled && (h.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights), uf(this._ambientTexture, h, "ambient")), this._opacityTexture && kv.OpacityTextureEnabled && (h.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), uf(this._opacityTexture, h, "opacity")), l && kv.ReflectionTextureEnabled) {
								if (h.updateMatrix("reflectionMatrix", l.getReflectionTextureMatrix()), h.updateFloat2("vReflectionInfos", l.level, 0), l.boundingBoxSize) {
									const e = l;
									h.updateVector3("vReflectionPosition", e.boundingBoxPosition), h.updateVector3("vReflectionSize", e.boundingBoxSize)
								}
								if (this.realTimeFiltering) {
									const e = l.getSize().width;
									h.updateFloat2("vReflectionFilteringInfo", e, Ac.Log2(e))
								}
								if (!n.USEIRRADIANCEMAP) {
									const e = l.sphericalPolynomial;
									if (n.USESPHERICALFROMREFLECTIONMAP && e)
										if (n.SPHERICAL_HARMONICS) {
											const t = e.preScaledHarmonics;
											h.updateVector3("vSphericalL00", t.l00), h.updateVector3("vSphericalL1_1", t.l1_1), h.updateVector3("vSphericalL10", t.l10), h.updateVector3("vSphericalL11", t.l11), h.updateVector3("vSphericalL2_2", t.l2_2), h.updateVector3("vSphericalL2_1", t.l2_1), h.updateVector3("vSphericalL20", t.l20), h.updateVector3("vSphericalL21", t.l21), h.updateVector3("vSphericalL22", t.l22)
										} else h.updateFloat3("vSphericalX", e.x.x, e.x.y, e.x.z), h.updateFloat3("vSphericalY", e.y.x, e.y.y, e.y.z), h.updateFloat3("vSphericalZ", e.z.x, e.z.y, e.z.z), h.updateFloat3("vSphericalXX_ZZ", e.xx.x - e.zz.x, e.xx.y - e.zz.y, e.xx.z - e.zz.z), h.updateFloat3("vSphericalYY_ZZ", e.yy.x - e.zz.x, e.yy.y - e.zz.y, e.yy.z - e.zz.z), h.updateFloat3("vSphericalZZ", e.zz.x, e.zz.y, e.zz.z), h.updateFloat3("vSphericalXY", e.xy.x, e.xy.y, e.xy.z), h.updateFloat3("vSphericalYZ", e.yz.x, e.yz.y, e.yz.z), h.updateFloat3("vSphericalZX", e.zx.x, e.zx.y, e.zx.z)
								}
								h.updateFloat3("vReflectionMicrosurfaceInfos", l.getSize().width, l.lodGenerationScale, l.lodGenerationOffset)
							}
							this._emissiveTexture && kv.EmissiveTextureEnabled && (h.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), uf(this._emissiveTexture, h, "emissive")), this._lightmapTexture && kv.LightmapTextureEnabled && (h.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), uf(this._lightmapTexture, h, "lightmap")), kv.SpecularTextureEnabled && (this._metallicTexture ? (h.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength), uf(this._metallicTexture, h, "reflectivity")) : this._reflectivityTexture && (h.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1), uf(this._reflectivityTexture, h, "reflectivity")), this._metallicReflectanceTexture && (h.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level), uf(this._metallicReflectanceTexture, h, "metallicReflectance")), this._reflectanceTexture && n.REFLECTANCE && (h.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level), uf(this._reflectanceTexture, h, "reflectance")), this._microSurfaceTexture && (h.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level), uf(this._microSurfaceTexture, h, "microSurfaceSampler"))), this._bumpTexture && r.getCaps().standardDerivatives && kv.BumpTextureEnabled && !this._disableBumpMap && (h.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias), uf(this._bumpTexture, h, "bump"), s._mirroredCameraPosition ? h.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : h.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1))
						}
						if (this.pointsCloud && h.updateFloat("pointSize", this.pointSize), n.METALLICWORKFLOW) {
							Rc.Color3[0].r = void 0 === this._metallic || null === this._metallic ? 1 : this._metallic, Rc.Color3[0].g = void 0 === this._roughness || null === this._roughness ? 1 : this._roughness, h.updateColor4("vReflectivityColor", Rc.Color3[0], 1);
							const e = this.subSurface?._indexOfRefraction ?? 1.5,
								t = 1,
								i = Math.pow((e - t) / (e + t), 2);
							this._metallicReflectanceColor.scaleToRef(i * this._metallicF0Factor, Rc.Color3[0]);
							const s = this._metallicF0Factor;
							h.updateColor4("vMetallicReflectanceFactors", Rc.Color3[0], s)
						} else h.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
						h.updateColor3("vEmissiveColor", kv.EmissiveTextureEnabled ? this._emissiveColor : Tc.BlackReadOnly), h.updateColor3("vReflectionColor", this._reflectionColor), !n.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency ? h.updateColor4("vAlbedoColor", this._albedoColor, 1) : h.updateColor4("vAlbedoColor", this._albedoColor, this.alpha), this._lightingInfos.x = this._directIntensity, this._lightingInfos.y = this._emissiveIntensity, this._lightingInfos.z = this._environmentIntensity * s.environmentIntensity, this._lightingInfos.w = this._specularIntensity, h.updateVector4("vLightingIntensity", this._lightingInfos), s.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor), h.updateColor3("vAmbientColor", this._globalAmbientColor), h.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor)
					}
					s.texturesEnabled && (this._albedoTexture && kv.DiffuseTextureEnabled && h.setTexture("albedoSampler", this._albedoTexture), this._ambientTexture && kv.AmbientTextureEnabled && h.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && kv.OpacityTextureEnabled && h.setTexture("opacitySampler", this._opacityTexture), l && kv.ReflectionTextureEnabled && (n.LODBASEDMICROSFURACE ? h.setTexture("reflectionSampler", l) : (h.setTexture("reflectionSampler", l._lodTextureMid || l), h.setTexture("reflectionSamplerLow", l._lodTextureLow || l), h.setTexture("reflectionSamplerHigh", l._lodTextureHigh || l)), n.USEIRRADIANCEMAP && h.setTexture("irradianceSampler", l.irradianceTexture)), n.ENVIRONMENTBRDF && h.setTexture("environmentBrdfSampler", this._environmentBRDFTexture), this._emissiveTexture && kv.EmissiveTextureEnabled && h.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && kv.LightmapTextureEnabled && h.setTexture("lightmapSampler", this._lightmapTexture), kv.SpecularTextureEnabled && (this._metallicTexture ? h.setTexture("reflectivitySampler", this._metallicTexture) : this._reflectivityTexture && h.setTexture("reflectivitySampler", this._reflectivityTexture), this._metallicReflectanceTexture && h.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture), this._reflectanceTexture && n.REFLECTANCE && h.setTexture("reflectanceSampler", this._reflectanceTexture), this._microSurfaceTexture && h.setTexture("microSurfaceSampler", this._microSurfaceTexture)), this._bumpTexture && r.getCaps().standardDerivatives && kv.BumpTextureEnabled && !this._disableBumpMap && h.setTexture("bumpSampler", this._bumpTexture)), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(t) && this.getScene().depthPeelingRenderer.bind(a), this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), Qd(this._activeEffect, this, s), this.bindEyePosition(a)
				} else s.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
				!o && this.isFrozen || (s.lightsEnabled && !this._disableLighting && pf(s, t, this._activeEffect, n, this._maxSimultaneousLights), (s.fogEnabled && t.applyFog && s.fogMode !== bg.FOGMODE_NONE || l || this.subSurface.refractionTexture || t.receiveShadows || n.PREPASS) && this.bindView(a), nf(s, t, this._activeEffect, !0), n.NUM_MORPH_INFLUENCERS && lf(t, this._activeEffect), n.BAKED_VERTEX_ANIMATION_TEXTURE && t.bakedVertexAnimationManager?.bind(a, n.INSTANCES), this._imageProcessingConfiguration.bind(this._activeEffect), sf(n, this._activeEffect, s)), this._afterBind(t, this._activeEffect, i), h.update()
			}
			_shouldUseAlphaFromAlbedoTexture() {
				return null != this._albedoTexture && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== e.PBRMATERIAL_OPAQUE
			}
			_prepareEffect(e, t, i = null, s = null, n = null, a = null, r) {
				if (this._prepareDefines(e, t, n, a, r), !t.isDirty) return null;
				t.markAsProcessed();
				const o = this.getScene().getEngine(),
					l = new Op;
				let h = 0;
				t.USESPHERICALINVERTEX && l.addFallback(h++, "USESPHERICALINVERTEX"), t.FOG && l.addFallback(h, "FOG"), t.SPECULARAA && l.addFallback(h, "SPECULARAA"), t.POINTSIZE && l.addFallback(h, "POINTSIZE"), t.LOGARITHMICDEPTH && l.addFallback(h, "LOGARITHMICDEPTH"), t.PARALLAX && l.addFallback(h, "PARALLAX"), t.PARALLAX_RHS && l.addFallback(h, "PARALLAX_RHS"), t.PARALLAXOCCLUSION && l.addFallback(h++, "PARALLAXOCCLUSION"), t.ENVIRONMENTBRDF && l.addFallback(h++, "ENVIRONMENTBRDF"), t.TANGENT && l.addFallback(h++, "TANGENT"), t.BUMP && l.addFallback(h++, "BUMP"), h = vf(t, l, this._maxSimultaneousLights, h++), t.SPECULARTERM && l.addFallback(h++, "SPECULARTERM"), t.USESPHERICALFROMREFLECTIONMAP && l.addFallback(h++, "USESPHERICALFROMREFLECTIONMAP"), t.USEIRRADIANCEMAP && l.addFallback(h++, "USEIRRADIANCEMAP"), t.LIGHTMAP && l.addFallback(h++, "LIGHTMAP"), t.NORMAL && l.addFallback(h++, "NORMAL"), t.AMBIENT && l.addFallback(h++, "AMBIENT"), t.EMISSIVE && l.addFallback(h++, "EMISSIVE"), t.VERTEXCOLOR && l.addFallback(h++, "VERTEXCOLOR"), t.MORPHTARGETS && l.addFallback(h++, "MORPHTARGETS"), t.MULTIVIEW && l.addFallback(0, "MULTIVIEW");
				const c = [eu.PositionKind];
				t.NORMAL && c.push(eu.NormalKind), t.TANGENT && c.push(eu.TangentKind);
				for (let e = 1; e <= 6; ++e) t["UV" + e] && c.push(`uv${1===e?"":e}`);
				t.VERTEXCOLOR && c.push(eu.ColorKind), _f(c, e, t, l), gf(c, t), rf(c, e, t), mf(c, 0, t);
				let u = "pbr";
				const m = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vAlbedoColor", "vReflectivityColor", "vMetallicReflectanceFactors", "vEmissiveColor", "visibility", "vReflectionColor", "vFogInfos", "vFogColor", "pointSize", "vAlbedoInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vReflectionPosition", "vReflectionSize", "vEmissiveInfos", "vReflectivityInfos", "vReflectionFilteringInfo", "vMetallicReflectanceInfos", "vReflectanceInfos", "vMicroSurfaceSamplerInfos", "vBumpInfos", "vLightmapInfos", "mBones", "albedoMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "reflectivityMatrix", "normalMatrix", "microSurfaceSamplerMatrix", "bumpMatrix", "lightmapMatrix", "metallicReflectanceMatrix", "reflectanceMatrix", "vLightingIntensity", "logarithmicDepthConstant", "vSphericalX", "vSphericalY", "vSphericalZ", "vSphericalXX_ZZ", "vSphericalYY_ZZ", "vSphericalZZ", "vSphericalXY", "vSphericalYZ", "vSphericalZX", "vSphericalL00", "vSphericalL1_1", "vSphericalL10", "vSphericalL11", "vSphericalL2_2", "vSphericalL2_1", "vSphericalL20", "vSphericalL21", "vSphericalL22", "vReflectionMicrosurfaceInfos", "vTangentSpaceParams", "boneTextureWidth", "vDebugMode", "morphTargetTextureInfo", "morphTargetTextureIndices"],
					d = ["albedoSampler", "reflectivitySampler", "ambientSampler", "emissiveSampler", "bumpSampler", "lightmapSampler", "opacitySampler", "reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh", "irradianceSampler", "microSurfaceSampler", "environmentBrdfSampler", "boneSampler", "metallicReflectanceSampler", "reflectanceSampler", "morphTargets", "oitDepthSampler", "oitFrontColorSampler"],
					f = ["Material", "Scene", "Mesh"],
					p = {
						maxSimultaneousLights: this._maxSimultaneousLights,
						maxSimultaneousMorphTargets: t.NUM_MORPH_INFLUENCERS
					};
				this._eventInfo.fallbacks = l, this._eventInfo.fallbackRank = h, this._eventInfo.defines = t, this._eventInfo.uniforms = m, this._eventInfo.attributes = c, this._eventInfo.samplers = d, this._eventInfo.uniformBuffersNames = f, this._eventInfo.customCode = void 0, this._eventInfo.mesh = e, this._eventInfo.indexParameters = p, this._callbackPluginEventGeneric(128, this._eventInfo), Pv.AddUniforms(m), Pv.AddSamplers(d), Jd(m), B_ && (B_.PrepareUniforms(m, t), B_.PrepareSamplers(d, t)), If({
					uniformsNames: m,
					uniformBuffersNames: f,
					samplers: d,
					defines: t,
					maxSimultaneousLights: this._maxSimultaneousLights
				});
				const _ = {};
				this.customShaderNameResolve && (u = this.customShaderNameResolve(u, m, f, d, t, c, _));
				const g = t.toString(),
					v = o.createEffect(u, {
						attributes: c,
						uniformsNames: m,
						uniformBuffersNames: f,
						samplers: d,
						defines: g,
						fallbacks: l,
						onCompiled: i,
						onError: s,
						indexParameters: p,
						processFinalCode: _.processFinalCode,
						processCodeAfterIncludes: this._eventInfo.customCode,
						multiTarget: t.PREPASS,
						shaderLanguage: this._shaderLanguage
					}, o);
				return this._eventInfo.customCode = void 0, v
			}
			forceCompilation(e, t, i) {
				const s = {
					clipPlane: !1,
					useInstances: !1,
					...i
				};
				this._uniformBufferLayoutBuilt || this.buildUniformLayout(), this._callbackPluginEventGeneric(4, this._eventInfo);
				const n = () => {
					if (!this._breakShaderLoadedCheck)
						if (this._shadersLoaded) {
							const i = new CA(this._eventInfo.defineNames),
								n = this._prepareEffect(e, i, void 0, void 0, s.useInstances, s.clipPlane, e.hasThinInstances);
							this._onEffectCreatedObservable && (MA.effect = n, MA.subMesh = null, this._onEffectCreatedObservable.notifyObservers(MA)), n.isReady() ? t && t(this) : n.onCompileObservable.add((() => {
								t && t(this)
							}))
						} else setTimeout(n, 16)
				};
				n()
			}
			buildUniformLayout() {
				const e = this._uniformBuffer;
				e.addUniform("vAlbedoInfos", 2), e.addUniform("vAmbientInfos", 4), e.addUniform("vOpacityInfos", 2), e.addUniform("vEmissiveInfos", 2), e.addUniform("vLightmapInfos", 2), e.addUniform("vReflectivityInfos", 3), e.addUniform("vMicroSurfaceSamplerInfos", 2), e.addUniform("vReflectionInfos", 2), e.addUniform("vReflectionFilteringInfo", 2), e.addUniform("vReflectionPosition", 3), e.addUniform("vReflectionSize", 3), e.addUniform("vBumpInfos", 3), e.addUniform("albedoMatrix", 16), e.addUniform("ambientMatrix", 16), e.addUniform("opacityMatrix", 16), e.addUniform("emissiveMatrix", 16), e.addUniform("lightmapMatrix", 16), e.addUniform("reflectivityMatrix", 16), e.addUniform("microSurfaceSamplerMatrix", 16), e.addUniform("bumpMatrix", 16), e.addUniform("vTangentSpaceParams", 2), e.addUniform("reflectionMatrix", 16), e.addUniform("vReflectionColor", 3), e.addUniform("vAlbedoColor", 4), e.addUniform("vLightingIntensity", 4), e.addUniform("vReflectionMicrosurfaceInfos", 3), e.addUniform("pointSize", 1), e.addUniform("vReflectivityColor", 4), e.addUniform("vEmissiveColor", 3), e.addUniform("vAmbientColor", 3), e.addUniform("vDebugMode", 2), e.addUniform("vMetallicReflectanceFactors", 4), e.addUniform("vMetallicReflectanceInfos", 2), e.addUniform("metallicReflectanceMatrix", 16), e.addUniform("vReflectanceInfos", 2), e.addUniform("reflectanceMatrix", 16), e.addUniform("vSphericalL00", 3), e.addUniform("vSphericalL1_1", 3), e.addUniform("vSphericalL10", 3), e.addUniform("vSphericalL11", 3), e.addUniform("vSphericalL2_2", 3), e.addUniform("vSphericalL2_1", 3), e.addUniform("vSphericalL20", 3), e.addUniform("vSphericalL21", 3), e.addUniform("vSphericalL22", 3), e.addUniform("vSphericalX", 3), e.addUniform("vSphericalY", 3), e.addUniform("vSphericalZ", 3), e.addUniform("vSphericalXX_ZZ", 3), e.addUniform("vSphericalYY_ZZ", 3), e.addUniform("vSphericalZZ", 3), e.addUniform("vSphericalXY", 3), e.addUniform("vSphericalYZ", 3), e.addUniform("vSphericalZX", 3), super.buildUniformLayout()
			}
			hasTexture(e) {
				return !!super.hasTexture(e) || (this._albedoTexture === e || (this._ambientTexture === e || (this._opacityTexture === e || (this._reflectionTexture === e || (this._emissiveTexture === e || (this._reflectivityTexture === e || (this._metallicTexture === e || (this._metallicReflectanceTexture === e || (this._reflectanceTexture === e || (this._microSurfaceTexture === e || (this._bumpTexture === e || this._lightmapTexture === e)))))))))))
			}
			_attachImageProcessingConfiguration(e) {
				e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add((() => {
					this._markAllSubMeshesAsImageProcessingDirty()
				}))))
			}
			needAlphaTesting() {
				return !!this._forceAlphaTest || !this.subSurface?.disableAlphaBlending && (this._hasAlphaChannel() && (null == this._transparencyMode || this._transparencyMode === e.PBRMATERIAL_ALPHATEST))
			}
			get _disableAlphaBlending() {
				return this._transparencyMode === e.PBRMATERIAL_OPAQUE || this._transparencyMode === e.PBRMATERIAL_ALPHATEST || this.subSurface?.disableAlphaBlending
			}
			dispose(e, t) {
				this._breakShaderLoadedCheck = !0, t && (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture && this._environmentBRDFTexture.dispose(), this._albedoTexture?.dispose(), this._ambientTexture?.dispose(), this._opacityTexture?.dispose(), this._reflectionTexture?.dispose(), this._emissiveTexture?.dispose(), this._metallicTexture?.dispose(), this._reflectivityTexture?.dispose(), this._bumpTexture?.dispose(), this._lightmapTexture?.dispose(), this._metallicReflectanceTexture?.dispose(), this._reflectanceTexture?.dispose(), this._microSurfaceTexture?.dispose()), this._renderTargets.dispose(), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), super.dispose(e, t)
			}
			setPrePassRenderer() {
				if (!this.subSurface?.isScatteringEnabled) return !1;
				const e = this.getScene().enableSubSurfaceForPrePass();
				return e && (e.enabled = !0), !0
			}
			get hasRenderTargetTextures() {
				return !!(kv.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) || this._cacheHasRenderTargetTextures
			}
			constructor(t, i, s = !1) {
				super(t, i), this._directIntensity = 1, this._emissiveIntensity = 1, this._environmentIntensity = 1, this._specularIntensity = 1, this._lightingInfos = new Bc(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity), this._disableBumpMap = !1, this._albedoTexture = null, this._ambientTexture = null, this._ambientTextureStrength = 1, this._ambientTextureImpactOnAnalyticalLights = e.DEFAULT_AO_ON_ANALYTICAL_LIGHTS, this._opacityTexture = null, this._reflectionTexture = null, this._emissiveTexture = null, this._reflectivityTexture = null, this._metallicTexture = null, this._metallic = null, this._roughness = null, this._metallicF0Factor = 1, this._metallicReflectanceColor = Tc.White(), this._useOnlyMetallicFromMetallicReflectanceTexture = !1, this._metallicReflectanceTexture = null, this._reflectanceTexture = null, this._microSurfaceTexture = null, this._bumpTexture = null, this._lightmapTexture = null, this._ambientColor = new Tc(0, 0, 0), this._albedoColor = new Tc(1, 1, 1), this._reflectivityColor = new Tc(1, 1, 1), this._reflectionColor = new Tc(1, 1, 1), this._emissiveColor = new Tc(0, 0, 0), this._microSurface = .9, this._useLightmapAsShadowmap = !1, this._useHorizonOcclusion = !0, this._useRadianceOcclusion = !0, this._useAlphaFromAlbedoTexture = !1, this._useSpecularOverAlpha = !0, this._useMicroSurfaceFromReflectivityMapAlpha = !1, this._useRoughnessFromMetallicTextureAlpha = !0, this._useRoughnessFromMetallicTextureGreen = !1, this._useMetallnessFromMetallicTextureBlue = !1, this._useAmbientOcclusionFromMetallicTextureRed = !1, this._useAmbientInGrayScale = !1, this._useAutoMicroSurfaceFromReflectivityMap = !1, this._lightFalloff = e.LIGHTFALLOFF_PHYSICAL, this._useRadianceOverAlpha = !0, this._useObjectSpaceNormalMap = !1, this._useParallax = !1, this._useParallaxOcclusion = !1, this._parallaxScaleBias = .05, this._disableLighting = !1, this._maxSimultaneousLights = 4, this._invertNormalMapX = !1, this._invertNormalMapY = !1, this._twoSidedLighting = !1, this._alphaCutOff = .4, this._forceAlphaTest = !1, this._useAlphaFresnel = !1, this._useLinearAlphaFresnel = !1, this._environmentBRDFTexture = null, this._forceIrradianceInFragment = !1, this._realTimeFiltering = !1, this._realTimeFilteringQuality = 8, this._forceNormalForward = !1, this._enableSpecularAntiAliasing = !1, this._imageProcessingObserver = null, this._renderTargets = new pd(16), this._globalAmbientColor = new Tc(0, 0, 0), this._unlit = !1, this._applyDecalMapAfterDetailMap = !1, this._debugMode = 0, this._shadersLoaded = !1, this._breakShaderLoadedCheck = !1, this.debugMode = 0, this.debugLimit = -1, this.debugFactor = 1, this._cacheHasRenderTargetTextures = !1, this._initShaderSourceAsync(s), this.brdf = new fA(this), this.clearCoat = new _A(this), this.iridescence = new vA(this), this.anisotropy = new SA(this), this.sheen = new AA(this), this.subSurface = new xA(this), this.detailMap = new Hv(this), this._attachImageProcessingConfiguration(null), this.getRenderTargetTextures = () => (this._renderTargets.reset(), kv.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture), this._eventInfo.renderTargets = this._renderTargets, this._callbackPluginEventFillRenderTargetTextures(this._eventInfo), this._renderTargets), this._environmentBRDFTexture = mA(this.getScene()), this.prePassConfiguration = new Pv
			}
			_hasAlphaChannel() {
				return null != this._albedoTexture && this._albedoTexture.hasAlpha || null != this._opacityTexture
			}
			get realTimeFilteringQuality() {
				return this._realTimeFilteringQuality
			}
			isMetallicWorkflow() {
				return !(null == this._metallic && null == this._roughness && !this._metallicTexture)
			}
			getAlphaTestTexture() {
				return this._albedoTexture
			}
			get realTimeFiltering() {
				return this._realTimeFiltering
			}
		};
	TA.PBRMATERIAL_OPAQUE = Pf.MATERIAL_OPAQUE, TA.PBRMATERIAL_ALPHATEST = Pf.MATERIAL_ALPHATEST, TA.PBRMATERIAL_ALPHABLEND = Pf.MATERIAL_ALPHABLEND, TA.PBRMATERIAL_ALPHATESTANDBLEND = Pf.MATERIAL_ALPHATESTANDBLEND, TA.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0, TA.LIGHTFALLOFF_PHYSICAL = 0, TA.LIGHTFALLOFF_GLTF = 1, TA.LIGHTFALLOFF_STANDARD = 2, TA.ForceGLSL = !1, Gh([function(e) {
		return Wh(9, e)
	}()], TA.prototype, "_imageProcessingConfiguration", void 0), Gh([zh("_markAllSubMeshesAsMiscDirty")], TA.prototype, "debugMode", void 0);
	var wA = class e extends TA {
		get imageProcessingConfiguration() {
			return this._imageProcessingConfiguration
		}
		set linkRefractionWithTransparency(e) {
			this.subSurface.linkRefractionWithTransparency = e, e && (this.subSurface.isRefractionEnabled = !0)
		}
		get cameraExposure() {
			return this._imageProcessingConfiguration.exposure
		}
		set indexOfRefraction(e) {
			this.subSurface.indexOfRefraction = e
		}
		set cameraContrast(e) {
			this._imageProcessingConfiguration.contrast = e
		}
		clone(t, i = !0, s = "") {
			const n = Xc.Clone((() => new e(t, this.getScene())), this, {
				cloneTexturesOnlyOnce: i
			});
			return n.id = t, n.name = t, this.stencil.copyTo(n.stencil), this._clonePlugins(n, s), n
		}
		set imageProcessingConfiguration(e) {
			this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty()
		}
		get refractionTexture() {
			return this.subSurface.refractionTexture
		}
		set useGLTFLightFalloff(e) {
			e !== this.useGLTFLightFalloff && (this._markAllSubMeshesAsTexturesDirty(), this._lightFalloff = e ? TA.LIGHTFALLOFF_GLTF : TA.LIGHTFALLOFF_STANDARD)
		}
		get cameraColorCurvesEnabled() {
			return this.imageProcessingConfiguration.colorCurvesEnabled
		}
		set cameraExposure(e) {
			this._imageProcessingConfiguration.exposure = e
		}
		get indexOfRefraction() {
			return this.subSurface.indexOfRefraction
		}
		get cameraColorCurves() {
			return this._imageProcessingConfiguration.colorCurves
		}
		get invertRefractionY() {
			return this.subSurface.invertRefractionY
		}
		get cameraColorGradingEnabled() {
			return this.imageProcessingConfiguration.colorGradingEnabled
		}
		set cameraColorGradingEnabled(e) {
			this.imageProcessingConfiguration.colorGradingEnabled = e
		}
		get linkRefractionWithTransparency() {
			return this.subSurface.linkRefractionWithTransparency
		}
		set cameraToneMappingEnabled(e) {
			this._imageProcessingConfiguration.toneMappingEnabled = e
		}
		getClassName() {
			return "PBRMaterial"
		}
		get cameraContrast() {
			return this._imageProcessingConfiguration.contrast
		}
		set refractionTexture(e) {
			this.subSurface.refractionTexture = e, e ? this.subSurface.isRefractionEnabled = !0 : this.subSurface.linkRefractionWithTransparency || (this.subSurface.isRefractionEnabled = !1)
		}
		set invertRefractionY(e) {
			this.subSurface.invertRefractionY = e
		}
		get usePhysicalLightFalloff() {
			return this._lightFalloff === TA.LIGHTFALLOFF_PHYSICAL
		}
		set cameraColorCurves(e) {
			this._imageProcessingConfiguration.colorCurves = e
		}
		set cameraColorGradingTexture(e) {
			this._imageProcessingConfiguration.colorGradingTexture = e
		}
		constructor(t, i, s = !1) {
			super(t, i, s), this.directIntensity = 1, this.emissiveIntensity = 1, this.environmentIntensity = 1, this.specularIntensity = 1, this.disableBumpMap = !1, this.ambientTextureStrength = 1, this.ambientTextureImpactOnAnalyticalLights = e.DEFAULT_AO_ON_ANALYTICAL_LIGHTS, this.metallicF0Factor = 1, this.metallicReflectanceColor = Tc.White(), this.useOnlyMetallicFromMetallicReflectanceTexture = !1, this.ambientColor = new Tc(0, 0, 0), this.albedoColor = new Tc(1, 1, 1), this.reflectivityColor = new Tc(1, 1, 1), this.reflectionColor = new Tc(1, 1, 1), this.emissiveColor = new Tc(0, 0, 0), this.microSurface = 1, this.useLightmapAsShadowmap = !1, this.useAlphaFromAlbedoTexture = !1, this.forceAlphaTest = !1, this.alphaCutOff = .4, this.useSpecularOverAlpha = !0, this.useMicroSurfaceFromReflectivityMapAlpha = !1, this.useRoughnessFromMetallicTextureAlpha = !0, this.useRoughnessFromMetallicTextureGreen = !1, this.useMetallnessFromMetallicTextureBlue = !1, this.useAmbientOcclusionFromMetallicTextureRed = !1, this.useAmbientInGrayScale = !1, this.useAutoMicroSurfaceFromReflectivityMap = !1, this.useRadianceOverAlpha = !0, this.useObjectSpaceNormalMap = !1, this.useParallax = !1, this.useParallaxOcclusion = !1, this.parallaxScaleBias = .05, this.disableLighting = !1, this.forceIrradianceInFragment = !1, this.maxSimultaneousLights = 4, this.invertNormalMapX = !1, this.invertNormalMapY = !1, this.twoSidedLighting = !1, this.useAlphaFresnel = !1, this.useLinearAlphaFresnel = !1, this.environmentBRDFTexture = null, this.forceNormalForward = !1, this.enableSpecularAntiAliasing = !1, this.useHorizonOcclusion = !0, this.useRadianceOcclusion = !0, this.unlit = !1, this.applyDecalMapAfterDetailMap = !1, this._environmentBRDFTexture = mA(this.getScene())
		}
		set usePhysicalLightFalloff(e) {
			e !== this.usePhysicalLightFalloff && (this._markAllSubMeshesAsTexturesDirty(), this._lightFalloff = e ? TA.LIGHTFALLOFF_PHYSICAL : TA.LIGHTFALLOFF_STANDARD)
		}
		get cameraColorGradingTexture() {
			return this._imageProcessingConfiguration.colorGradingTexture
		}
		get cameraToneMappingEnabled() {
			return this._imageProcessingConfiguration.toneMappingEnabled
		}
		set cameraColorCurvesEnabled(e) {
			this.imageProcessingConfiguration.colorCurvesEnabled = e
		}
		get useGLTFLightFalloff() {
			return this._lightFalloff === TA.LIGHTFALLOFF_GLTF
		}
		serialize() {
			const e = super.serialize();
			return e.customType = "BABYLON.PBRMaterial", e
		}
		static Parse(t, i, s) {
			const n = Xc.Parse((() => new e(t.name, i)), t, i, s);
			return t.stencil && n.stencil.parse(t.stencil, i, s), Pf._ParsePlugins(t, n, i, s), t.clearCoat && n.clearCoat.parse(t.clearCoat, i, s), t.anisotropy && n.anisotropy.parse(t.anisotropy, i, s), t.brdf && n.brdf.parse(t.brdf, i, s), t.sheen && n.sheen.parse(t.sheen, i, s), t.subSurface && n.subSurface.parse(t.subSurface, i, s), t.iridescence && n.iridescence.parse(t.iridescence, i, s), n
		}
	};
	wA.PBRMATERIAL_OPAQUE = TA.PBRMATERIAL_OPAQUE, wA.PBRMATERIAL_ALPHATEST = TA.PBRMATERIAL_ALPHATEST, wA.PBRMATERIAL_ALPHABLEND = TA.PBRMATERIAL_ALPHABLEND, wA.PBRMATERIAL_ALPHATESTANDBLEND = TA.PBRMATERIAL_ALPHATESTANDBLEND, wA.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = TA.DEFAULT_AO_ON_ANALYTICAL_LIGHTS, Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "directIntensity", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "emissiveIntensity", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "environmentIntensity", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "specularIntensity", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "disableBumpMap", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "albedoTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "ambientTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "ambientTextureStrength", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "ambientTextureImpactOnAnalyticalLights", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesAndMiscDirty")], wA.prototype, "opacityTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "reflectionTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "emissiveTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "reflectivityTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "metallicTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "metallic", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "roughness", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "metallicF0Factor", void 0), Gh([jh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "metallicReflectanceColor", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "metallicReflectanceTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "reflectanceTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "microSurfaceTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "bumpTexture", void 0), Gh([Yh(), zh("_markAllSubMeshesAsTexturesDirty", null)], wA.prototype, "lightmapTexture", void 0), Gh([jh("ambient"), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "ambientColor", void 0), Gh([jh("albedo"), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "albedoColor", void 0), Gh([jh("reflectivity"), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "reflectivityColor", void 0), Gh([jh("reflection"), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "reflectionColor", void 0), Gh([jh("emissive"), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "emissiveColor", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "microSurface", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useLightmapAsShadowmap", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesAndMiscDirty")], wA.prototype, "useAlphaFromAlbedoTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesAndMiscDirty")], wA.prototype, "forceAlphaTest", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesAndMiscDirty")], wA.prototype, "alphaCutOff", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useSpecularOverAlpha", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useRoughnessFromMetallicTextureAlpha", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useRoughnessFromMetallicTextureGreen", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useMetallnessFromMetallicTextureBlue", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useAmbientInGrayScale", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0), Gh([Xh()], wA.prototype, "usePhysicalLightFalloff", null), Gh([Xh()], wA.prototype, "useGLTFLightFalloff", null), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useRadianceOverAlpha", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useObjectSpaceNormalMap", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useParallax", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useParallaxOcclusion", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "parallaxScaleBias", void 0), Gh([Xh(), zh("_markAllSubMeshesAsLightsDirty")], wA.prototype, "disableLighting", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "forceIrradianceInFragment", void 0), Gh([Xh(), zh("_markAllSubMeshesAsLightsDirty")], wA.prototype, "maxSimultaneousLights", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "invertNormalMapX", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "invertNormalMapY", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "twoSidedLighting", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useAlphaFresnel", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useLinearAlphaFresnel", void 0), Gh([zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "environmentBRDFTexture", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "forceNormalForward", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "enableSpecularAntiAliasing", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useHorizonOcclusion", void 0), Gh([Xh(), zh("_markAllSubMeshesAsTexturesDirty")], wA.prototype, "useRadianceOcclusion", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], wA.prototype, "unlit", void 0), Gh([Xh(), zh("_markAllSubMeshesAsMiscDirty")], wA.prototype, "applyDecalMapAfterDetailMap", void 0), cc("BABYLON.PBRMaterial", wA);
	var RA = class e {
		get hasNormals() {
			return !!this._normals
		}
		get influence() {
			return this._influence
		}
		get animationPropertiesOverride() {
			return !this._animationPropertiesOverride && this._scene ? this._scene.animationPropertiesOverride : this._animationPropertiesOverride
		}
		setNormals(e) {
			const t = this.hasNormals;
			this._normals = e, t !== this.hasNormals && this._onDataLayoutChanged.notifyObservers(void 0)
		}
		static Parse(t, i) {
			const s = new e(t.name, t.influence);
			if (s.setPositions(t.positions), null != t.id && (s.id = t.id), t.normals && s.setNormals(t.normals), t.tangents && s.setTangents(t.tangents), t.uvs && s.setUVs(t.uvs), t.animations) {
				for (let e = 0; e < t.animations.length; e++) {
					const i = t.animations[e],
						n = uc("BABYLON.Animation");
					n && s.animations.push(n.Parse(i))
				}
				t.autoAnimate && i && i.beginAnimation(s, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1)
			}
			return s
		}
		get ik() {
			return this._uniqueId
		}
		get hasPositions() {
			return !!this._positions
		}
		getClassName() {
			return "MorphTarget"
		}
		getUVs() {
			return this._uvs
		}
		serialize() {
			const e = {};
			return e.name = this.name, e.influence = this.influence, e.positions = Array.prototype.slice.call(this.getPositions()), null != this.id && (e.id = this.id), this.hasNormals && (e.normals = Array.prototype.slice.call(this.getNormals())), this.hasTangents && (e.tangents = Array.prototype.slice.call(this.getTangents())), this.hasUVs && (e.uvs = Array.prototype.slice.call(this.getUVs())), Xc.AppendSerializedAnimations(this, e), e
		}
		constructor(e, t = 0, i = null) {
			this.name = e, this.animations = [], this._positions = null, this._normals = null, this._tangents = null, this._uvs = null, this._uniqueId = 0, this.onInfluenceChanged = new kc, this._onDataLayoutChanged = new kc, this._animationPropertiesOverride = null, this._scene = i || Dc.LastCreatedScene, this.influence = t, this._scene && (this._uniqueId = this._scene.getUniqueId())
		}
		get hasTangents() {
			return !!this._tangents
		}
		static FromMesh(t, i, s) {
			i || (i = t.name);
			const n = new e(i, s, t.getScene());
			return n.setPositions(t.getVerticesData(eu.PositionKind)), t.isVerticesDataPresent(eu.NormalKind) && n.setNormals(t.getVerticesData(eu.NormalKind)), t.isVerticesDataPresent(eu.TangentKind) && n.setTangents(t.getVerticesData(eu.TangentKind)), t.isVerticesDataPresent(eu.UVKind) && n.setUVs(t.getVerticesData(eu.UVKind)), n
		}
		setUVs(e) {
			const t = this.hasUVs;
			this._uvs = e, t !== this.hasUVs && this._onDataLayoutChanged.notifyObservers(void 0)
		}
		set influence(e) {
			if (this._influence === e) return;
			const t = this._influence;
			this._influence = e, this.onInfluenceChanged.hasObservers() && this.onInfluenceChanged.notifyObservers(0 === t || 0 === e)
		}
		clone() {
			const t = Xc.Clone((() => new e(this.name, this.influence, this._scene)), this);
			return t._positions = this._positions, t._normals = this._normals, t._tangents = this._tangents, t._uvs = this._uvs, t
		}
		getNormals() {
			return this._normals
		}
		getTangents() {
			return this._tangents
		}
		set animationPropertiesOverride(e) {
			this._animationPropertiesOverride = e
		}
		get hasUVs() {
			return !!this._uvs
		}
		setPositions(e) {
			const t = this.hasPositions;
			this._positions = e, t !== this.hasPositions && this._onDataLayoutChanged.notifyObservers(void 0)
		}
		setTangents(e) {
			const t = this.hasTangents;
			this._tangents = e, t !== this.hasTangents && this._onDataLayoutChanged.notifyObservers(void 0)
		}
		getPositions() {
			return this._positions
		}
	};
	Gh([Xh()], RA.prototype, "id", void 0);
	var NA = class e extends Np {
			get depth() {
				return this._depth
			}
			static CreateRGBATexture(t, i, s, n, a, r = !0, o = !1, l = 3, h = 0) {
				return new e(t, i, s, n, 5, a, r, o, l, h)
			}
			update(e) {
				this._texture && this._getEngine().updateRawTexture2DArray(this._texture, e, this._texture.format, this._texture.invertY, null, this._texture.type)
			}
			constructor(e, t, i, s, n, a, r = !0, o = !1, l = Np.TRILINEAR_SAMPLINGMODE, h = 0, c) {
				super(null, a, !r, o), this.format = n, this._texture = a.getEngine().createRawTexture2DArray(e, t, i, s, n, r, o, l, null, h, c), this._depth = s, this.is2DArray = !0
			}
		},
		IA = class e {
			get numTargets() {
				return this._targets.length
			}
			addTarget(e) {
				this._targets.push(e), this._targetInfluenceChangedObservers.push(e.onInfluenceChanged.add((e => {
					this._syncActiveTargets(e)
				}))), this._targetDataLayoutChangedObservers.push(e._onDataLayoutChanged.add((() => {
					this._syncActiveTargets(!0)
				}))), this._syncActiveTargets(!0)
			}
			get numMaxInfluencers() {
				return this._numMaxInfluencers
			}
			get supportsUVs() {
				return this._supportsUVs && this.enableUVMorphing
			}
			get areUpdatesFrozen() {
				return this._blockCounter > 0
			}
			getActiveTarget(e) {
				return this._activeTargets.data[e]
			}
			constructor(e = null) {
				if (this._targets = new Array, this._targetInfluenceChangedObservers = new Array, this._targetDataLayoutChangedObservers = new Array, this._activeTargets = new pd(16), this._supportsNormals = !1, this._supportsTangents = !1, this._supportsUVs = !1, this._vertexCount = 0, this._uniqueId = 0, this._tempInfluences = new Array, this._canUseTextureForTargets = !1, this._blockCounter = 0, this._textureVertexStride = 0, this._textureWidth = 0, this._textureHeight = 1, this._parentContainer = null, this.optimizeInfluencers = !0, this.enableNormalMorphing = !0, this.enableTangentMorphing = !0, this.enableUVMorphing = !0, this._numMaxInfluencers = 0, this._useTextureToStoreTargets = !0, e || (e = Dc.LastCreatedScene), this._scene = e, this._scene) {
					this._scene.addMorphTargetManager(this), this._uniqueId = this._scene.getUniqueId();
					const e = this._scene.getEngine().getCaps();
					this._canUseTextureForTargets = e.canUseGLVertexID && e.textureFloat && e.maxVertexTextureImageUnits > 0 && e.texture2DArrayMaxLayerCount > 1
				}
			}
			getTarget(e) {
				return this._targets[e]
			}
			removeTarget(e) {
				const t = this._targets.indexOf(e);
				t >= 0 && (this._targets.splice(t, 1), e.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(t, 1)[0]), e._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(t, 1)[0]), this._syncActiveTargets(!0)), this._scene && this._scene.stopAnimation(e)
			}
			_bind(e) {
				e.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight), e.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices), e.setTexture("morphTargets", this._targetStoreTexture), e.setInt("morphTargetCount", this.numInfluencers)
			}
			clone() {
				const t = new e(this._scene);
				for (const e of this._targets) t.addTarget(e.clone());
				return t.enableNormalMorphing = this.enableNormalMorphing, t.enableTangentMorphing = this.enableTangentMorphing, t.enableUVMorphing = this.enableUVMorphing, t
			}
			set numMaxInfluencers(e) {
				this._numMaxInfluencers !== e && (this._numMaxInfluencers = e, this._syncActiveTargets(!0))
			}
			get numInfluencers() {
				return this._activeTargets.length
			}
			getTargetByName(e) {
				for (const t of this._targets)
					if (t.name === e) return t;
				return null
			}
			dispose() {
				if (this._targetStoreTexture && this._targetStoreTexture.dispose(), this._targetStoreTexture = null, this._scene) {
					if (this._scene.removeMorphTargetManager(this), this._parentContainer) {
						const e = this._parentContainer.morphTargetManagers.indexOf(this);
						e > -1 && this._parentContainer.morphTargetManagers.splice(e, 1), this._parentContainer = null
					}
					for (const e of this._targets) this._scene.stopAnimation(e)
				}
			}
			get isUsingTextureForTargets() {
				return e.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !this._scene?.getEngine().getCaps().disableMorphTargetTexture
			}
			get useTextureToStoreTargets() {
				return this._useTextureToStoreTargets
			}
			get ik() {
				return this._uniqueId
			}
			serialize() {
				const e = {};
				e.id = this.ik, e.targets = [];
				for (const t of this._targets) e.targets.push(t.serialize());
				return e
			}
			synchronize() {
				if (this._scene && !this.areUpdatesFrozen) {
					if (this.isUsingTextureForTargets && (this._vertexCount || this.numMaxInfluencers > 0)) {
						this._textureVertexStride = 1, this._supportsNormals && this._textureVertexStride++, this._supportsTangents && this._textureVertexStride++, this._supportsUVs && this._textureVertexStride++, this._textureWidth = this._vertexCount * this._textureVertexStride || 1, this._textureHeight = 1;
						const e = this._scene.getEngine().getCaps().maxTextureSize;
						this._textureWidth > e && (this._textureHeight = Math.ceil(this._textureWidth / e), this._textureWidth = e);
						let t = !0;
						if (this._targetStoreTexture) {
							const e = this._targetStoreTexture.getSize();
							e.width === this._textureWidth && e.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length && (t = !1)
						}
						if (t) {
							this._targetStoreTexture && this._targetStoreTexture.dispose();
							const e = this._targets.length,
								t = new Float32Array(e * this._textureWidth * this._textureHeight * 4);
							let i = 0;
							for (let s = 0; s < e; s++) {
								const e = this._targets[s],
									n = e.getPositions(),
									a = e.getNormals(),
									r = e.getUVs(),
									o = e.getTangents();
								if (!n) return void(0 === s && Qc.Error("Invalid morph target. Target must have positions."));
								i = s * this._textureWidth * this._textureHeight * 4;
								for (let e = 0; e < this._vertexCount; e++) t[i] = n[3 * e], t[i + 1] = n[3 * e + 1], t[i + 2] = n[3 * e + 2], i += 4, this._supportsNormals && a && (t[i] = a[3 * e], t[i + 1] = a[3 * e + 1], t[i + 2] = a[3 * e + 2], i += 4), this._supportsUVs && r && (t[i] = r[2 * e], t[i + 1] = r[2 * e + 1], i += 4), this._supportsTangents && o && (t[i] = o[3 * e], t[i + 1] = o[3 * e + 1], t[i + 2] = o[3 * e + 2], i += 4)
							}
							this._targetStoreTexture = NA.CreateRGBATexture(t, this._textureWidth, this._textureHeight, e, this._scene, !1, !1, 1, 1)
						}
					}
					for (const e of this._scene.meshes) e.morphTargetManager === this && e._syncGeometryWithMorphTargetManager()
				}
			}
			get supportsNormals() {
				return this._supportsNormals && this.enableNormalMorphing
			}
			get influences() {
				return this._influences
			}
			_syncActiveTargets(t) {
				if (this.areUpdatesFrozen) return;
				let i = 0;
				this._activeTargets.reset(), this._supportsNormals = !0, this._supportsTangents = !0, this._supportsUVs = !0, this._vertexCount = 0, this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount && (this.useTextureToStoreTargets = !1), this._morphTargetTextureIndices && this._morphTargetTextureIndices.length === this._targets.length || (this._morphTargetTextureIndices = new Float32Array(this._targets.length));
				let s = -1;
				for (const t of this._targets) {
					if (s++, 0 === t.influence && this.optimizeInfluencers) continue;
					if (this._activeTargets.length >= e.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) break;
					this._activeTargets.push(t), this._morphTargetTextureIndices[i] = s, this._tempInfluences[i++] = t.influence, this._supportsNormals = this._supportsNormals && t.hasNormals, this._supportsTangents = this._supportsTangents && t.hasTangents, this._supportsUVs = this._supportsUVs && t.hasUVs;
					const n = t.getPositions();
					if (n) {
						const e = n.length / 3;
						if (0 === this._vertexCount) this._vertexCount = e;
						else if (this._vertexCount !== e) return void Qc.Error("Incompatible target. Targets must all have the same vertices count.")
					}
				}
				this._morphTargetTextureIndices.length !== i && (this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, i)), this._influences && this._influences.length === i || (this._influences = new Float32Array(i));
				for (let e = 0; e < i; e++) this._influences[e] = this._tempInfluences[e];
				t && this.synchronize()
			}
			set areUpdatesFrozen(e) {
				e ? this._blockCounter++ : (this._blockCounter--, this._blockCounter <= 0 && (this._blockCounter = 0, this._syncActiveTargets(!0)))
			}
			get vertexCount() {
				return this._vertexCount
			}
			static Parse(t, i) {
				const s = new e(i);
				s._uniqueId = t.id;
				for (const e of t.targets) s.addTarget(RA.Parse(e, i));
				return s
			}
			set useTextureToStoreTargets(e) {
				this._useTextureToStoreTargets = e
			}
			get supportsTangents() {
				return this._supportsTangents && this.enableTangentMorphing
			}
		};

	function PA(e, t, i, s) {
		return Lc.FromArray(t, i).scaleInPlace(s)
	}
	IA.EnableTextureStorage = !0, IA.MaxActiveMorphTargetsInVertexAttributeMode = 8;
	var kA = class {
			_buildAnimation(e, t, i) {
				const s = new Wg(e, this.name, t, this.type);
				return s.setKeys(i), s
			}
			constructor(e, t, i, s) {
				this.type = e, this.name = t, this.getValue = i, this.getStride = s
			}
		},
		DA = class extends kA {
			buildAnimations(e, t, i, s, n) {
				n(e._babylonTransformNode, this._buildAnimation(t, i, s))
			}
		},
		OA = {
			translation: [new DA(Wg.ANIMATIONTYPE_VECTOR3, "position", PA, (() => 3))],
			rotation: [new DA(Wg.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", (function(e, t, i, s) {
				return Gc.FromArray(t, i).scaleInPlace(s)
			}), (() => 4))],
			scale: [new DA(Wg.ANIMATIONTYPE_VECTOR3, "scaling", PA, (() => 3))],
			weights: [new class extends kA {
				buildAnimations(e, t, i, s, n) {
					if (e._numMorphTargets)
						for (let a = 0; a < e._numMorphTargets; a++) {
							const r = new Wg(`${t}_${a}`, this.name, i, this.type);
							if (r.setKeys(s.map((e => ({
									frame: e.frame,
									inTangent: e.inTangent ? e.inTangent[a] : void 0,
									value: e.value[a],
									outTangent: e.outTangent ? e.outTangent[a] : void 0,
									interpolation: e.interpolation
								})))), e._primitiveBabylonMeshes)
								for (const t of e._primitiveBabylonMeshes)
									if (t.morphTargetManager) {
										const e = t.morphTargetManager.getTarget(a),
											i = r.clone();
										e.animations.push(i), n(e, i)
									}
						}
				}
			}(Wg.ANIMATIONTYPE_FLOAT, "influence", (function(e, t, i, s) {
				const n = new Array(e._numMorphTargets);
				for (let e = 0; e < n.length; e++) n[e] = t[i++] * s;
				return n
			}), (e => e._numMorphTargets))]
		};

	function FA(...e) {
		const t = e => e && "object" == typeof e;
		return e.reduce(((e, i) => (Object.keys(i).forEach((s => {
			const n = e[s],
				a = i[s];
			Array.isArray(n) && Array.isArray(a) ? e[s] = n.concat(...a) : t(n) && t(a) ? e[s] = FA(n, a) : e[s] = a
		})), e)), {})
	}
	var LA = class {
			static TryGet(e, t) {
				return e && null != t && e[t] ? e[t] : null
			}
			static Assign(e) {
				if (e)
					for (let t = 0; t < e.length; t++) e[t].index = t
			}
			static Get(e, t, i) {
				if (!t || null == i || !t[i]) throw new Error(`${e}: Failed to find index (${i})`);
				return t[i]
			}
		},
		BA = class e {
			_loadSampler(t, i) {
				return i._data || (i._data = {
					noMipMaps: 9728 === i.minFilter || 9729 === i.minFilter,
					samplingMode: e._GetTextureSamplingMode(t, i),
					wrapU: e._GetTextureWrapMode(`${t}/wrapS`, i.wrapS),
					wrapV: e._GetTextureWrapMode(`${t}/wrapT`, i.wrapT)
				}), i._data
			}
			_loadAnimationChannelAsync(e, t, i, s, n) {
				const a = this._extensionsLoadAnimationChannelAsync(e, t, i, s, n);
				if (a) return a;
				if (null == s.target.node) return Promise.resolve();
				const r = LA.Get(`${e}/target/node`, this._gltf.nodes, s.target.node),
					o = s.target.path,
					l = "weights" === o;
				if (l && !r._numMorphTargets || !l && !r._babylonTransformNode) return Promise.resolve();
				if (!this._parent.loadNodeAnimations && !l && !r._isJoint) return Promise.resolve();
				let h;
				switch (o) {
					case "translation":
						h = OA.translation;
						break;
					case "rotation":
						h = OA.rotation;
						break;
					case "scale":
						h = OA.scale;
						break;
					case "weights":
						h = OA.weights;
						break;
					default:
						throw new Error(`${e}/target/path: Invalid value (${s.target.path})`)
				}
				const c = {
					object: r,
					info: h
				};
				return this._loadAnimationChannelFromTargetInfoAsync(e, t, i, s, c, n)
			}
			_extensionsLoadSceneAsync(e, t) {
				return this._applyExtensions(t, "loadScene", (i => i.loadSceneAsync && i.loadSceneAsync(e, t)))
			}
			_setupData() {
				if (LA.Assign(this._gltf.accessors), LA.Assign(this._gltf.animations), LA.Assign(this._gltf.buffers), LA.Assign(this._gltf.bufferViews), LA.Assign(this._gltf.cameras), LA.Assign(this._gltf.images), LA.Assign(this._gltf.materials), LA.Assign(this._gltf.meshes), LA.Assign(this._gltf.nodes), LA.Assign(this._gltf.samplers), LA.Assign(this._gltf.scenes), LA.Assign(this._gltf.skins), LA.Assign(this._gltf.textures), this._gltf.nodes) {
					const e = {};
					for (const t of this._gltf.nodes)
						if (t.children)
							for (const i of t.children) e[i] = t.index;
					const t = this._createRootNode();
					for (const i of this._gltf.nodes) {
						const s = e[i.index];
						i.parent = void 0 === s ? t : this._gltf.nodes[s]
					}
				}
			}
			_forEachExtensions(e) {
				for (const t of this._extensions) t.enabled && e(t)
			}
			_extensionsLoadBufferAsync(e, t, i, s) {
				return this._applyExtensions(t, "loadBuffer", (n => n.loadBufferAsync && n.loadBufferAsync(e, t, i, s)))
			}
			static LoadExtensionAsync(e, t, i, s) {
				if (!t.extensions) return null;
				const n = t.extensions[i];
				return n ? s(`${e}/extensions/${i}`, n) : null
			}
			static _GetDrawMode(e, t) {
				switch (null == t && (t = 4), t) {
					case 0:
						return Pf.PointListDrawMode;
					case 1:
						return Pf.LineListDrawMode;
					case 2:
						return Pf.LineLoopDrawMode;
					case 3:
						return Pf.LineStripDrawMode;
					case 4:
						return Pf.TriangleFillMode;
					case 5:
						return Pf.TriangleStripDrawMode;
					case 6:
						return Pf.TriangleFanDrawMode
				}
				throw new Error(`${e}: Invalid mesh primitive mode (${t})`)
			}
			_loadVertexBufferViewAsync(e) {
				if (e._babylonBuffer) return e._babylonBuffer;
				const t = this._babylonScene.getEngine();
				return e._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${e.index}`, e).then((e => new Zc(t, e, !1))), e._babylonBuffer
			}
			_forEachPrimitive(e, t) {
				if (e._primitiveBabylonMeshes)
					for (const i of e._primitiveBabylonMeshes) t(i)
			}
			loadTextureInfoAsync(t, i, s = () => {}) {
				const n = this._extensionsLoadTextureInfoAsync(t, i, s);
				if (n) return n;
				if (this.logOpen(`${t}`), i.texCoord >= 6) throw new Error(`${t}/texCoord: Invalid value (${i.texCoord})`);
				const a = LA.Get(`${t}/index`, this._gltf.textures, i.index);
				a._textureInfo = i;
				const r = this._loadTextureAsync(`/textures/${i.index}`, a, (n => {
					n.coordinatesIndex = i.texCoord || 0, e.AddPointerMetadata(n, t), this._parent.onTextureLoadedObservable.notifyObservers(n), s(n)
				}));
				return this.logClose(), r
			}
			get babylonScene() {
				if (!this._babylonScene) throw new Error("Scene is not available");
				return this._babylonScene
			}
			_getSkeletons() {
				const e = [],
					t = this._gltf.skins;
				if (t)
					for (const i of t) i._data && e.push(i._data.babylonSkeleton);
				return e
			}
			_extensionsLoadMaterialAsync(e, t, i, s, n) {
				return this._applyExtensions(t, "loadMaterial", (a => a._loadMaterialAsync && a._loadMaterialAsync(e, t, i, s, n)))
			}
			importMeshAsync(e, t, i, s, n, a, r = "") {
				return Promise.resolve().then((() => {
					this._babylonScene = t, this._assetContainer = i, this._loadData(s);
					let a = null;
					if (e) {
						const t = {};
						if (this._gltf.nodes)
							for (const e of this._gltf.nodes) e.name && (t[e.name] = e.index);
						a = (e instanceof Array ? e : [e]).map((e => {
							const i = t[e];
							if (void 0 === i) throw new Error(`Failed to find node '${e}'`);
							return i
						}))
					}
					return this._loadAsync(n, r, a, (() => ({
						meshes: this._getMeshes(),
						particleSystems: [],
						skeletons: this._getSkeletons(),
						animationGroups: this._getAnimationGroups(),
						lights: this._babylonLights,
						transformNodes: this._getTransformNodes(),
						geometries: this._getGeometries(),
						spriteManagers: []
					})))
				}))
			}
			_loadMaterialAsync(t, i, s, n, a = () => {}) {
				const r = this._extensionsLoadMaterialAsync(t, i, s, n, a);
				if (r) return r;
				i._data = i._data || {};
				let o = i._data[n];
				if (!o) {
					this.logOpen(`${t} ${i.name||""}`);
					const s = this.createMaterial(t, i, n);
					o = {
						babylonMaterial: s,
						babylonMeshes: [],
						promise: this.loadMaterialPropertiesAsync(t, i, s)
					}, i._data[n] = o, e.AddPointerMetadata(s, t), this._parent.onMaterialLoadedObservable.notifyObservers(s), this.logClose()
				}
				return s && (o.babylonMeshes.push(s), s.onDisposeObservable.addOnce((() => {
					const e = o.babylonMeshes.indexOf(s); - 1 !== e && o.babylonMeshes.splice(e, 1)
				}))), a(o.babylonMaterial), o.promise.then((() => o.babylonMaterial))
			}
			loadMaterialBasePropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.emissiveColor = t.emissiveFactor ? Tc.FromArray(t.emissiveFactor) : new Tc(0, 0, 0), t.doubleSided && (i.backFaceCulling = !1, i.twoSidedLighting = !0), t.normalTexture && (t.normalTexture.nonColorData = !0, s.push(this.loadTextureInfoAsync(`${e}/normalTexture`, t.normalTexture, (e => {
					e.name = `${i.name} (Normal)`, i.bumpTexture = e
				}))), i.invertNormalMapX = !this._babylonScene.useRightHandedSystem, i.invertNormalMapY = this._babylonScene.useRightHandedSystem, null != t.normalTexture.scale && i.bumpTexture && (i.bumpTexture.level = t.normalTexture.scale), i.forceIrradianceInFragment = !0), t.occlusionTexture && (t.occlusionTexture.nonColorData = !0, s.push(this.loadTextureInfoAsync(`${e}/occlusionTexture`, t.occlusionTexture, (e => {
					e.name = `${i.name} (Occlusion)`, i.ambientTexture = e
				}))), i.useAmbientInGrayScale = !0, null != t.occlusionTexture.strength && (i.ambientTextureStrength = t.occlusionTexture.strength)), t.emissiveTexture && s.push(this.loadTextureInfoAsync(`${e}/emissiveTexture`, t.emissiveTexture, (e => {
					e.name = `${i.name} (Emissive)`, i.emissiveTexture = e
				}))), Promise.all(s).then((() => {}))
			}
			loadNodeAsync(t, i, s = () => {}) {
				const n = this._extensionsLoadNodeAsync(t, i, s);
				if (n) return n;
				if (i._babylonTransformNode) throw new Error(`${t}: Invalid recursive node hierarchy`);
				const a = new Array;
				this.logOpen(`${t} ${i.name||""}`);
				const r = n => {
						if (e.AddPointerMetadata(n, t), e._LoadTransform(i, n), null != i.camera) {
							const e = LA.Get(`${t}/camera`, this._gltf.cameras, i.camera);
							a.push(this.loadCameraAsync(`/cameras/${e.index}`, e, (e => {
								e.parent = n
							})))
						}
						if (i.children)
							for (const e of i.children) {
								const i = LA.Get(`${t}/children/${e}`, this._gltf.nodes, e);
								a.push(this.loadNodeAsync(`/nodes/${i.index}`, i, (e => {
									e.parent = n
								})))
							}
						s(n)
					},
					o = null != i.mesh,
					l = this._parent.loadSkins && null != i.skin;
				if (!o || l) {
					const e = i.name || `node${i.index}`;
					this._babylonScene._blockEntityCollection = !!this._assetContainer;
					const t = new Jc(e, this._babylonScene);
					t._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, null == i.mesh ? i._babylonTransformNode = t : i._babylonTransformNodeForSkin = t, r(t)
				}
				if (o)
					if (l) {
						const e = LA.Get(`${t}/mesh`, this._gltf.meshes, i.mesh);
						a.push(this._loadMeshAsync(`/meshes/${e.index}`, i, e, (e => {
							const s = i._babylonTransformNodeForSkin;
							e.metadata = FA(s.metadata, e.metadata || {});
							const n = LA.Get(`${t}/skin`, this._gltf.skins, i.skin);
							a.push(this._loadSkinAsync(`/skins/${n.index}`, i, n, (t => {
								this._forEachPrimitive(i, (e => {
									e.skeleton = t
								})), this._postSceneLoadActions.push((() => {
									if (null != n.skeleton) {
										const t = LA.Get(`/skins/${n.index}/skeleton`, this._gltf.nodes, n.skeleton).parent;
										i.index === t.index ? e.parent = s.parent : e.parent = t._babylonTransformNode
									} else e.parent = this._rootBabylonMesh;
									this._parent.onSkinLoadedObservable.notifyObservers({
										node: s,
										skinnedNode: e
									})
								}))
							})))
						})))
					} else {
						const e = LA.Get(`${t}/mesh`, this._gltf.meshes, i.mesh);
						a.push(this._loadMeshAsync(`/meshes/${e.index}`, i, e, r))
					} return this.logClose(), Promise.all(a).then((() => (this._forEachPrimitive(i, (e => {
					e.geometry && e.geometry.useBoundingInfoFromGeometry ? e._updateBoundingInfo() : e.refreshBoundingInfo(!0, !0)
				})), i._babylonTransformNode)))
			}
			static _ValidateUri(e) {
				return dd.IsBase64(e) || -1 === e.indexOf("..")
			}
			_extensionsLoadAnimationChannelAsync(e, t, i, s, n) {
				return this._applyExtensions(i, "loadAnimationChannel", (a => a._loadAnimationChannelAsync && a._loadAnimationChannelAsync(e, t, i, s, n)))
			}
			logClose() {
				this._parent._logClose()
			}
			static _GetTextureWrapMode(e, t) {
				switch (t = null == t ? 10497 : t) {
					case 33071:
						return Np.CLAMP_ADDRESSMODE;
					case 33648:
						return Np.MIRROR_ADDRESSMODE;
					case 10497:
						return Np.WRAP_ADDRESSMODE;
					default:
						return Qc.Warn(`${e}: Invalid value (${t})`), Np.WRAP_ADDRESSMODE
				}
			}
			static UnregisterExtension(t) {
				return !!e._RegisteredExtensions[t] && (delete e._RegisteredExtensions[t], !0)
			}
			_createTextureAsync(e, t, i, s = () => {}, n, a) {
				const r = this._loadSampler(`/samplers/${t.index}`, t),
					o = new Array,
					l = new oA;
				this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const h = {
						noMipmap: r.noMipMaps,
						invertY: !1,
						samplingMode: r.samplingMode,
						onLoad: () => {
							this._disposed || l.resolve()
						},
						onError: (t, i) => {
							this._disposed || l.reject(new Error(`${e}: ${i&&i.message?i.message:t||"Failed to load texture"}`))
						},
						mimeType: i.mimeType,
						loaderOptions: n,
						useSRGBBuffer: !!a && this._parent.useSRGBBuffers
					},
					c = new Np(null, this._babylonScene, h);
				return c._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, o.push(l.promise), o.push(this.loadImageAsync(`/images/${i.index}`, i).then((e => {
					const t = i.uri || `${this._fileName}#image${i.index}`,
						s = `data:${this._uniqueRootUrl}${t}`;
					c.updateURL(s, e)
				}))), c.wrapU = r.wrapU, c.wrapV = r.wrapV, s(c), Promise.all(o).then((() => c))
			}
			loadAnimationAsync(e, t) {
				const i = this._extensionsLoadAnimationAsync(e, t);
				if (i) return i;
				this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const s = new hA(t.name || `animation${t.index}`, this._babylonScene);
				s._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, t._babylonAnimationGroup = s;
				const n = new Array;
				LA.Assign(t.channels), LA.Assign(t.samplers);
				for (const i of t.channels) n.push(this._loadAnimationChannelAsync(`${e}/channels/${i.index}`, e, t, i, ((e, t) => {
					e.animations = e.animations || [], e.animations.push(t), s.addTargetedAnimation(t, e)
				})));
				return Promise.all(n).then((() => (s.normalize(0), s)))
			}
			startPerformanceCounter(e) {
				this._parent._startPerformanceCounter(e)
			}
			log(e) {
				this._parent._log(e)
			}
			_loadMaterialMetallicRoughnessPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return t && (t.baseColorFactor ? (i.albedoColor = Tc.FromArray(t.baseColorFactor), i.alpha = t.baseColorFactor[3]) : i.albedoColor = Tc.White(), i.metallic = null == t.metallicFactor ? 1 : t.metallicFactor, i.roughness = null == t.roughnessFactor ? 1 : t.roughnessFactor, t.baseColorTexture && s.push(this.loadTextureInfoAsync(`${e}/baseColorTexture`, t.baseColorTexture, (e => {
					e.name = `${i.name} (Base Color)`, i.albedoTexture = e
				}))), t.metallicRoughnessTexture && (t.metallicRoughnessTexture.nonColorData = !0, s.push(this.loadTextureInfoAsync(`${e}/metallicRoughnessTexture`, t.metallicRoughnessTexture, (e => {
					e.name = `${i.name} (Metallic Roughness)`, i.metallicTexture = e
				}))), i.useMetallnessFromMetallicTextureBlue = !0, i.useRoughnessFromMetallicTextureGreen = !0, i.useRoughnessFromMetallicTextureAlpha = !1)), Promise.all(s).then((() => {}))
			}
			loadImageAsync(e, t) {
				if (!t._data) {
					if (this.logOpen(`${e} ${t.name||""}`), t.uri) t._data = this.loadUriAsync(`${e}/uri`, t, t.uri);
					else {
						const i = LA.Get(`${e}/bufferView`, this._gltf.bufferViews, t.bufferView);
						t._data = this.loadBufferViewAsync(`/bufferViews/${i.index}`, i)
					}
					this.logClose()
				}
				return t._data
			}
			_extensionsLoadMeshPrimitiveAsync(e, t, i, s, n, a) {
				return this._applyExtensions(n, "loadMeshPrimitive", (r => r._loadMeshPrimitiveAsync && r._loadMeshPrimitiveAsync(e, t, i, s, n, a)))
			}
			_loadIndicesAccessorAsync(t, i) {
				if ("SCALAR" !== i.type) throw new Error(`${t}/type: Invalid value ${i.type}`);
				if (5121 !== i.componentType && 5123 !== i.componentType && 5125 !== i.componentType) throw new Error(`${t}/componentType: Invalid value ${i.componentType}`);
				if (i._data) return i._data;
				if (i.sparse) {
					const s = e._GetTypedArrayConstructor(`${t}/componentType`, i.componentType);
					i._data = this._loadAccessorAsync(t, i, s)
				} else {
					const s = LA.Get(`${t}/bufferView`, this._gltf.bufferViews, i.bufferView);
					i._data = this.loadBufferViewAsync(`/bufferViews/${s.index}`, s).then((s => e._GetTypedArray(t, i.componentType, s, i.byteOffset, i.count)))
				}
				return i._data
			}
			loadSceneAsync(e, t) {
				const i = this._extensionsLoadSceneAsync(e, t);
				if (i) return i;
				const s = new Array;
				if (this.logOpen(`${e} ${t.name||""}`), t.nodes)
					for (const i of t.nodes) {
						const t = LA.Get(`${e}/nodes/${i}`, this._gltf.nodes, i);
						s.push(this.loadNodeAsync(`/nodes/${t.index}`, t, (e => {
							e.parent = this._rootBabylonMesh
						})))
					}
				for (const e of this._postSceneLoadActions) e();
				return s.push(this._loadAnimationsAsync()), this.logClose(), Promise.all(s).then((() => {}))
			}
			_compileShadowGeneratorsAsync() {
				this._parent._startPerformanceCounter("Compile shadow generators");
				const e = new Array,
					t = this._babylonScene.lights;
				for (const i of t) {
					const t = i.getShadowGenerator();
					t && e.push(t.forceCompilationAsync())
				}
				return Promise.all(e).then((() => {
					this._parent._endPerformanceCounter("Compile shadow generators")
				}))
			}
			_loadSkinInverseBindMatricesDataAsync(e, t) {
				if (null == t.inverseBindMatrices) return Promise.resolve(null);
				const i = LA.Get(`${e}/inverseBindMatrices`, this._gltf.accessors, t.inverseBindMatrices);
				return this._loadFloatAccessorAsync(`/accessors/${i.index}`, i)
			}
			_loadAsync(e, t, i, s) {
				return Promise.resolve().then((() => {
					this._rootUrl = e, this._uniqueRootUrl = !e.startsWith("file:") && t ? e : `${e}${Date.now()}/`, this._fileName = t, this._allMaterialsDirtyRequired = !1, this._loadExtensions(), this._checkExtensions();
					const n = `${hE[hE.LOADING]} => ${hE[hE.READY]}`,
						a = `${hE[hE.LOADING]} => ${hE[hE.COMPLETE]}`;
					this._parent._startPerformanceCounter(n), this._parent._startPerformanceCounter(a), this._parent._setState(hE.LOADING), this._extensionsOnLoading();
					const r = new Array,
						o = this._babylonScene.blockMaterialDirtyMechanism;
					if (this._babylonScene.blockMaterialDirtyMechanism = !0, !this.parent.loadOnlyMaterials)
						if (i) r.push(this.loadSceneAsync("/nodes", {
							nodes: i,
							index: -1
						}));
						else if (null != this._gltf.scene || this._gltf.scenes && this._gltf.scenes[0]) {
						const e = LA.Get("/scene", this._gltf.scenes, this._gltf.scene || 0);
						r.push(this.loadSceneAsync(`/scenes/${e.index}`, e))
					}
					if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials)
						for (let e = 0; e < this._gltf.materials.length; ++e) {
							const t = this._gltf.materials[e],
								i = "/materials/" + e,
								s = Pf.TriangleFillMode;
							r.push(this._loadMaterialAsync(i, t, null, s, (() => {})))
						}
					this._allMaterialsDirtyRequired ? this._babylonScene.blockMaterialDirtyMechanism = o : this._babylonScene._forceBlockMaterialDirtyMechanism(o), this._parent.compileMaterials && r.push(this._compileMaterialsAsync()), this._parent.compileShadowGenerators && r.push(this._compileShadowGeneratorsAsync());
					return Promise.all(r).then((() => (this._rootBabylonMesh && this._rootBabylonMesh !== this._parent.customRootNode && this._rootBabylonMesh.setEnabled(!0), this._extensionsOnReady(), this._parent._setState(hE.READY), this._startAnimations(), s()))).then((e => (this._parent._endPerformanceCounter(n), dd.SetImmediate((() => {
						this._disposed || Promise.all(this._completePromises).then((() => {
							this._parent._endPerformanceCounter(a), this._parent._setState(hE.COMPLETE), this._parent.onCompleteObservable.notifyObservers(void 0), this._parent.onCompleteObservable.clear(), this.dispose()
						}), (e => {
							this._parent.onErrorObservable.notifyObservers(e), this._parent.onErrorObservable.clear(), this.dispose()
						}))
					})), e)))
				})).catch((e => {
					throw this._disposed || (this._parent.onErrorObservable.notifyObservers(e), this._parent.onErrorObservable.clear(), this.dispose()), e
				}))
			}
			_extensionsOnReady() {
				this._forEachExtensions((e => e.onReady && e.onReady()))
			}
			static _LoadTransform(e, t) {
				if (null != e.skin) return;
				let i = Lc.Zero(),
					s = Gc.Identity(),
					n = Lc.One();
				if (e.matrix) {
					Hc.FromArray(e.matrix).decompose(n, s, i)
				} else e.translation && (i = Lc.FromArray(e.translation)), e.rotation && (s = Gc.FromArray(e.rotation)), e.scale && (n = Lc.FromArray(e.scale));
				t.position = i, t.rotationQuaternion = s, t.scaling = n
			}
			static LoadExtraAsync(e, t, i, s) {
				if (!t.extras) return null;
				const n = t.extras[i];
				return n ? s(`${e}/extras/${i}`, n) : null
			}
			_getGeometries() {
				const e = [],
					t = this._gltf.nodes;
				if (t)
					for (const i of t) this._forEachPrimitive(i, (t => {
						const i = t.geometry;
						i && -1 === e.indexOf(i) && e.push(i)
					}));
				return e
			}
			_extensionsLoadNodeAsync(e, t, i) {
				return this._applyExtensions(t, "loadNode", (s => s.loadNodeAsync && s.loadNodeAsync(e, t, i)))
			}
			_loadVertexAccessorAsync(t, i, s) {
				if (i._babylonVertexBuffer?.[s]) return i._babylonVertexBuffer[s];
				i._babylonVertexBuffer || (i._babylonVertexBuffer = {});
				const n = this._babylonScene.getEngine();
				if (i.sparse || null == i.bufferView) i._babylonVertexBuffer[s] = this._loadFloatAccessorAsync(t, i).then((e => new eu(n, e, s, !1)));
				else {
					const a = LA.Get(`${t}/bufferView`, this._gltf.bufferViews, i.bufferView);
					i._babylonVertexBuffer[s] = this._loadVertexBufferViewAsync(a).then((r => {
						const o = e._GetNumComponents(t, i.type);
						return new eu(n, r, s, !1, void 0, a.byteStride, void 0, i.byteOffset, o, i.componentType, i.normalized, !0, void 0, !0)
					}))
				}
				return i._babylonVertexBuffer[s]
			}
			loadUriAsync(t, i, s) {
				const n = this._extensionsLoadUriAsync(t, i, s);
				if (n) return n;
				if (!e._ValidateUri(s)) throw new Error(`${t}: '${s}' is invalid`);
				if (Ym(s)) {
					const e = new Uint8Array(Km(s));
					return this.log(`${t}: Decoded ${s.substr(0,64)}... (${e.length} bytes)`), Promise.resolve(e)
				}
				return this.log(`${t}: Loading ${s}`), this._parent.preprocessUrlAsync(this._rootUrl + s).then((e => new Promise(((i, n) => {
					this._parent._loadFile(this._babylonScene, e, (e => {
						this._disposed || (this.log(`${t}: Loaded ${s} (${e.byteLength} bytes)`), i(new Uint8Array(e)))
					}), !0, (e => {
						n(new Fm(`${t}: Failed to load '${s}'${e?": "+e.status+" "+e.statusText:""}`, e))
					}))
				}))))
			}
			dispose() {
				this._disposed || (this._disposed = !0, this._completePromises.length = 0, this._extensions.forEach((e => e.dispose && e.dispose())), this._extensions.length = 0, this._gltf = null, this._bin = null, this._babylonScene = null, this._rootBabylonMesh = null, this._defaultBabylonMaterialData = {}, this._postSceneLoadActions.length = 0, this._parent.dispose())
			}
			_getNodeMatrix(e) {
				return e.matrix ? Hc.FromArray(e.matrix) : Hc.Compose(e.scale ? Lc.FromArray(e.scale) : Lc.One(), e.rotation ? Gc.FromArray(e.rotation) : Gc.Identity(), e.translation ? Lc.FromArray(e.translation) : Lc.Zero())
			}
			_loadAnimationsAsync() {
				const e = this._gltf.animations;
				if (!e) return Promise.resolve();
				const t = new Array;
				for (let i = 0; i < e.length; i++) {
					const s = e[i];
					t.push(this.loadAnimationAsync(`/animations/${s.index}`, s).then((e => {
						0 === e.targetedAnimations.length && e.dispose()
					})))
				}
				return Promise.all(t).then((() => {}))
			}
			static _GetTypedArray(t, i, s, n, a) {
				const r = s.buffer;
				n = s.byteOffset + (n || 0);
				const o = e._GetTypedArrayConstructor(`${t}/componentType`, i),
					l = eu.GetTypeByteLength(i);
				return n % l != 0 ? (Qc.Warn(`${t}: Copying buffer as byte offset (${n}) is not a multiple of component type byte length (${l})`), new o(r.slice(n, n + a * l), 0)) : new o(r, n, a)
			}
			_extensionsLoadTextureAsync(e, t, i) {
				return this._applyExtensions(t, "loadTexture", (s => s._loadTextureAsync && s._loadTextureAsync(e, t, i)))
			}
			get rootUrl() {
				return this._rootUrl
			}
			_createRootNode() {
				if (void 0 !== this._parent.customRootNode) return this._rootBabylonMesh = this._parent.customRootNode, {
					_babylonTransformNode: null === this._rootBabylonMesh ? void 0 : this._rootBabylonMesh,
					index: -1
				};
				this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const t = new Vf("__root__", this._babylonScene);
				this._rootBabylonMesh = t, this._rootBabylonMesh._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, this._rootBabylonMesh.setEnabled(!1);
				const i = {
					_babylonTransformNode: this._rootBabylonMesh,
					index: -1
				};
				switch (this._parent.coordinateSystemMode) {
					case aE.AUTO:
						this._babylonScene.useRightHandedSystem || (i.rotation = [0, 1, 0, 0], i.scale = [1, 1, -1], e._LoadTransform(i, this._rootBabylonMesh));
						break;
					case aE.FORCE_RIGHT_HANDED:
						this._babylonScene.useRightHandedSystem = !0;
						break;
					default:
						throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`)
				}
				return this._parent.onMeshLoadedObservable.notifyObservers(t), i
			}
			get bin() {
				return this._bin
			}
			_extensionsLoadBufferViewAsync(e, t) {
				return this._applyExtensions(t, "loadBufferView", (i => i.loadBufferViewAsync && i.loadBufferViewAsync(e, t)))
			}
			constructor(e) {
				this._completePromises = new Array, this._assetContainer = null, this._babylonLights = [], this._disableInstancedMesh = 0, this._allMaterialsDirtyRequired = !1, this._extensions = new Array, this._disposed = !1, this._rootUrl = null, this._fileName = null, this._uniqueRootUrl = null, this._bin = null, this._rootBabylonMesh = null, this._defaultBabylonMaterialData = {}, this._postSceneLoadActions = new Array, this._parent = e
			}
			_loadMorphTargetVertexDataAsync(e, t, i, s) {
				const n = new Array,
					a = (s, a, r) => {
						if (null == i[s]) return;
						const o = t.getVertexBuffer(a);
						if (!o) return;
						const l = LA.Get(`${e}/${s}`, this._gltf.accessors, i[s]);
						n.push(this._loadFloatAccessorAsync(`/accessors/${l.index}`, l).then((e => {
							r(o, e)
						})))
					};
				return a("POSITION", eu.PositionKind, ((e, t) => {
					const i = new Float32Array(t.length);
					e.forEach(t.length, ((e, s) => {
						i[s] = t[s] + e
					})), s.setPositions(i)
				})), a("NORMAL", eu.NormalKind, ((e, t) => {
					const i = new Float32Array(t.length);
					e.forEach(i.length, ((e, s) => {
						i[s] = t[s] + e
					})), s.setNormals(i)
				})), a("TANGENT", eu.TangentKind, ((e, t) => {
					const i = new Float32Array(t.length / 3 * 4);
					let n = 0;
					e.forEach(t.length / 3 * 4, ((e, s) => {
						(s + 1) % 4 != 0 && (i[n] = t[n] + e, n++)
					})), s.setTangents(i)
				})), Promise.all(n).then((() => {}))
			}
			loadMaterialPropertiesAsync(e, t, i) {
				const s = this._extensionsLoadMaterialPropertiesAsync(e, t, i);
				if (s) return s;
				const n = new Array;
				return n.push(this.loadMaterialBasePropertiesAsync(e, t, i)), t.pbrMetallicRoughness && n.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${e}/pbrMetallicRoughness`, t.pbrMetallicRoughness, i)), this.loadMaterialAlphaProperties(e, t, i), Promise.all(n).then((() => {}))
			}
			_loadMeshAsync(e, t, i, s) {
				const n = i.primitives;
				if (!n || !n.length) throw new Error(`${e}: Primitives are missing`);
				null == n[0].index && LA.Assign(n);
				const a = new Array;
				this.logOpen(`${e} ${i.name||""}`);
				const r = t.name || `node${t.index}`;
				if (1 === n.length) {
					const s = i.primitives[0];
					a.push(this._loadMeshPrimitiveAsync(`${e}/primitives/${s.index}`, r, t, i, s, (e => {
						t._babylonTransformNode = e, t._primitiveBabylonMeshes = [e]
					})))
				} else {
					this._babylonScene._blockEntityCollection = !!this._assetContainer, t._babylonTransformNode = new Jc(r, this._babylonScene), t._babylonTransformNode._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, t._primitiveBabylonMeshes = [];
					for (const s of n) a.push(this._loadMeshPrimitiveAsync(`${e}/primitives/${s.index}`, `${r}_primitive${s.index}`, t, i, s, (e => {
						e.parent = t._babylonTransformNode, t._primitiveBabylonMeshes.push(e)
					})))
				}
				return s(t._babylonTransformNode), this.logClose(), Promise.all(a).then((() => t._babylonTransformNode))
			}
			isExtensionUsed(e) {
				return !!this._gltf.extensionsUsed && -1 !== this._gltf.extensionsUsed.indexOf(e)
			}
			get gltf() {
				if (!this._gltf) throw new Error("glTF JSON is not available");
				return this._gltf
			}
			static _GetTypedArrayConstructor(e, t) {
				switch (t) {
					case 5120:
						return Int8Array;
					case 5121:
						return Uint8Array;
					case 5122:
						return Int16Array;
					case 5123:
						return Uint16Array;
					case 5125:
						return Uint32Array;
					case 5126:
						return Float32Array;
					default:
						throw new Error(`${e}: Invalid component type ${t}`)
				}
			}
			loadBufferViewAsync(e, t) {
				const i = this._extensionsLoadBufferViewAsync(e, t);
				if (i) return i;
				if (t._data) return t._data;
				const s = LA.Get(`${e}/buffer`, this._gltf.buffers, t.buffer);
				return t._data = this.loadBufferAsync(`/buffers/${s.index}`, s, t.byteOffset || 0, t.byteLength), t._data
			}
			_extensionsCreateMaterial(e, t, i) {
				return this._applyExtensions(t, "createMaterial", (s => s.createMaterial && s.createMaterial(e, t, i)))
			}
			_extensionsLoadMaterialPropertiesAsync(e, t, i) {
				return this._applyExtensions(t, "loadMaterialProperties", (s => s.loadMaterialPropertiesAsync && s.loadMaterialPropertiesAsync(e, t, i)))
			}
			loadMaterialAlphaProperties(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				switch (t.alphaMode || "OPAQUE") {
					case "OPAQUE":
						i.transparencyMode = wA.PBRMATERIAL_OPAQUE, i.alpha = 1;
						break;
					case "MASK":
						i.transparencyMode = wA.PBRMATERIAL_ALPHATEST, i.alphaCutOff = null == t.alphaCutoff ? .5 : t.alphaCutoff, i.albedoTexture && (i.albedoTexture.hasAlpha = !0);
						break;
					case "BLEND":
						i.transparencyMode = wA.PBRMATERIAL_ALPHABLEND, i.albedoTexture && (i.albedoTexture.hasAlpha = !0, i.useAlphaFromAlbedoTexture = !0);
						break;
					default:
						throw new Error(`${e}/alphaMode: Invalid value (${t.alphaMode})`)
				}
			}
			_loadTextureAsync(t, i, s = () => {}) {
				const n = this._extensionsLoadTextureAsync(t, i, s);
				if (n) return n;
				this.logOpen(`${t} ${i.name||""}`);
				const a = null == i.sampler ? e.DefaultSampler : LA.Get(`${t}/sampler`, this._gltf.samplers, i.sampler),
					r = LA.Get(`${t}/source`, this._gltf.images, i.source),
					o = this._createTextureAsync(t, a, r, s, void 0, !i._textureInfo.nonColorData);
				return this.logClose(), o
			}
			static _GetNumComponents(e, t) {
				switch (t) {
					case "SCALAR":
						return 1;
					case "VEC2":
						return 2;
					case "VEC3":
						return 3;
					case "VEC4":
					case "MAT2":
						return 4;
					case "MAT3":
						return 9;
					case "MAT4":
						return 16
				}
				throw new Error(`${e}: Invalid type (${t})`)
			}
			_extensionsLoadTextureInfoAsync(e, t, i) {
				return this._applyExtensions(t, "loadTextureInfo", (s => s.loadTextureInfoAsync && s.loadTextureInfoAsync(e, t, i)))
			}
			_loadVertexDataAsync(e, t, i) {
				const s = this._extensionsLoadVertexDataAsync(e, t, i);
				if (s) return s;
				const n = t.attributes;
				if (!n) throw new Error(`${e}: Attributes are missing`);
				const a = new Array,
					r = new bd(i.name, this._babylonScene);
				if (null == t.indices) i.isUnIndexed = !0;
				else {
					const i = LA.Get(`${e}/indices`, this._gltf.accessors, t.indices);
					a.push(this._loadIndicesAccessorAsync(`/accessors/${i.index}`, i).then((e => {
						r.setIndices(e)
					})))
				}
				const o = (t, s, o) => {
					if (null == n[t]) return;
					i._delayInfo = i._delayInfo || [], -1 === i._delayInfo.indexOf(s) && i._delayInfo.push(s);
					const l = LA.Get(`${e}/attributes/${t}`, this._gltf.accessors, n[t]);
					a.push(this._loadVertexAccessorAsync(`/accessors/${l.index}`, l, s).then((e => {
						if (e.getKind() === eu.PositionKind && !this.parent.alwaysComputeBoundingBox && !i.skeleton && l.min && l.max) {
							const e = Vc.Vector3[0].copyFromFloats(...l.min),
								t = Vc.Vector3[1].copyFromFloats(...l.max);
							if (l.normalized && 5126 !== l.componentType) {
								let i = 1;
								switch (l.componentType) {
									case 5120:
										i = 127;
										break;
									case 5121:
										i = 255;
										break;
									case 5122:
										i = 32767;
										break;
									case 5123:
										i = 65535
								}
								const s = 1 / i;
								e.scaleInPlace(s), t.scaleInPlace(s)
							}
							r._boundingInfo = new yu(e, t), r.useBoundingInfoFromGeometry = !0
						}
						r.setVerticesBuffer(e, l.count)
					}))), s == eu.MatricesIndicesExtraKind && (i.numBoneInfluencers = 8), o && o(l)
				};
				return o("POSITION", eu.PositionKind), o("NORMAL", eu.NormalKind), o("TANGENT", eu.TangentKind), o("TEXCOORD_0", eu.UVKind), o("TEXCOORD_1", eu.UV2Kind), o("TEXCOORD_2", eu.UV3Kind), o("TEXCOORD_3", eu.UV4Kind), o("TEXCOORD_4", eu.UV5Kind), o("TEXCOORD_5", eu.UV6Kind), o("JOINTS_0", eu.MatricesIndicesKind), o("WEIGHTS_0", eu.MatricesWeightsKind), o("JOINTS_1", eu.MatricesIndicesExtraKind), o("WEIGHTS_1", eu.MatricesWeightsExtraKind), o("COLOR_0", eu.ColorKind, (e => {
					"VEC4" === e.type && (i.hasVertexAlpha = !0)
				})), Promise.all(a).then((() => r))
			}
			_createMorphTargets(e, t, i, s, n) {
				if (!s.targets || !this._parent.loadMorphTargets) return;
				if (null == t._numMorphTargets) t._numMorphTargets = s.targets.length;
				else if (s.targets.length !== t._numMorphTargets) throw new Error(`${e}: Primitives do not have the same number of targets`);
				const a = i.extras ? i.extras.targetNames : null;
				this._babylonScene._blockEntityCollection = !!this._assetContainer, n.morphTargetManager = new IA(this._babylonScene), n.morphTargetManager._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, n.morphTargetManager.areUpdatesFrozen = !0;
				for (let e = 0; e < s.targets.length; e++) {
					const s = t.weights ? t.weights[e] : i.weights ? i.weights[e] : 0,
						r = a ? a[e] : `morphTarget${e}`;
					n.morphTargetManager.addTarget(new RA(r, s, n.getScene()))
				}
			}
			get parent() {
				return this._parent
			}
			static RegisterExtension(t, i) {
				e.UnregisterExtension(t) && Qc.Warn(`Extension with the name '${t}' already exists`), e._RegisteredExtensions[t] = {
					factory: i
				}
			}
			_extensionsOnLoading() {
				this._forEachExtensions((e => e.onLoading && e.onLoading()))
			}
			_findSkeletonRootNode(e, t) {
				if (0 === t.length) return null;
				const i = {};
				for (const s of t) {
					const t = [];
					let n = LA.Get(`${e}/${s}`, this._gltf.nodes, s);
					for (; - 1 !== n.index;) t.unshift(n), n = n.parent;
					i[s] = t
				}
				let s = null;
				for (let e = 0;; ++e) {
					let n = i[t[0]];
					if (e >= n.length) return s;
					const a = n[e];
					for (let r = 1; r < t.length; ++r)
						if (n = i[t[r]], e >= n.length || a !== n[e]) return s;
					s = a
				}
			}
			_loadMorphTargetsAsync(e, t, i, s) {
				if (!t.targets || !this._parent.loadMorphTargets) return Promise.resolve();
				const n = new Array,
					a = i.morphTargetManager;
				for (let i = 0; i < a.numTargets; i++) {
					const r = a.getTarget(i);
					n.push(this._loadMorphTargetVertexDataAsync(`${e}/targets/${i}`, s, t.targets[i], r))
				}
				return Promise.all(n).then((() => {
					a.areUpdatesFrozen = !1
				}))
			}
			_loadFloatAccessorAsync(e, t) {
				return this._loadAccessorAsync(e, t, Float32Array)
			}
			_loadAnimationChannelFromTargetInfoAsync(e, t, i, s, n, a) {
				const r = this.parent.targetFps,
					o = 1 / r,
					l = LA.Get(`${e}/sampler`, i.samplers, s.sampler);
				return this._loadAnimationSamplerAsync(`${t}/samplers/${s.sampler}`, l).then((e => {
					let t = 0;
					const l = n.object,
						h = n.info;
					for (const n of h) {
						const h = n.getStride(l),
							c = e.input,
							u = e.output,
							m = new Array(c.length);
						let d = 0;
						switch (e.interpolation) {
							case "STEP":
								for (let e = 0; e < c.length; e++) {
									const t = n.getValue(l, u, d, 1);
									d += h, m[e] = {
										frame: c[e] * r,
										value: t,
										interpolation: 1
									}
								}
								break;
							case "CUBICSPLINE":
								for (let e = 0; e < c.length; e++) {
									const t = n.getValue(l, u, d, o);
									d += h;
									const i = n.getValue(l, u, d, 1);
									d += h;
									const s = n.getValue(l, u, d, o);
									d += h, m[e] = {
										frame: c[e] * r,
										inTangent: t,
										value: i,
										outTangent: s
									}
								}
								break;
							case "LINEAR":
								for (let e = 0; e < c.length; e++) {
									const t = n.getValue(l, u, d, 1);
									d += h, m[e] = {
										frame: c[e] * r,
										value: t
									}
								}
						}
						if (d > 0) {
							const e = `${i.name||`animation${i.index}`}_channel${s.index}_${t}`;
							n.buildAnimations(l, e, r, m, ((e, i) => {
								++t, a(e, i)
							}))
						}
					}
				}))
			}
			_applyExtensions(e, t, i) {
				for (const s of this._extensions)
					if (s.enabled) {
						const n = `${s.name}.${t}`,
							a = e;
						a._activeLoaderExtensionFunctions = a._activeLoaderExtensionFunctions || {};
						const r = a._activeLoaderExtensionFunctions;
						if (!r[n]) {
							r[n] = !0;
							try {
								const e = i(s);
								if (e) return e
							} finally {
								delete r[n]
							}
						}
					} return null
			}
			_startAnimations() {
				switch (this._parent.animationStartMode) {
					case oE.NONE:
						break;
					case oE.FIRST: {
						const e = this._getAnimationGroups();
						0 !== e.length && e[0].start(!0);
						break
					}
					case oE.ALL: {
						const e = this._getAnimationGroups();
						for (const t of e) t.start(!0);
						break
					}
					default:
						return void Qc.Error(`Invalid animation start mode (${this._parent.animationStartMode})`)
				}
			}
			_getTransformNodes() {
				const e = [],
					t = this._gltf.nodes;
				if (t)
					for (const i of t) i._babylonTransformNode && "TransformNode" === i._babylonTransformNode.getClassName() && e.push(i._babylonTransformNode), i._babylonTransformNodeForSkin && e.push(i._babylonTransformNodeForSkin);
				return e
			}
			_updateBoneMatrices(e, t) {
				for (const i of e.bones) {
					const e = Hc.Identity(),
						s = i._index;
					t && -1 !== s && (Hc.FromArrayToRef(t, 16 * s, e), e.invertToRef(e));
					const n = i.getParent();
					n && e.multiplyToRef(n.getAbsoluteInverseBindMatrix(), e), i.updateMatrix(e, !1, !1), i._updateAbsoluteBindMatrices(void 0, !1)
				}
			}
			_extensionsLoadVertexDataAsync(e, t, i) {
				return this._applyExtensions(t, "loadVertexData", (s => s._loadVertexDataAsync && s._loadVertexDataAsync(e, t, i)))
			}
			logOpen(e) {
				this._parent._logOpen(e)
			}
			_loadExtensions() {
				for (const t in e._RegisteredExtensions)
					if (!1 === this.parent.extensionOptions[t]?.enabled) this.isExtensionUsed(t) && Qc.Warn(`Extension ${t} is used but has been explicitly disabled.`);
					else {
						const i = e._RegisteredExtensions[t].factory(this);
						i.name !== t && Qc.Warn(`The name of the glTF loader extension instance does not match the registered name: ${i.name} !== ${t}`), this._extensions.push(i), this._parent.onExtensionLoadedObservable.notifyObservers(i)
					} this._extensions.sort(((e, t) => (e.order || Number.MAX_VALUE) - (t.order || Number.MAX_VALUE))), this._parent.onExtensionLoadedObservable.clear()
			}
			endPerformanceCounter(e) {
				this._parent._endPerformanceCounter(e)
			}
			_extensionsLoadAnimationAsync(e, t) {
				return this._applyExtensions(t, "loadAnimation", (i => i.loadAnimationAsync && i.loadAnimationAsync(e, t)))
			}
			_loadAccessorAsync(t, i, s) {
				if (i._data) return i._data;
				const n = e._GetNumComponents(t, i.type),
					a = n * eu.GetTypeByteLength(i.componentType),
					r = n * i.count;
				if (null == i.bufferView) i._data = Promise.resolve(new s(r));
				else {
					const o = LA.Get(`${t}/bufferView`, this._gltf.bufferViews, i.bufferView);
					i._data = this.loadBufferViewAsync(`/bufferViews/${o.index}`, o).then((l => {
						if (5126 !== i.componentType || i.normalized || o.byteStride && o.byteStride !== a) {
							const e = new s(r);
							return eu.ForEach(l, i.byteOffset || 0, o.byteStride || a, n, i.componentType, e.length, i.normalized || !1, ((t, i) => {
								e[i] = t
							})), e
						}
						return e._GetTypedArray(t, i.componentType, l, i.byteOffset, r)
					}))
				}
				if (i.sparse) {
					const r = i.sparse;
					i._data = i._data.then((o => {
						const l = o,
							h = LA.Get(`${t}/sparse/indices/bufferView`, this._gltf.bufferViews, r.indices.bufferView),
							c = LA.Get(`${t}/sparse/values/bufferView`, this._gltf.bufferViews, r.values.bufferView);
						return Promise.all([this.loadBufferViewAsync(`/bufferViews/${h.index}`, h), this.loadBufferViewAsync(`/bufferViews/${c.index}`, c)]).then((([o, h]) => {
							const c = e._GetTypedArray(`${t}/sparse/indices`, r.indices.componentType, o, r.indices.byteOffset, r.count),
								u = n * r.count;
							let m;
							if (5126 !== i.componentType || i.normalized) {
								const o = e._GetTypedArray(`${t}/sparse/values`, i.componentType, h, r.values.byteOffset, u);
								m = new s(u), eu.ForEach(o, 0, a, n, i.componentType, m.length, i.normalized || !1, ((e, t) => {
									m[t] = e
								}))
							} else m = e._GetTypedArray(`${t}/sparse/values`, i.componentType, h, r.values.byteOffset, u);
							let d = 0;
							for (let e = 0; e < c.length; e++) {
								let t = c[e] * n;
								for (let e = 0; e < n; e++) l[t++] = m[d++]
							}
							return l
						}))
					}))
				}
				return i._data
			}
			get rootBabylonMesh() {
				return this._rootBabylonMesh
			}
			_checkExtensions() {
				if (this._gltf.extensionsRequired)
					for (const e of this._gltf.extensionsRequired) {
						if (!this._extensions.some((t => t.name === e && t.enabled))) {
							if (!1 === this.parent.extensionOptions[e]?.enabled) throw new Error(`Required extension ${e} is disabled`);
							throw new Error(`Required extension ${e} is not available`)
						}
					}
			}
			_getAnimationGroups() {
				const e = [],
					t = this._gltf.animations;
				if (t)
					for (const i of t) i._babylonAnimationGroup && e.push(i._babylonAnimationGroup);
				return e
			}
			createMaterial(e, t, i) {
				const s = this._extensionsCreateMaterial(e, t, i);
				if (s) return s;
				const n = t.name || `material${t.index}`;
				return this._createDefaultMaterial(n, i)
			}
			static _GetTextureSamplingMode(e, t) {
				const i = null == t.magFilter ? 9729 : t.magFilter,
					s = null == t.minFilter ? 9987 : t.minFilter;
				if (9729 === i) switch (s) {
					case 9728:
						return Np.LINEAR_NEAREST;
					case 9729:
						return Np.LINEAR_LINEAR;
					case 9984:
						return Np.LINEAR_NEAREST_MIPNEAREST;
					case 9985:
						return Np.LINEAR_LINEAR_MIPNEAREST;
					case 9986:
						return Np.LINEAR_NEAREST_MIPLINEAR;
					case 9987:
						return Np.LINEAR_LINEAR_MIPLINEAR;
					default:
						return Qc.Warn(`${e}/minFilter: Invalid value (${s})`), Np.LINEAR_LINEAR_MIPLINEAR
				} else switch (9728 !== i && Qc.Warn(`${e}/magFilter: Invalid value (${i})`), s) {
					case 9728:
						return Np.NEAREST_NEAREST;
					case 9729:
						return Np.NEAREST_LINEAR;
					case 9984:
						return Np.NEAREST_NEAREST_MIPNEAREST;
					case 9985:
						return Np.NEAREST_LINEAR_MIPNEAREST;
					case 9986:
						return Np.NEAREST_NEAREST_MIPLINEAR;
					case 9987:
						return Np.NEAREST_LINEAR_MIPLINEAR;
					default:
						return Qc.Warn(`${e}/minFilter: Invalid value (${s})`), Np.NEAREST_NEAREST_MIPNEAREST
				}
			}
			_loadSkinAsync(e, t, i, s) {
				if (!this._parent.loadSkins) return Promise.resolve();
				const n = this._extensionsLoadSkinAsync(e, t, i);
				if (n) return n;
				if (i._data) return s(i._data.babylonSkeleton), i._data.promise;
				const a = `skeleton${i.index}`;
				this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const r = new gS(i.name || a, a, this._babylonScene);
				r._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, this._loadBones(e, i, r);
				const o = this._loadSkinInverseBindMatricesDataAsync(e, i).then((e => {
					this._updateBoneMatrices(r, e)
				}));
				return i._data = {
					babylonSkeleton: r,
					promise: o
				}, s(r), o
			}
			loadCameraAsync(t, i, s = () => {}) {
				const n = this._extensionsLoadCameraAsync(t, i, s);
				if (n) return n;
				const a = new Array;
				this.logOpen(`${t} ${i.name||""}`), this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const r = new lv(i.name || `camera${i.index}`, Lc.Zero(), this._babylonScene, !1);
				switch (r._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, r.ignoreParentScaling = !0, i._babylonCamera = r, r.rotation.set(0, Math.PI, 0), i.type) {
					case "perspective": {
						const e = i.perspective;
						if (!e) throw new Error(`${t}: Camera perspective properties are missing`);
						r.mk = e.yfov, r.minZ = e.znear, r.maxZ = e.zfar || 0;
						break
					}
					case "orthographic":
						if (!i.orthographic) throw new Error(`${t}: Camera orthographic properties are missing`);
						r.mode = Sd.ORTHOGRAPHIC_CAMERA, r.orthoLeft = -i.orthographic.xmag, r.orthoRight = i.orthographic.xmag, r.orthoBottom = -i.orthographic.ymag, r.orthoTop = i.orthographic.ymag, r.minZ = i.orthographic.znear, r.maxZ = i.orthographic.zfar;
						break;
					default:
						throw new Error(`${t}: Invalid camera type (${i.type})`)
				}
				return e.AddPointerMetadata(r, t), this._parent.onCameraLoadedObservable.notifyObservers(r), s(r), this.logClose(), Promise.all(a).then((() => r))
			}
			_loadBones(e, t, i) {
				if (null == t.skeleton || this._parent.alwaysComputeSkeletonRootNode) {
					const i = this._findSkeletonRootNode(`${e}/joints`, t.joints);
					if (i)
						if (void 0 === t.skeleton) t.skeleton = i.index;
						else {
							const s = (e, t) => {
									for (; t.parent; t = t.parent)
										if (t.parent === e) return !0;
									return !1
								},
								n = LA.Get(`${e}/skeleton`, this._gltf.nodes, t.skeleton);
							n === i || s(n, i) || (Qc.Warn(`${e}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`), t.skeleton = i.index)
						}
					else Qc.Warn(`${e}: Failed to find common root`)
				}
				const s = {};
				for (const n of t.joints) {
					const a = LA.Get(`${e}/joints/${n}`, this._gltf.nodes, n);
					this._loadBone(a, t, i, s)
				}
			}
			_loadAnimationSamplerAsync(e, t) {
				if (t._data) return t._data;
				const i = t.interpolation || "LINEAR";
				switch (i) {
					case "STEP":
					case "LINEAR":
					case "CUBICSPLINE":
						break;
					default:
						throw new Error(`${e}/interpolation: Invalid value (${t.interpolation})`)
				}
				const s = LA.Get(`${e}/input`, this._gltf.accessors, t.input),
					n = LA.Get(`${e}/output`, this._gltf.accessors, t.output);
				return t._data = Promise.all([this._loadFloatAccessorAsync(`/accessors/${s.index}`, s), this._loadFloatAccessorAsync(`/accessors/${n.index}`, n)]).then((([e, t]) => ({
					input: e,
					interpolation: i,
					output: t
				}))), t._data
			}
			_loadBone(e, t, i, s) {
				e._isJoint = !0;
				let n = s[e.index];
				if (n) return n;
				let a = null;
				e.index !== t.skeleton && (e.parent && -1 !== e.parent.index ? a = this._loadBone(e.parent, t, i, s) : void 0 !== t.skeleton && Qc.Warn(`/skins/${t.index}/skeleton: Skeleton node is not a common root`));
				const r = t.joints.indexOf(e.index);
				return n = new mS(e.name || `joint${e.index}`, i, a, this._getNodeMatrix(e), null, null, r), s[e.index] = n, this._postSceneLoadActions.push((() => {
					n.linkTransformNode(e._babylonTransformNode)
				})), n
			}
			loadBufferAsync(e, t, i, s) {
				const n = this._extensionsLoadBufferAsync(e, t, i, s);
				if (n) return n;
				if (!t._data)
					if (t.uri) t._data = this.loadUriAsync(`${e}/uri`, t, t.uri);
					else {
						if (!this._bin) throw new Error(`${e}: Uri is missing or the binary glTF is missing its binary chunk`);
						t._data = this._bin.readAsync(0, t.byteLength)
					} return t._data.then((t => {
					try {
						return new Uint8Array(t.buffer, t.byteOffset + i, s)
					} catch (t) {
						throw new Error(`${e}: ${t.message}`)
					}
				}))
			}
			_extensionsLoadCameraAsync(e, t, i) {
				return this._applyExtensions(t, "loadCamera", (s => s.loadCameraAsync && s.loadCameraAsync(e, t, i)))
			}
			_loadMeshPrimitiveAsync(t, i, s, n, a, r) {
				const o = this._extensionsLoadMeshPrimitiveAsync(t, i, s, n, a, r);
				if (o) return o;
				this.logOpen(`${t}`);
				const l = 0 === this._disableInstancedMesh && this._parent.createInstances && null == s.skin && !n.primitives[0].targets;
				let h, c;
				if (l && a._instanceData) this._babylonScene._blockEntityCollection = !!this._assetContainer, h = a._instanceData.babylonSourceMesh.createInstance(i), h._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, c = a._instanceData.promise;
				else {
					const r = new Array;
					this._babylonScene._blockEntityCollection = !!this._assetContainer;
					const o = new Vf(i, this._babylonScene);
					o._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, o.sideOrientation = this._babylonScene.useRightHandedSystem ? Pf.CounterClockWiseSideOrientation : Pf.ClockWiseSideOrientation, this._createMorphTargets(t, s, n, a, o), r.push(this._loadVertexDataAsync(t, a, o).then((e => this._loadMorphTargetsAsync(t, a, o, e).then((() => {
						this._disposed || (this._babylonScene._blockEntityCollection = !!this._assetContainer, e.applyToMesh(o), e._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1)
					})))));
					const u = e._GetDrawMode(t, a.mode);
					if (null == a.material) {
						let e = this._defaultBabylonMaterialData[u];
						e || (e = this._createDefaultMaterial("__GLTFLoader._default", u), this._parent.onMaterialLoadedObservable.notifyObservers(e), this._defaultBabylonMaterialData[u] = e), o.material = e
					} else if (!this.parent.skipMaterials) {
						const e = LA.Get(`${t}/material`, this._gltf.materials, a.material);
						r.push(this._loadMaterialAsync(`/materials/${e.index}`, e, o, u, (e => {
							o.material = e
						})))
					}
					c = Promise.all(r), l && (a._instanceData = {
						babylonSourceMesh: o,
						promise: c
					}), h = o
				}
				return e.AddPointerMetadata(h, t), this._parent.onMeshLoadedObservable.notifyObservers(h), r(h), this.logClose(), c.then((() => h))
			}
			static AddPointerMetadata(e, t) {
				e.metadata = e.metadata || {};
				const i = e._internalMetadata = e._internalMetadata || {},
					s = i.gltf = i.gltf || {};
				(s.pointers = s.pointers || []).push(t)
			}
			_extensionsLoadUriAsync(e, t, i) {
				return this._applyExtensions(t, "loadUri", (s => s._loadUriAsync && s._loadUriAsync(e, t, i)))
			}
			_extensionsLoadSkinAsync(e, t, i) {
				return this._applyExtensions(i, "loadSkin", (s => s._loadSkinAsync && s._loadSkinAsync(e, t, i)))
			}
			_compileMaterialsAsync() {
				this._parent._startPerformanceCounter("Compile materials");
				const e = new Array;
				if (this._gltf.materials)
					for (const t of this._gltf.materials)
						if (t._data)
							for (const i in t._data) {
								const s = t._data[i];
								for (const t of s.babylonMeshes) {
									t.computeWorldMatrix(!0);
									const i = s.babylonMaterial;
									e.push(i.forceCompilationAsync(t)), e.push(i.forceCompilationAsync(t, {
										useInstances: !0
									})), this._parent.useClipPlane && (e.push(i.forceCompilationAsync(t, {
										clipPlane: !0
									})), e.push(i.forceCompilationAsync(t, {
										clipPlane: !0,
										useInstances: !0
									})))
								}
							}
				return Promise.all(e).then((() => {
					this._parent._endPerformanceCounter("Compile materials")
				}))
			}
			_loadData(e) {
				if (this._gltf = e.json, this._setupData(), e.bin) {
					const t = this._gltf.buffers;
					if (t && t[0] && !t[0].uri) {
						const i = t[0];
						(i.byteLength < e.bin.byteLength - 3 || i.byteLength > e.bin.byteLength) && Qc.Warn(`Binary buffer length (${i.byteLength}) from JSON does not match chunk length (${e.bin.byteLength})`), this._bin = e.bin
					} else Qc.Warn("Unexpected BIN chunk")
				}
			}
			_createDefaultMaterial(e, t) {
				this._babylonScene._blockEntityCollection = !!this._assetContainer;
				const i = new wA(e, this._babylonScene);
				return i._parentContainer = this._assetContainer, this._babylonScene._blockEntityCollection = !1, i.fillMode = t, i.enableSpecularAntiAliasing = !0, i.useRadianceOverAlpha = !this._parent.transparencyAsCoverage, i.useSpecularOverAlpha = !this._parent.transparencyAsCoverage, i.transparencyMode = wA.PBRMATERIAL_OPAQUE, i.metallic = 1, i.roughness = 1, i
			}
			loadAsync(e, t, i, s, n = "") {
				return Promise.resolve().then((() => (this._babylonScene = e, this._loadData(t), this._loadAsync(i, n, null, (() => {})))))
			}
			_getMeshes() {
				const e = [];
				this._rootBabylonMesh instanceof jd && e.push(this._rootBabylonMesh);
				const t = this._gltf.nodes;
				if (t)
					for (const i of t) this._forEachPrimitive(i, (t => {
						e.push(t)
					}));
				return e
			}
		};
	BA._RegisteredExtensions = {}, BA.DefaultSampler = {
		index: -1
	}, NE._CreateGLTF2Loader = e => new BA(e);

	function GA(e, t, i, s, n, a, r, o, l, h, c) {
		return new Promise(((u, m) => {
			if (i) {
				const i = t.createTexture(null, !0, !0, null, 1, null, (e => {
					m(e)
				}), e);
				s?.onEffectCreatedObservable.addOnce((o => {
					o.executeWhenCompiled((() => {
						s.externalTextureSamplerBinding = !0, s.onApply = s => {
							s._bindTexture("textureSampler", i), s.setFloat2("scale", 1, t._features.needsInvertingBitmap && e instanceof ImageBitmap ? -1 : 1)
						}, t.scenes.length && (t.scenes[0].postProcessManager.directRender([s], h, !0, a, r), t.restoreDefaultFramebuffer(), i.dispose(), URL.revokeObjectURL(n), u())
					}))
				}))
			} else {
				if (t._uploadImageToTexture(c, e, a, r), o) {
					const i = l[r];
					i && t._uploadImageToTexture(i._texture, e, a, 0)
				}
				u()
			}
		}))
	}
	async function HA(e, t, i = "image/png") {
		if (!dd.IsExponentOfTwo(e.width)) throw new Error("Texture size must be a power of two");
		const s = Ac.ILog2(e.width) + 1,
			n = e.getEngine();
		let a = !1,
			r = !1,
			o = null,
			l = null,
			h = null;
		const c = n.getCaps();
		e.format = 5, e.type = 0, e.generateMipMaps = !0, e._cachedAnisotropicFilteringLevel = null, n.updateTextureSamplingMode(3, e), c.textureLOD ? n._features.supportRenderAndCopyToLodForFloatTextures ? c.textureHalfFloatRender && c.textureHalfFloatLinearFiltering ? (a = !0, e.type = 2) : c.textureFloatRender && c.textureFloatLinearFiltering && (a = !0, e.type = 1) : a = !1 : (a = !1, r = !0, h = {});
		let u = 0;
		if (a) n.isWebGPU ? (u = 1, await Promise.resolve().then((() => (to(), qr)))) : await Promise.resolve().then((() => (uo(), oo))), o = new Bp("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, n, !1, void 0, e.type, void 0, null, !1, void 0, u), e._isRGBD = !1, e.invertY = !1, l = n.createRenderTargetCubeTexture(e.width, {
			generateDepthBuffer: !1,
			generateMipMaps: !0,
			generateStencilBuffer: !1,
			samplingMode: 3,
			type: e.type,
			format: 5
		});
		else if (e._isRGBD = !0, e.invertY = !0, r) {
			const t = 3,
				i = e._lodGenerationScale,
				a = e._lodGenerationOffset;
			for (let r = 0; r < t; r++) {
				const o = (s - 1) * i + a,
					l = a + (o - a) * (1 - r / (t - 1)),
					c = Math.round(Math.min(Math.max(l, 0), o)),
					u = new Pm(n, 2);
				u.isCube = !0, u.invertY = !0, u.generateMipMaps = !1, n.updateTextureSamplingMode(2, u);
				const m = new wp(null);
				switch (m._isCube = !0, m._texture = u, h[c] = m, r) {
					case 0:
						e._lodTextureLow = m;
						break;
					case 1:
						e._lodTextureMid = m;
						break;
					case 2:
						e._lodTextureHigh = m
				}
			}
		}
		const m = [];
		for (let s = 0; s < t.length; s++)
			for (let c = 0; c < 6; c++) {
				const u = t[s][c],
					d = new Blob([u], {
						type: i
					}),
					f = URL.createObjectURL(d);
				let p;
				if (n._features.forceBitmapOverHTMLImageElement) p = n.createImageBitmap(d, {
					premultiplyAlpha: "none"
				}).then((t => GA(t, n, a, o, f, c, s, r, h, l, e)));
				else {
					const t = new Image;
					t.src = f, p = new Promise(((i, u) => {
						t.onload = () => {
							GA(t, n, a, o, f, c, s, r, h, l, e).then((() => i())).catch((e => {
								u(e)
							}))
						}, t.onerror = e => {
							u(e)
						}
					}))
				}
				m.push(p)
			}
		if (t.length < s) {
			let i;
			const a = Math.pow(2, s - 1 - t.length),
				r = a * a * 4;
			switch (e.type) {
				case 0:
					i = new Uint8Array(r);
					break;
				case 2:
					i = new Uint16Array(r);
					break;
				case 1:
					i = new Float32Array(r)
			}
			for (let a = t.length; a < s; a++)
				for (let t = 0; t < 6; t++) n._uploadArrayBufferViewToTexture(e, i, t, a)
		}
		return Promise.all(m).then((() => {
			l && (n._releaseTexture(e), l._swapAndDie(e)), o && o.dispose(), r && (e._lodTextureHigh && e._lodTextureHigh._texture && (e._lodTextureHigh._texture.isReady = !0), e._lodTextureMid && e._lodTextureMid._texture && (e._lodTextureMid._texture.isReady = !0), e._lodTextureLow && e._lodTextureLow._texture && (e._lodTextureLow._texture.isReady = !0))
		}))
	}
	var UA = class e extends Iv {
			updateRGBDAsync(e, t = null, i = .8, s = 0) {
				return function(e, t, i, s, n) {
					const a = HA(e.getEngine().createRawCubeTexture(null, e.width, e.format, e.type, e.generateMipMaps, e.invertY, e.samplingMode, e._compression), t).then((() => e));
					return e.onRebuildCallback = e => ({
						proxy: a,
						isReady: !0,
						isAsync: !0
					}), e._source = 13, e._bufferViewArrayArray = t, e._lodGenerationScale = s, e._lodGenerationOffset = n, e._sphericalPolynomial = i, HA(e, t).then((() => (e.isReady = !0, e)))
				}(this._texture, e, t, i, s).then((() => {}))
			}
			constructor(e, t, i, s = 5, n = 0, a = !1, r = !1, o = 3, l = null) {
				super("", e), this._texture = e.getEngine().createRawCubeTexture(t, i, s, n, a, r, o, l)
			}
			update(e, t, i, s, n = null) {
				this._texture.getEngine().updateRawCubeTexture(this._texture, e, t, i, s, n)
			}
			clone() {
				return Xc.Clone((() => {
					const t = this.getScene(),
						i = this._texture,
						s = new e(t, i._bufferViewArray, i.width, i.format, i.type, i.generateMipMaps, i.invertY, i.samplingMode, i._compression);
					return 13 === i.source && s.updateRGBDAsync(i._bufferViewArrayArray, i._sphericalPolynomial, i._lodGenerationScale, i._lodGenerationOffset), s
				}), this)
			}
		},
		VA = "EXT_lights_image_based",
		WA = class {
			onLoading() {
				const e = this._loader.gltf.extensions;
				if (e && e[this.name]) {
					const t = e[this.name];
					this._lights = t.lights
				}
			}
			constructor(e) {
				this.name = VA, this._loader = e, this.enabled = this._loader.isExtensionUsed(VA)
			}
			_loadLightAsync(e, t) {
				if (!t._loaded) {
					const i = new Array;
					this._loader.logOpen(`${e}`);
					const s = new Array(t.specularImages.length);
					for (let n = 0; n < t.specularImages.length; n++) {
						const a = t.specularImages[n];
						s[n] = new Array(a.length);
						for (let t = 0; t < a.length; t++) {
							const r = `${e}/specularImages/${n}/${t}`;
							this._loader.logOpen(`${r}`);
							const o = a[t],
								l = LA.Get(r, this._loader.gltf.images, o);
							i.push(this._loader.loadImageAsync(`/images/${o}`, l).then((e => {
								s[n][t] = e
							}))), this._loader.logClose()
						}
					}
					this._loader.logClose(), t._loaded = Promise.all(i).then((() => {
						const i = new UA(this._loader.babylonScene, null, t.specularImageSize);
						if (i.name = t.name || "environment", t._babylonTexture = i, null != t.intensity && (i.level = t.intensity), t.rotation) {
							let e = Gc.FromArray(t.rotation);
							this._loader.babylonScene.useRightHandedSystem || (e = Gc.Inverse(e)), Hc.FromQuaternionToRef(e, i.getReflectionTextureMatrix())
						}
						if (!t.irradianceCoefficients) throw new Error(`${e}: Irradiance coefficients are missing`);
						const n = fv.FromArray(t.irradianceCoefficients);
						n.scaleInPlace(t.intensity), n.convertIrradianceToLambertianRadiance();
						const a = pv.FromHarmonics(n),
							r = (s.length - 1) / Ac.Log2(t.specularImageSize);
						return i.updateRGBDAsync(s, a, r)
					}))
				}
				return t._loaded.then((() => t._babylonTexture))
			}
			dispose() {
				this._loader = null, delete this._lights
			}
			loadSceneAsync(e, t) {
				return BA.LoadExtensionAsync(e, t, this.name, ((i, s) => {
					this._loader._allMaterialsDirtyRequired = !0;
					const n = new Array;
					n.push(this._loader.loadSceneAsync(e, t)), this._loader.logOpen(`${i}`);
					const a = LA.Get(`${i}/light`, this._lights, s.light);
					return n.push(this._loadLightAsync(`/extensions/${this.name}/lights/${s.light}`, a).then((e => {
						this._loader.babylonScene.environmentTexture = e
					}))), this._loader.logClose(), Promise.all(n).then((() => {}))
				}))
			}
		};
	BA.RegisterExtension(VA, (e => new WA(e))), Vf.prototype.thinInstanceAdd = function(e, t = !0) {
		if (!this.getScene().getEngine().getCaps().instancedArrays) return Qc.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"), -1;
		this._thinInstanceUpdateBufferSize("matrix", Array.isArray(e) ? e.length : 1);
		const i = this._thinInstanceDataStorage.instancesCount;
		if (Array.isArray(e))
			for (let i = 0; i < e.length; ++i) this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, e[i], i === e.length - 1 && t);
		else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, e, t);
		return i
	}, Vf.prototype.thinInstanceAddSelf = function(e = !0) {
		return this.thinInstanceAdd(Hc.IdentityReadOnly, e)
	}, Vf.prototype.thinInstanceRegisterAttribute = function(e, t) {
		e === eu.ColorKind && (e = eu.ColorInstanceKind), this.removeVerticesData(e), this._thinInstanceInitializeUserStorage(), this._userThinInstanceBuffersStorage.strides[e] = t, this._userThinInstanceBuffersStorage.sizes[e] = t * Math.max(32, this._thinInstanceDataStorage.instancesCount), this._userThinInstanceBuffersStorage.data[e] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[e]), this._userThinInstanceBuffersStorage.vertexBuffers[e] = new eu(this.getEngine(), this._userThinInstanceBuffersStorage.data[e], e, !0, !1, t, !0), this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])
	}, Vf.prototype.thinInstanceSetMatrixAt = function(e, t, i = !0) {
		if (!this._thinInstanceDataStorage.matrixData || e >= this._thinInstanceDataStorage.instancesCount) return !1;
		const s = this._thinInstanceDataStorage.matrixData;
		return t.copyToArray(s, 16 * e), this._thinInstanceDataStorage.worldMatrices && (this._thinInstanceDataStorage.worldMatrices[e] = t), i && (this.thinInstanceBufferUpdated("matrix"), this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1)), !0
	}, Vf.prototype.thinInstanceSetAttributeAt = function(e, t, i, s = !0) {
		return e === eu.ColorKind && (e = eu.ColorInstanceKind), !(!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[e] || t >= this._thinInstanceDataStorage.instancesCount) && (this._thinInstanceUpdateBufferSize(e, 0), this._userThinInstanceBuffersStorage.data[e].set(i, t * this._userThinInstanceBuffersStorage.strides[e]), s && this.thinInstanceBufferUpdated(e), !0)
	}, Object.defineProperty(Vf.prototype, "thinInstanceCount", {
		get: function() {
			return this._thinInstanceDataStorage.instancesCount
		},
		set: function(e) {
			const t = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;
			e <= (t ? t.length / 16 : 0) && (this._thinInstanceDataStorage.instancesCount = e)
		},
		enumerable: !0,
		configurable: !0
	}), Vf.prototype._thinInstanceCreateMatrixBuffer = function(e, t, i = !0) {
		const s = new Zc(this.getEngine(), t, !i, 16, !1, !0);
		for (let t = 0; t < 4; t++) this.setVerticesBuffer(s.createVertexBuffer(e + t, 4 * t, 4));
		return s
	}, Vf.prototype.thinInstanceSetBuffer = function(e, t, i = 0, s = !0) {
		i = i || 16, "matrix" === e ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(), this._thinInstanceDataStorage.matrixBuffer = null, this._thinInstanceDataStorage.matrixBufferSize = t ? t.length : 32 * i, this._thinInstanceDataStorage.matrixData = t, this._thinInstanceDataStorage.worldMatrices = null, null !== t ? (this._thinInstanceDataStorage.instancesCount = t.length / i, this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", t, s), this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1)) : (this._thinInstanceDataStorage.instancesCount = 0, this.doNotSyncBoundingInfo || this.refreshBoundingInfo())) : "previousMatrix" === e ? (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(), this._thinInstanceDataStorage.previousMatrixBuffer = null, this._thinInstanceDataStorage.previousMatrixData = t, null !== t && (this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", t, s))) : (e === eu.ColorKind && (e = eu.ColorInstanceKind), null === t ? this._userThinInstanceBuffersStorage?.data[e] && (this.removeVerticesData(e), delete this._userThinInstanceBuffersStorage.data[e], delete this._userThinInstanceBuffersStorage.strides[e], delete this._userThinInstanceBuffersStorage.sizes[e], delete this._userThinInstanceBuffersStorage.vertexBuffers[e]) : (this._thinInstanceInitializeUserStorage(), this._userThinInstanceBuffersStorage.data[e] = t, this._userThinInstanceBuffersStorage.strides[e] = i, this._userThinInstanceBuffersStorage.sizes[e] = t.length, this._userThinInstanceBuffersStorage.vertexBuffers[e] = new eu(this.getEngine(), t, e, !s, !1, i, !0), this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])))
	}, Vf.prototype.thinInstanceBufferUpdated = function(e) {
		"matrix" === e ? (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable() && this._thinInstanceRecreateBuffer(e), this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount)) : "previousMatrix" === e ? (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable() && this._thinInstanceRecreateBuffer(e), this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount)) : (e === eu.ColorKind && (e = eu.ColorInstanceKind), this._userThinInstanceBuffersStorage?.vertexBuffers[e] && (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[e].isUpdatable() && this._thinInstanceRecreateBuffer(e), this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(this._userThinInstanceBuffersStorage.data[e], 0)))
	}, Vf.prototype.thinInstancePartialBufferUpdate = function(e, t, i) {
		"matrix" === e ? this._thinInstanceDataStorage.matrixBuffer && this._thinInstanceDataStorage.matrixBuffer.updateDirectly(t, i) : (e === eu.ColorKind && (e = eu.ColorInstanceKind), this._userThinInstanceBuffersStorage?.vertexBuffers[e] && this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(t, i))
	}, Vf.prototype.thinInstanceGetWorldMatrices = function() {
		if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) return [];
		const e = this._thinInstanceDataStorage.matrixData;
		if (!this._thinInstanceDataStorage.worldMatrices) {
			this._thinInstanceDataStorage.worldMatrices = [];
			for (let t = 0; t < this._thinInstanceDataStorage.instancesCount; ++t) this._thinInstanceDataStorage.worldMatrices[t] = Hc.FromArray(e, 16 * t)
		}
		return this._thinInstanceDataStorage.worldMatrices
	}, Vf.prototype.thinInstanceRefreshBoundingInfo = function(e = !1, t = !1, i = !1) {
		if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) return;
		const s = this._thinInstanceDataStorage.boundingVectors;
		if (e || !this.rawBoundingInfo) {
			s.length = 0, this.refreshBoundingInfo(t, i);
			const e = this.getBoundingInfo();
			this.rawBoundingInfo = new yu(e.minimum, e.maximum)
		}
		const n = this.getBoundingInfo(),
			a = this._thinInstanceDataStorage.matrixData;
		if (0 === s.length)
			for (let e = 0; e < n.boundingBox.vectors.length; ++e) s.push(n.boundingBox.vectors[e].clone());
		Vc.Vector3[0].setAll(Number.POSITIVE_INFINITY), Vc.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
		for (let e = 0; e < this._thinInstanceDataStorage.instancesCount; ++e) {
			Hc.FromArrayToRef(a, 16 * e, Vc.Matrix[0]);
			for (let e = 0; e < s.length; ++e) Lc.TransformCoordinatesToRef(s[e], Vc.Matrix[0], Vc.Vector3[2]), Vc.Vector3[0].minimizeInPlace(Vc.Vector3[2]), Vc.Vector3[1].maximizeInPlace(Vc.Vector3[2])
		}
		n.reConstruct(Vc.Vector3[0], Vc.Vector3[1]), this._updateBoundingInfo()
	}, Vf.prototype._thinInstanceRecreateBuffer = function(e, t = !0) {
		"matrix" === e ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(), this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, t)) : "previousMatrix" === e ? this._scene.needsPreviousWorldMatrices && (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(), this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, t)) : (e === eu.ColorKind && (e = eu.ColorInstanceKind), this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(), this._userThinInstanceBuffersStorage.vertexBuffers[e] = new eu(this.getEngine(), this._userThinInstanceBuffersStorage.data[e], e, !t, !1, this._userThinInstanceBuffersStorage.strides[e], !0), this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))
	}, Vf.prototype._thinInstanceUpdateBufferSize = function(e, t = 1) {
		e === eu.ColorKind && (e = eu.ColorInstanceKind);
		const i = "matrix" === e;
		if (!(i || this._userThinInstanceBuffersStorage && this._userThinInstanceBuffersStorage.strides[e])) return;
		const s = i ? 16 : this._userThinInstanceBuffersStorage.strides[e],
			n = i ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[e];
		let a = i ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[e];
		const r = (this._thinInstanceDataStorage.instancesCount + t) * s;
		let o = n;
		for (; o < r;) o *= 2;
		if (!a || n != o) {
			if (a) {
				const e = new Float32Array(o);
				e.set(a, 0), a = e
			} else a = new Float32Array(o);
			i ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(), this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", a, !1), this._thinInstanceDataStorage.matrixData = a, this._thinInstanceDataStorage.matrixBufferSize = o, this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(), this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", a, !1))) : (this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(), this._userThinInstanceBuffersStorage.data[e] = a, this._userThinInstanceBuffersStorage.sizes[e] = o, this._userThinInstanceBuffersStorage.vertexBuffers[e] = new eu(this.getEngine(), a, e, !0, !1, s, !0), this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))
		}
	}, Vf.prototype._thinInstanceInitializeUserStorage = function() {
		this._userThinInstanceBuffersStorage || (this._userThinInstanceBuffersStorage = {
			data: {},
			sizes: {},
			vertexBuffers: {},
			strides: {}
		})
	}, Vf.prototype._disposeThinInstanceSpecificData = function() {
		this._thinInstanceDataStorage?.matrixBuffer && (this._thinInstanceDataStorage.matrixBuffer.dispose(), this._thinInstanceDataStorage.matrixBuffer = null)
	};
	var zA = "EXT_mesh_gpu_instancing",
		XA = class {
			constructor(e) {
				this.name = zA, this._loader = e, this.enabled = this._loader.isExtensionUsed(zA)
			}
			dispose() {
				this._loader = null
			}
			loadNodeAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((e, s) => {
					this._loader._disableInstancedMesh++;
					const n = this._loader.loadNodeAsync(`/nodes/${t.index}`, t, i);
					if (this._loader._disableInstancedMesh--, !t._primitiveBabylonMeshes) return n;
					const a = new Array;
					let r = 0;
					const o = t => {
						if (null == s.attributes[t]) return void a.push(Promise.resolve(null));
						const i = LA.Get(`${e}/attributes/${t}`, this._loader.gltf.accessors, s.attributes[t]);
						if (a.push(this._loader._loadFloatAccessorAsync(`/accessors/${i.bufferView}`, i)), 0 === r) r = i.count;
						else if (r !== i.count) throw new Error(`${e}/attributes: Instance buffer accessors do not have the same count.`)
					};
					return o("TRANSLATION"), o("ROTATION"), o("SCALE"), n.then((e => Promise.all(a).then((([i, s, n]) => {
						const a = new Float32Array(16 * r);
						Vc.Vector3[0].copyFromFloats(0, 0, 0), Vc.uk[0].copyFromFloats(0, 0, 0, 1), Vc.Vector3[1].copyFromFloats(1, 1, 1);
						for (let e = 0; e < r; ++e) i && Lc.FromArrayToRef(i, 3 * e, Vc.Vector3[0]), s && Gc.FromArrayToRef(s, 4 * e, Vc.uk[0]), n && Lc.FromArrayToRef(n, 3 * e, Vc.Vector3[1]), Hc.ComposeToRef(Vc.Vector3[1], Vc.uk[0], Vc.Vector3[0], Vc.Matrix[0]), Vc.Matrix[0].copyToArray(a, 16 * e);
						for (const e of t._primitiveBabylonMeshes) e.thinInstanceSetBuffer("matrix", a, 16, !0);
						return e
					}))))
				}))
			}
		};
	BA.RegisterExtension(zA, (e => new XA(e)));
	var YA = class e {
		decodeGltfBufferAsync(e, t, i, s, n) {
			return this._decoderModulePromise.then((async () => {
				MeshoptDecoder.useWorkers(1);
				const a = await MeshoptDecoder.decodeGltfBufferAsync(t, i, e, s, n);
				return MeshoptDecoder.useWorkers(0), a
			}))
		}
		constructor() {
			const t = e.Configuration.decoder;
			this._decoderModulePromise = dd.LoadBabylonScriptAsync(t.url).then((() => MeshoptDecoder.ready))
		}
		static get Default() {
			return e._Default || (e._Default = new e), e._Default
		}
		dispose() {
			delete this._decoderModulePromise
		}
	};
	YA.Configuration = {
		decoder: {
			url: `${dd._DefaultCdnUrl}/meshopt_decoder.js`
		}
	}, YA._Default = null;
	var jA = "EXT_meshopt_compression",
		KA = class {
			constructor(e) {
				this.name = jA, this.enabled = e.isExtensionUsed(jA), this._loader = e
			}
			dispose() {
				this._loader = null
			}
			loadBufferViewAsync(e, t) {
				return BA.LoadExtensionAsync(e, t, this.name, ((i, s) => {
					const n = t;
					if (n._meshOptData) return n._meshOptData;
					const a = LA.Get(`${e}/buffer`, this._loader.gltf.buffers, s.buffer);
					return n._meshOptData = this._loader.loadBufferAsync(`/buffers/${a.index}`, a, s.byteOffset || 0, s.byteLength).then((e => YA.Default.decodeGltfBufferAsync(e, s.count, s.byteStride, s.mode, s.filter))), n._meshOptData
				}))
			}
		};
	BA.RegisterExtension(jA, (e => new KA(e)));
	var $A = "EXT_texture_webp",
		JA = class {
			constructor(e) {
				this.name = $A, this._loader = e, this.enabled = e.isExtensionUsed($A)
			}
			dispose() {
				this._loader = null
			}
			_loadTextureAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = null == t.sampler ? BA.DefaultSampler : LA.Get(`${e}/sampler`, this._loader.gltf.samplers, t.sampler),
						r = LA.Get(`${s}/source`, this._loader.gltf.images, n.source);
					return this._loader._createTextureAsync(e, a, r, (e => {
						i(e)
					}), void 0, !t._textureInfo.nonColorData)
				}))
			}
		};
	BA.RegisterExtension($A, (e => new JA(e)));
	var qA = "EXT_texture_avif",
		QA = class {
			_loadTextureAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = null == t.sampler ? BA.DefaultSampler : LA.Get(`${e}/sampler`, this._loader.gltf.samplers, t.sampler),
						r = LA.Get(`${s}/source`, this._loader.gltf.images, n.source);
					return this._loader._createTextureAsync(e, a, r, (e => {
						i(e)
					}), void 0, !t._textureInfo.nonColorData)
				}))
			}
			constructor(e) {
				this.name = qA, this._loader = e, this.enabled = e.isExtensionUsed(qA)
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(qA, (e => new QA(e)));
	var ZA = class {
			_execute(e, t) {
				e.idle = !1, e.workerPromise.then((i => {
					t(i, (() => {
						const t = this._pendingActions.shift();
						t ? this._execute(e, t) : e.idle = !0
					}))
				}))
			}
			dispose() {
				for (const e of this._workerInfos) e.workerPromise.then((e => {
					e.terminate()
				}));
				this._workerInfos.length = 0, this._pendingActions.length = 0
			}
			push(e) {
				this._executeOnIdleWorker(e) || this._pendingActions.push(e)
			}
			constructor(e) {
				this._pendingActions = new Array, this._workerInfos = e.map((e => ({
					workerPromise: Promise.resolve(e),
					idle: !0
				})))
			}
			_executeOnIdleWorker(e) {
				for (const t of this._workerInfos)
					if (t.idle) return this._execute(t, e), !0;
				return !1
			}
		},
		eb = class e extends ZA {
			constructor(t, i, s = e.DefaultOptions) {
				super([]), this._maxWorkers = t, this._createWorkerAsync = i, this._options = s
			}
			_execute(e, t) {
				e.timeoutId && (clearTimeout(e.timeoutId), delete e.timeoutId), super._execute(e, ((i, s) => {
					t(i, (() => {
						s(), e.idle && (e.timeoutId = setTimeout((() => {
							e.workerPromise.then((e => {
								e.terminate()
							}));
							const t = this._workerInfos.indexOf(e); - 1 !== t && this._workerInfos.splice(t, 1)
						}), this._options.idleTimeElapsedBeforeRelease))
					}))
				}))
			}
			push(e) {
				if (!this._executeOnIdleWorker(e))
					if (this._workerInfos.length < this._maxWorkers) {
						const t = {
							workerPromise: this._createWorkerAsync(),
							idle: !1
						};
						this._workerInfos.push(t), this._execute(t, e)
					} else this._pendingActions.push(e)
			}
		};

	function tb(e, t, i, s, n) {
		let a = null,
			r = null,
			o = null;
		try {
			let l;
			a = new e.Decoder, r = new e.DecoderBuffer, r.Init(t, t.byteLength);
			const h = a.GetEncodedGeometryType(r);
			switch (h) {
				case e.TRIANGULAR_MESH: {
					const t = new e.Mesh;
					if (l = a.DecodeBufferToMesh(r, t), !l.ok() || 0 === t.ptr) throw new Error(l.error_msg());
					const i = 3 * t.num_faces(),
						n = 4 * i,
						h = e._malloc(n);
					try {
						a.GetTrianglesUInt32Array(t, n, h);
						const r = new Uint32Array(i);
						r.set(new Uint32Array(e.HEAPF32.buffer, h, i)), s(r)
					} finally {
						e._free(h)
					}
					o = t;
					break
				}
				case e.POINT_CLOUD: {
					const t = new e.PointCloud;
					if (l = a.DecodeBufferToPointCloud(r, t), !l.ok() || !t.ptr) throw new Error(l.error_msg());
					o = t;
					break
				}
				default:
					throw new Error(`Invalid geometry type ${h}`)
			}
			const c = o.num_points(),
				u = (t, i, s, a) => {
					const r = a.data_type(),
						o = a.num_components(),
						l = a.normalized(),
						h = a.byte_stride(),
						u = a.byte_offset(),
						m = {
							[e.DT_FLOAT32]: {
								typedArrayConstructor: Float32Array,
								heap: e.HEAPF32
							},
							[e.DT_INT8]: {
								typedArrayConstructor: Int8Array,
								heap: e.HEAP8
							},
							[e.DT_INT16]: {
								typedArrayConstructor: Int16Array,
								heap: e.HEAP16
							},
							[e.DT_INT32]: {
								typedArrayConstructor: Int32Array,
								heap: e.HEAP32
							},
							[e.DT_UINT8]: {
								typedArrayConstructor: Uint8Array,
								heap: e.HEAPU8
							},
							[e.DT_UINT16]: {
								typedArrayConstructor: Uint16Array,
								heap: e.HEAPU16
							},
							[e.DT_UINT32]: {
								typedArrayConstructor: Uint32Array,
								heap: e.HEAPU32
							}
						} [r];
					if (!m) throw new Error(`Invalid data type ${r}`);
					const d = c * o,
						f = d * m.typedArrayConstructor.BYTES_PER_ELEMENT,
						p = e._malloc(f);
					try {
						t.GetAttributeDataArrayForAllPoints(i, a, r, f, p);
						const e = new m.typedArrayConstructor(m.heap.buffer, p, d);
						n(s, e.slice(), o, u, h, l)
					} finally {
						e._free(p)
					}
				};
			if (i)
				for (const e in i) {
					const t = i[e],
						s = a.GetAttributeByUniqueId(o, t);
					u(a, o, e, s)
				} else {
					const t = {
						position: e.POSITION,
						normal: e.NORMAL,
						color: e.COLOR,
						uv: e.TEX_COORD
					};
					for (const e in t) {
						const i = a.GetAttributeId(o, t[e]);
						if (-1 !== i) {
							const t = a.GetAttribute(o, i);
							u(a, o, e, t)
						}
					}
				}
			return c
		} finally {
			o && e.destroy(o), r && e.destroy(r), a && e.destroy(a)
		}
	}

	function ib() {
		let e;
		onmessage = t => {
			const i = t.data;
			switch (i.id) {
				case "init": {
					const t = i.decoder;
					t.url && importScripts(t.url);
					const s = t.wasmBinary ? {
						wasmBinary: t.wasmBinary
					} : {};
					e = DracoDecoderModule(s), postMessage({
						id: "initDone"
					});
					break
				}
				case "decodeMesh":
					if (!e) throw new Error("Draco decoder module is not available");
					e.then((e => {
						const t = tb(e, i.dataView, i.attributes, (e => {
							postMessage({
								id: "indices",
								data: e
							}, [e.buffer])
						}), ((e, t, i, s, n, a) => {
							postMessage({
								id: "attribute",
								kind: e,
								data: t,
								size: i,
								byteOffset: s,
								byteStride: n,
								normalized: a
							}, [t.buffer])
						}));
						postMessage({
							id: "decodeMeshDone",
							totalVertices: t
						})
					}))
			}
		}
	}
	eb.DefaultOptions = {
		idleTimeElapsedBeforeRelease: 1e3
	};
	var sb = class e {
		decodeMeshToMeshDataAsync(e, t, i) {
			const s = e instanceof ArrayBuffer ? new Int8Array(e) : new Int8Array(e.buffer, e.byteOffset, e.byteLength);
			if (this._workerPoolPromise) return this._workerPoolPromise.then((e => new Promise(((n, a) => {
				e.push(((e, r) => {
					let o = null;
					const l = [],
						h = t => {
							e.removeEventListener("error", h), e.removeEventListener("message", c), a(t), r()
						},
						c = t => {
							const s = t.data;
							switch (s.id) {
								case "decodeMeshDone":
									e.removeEventListener("error", h), e.removeEventListener("message", c), n({
										indices: o,
										attributes: l,
										totalVertices: s.totalVertices
									}), r();
									break;
								case "indices":
									o = s.data;
									break;
								case "attribute":
									l.push({
										kind: s.kind,
										data: s.data,
										size: s.size,
										byteOffset: s.byteOffset,
										byteStride: s.byteStride,
										normalized: (a = s.kind, u = s.normalized, i && void 0 !== i[a] ? (u !== i[a] && Qc.Warn(`Normalized flag from Draco data (${u}) does not match normalized flag from glTF accessor (${i[a]}). Using flag from glTF accessor.`), i[a]) : u)
									})
							}
							var a, u
						};
					e.addEventListener("error", h), e.addEventListener("message", c);
					const u = s.slice();
					e.postMessage({
						id: "decodeMesh",
						dataView: u,
						attributes: t
					}, [u.buffer])
				}))
			}))));
			if (this._decoderModulePromise) return this._decoderModulePromise.then((e => {
				let i = null;
				const n = [],
					a = tb(e.module, s, t, (e => {
						i = e
					}), ((e, t, i, s, a, r) => {
						n.push({
							kind: e,
							data: t,
							size: i,
							byteOffset: s,
							byteStride: a,
							normalized: r
						})
					}));
				return {
					indices: i,
					attributes: n,
					totalVertices: a
				}
			}));
			throw new Error("Draco decoder module is not available")
		}
		async decodeMeshToGeometryAsync(e, t, i, s) {
			const n = await this.decodeMeshToMeshDataAsync(i, s),
				a = new bd(e, t);
			n.indices && a.setIndices(n.indices);
			for (const e of n.attributes) a.setVerticesBuffer(new eu(t.getEngine(), e.data, e.kind, !1, void 0, e.byteStride, void 0, e.byteOffset, e.size, void 0, e.normalized, !0), n.totalVertices);
			return a
		}
		async whenReadyAsync() {
			this._workerPoolPromise ? await this._workerPoolPromise : this._decoderModulePromise && await this._decoderModulePromise
		}
		static get Default() {
			return e._Default || (e._Default = new e), e._Default
		}
		dispose() {
			this._workerPoolPromise && this._workerPoolPromise.then((e => {
				e.dispose()
			})), delete this._workerPoolPromise, delete this._decoderModulePromise
		}
		static GetDefaultNumWorkers() {
			return "object" == typeof navigator && navigator.hardwareConcurrency ? Math.min(Math.floor(.5 * navigator.hardwareConcurrency), 4) : 1
		}
		async _decodeMeshToGeometryForGltfAsync(e, t, i, s, n) {
			const a = await this.decodeMeshToMeshDataAsync(i, s, n),
				r = new bd(e, t);
			a.indices && r.setIndices(a.indices);
			for (const e of a.attributes) r.setVerticesBuffer(new eu(t.getEngine(), e.data, e.kind, !1, void 0, e.byteStride, void 0, e.byteOffset, e.size, void 0, e.normalized, !0), a.totalVertices);
			return r
		}
		constructor(t = e.DefaultNumWorkers) {
			const i = e.Configuration.decoder;
			if (i.workerPool || "object" == typeof t && t.workerPool) this._workerPoolPromise = Promise.resolve(i.workerPool || t.workerPool);
			else {
				const e = i.wasmBinary || "object" == typeof t && t.wasmBinary,
					s = "number" == typeof t ? t : t.numWorkers,
					n = s && "function" == typeof Worker && "function" == typeof URL,
					a = n || !n && !i.jsModule,
					r = i.wasmUrl && i.wasmBinaryUrl && "object" == typeof WebAssembly ? {
						url: a ? dd.GetBabylonScriptURL(i.wasmUrl, !0) : "",
						wasmBinaryPromise: e ? Promise.resolve(e) : dd.LoadFileAsync(dd.GetBabylonScriptURL(i.wasmBinaryUrl, !0))
					} : {
						url: a ? dd.GetBabylonScriptURL(i.fallbackUrl) : "",
						wasmBinaryPromise: Promise.resolve(void 0)
					};
				n ? this._workerPoolPromise = r.wasmBinaryPromise.then((e => {
					const t = `${tb}(${ib})()`,
						i = URL.createObjectURL(new Blob([t], {
							type: "application/javascript"
						}));
					return new eb(s, (() => function(e, t, i) {
						return new Promise(((s, n) => {
							const a = t => {
									e.removeEventListener("error", a), e.removeEventListener("message", r), n(t)
								},
								r = t => {
									"initDone" === t.data.id && (e.removeEventListener("error", a), e.removeEventListener("message", r), s(e))
								};
							if (e.addEventListener("error", a), e.addEventListener("message", r), t) {
								const s = t.slice(0);
								e.postMessage({
									id: "init",
									decoder: {
										url: i,
										wasmBinary: s
									}
								}, [s])
							} else e.postMessage({
								id: "init",
								decoder: {
									url: i
								}
							})
						}))
					}(new Worker(i), e, r.url)))
				})) : this._decoderModulePromise = r.wasmBinaryPromise.then((async e => {
					if ("undefined" == typeof DracoDecoderModule && !i.jsModule) {
						if (!r.url) throw new Error("Draco decoder module is not available");
						await dd.LoadBabylonScriptAsync(r.url)
					}
					return await (t = e, s = i.jsModule, new Promise((e => {
						(s || DracoDecoderModule)({
							wasmBinary: t
						}).then((t => {
							e({
								module: t
							})
						}))
					})));
					var t, s
				}))
			}
		}
		static get DecoderAvailable() {
			const t = e.Configuration.decoder;
			return !!(t.wasmUrl && t.wasmBinaryUrl && "object" == typeof WebAssembly || t.fallbackUrl)
		}
		async decodeMeshAsync(e, t) {
			const i = await this.decodeMeshToMeshDataAsync(e, t),
				s = new Mu;
			i.indices && (s.indices = i.indices);
			for (const e of i.attributes) {
				const t = eu.GetFloatData(e.data, e.size, eu.GetDataType(e.data), e.byteOffset, e.byteStride, e.normalized, i.totalVertices);
				s.set(t, e.kind)
			}
			return s
		}
		static ResetDefault(t) {
			e._Default && (t || e._Default.dispose(), e._Default = null)
		}
	};
	sb.Configuration = {
		decoder: {
			wasmUrl: `${dd._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,
			wasmBinaryUrl: `${dd._DefaultCdnUrl}/draco_decoder_gltf.wasm`,
			fallbackUrl: `${dd._DefaultCdnUrl}/draco_decoder_gltf.js`
		}
	}, sb.DefaultNumWorkers = sb.GetDefaultNumWorkers(), sb._Default = null;
	var nb = "KHR_draco_mesh_compression",
		ab = class {
			constructor(e) {
				this.name = nb, this.useNormalizedFlagFromAccessor = !0, this._loader = e, this.enabled = sb.DecoderAvailable && this._loader.isExtensionUsed(nb)
			}
			dispose() {
				delete this.dracoCompression, this._loader = null
			}
			_loadVertexDataAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					if (null != t.mode && 4 !== t.mode && 5 !== t.mode) throw new Error(`${e}: Unsupported mode ${t.mode}`);
					const a = {},
						r = {},
						o = (e, s) => {
							const o = n.attributes[e];
							if (null != o && (i._delayInfo = i._delayInfo || [], -1 === i._delayInfo.indexOf(s) && i._delayInfo.push(s), a[s] = o, this.useNormalizedFlagFromAccessor)) {
								const i = LA.TryGet(this._loader.gltf.accessors, t.attributes[e]);
								i && (r[s] = i.normalized || !1)
							}
						};
					o("POSITION", eu.PositionKind), o("NORMAL", eu.NormalKind), o("TANGENT", eu.TangentKind), o("TEXCOORD_0", eu.UVKind), o("TEXCOORD_1", eu.UV2Kind), o("TEXCOORD_2", eu.UV3Kind), o("TEXCOORD_3", eu.UV4Kind), o("TEXCOORD_4", eu.UV5Kind), o("TEXCOORD_5", eu.UV6Kind), o("JOINTS_0", eu.MatricesIndicesKind), o("WEIGHTS_0", eu.MatricesWeightsKind), o("COLOR_0", eu.ColorKind);
					const l = LA.Get(s, this._loader.gltf.bufferViews, n.bufferView);
					return l._dracoBabylonGeometry || (l._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${l.index}`, l).then((t => (this.dracoCompression || sb.Default)._decodeMeshToGeometryForGltfAsync(i.name, this._loader.babylonScene, t, a, r).catch((t => {
						throw new Error(`${e}: ${t.message}`)
					}))))), l._dracoBabylonGeometry
				}))
			}
		};
	BA.RegisterExtension(nb, (e => new ab(e)));
	var rb = "KHR_lights_punctual",
		ob = class {
			dispose() {
				this._loader = null, delete this._lights
			}
			onLoading() {
				const e = this._loader.gltf.extensions;
				if (e && e[this.name]) {
					const t = e[this.name];
					this._lights = t.lights, LA.Assign(this._lights)
				}
			}
			loadNodeAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => (this._loader._allMaterialsDirtyRequired = !0, this._loader.loadNodeAsync(e, t, (e => {
					let t;
					const a = LA.Get(s, this._lights, n.light),
						r = a.name || e.name;
					switch (this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer, a.type) {
						case "directional": {
							const e = new Tg(r, Lc.Backward(), this._loader.babylonScene);
							e.position.setAll(0), t = e;
							break
						}
						case "point":
							t = new IE(r, Lc.Zero(), this._loader.babylonScene);
							break;
						case "spot": {
							const e = new PE(r, Lc.Zero(), Lc.Backward(), 0, 1, this._loader.babylonScene);
							e.angle = 2 * (a.spot && a.spot.outerConeAngle || Math.PI / 4), e.innerAngle = 2 * (a.spot && a.spot.innerConeAngle || 0), t = e;
							break
						}
						default:
							throw this._loader.babylonScene._blockEntityCollection = !1, new Error(`${s}: Invalid light type (${a.type})`)
					}
					t._parentContainer = this._loader._assetContainer, this._loader.babylonScene._blockEntityCollection = !1, a._babylonLight = t, t.falloffType = xg.FALLOFF_GLTF, t.diffuse = a.color ? Tc.FromArray(a.color) : Tc.White(), t.intensity = null == a.intensity ? 1 : a.intensity, t.range = null == a.range ? Number.MAX_VALUE : a.range, t.parent = e, this._loader._babylonLights.push(t), BA.AddPointerMetadata(t, s), i(e)
				})))))
			}
			constructor(e) {
				this.name = rb, this._loader = e, this.enabled = this._loader.isExtensionUsed(rb)
			}
		};
	BA.RegisterExtension(rb, (e => new ob(e)));
	var lb = "KHR_materials_pbrSpecularGlossiness",
		hb = class {
			dispose() {
				this._loader = null
			}
			constructor(e) {
				this.name = lb, this.order = 200, this._loader = e, this.enabled = this._loader.isExtensionUsed(lb)
			}
			_loadSpecularGlossinessPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.metallic = null, i.roughness = null, t.diffuseFactor ? (i.albedoColor = Tc.FromArray(t.diffuseFactor), i.alpha = t.diffuseFactor[3]) : i.albedoColor = Tc.White(), i.reflectivityColor = t.specularFactor ? Tc.FromArray(t.specularFactor) : Tc.White(), i.microSurface = null == t.glossinessFactor ? 1 : t.glossinessFactor, t.diffuseTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/diffuseTexture`, t.diffuseTexture, (e => {
					e.name = `${i.name} (Diffuse)`, i.albedoTexture = e
				}))), t.specularGlossinessTexture && (s.push(this._loader.loadTextureInfoAsync(`${e}/specularGlossinessTexture`, t.specularGlossinessTexture, (e => {
					e.name = `${i.name} (Specular Glossiness)`, i.reflectivityTexture = e, i.reflectivityTexture.hasAlpha = !0
				}))), i.useMicroSurfaceFromReflectivityMapAlpha = !0), Promise.all(s).then((() => {}))
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialBasePropertiesAsync(e, t, i)), a.push(this._loadSpecularGlossinessPropertiesAsync(s, n, i)), this._loader.loadMaterialAlphaProperties(e, t, i), Promise.all(a).then((() => {}))
				}))
			}
		};
	BA.RegisterExtension(lb, (e => new hb(e)));
	var cb = "KHR_materials_unlit",
		ub = class {
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, (() => this._loadUnlitPropertiesAsync(e, t, i)))
			}
			dispose() {
				this._loader = null
			}
			constructor(e) {
				this.name = cb, this.order = 210, this._loader = e, this.enabled = this._loader.isExtensionUsed(cb)
			}
			_loadUnlitPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				i.unlit = !0;
				const n = t.pbrMetallicRoughness;
				return n && (n.baseColorFactor ? (i.albedoColor = Tc.FromArray(n.baseColorFactor), i.alpha = n.baseColorFactor[3]) : i.albedoColor = Tc.White(), n.baseColorTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/baseColorTexture`, n.baseColorTexture, (e => {
					e.name = `${i.name} (Base Color)`, i.albedoTexture = e
				})))), t.doubleSided && (i.backFaceCulling = !1, i.twoSidedLighting = !0), this._loader.loadMaterialAlphaProperties(e, t, i), Promise.all(s).then((() => {}))
			}
		};
	BA.RegisterExtension(cb, (e => new ub(e)));
	var mb = "KHR_materials_clearcoat",
		db = class {
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadClearCoatPropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
			constructor(e) {
				this.name = mb, this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(mb)
			}
			_loadClearCoatPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.clearCoat.isEnabled = !0, i.clearCoat.useRoughnessFromMainTexture = !1, i.clearCoat.remapF0OnInterfaceChange = !1, null != t.clearcoatFactor ? i.clearCoat.intensity = t.clearcoatFactor : i.clearCoat.intensity = 0, t.clearcoatTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/clearcoatTexture`, t.clearcoatTexture, (e => {
					e.name = `${i.name} (ClearCoat Intensity)`, i.clearCoat.texture = e
				}))), null != t.clearcoatRoughnessFactor ? i.clearCoat.roughness = t.clearcoatRoughnessFactor : i.clearCoat.roughness = 0, t.clearcoatRoughnessTexture && (t.clearcoatRoughnessTexture.nonColorData = !0, s.push(this._loader.loadTextureInfoAsync(`${e}/clearcoatRoughnessTexture`, t.clearcoatRoughnessTexture, (e => {
					e.name = `${i.name} (ClearCoat Roughness)`, i.clearCoat.textureRoughness = e
				})))), t.clearcoatNormalTexture && (t.clearcoatNormalTexture.nonColorData = !0, s.push(this._loader.loadTextureInfoAsync(`${e}/clearcoatNormalTexture`, t.clearcoatNormalTexture, (e => {
					e.name = `${i.name} (ClearCoat Normal)`, i.clearCoat.bumpTexture = e
				}))), i.invertNormalMapX = !i.getScene().useRightHandedSystem, i.invertNormalMapY = i.getScene().useRightHandedSystem, null != t.clearcoatNormalTexture.scale && (i.clearCoat.bumpTexture.level = t.clearcoatNormalTexture.scale)), Promise.all(s).then((() => {}))
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(mb, (e => new db(e)));
	var fb = "KHR_materials_iridescence",
		pb = class {
			dispose() {
				this._loader = null
			}
			_loadIridescencePropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.iridescence.isEnabled = !0, i.iridescence.intensity = t.iridescenceFactor ?? 0, i.iridescence.indexOfRefraction = t.iridescenceIor ?? t.iridescenceIOR ?? 1.3, i.iridescence.minimumThickness = t.iridescenceThicknessMinimum ?? 100, i.iridescence.maximumThickness = t.iridescenceThicknessMaximum ?? 400, t.iridescenceTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/iridescenceTexture`, t.iridescenceTexture, (e => {
					e.name = `${i.name} (Iridescence Intensity)`, i.iridescence.texture = e
				}))), t.iridescenceThicknessTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/iridescenceThicknessTexture`, t.iridescenceThicknessTexture, (e => {
					e.name = `${i.name} (Iridescence Thickness)`, i.iridescence.thicknessTexture = e
				}))), Promise.all(s).then((() => {}))
			}
			constructor(e) {
				this.name = fb, this.order = 195, this._loader = e, this.enabled = this._loader.isExtensionUsed(fb)
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadIridescencePropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
		};
	BA.RegisterExtension(fb, (e => new pb(e)));
	var _b = "KHR_materials_anisotropy",
		gb = class {
			constructor(e) {
				this.name = _b, this.order = 195, this._loader = e, this.enabled = this._loader.isExtensionUsed(_b)
			}
			dispose() {
				this._loader = null
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadIridescencePropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
			_loadIridescencePropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.anisotropy.isEnabled = !0, i.anisotropy.intensity = t.anisotropyStrength ?? 0, i.anisotropy.angle = t.anisotropyRotation ?? 0, t.anisotropyTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/anisotropyTexture`, t.anisotropyTexture, (e => {
					e.name = `${i.name} (Anisotropy Intensity)`, i.anisotropy.texture = e
				}))), Promise.all(s).then((() => {}))
			}
		};
	BA.RegisterExtension(_b, (e => new gb(e)));
	var vb = "KHR_materials_emissive_strength",
		yb = class {
			constructor(e) {
				this.name = vb, this.order = 170, this._loader = e, this.enabled = this._loader.isExtensionUsed(vb)
			}
			_loadEmissiveProperties(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				void 0 !== t.emissiveStrength && (i.emissiveIntensity = t.emissiveStrength)
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => this._loader.loadMaterialPropertiesAsync(e, t, i).then((() => {
					this._loadEmissiveProperties(s, n, i)
				}))))
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(vb, (e => new yb(e)));
	var Sb = "KHR_materials_sheen",
		Eb = class {
			_loadSheenPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return i.sheen.isEnabled = !0, i.sheen.intensity = 1, null != t.sheenColorFactor ? i.sheen.color = Tc.FromArray(t.sheenColorFactor) : i.sheen.color = Tc.Black(), t.sheenColorTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/sheenColorTexture`, t.sheenColorTexture, (e => {
					e.name = `${i.name} (Sheen Color)`, i.sheen.texture = e
				}))), void 0 !== t.sheenRoughnessFactor ? i.sheen.roughness = t.sheenRoughnessFactor : i.sheen.roughness = 0, t.sheenRoughnessTexture && (t.sheenRoughnessTexture.nonColorData = !0, s.push(this._loader.loadTextureInfoAsync(`${e}/sheenRoughnessTexture`, t.sheenRoughnessTexture, (e => {
					e.name = `${i.name} (Sheen Roughness)`, i.sheen.textureRoughness = e
				})))), i.sheen.albedoScaling = !0, i.sheen.useRoughnessFromMainTexture = !1, Promise.all(s).then((() => {}))
			}
			constructor(e) {
				this.name = Sb, this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(Sb)
			}
			dispose() {
				this._loader = null
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadSheenPropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
		};
	BA.RegisterExtension(Sb, (e => new Eb(e)));
	var Ab = "KHR_materials_specular",
		bb = class {
			_loadSpecularPropertiesAsync(e, t, i) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const s = new Array;
				return void 0 !== t.specularFactor && (i.metallicF0Factor = t.specularFactor), void 0 !== t.specularColorFactor && (i.metallicReflectanceColor = Tc.FromArray(t.specularColorFactor)), t.specularTexture && (t.specularTexture.nonColorData = !0, s.push(this._loader.loadTextureInfoAsync(`${e}/specularTexture`, t.specularTexture, (e => {
					e.name = `${i.name} (Specular F0 Strength)`, i.metallicReflectanceTexture = e, i.useOnlyMetallicFromMetallicReflectanceTexture = !0
				})))), t.specularColorTexture && s.push(this._loader.loadTextureInfoAsync(`${e}/specularColorTexture`, t.specularColorTexture, (e => {
					e.name = `${i.name} (Specular F0 Color)`, i.reflectanceTexture = e
				}))), Promise.all(s).then((() => {}))
			}
			dispose() {
				this._loader = null
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadSpecularPropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
			constructor(e) {
				this.name = Ab, this.order = 190, this._loader = e, this.enabled = this._loader.isExtensionUsed(Ab)
			}
		};
	BA.RegisterExtension(Ab, (e => new bb(e)));
	var xb = "KHR_materials_ior",
		Mb = class e {
			constructor(e) {
				this.name = xb, this.order = 180, this._loader = e, this.enabled = this._loader.isExtensionUsed(xb)
			}
			dispose() {
				this._loader = null
			}
			_loadIorPropertiesAsync(t, i, s) {
				if (!(s instanceof wA)) throw new Error(`${t}: Material type not supported`);
				return void 0 !== i.ior ? s.indexOfRefraction = i.ior : s.indexOfRefraction = e._DEFAULT_IOR, Promise.resolve()
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadIorPropertiesAsync(s, n, i)), Promise.all(a).then((() => {}))
				}))
			}
		};
	Mb._DEFAULT_IOR = 1.5, BA.RegisterExtension(xb, (e => new Mb(e)));
	var Cb = "KHR_materials_variants",
		Tb = class e {
			static Reset(e) {
				const t = this._GetExtensionMetadata(e);
				if (!t) throw new Error(`Cannot reset on a glTF mesh that does not have the ${Cb} extension`);
				for (const e of t.original) e.mesh.material = e.material;
				t.lastSelected = null
			}
			_loadMeshPrimitiveAsync(t, i, s, n, a, r) {
				return BA.LoadExtensionAsync(t, a, this.name, ((o, l) => {
					const h = new Array;
					return h.push(this._loader._loadMeshPrimitiveAsync(t, i, s, n, a, (i => {
						if (r(i), i instanceof Vf) {
							const s = BA._GetDrawMode(t, a.mode),
								n = this._loader.rootBabylonMesh,
								r = n ? n._internalMetadata = n._internalMetadata || {} : {},
								c = r.gltf = r.gltf || {},
								u = c[Cb] = c[Cb] || {
									lastSelected: null,
									original: [],
									variants: {}
								};
							u.original.push({
								mesh: i,
								material: i.material
							});
							for (let t = 0; t < l.mappings.length; ++t) {
								const a = l.mappings[t],
									r = LA.Get(`${o}/mappings/${t}/material`, this._loader.gltf.materials, a.material);
								h.push(this._loader._loadMaterialAsync(`#/materials/${a.material}`, r, i, s, (t => {
									for (let s = 0; s < a.variants.length; ++s) {
										const r = a.variants[s],
											o = LA.Get(`/extensions/${Cb}/variants/${r}`, this._variants, r);
										u.variants[o.name] = u.variants[o.name] || [], u.variants[o.name].push({
											mesh: i,
											material: t
										}), i.onClonedObservable.add((t => {
											const s = t;
											let a = null,
												r = s;
											do {
												if (r = r.parent, !r) return;
												a = e._GetExtensionMetadata(r)
											} while (null === a);
											if (n && a === e._GetExtensionMetadata(n)) {
												r._internalMetadata = {};
												for (const e in n._internalMetadata) r._internalMetadata[e] = n._internalMetadata[e];
												r._internalMetadata.gltf = [];
												for (const e in n._internalMetadata.gltf) r._internalMetadata.gltf[e] = n._internalMetadata.gltf[e];
												r._internalMetadata.gltf[Cb] = {
													lastSelected: null,
													original: [],
													variants: {}
												};
												for (const e of a.original) r._internalMetadata.gltf[Cb].original.push({
													mesh: e.mesh,
													material: e.material
												});
												for (const e in a.variants)
													if (Object.prototype.hasOwnProperty.call(a.variants, e)) {
														r._internalMetadata.gltf[Cb].variants[e] = [];
														for (const t of a.variants[e]) r._internalMetadata.gltf[Cb].variants[e].push({
															mesh: t.mesh,
															material: t.material
														})
													} a = r._internalMetadata.gltf[Cb]
											}
											for (const e of a.original) e.mesh === i && (e.mesh = s);
											for (const e of a.variants[o.name]) e.mesh === i && (e.mesh = s)
										}))
									}
								})))
							}
						}
					}))), Promise.all(h).then((([e]) => e))
				}))
			}
			constructor(e) {
				this.name = Cb, this._loader = e, this.enabled = this._loader.isExtensionUsed(Cb)
			}
			static SelectVariant(e, t) {
				const i = this._GetExtensionMetadata(e);
				if (!i) throw new Error(`Cannot select variant on a glTF mesh that does not have the ${Cb} extension`);
				const s = e => {
					const t = i.variants[e];
					if (t)
						for (const e of t) e.mesh.material = e.material
				};
				if (t instanceof Array)
					for (const e of t) s(e);
				else s(t);
				i.lastSelected = t
			}
			dispose() {
				this._loader = null
			}
			getAvailableVariants(t) {
				return e.GetAvailableVariants(t)
			}
			static GetAvailableVariants(e) {
				const t = this._GetExtensionMetadata(e);
				return t ? Object.keys(t.variants) : []
			}
			selectVariant(t, i) {
				e.SelectVariant(t, i)
			}
			reset(t) {
				e.Reset(t)
			}
			static _GetExtensionMetadata(e) {
				return e?._internalMetadata?.gltf?.[Cb] || null
			}
			static GetLastSelectedVariant(e) {
				const t = this._GetExtensionMetadata(e);
				if (!t) throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${Cb} extension`);
				return t.lastSelected
			}
			onLoading() {
				const e = this._loader.gltf.extensions;
				if (e && e[this.name]) {
					const t = e[this.name];
					this._variants = t.variants
				}
			}
			getLastSelectedVariant(t) {
				return e.GetLastSelectedVariant(t)
			}
		};
	BA.RegisterExtension(Cb, (e => new Tb(e)));
	var wb = class e {
			dispose() {
				this._scene._transmissionHelper = void 0, this._opaqueRenderTarget && (this._opaqueRenderTarget.dispose(), this._opaqueRenderTarget = null), this._transparentMeshesCache = [], this._opaqueMeshesCache = []
			}
			constructor(t, i) {
				this._opaqueRenderTarget = null, this._opaqueMeshesCache = [], this._transparentMeshesCache = [], this._materialObservers = {}, this._options = {
					...e._GetDefaultOptions(),
					...t
				}, this._scene = i, this._scene._transmissionHelper = this, this.onErrorObservable = new kc, this._scene.onDisposeObservable.addOnce((() => {
					this.dispose()
				})), this._parseScene(), this._setupRenderTargets()
			}
			getOpaqueTarget() {
				return this._opaqueRenderTarget
			}
			_setupRenderTargets() {
				let e, t;
				this._opaqueRenderTarget && this._opaqueRenderTarget.dispose(), this._opaqueRenderTarget = new r_("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, void 0, this._options.renderTargetTextureType), this._opaqueRenderTarget.ignoreCameraViewport = !0, this._opaqueRenderTarget.Tk = this._opaqueMeshesCache, this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone(), this._opaqueRenderTarget.gammaSpace = !1, this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale, this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset, this._opaqueRenderTarget.samples = this._options.samples, this._opaqueRenderTarget.renderSprites = !0, this._opaqueRenderTarget.renderParticles = !0, this._opaqueRenderTarget.onBeforeBindObservable.add((i => {
					t = this._scene.environmentIntensity, this._scene.environmentIntensity = 1, e = this._scene.imageProcessingConfiguration.applyByPostProcess, this._options.clearColor ? i.clearColor.copyFrom(this._options.clearColor) : this._scene.clearColor.toLinearSpaceToRef(i.clearColor, this._scene.getEngine().useExactSrgbConversions), this._scene.imageProcessingConfiguration._applyByPostProcess = !0
				})), this._opaqueRenderTarget.onAfterUnbindObservable.add((() => {
					this._scene.environmentIntensity = t, this._scene.imageProcessingConfiguration._applyByPostProcess = e
				})), this._transparentMeshesCache.forEach((e => {
					this._shouldRenderAsTransmission(e.material) && (e.material.refractionTexture = this._opaqueRenderTarget)
				}))
			}
			_isRenderTargetValid() {
				return null !== this._opaqueRenderTarget?.getInternalTexture()
			}
			static _GetDefaultOptions() {
				return {
					renderSize: 1024,
					samples: 4,
					lodGenerationScale: 1,
					lodGenerationOffset: -4,
					renderTargetTextureType: Jv.TEXTURETYPE_HALF_FLOAT,
					generateMipmaps: !0
				}
			}
			_shouldRenderAsTransmission(e) {
				return !!e && !!(e instanceof wA && e.subSurface.isRefractionEnabled)
			}
			updateOptions(e) {
				if (!Object.keys(e).filter((t => this._options[t] !== e[t])).length) return;
				const t = {
						...this._options,
						...e
					},
					i = this._options;
				this._options = t, t.renderSize === i.renderSize && t.renderTargetTextureType === i.renderTargetTextureType && t.generateMipmaps === i.generateMipmaps && this._opaqueRenderTarget ? (this._opaqueRenderTarget.samples = t.samples, this._opaqueRenderTarget.lodGenerationScale = t.lodGenerationScale, this._opaqueRenderTarget.lodGenerationOffset = t.lodGenerationOffset) : this._setupRenderTargets()
			}
			_removeMesh(e) {
				e.onMaterialChangedObservable.remove(this._materialObservers[e.ik]), delete this._materialObservers[e.ik];
				let t = this._transparentMeshesCache.indexOf(e); - 1 !== t && this._transparentMeshesCache.splice(t, 1), t = this._opaqueMeshesCache.indexOf(e), -1 !== t && this._opaqueMeshesCache.splice(t, 1)
			}
			_parseScene() {
				this._scene.meshes.forEach(this._addMesh.bind(this)), this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)), this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this))
			}
			_onMeshMaterialChanged(e) {
				const t = this._transparentMeshesCache.indexOf(e),
					i = this._opaqueMeshesCache.indexOf(e);
				this._shouldRenderAsTransmission(e.material) ? (e.material instanceof wA && (e.material.subSurface.refractionTexture = this._opaqueRenderTarget), -1 !== i ? (this._opaqueMeshesCache.splice(i, 1), this._transparentMeshesCache.push(e)) : -1 === t && this._transparentMeshesCache.push(e)) : -1 !== t ? (this._transparentMeshesCache.splice(t, 1), this._opaqueMeshesCache.push(e)) : -1 === i && this._opaqueMeshesCache.push(e)
			}
			_addMesh(e) {
				this._materialObservers[e.ik] = e.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this)), dd.SetImmediate((() => {
					this._shouldRenderAsTransmission(e.material) ? (e.material.refractionTexture = this._opaqueRenderTarget, -1 === this._transparentMeshesCache.indexOf(e) && this._transparentMeshesCache.push(e)) : -1 === this._opaqueMeshesCache.indexOf(e) && this._opaqueMeshesCache.push(e)
				}))
			}
		},
		Rb = "KHR_materials_transmission",
		Nb = class {
			dispose() {
				this._loader = null
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialBasePropertiesAsync(e, t, i)), a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadTransparentPropertiesAsync(s, t, i, n)), Promise.all(a).then((() => {}))
				}))
			}
			constructor(e) {
				this.name = Rb, this.order = 175, this._loader = e, this.enabled = this._loader.isExtensionUsed(Rb), this.enabled && (e.parent.transparencyAsCoverage = !0)
			}
			_loadTransparentPropertiesAsync(e, t, i, s) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const n = i;
				if (n.subSurface.isRefractionEnabled = !0, n.subSurface.volumeIndexOfRefraction = 1, n.subSurface.useAlbedoToTintRefraction = !0, void 0 === s.transmissionFactor) return n.subSurface.refractionIntensity = 0, n.subSurface.isRefractionEnabled = !1, Promise.resolve();
				{
					n.subSurface.refractionIntensity = s.transmissionFactor;
					const e = n.getScene();
					n.subSurface.refractionIntensity && !e._transmissionHelper ? new wb({}, n.getScene()) : n.subSurface.refractionIntensity && !e._transmissionHelper?._isRenderTargetValid() && e._transmissionHelper?._setupRenderTargets()
				}
				return n.subSurface.minimumThickness = 0, n.subSurface.maximumThickness = 0, s.transmissionTexture ? (s.transmissionTexture.nonColorData = !0, this._loader.loadTextureInfoAsync(`${e}/transmissionTexture`, s.transmissionTexture, void 0).then((e => {
					n.subSurface.refractionIntensityTexture = e, n.subSurface.useGltfStyleTextures = !0
				}))) : Promise.resolve()
			}
		};
	BA.RegisterExtension(Rb, (e => new Nb(e)));
	var Ib = "KHR_materials_diffuse_transmission",
		Pb = class {
			constructor(e) {
				this.name = Ib, this.order = 174, this._loader = e, this.enabled = this._loader.isExtensionUsed(Ib), this.enabled && (e.parent.transparencyAsCoverage = !0)
			}
			_loadTranslucentPropertiesAsync(e, t, i, s) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				const n = i;
				if (n.subSurface.isTranslucencyEnabled = !0, n.subSurface.volumeIndexOfRefraction = 1, n.subSurface.minimumThickness = 0, n.subSurface.maximumThickness = 0, n.subSurface.useAlbedoToTintTranslucency = !1, void 0 === s.diffuseTransmissionFactor) return n.subSurface.translucencyIntensity = 0, n.subSurface.isTranslucencyEnabled = !1, Promise.resolve();
				n.subSurface.translucencyIntensity = s.diffuseTransmissionFactor;
				const a = new Array;
				return n.subSurface.useGltfStyleTextures = !0, s.diffuseTransmissionTexture && (s.diffuseTransmissionTexture.nonColorData = !0, a.push(this._loader.loadTextureInfoAsync(`${e}/diffuseTransmissionTexture`, s.diffuseTransmissionTexture).then((e => {
					n.subSurface.translucencyIntensityTexture = e
				})))), void 0 !== s.diffuseTransmissionColorFactor ? n.subSurface.translucencyColor = Tc.FromArray(s.diffuseTransmissionColorFactor) : n.subSurface.translucencyColor = Tc.White(), s.diffuseTransmissionColorTexture && a.push(this._loader.loadTextureInfoAsync(`${e}/diffuseTransmissionColorTexture`, s.diffuseTransmissionColorTexture).then((e => {
					n.subSurface.translucencyColorTexture = e
				}))), Promise.all(a).then((() => {}))
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialBasePropertiesAsync(e, t, i)), a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadTranslucentPropertiesAsync(s, t, i, n)), Promise.all(a).then((() => {}))
				}))
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(Ib, (e => new Pb(e)));
	var kb = "KHR_materials_volume",
		Db = class {
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialBasePropertiesAsync(e, t, i)), a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadVolumePropertiesAsync(s, t, i, n)), Promise.all(a).then((() => {}))
				}))
			}
			_loadVolumePropertiesAsync(e, t, i, s) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				if (!i.subSurface.isRefractionEnabled && !i.subSurface.isTranslucencyEnabled || !s.thicknessFactor) return Promise.resolve();
				i.subSurface.volumeIndexOfRefraction = i.indexOfRefraction;
				const n = void 0 !== s.attenuationDistance ? s.attenuationDistance : Number.MAX_VALUE;
				return i.subSurface.tintColorAtDistance = n, void 0 !== s.attenuationColor && 3 == s.attenuationColor.length && i.subSurface.tintColor.copyFromFloats(s.attenuationColor[0], s.attenuationColor[1], s.attenuationColor[2]), i.subSurface.minimumThickness = 0, i.subSurface.maximumThickness = s.thicknessFactor, i.subSurface.useThicknessAsDepth = !0, s.thicknessTexture ? (s.thicknessTexture.nonColorData = !0, this._loader.loadTextureInfoAsync(`${e}/thicknessTexture`, s.thicknessTexture).then((e => {
					i.subSurface.thicknessTexture = e, i.subSurface.useGltfStyleTextures = !0
				}))) : Promise.resolve()
			}
			dispose() {
				this.enabled && this._loader._disableInstancedMesh--, this._loader = null
			}
			constructor(e) {
				this.name = kb, this.order = 173, this._loader = e, this.enabled = this._loader.isExtensionUsed(kb), this.enabled && this._loader._disableInstancedMesh++
			}
		};
	BA.RegisterExtension(kb, (e => new Db(e)));
	var Ob = "KHR_materials_dispersion",
		Fb = class {
			_loadDispersionPropertiesAsync(e, t, i, s) {
				if (!(i instanceof wA)) throw new Error(`${e}: Material type not supported`);
				return i.subSurface.isRefractionEnabled && s.dispersion ? (i.subSurface.isDispersionEnabled = !0, i.subSurface.dispersion = s.dispersion, Promise.resolve()) : Promise.resolve()
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = new Array;
					return a.push(this._loader.loadMaterialBasePropertiesAsync(e, t, i)), a.push(this._loader.loadMaterialPropertiesAsync(e, t, i)), a.push(this._loadDispersionPropertiesAsync(s, t, i, n)), Promise.all(a).then((() => {}))
				}))
			}
			dispose() {
				this._loader = null
			}
			constructor(e) {
				this.name = Ob, this.order = 174, this._loader = e, this.enabled = this._loader.isExtensionUsed(Ob)
			}
		};
	BA.RegisterExtension(Ob, (e => new Fb(e)));
	var Lb = "KHR_mesh_quantization",
		Bb = class {
			constructor(e) {
				this.name = Lb, this.enabled = e.isExtensionUsed(Lb)
			}
			dispose() {}
		};
	BA.RegisterExtension(Lb, (e => new Bb(e)));
	var Gb = "KHR_texture_basisu",
		Hb = class {
			dispose() {
				this._loader = null
			}
			_loadTextureAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => {
					const a = null == t.sampler ? BA.DefaultSampler : LA.Get(`${e}/sampler`, this._loader.gltf.samplers, t.sampler),
						r = LA.Get(`${s}/source`, this._loader.gltf.images, n.source);
					return this._loader._createTextureAsync(e, a, r, (e => {
						i(e)
					}), t._textureInfo.nonColorData ? {
						useRGBAIfASTCBC7NotAvailableWhenUASTC: !0
					} : void 0, !t._textureInfo.nonColorData)
				}))
			}
			constructor(e) {
				this.name = Gb, this._loader = e, this.enabled = e.isExtensionUsed(Gb)
			}
		};
	BA.RegisterExtension(Gb, (e => new Hb(e)));
	var Ub = "KHR_texture_transform",
		Vb = class {
			loadTextureInfoAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((s, n) => this._loader.loadTextureInfoAsync(e, t, (e => {
					if (!(e instanceof Np)) throw new Error(`${s}: Texture type not supported`);
					n.offset && (e.uOffset = n.offset[0], e.vOffset = n.offset[1]), e.uRotationCenter = 0, e.vRotationCenter = 0, n.rotation && (e.wAng = -n.rotation), n.scale && (e.uScale = n.scale[0], e.vScale = n.scale[1]), null != n.texCoord && (e.coordinatesIndex = n.texCoord), i(e)
				}))))
			}
			constructor(e) {
				this.name = Ub, this._loader = e, this.enabled = this._loader.isExtensionUsed(Ub)
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(Ub, (e => new Vb(e)));
	var Wb = "KHR_xmp_json_ld",
		zb = class {
			onLoading() {
				if (null === this._loader.rootBabylonMesh) return;
				const e = this._loader.gltf.extensions?.KHR_xmp_json_ld,
					t = this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld;
				if (e && t) {
					const i = +t.packet;
					e.packets && i < e.packets.length && (this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {}, this._loader.rootBabylonMesh.metadata.xmp = e.packets[i])
				}
			}
			dispose() {
				this._loader = null
			}
			constructor(e) {
				this.name = Wb, this.order = 100, this._loader = e, this.enabled = this._loader.isExtensionUsed(Wb)
			}
		};

	function Xb(e, t, i, s) {
		return Tc.FromArray(t, i).scale(s)
	}

	function Yb(e, t, i, s) {
		return t[i] * s
	}

	function jb(e, t, i, s) {
		return -t[i] * s
	}

	function Kb(e, t, i, s) {
		return t[i + 1] * s
	}

	function $b(e, t, i, s) {
		return t[i] * s * 2
	}

	function Jb(e) {
		return {
			scale: [new Qb(Wg.ANIMATIONTYPE_FLOAT, `${e}.uScale`, Yb, (() => 2)), new Qb(Wg.ANIMATIONTYPE_FLOAT, `${e}.vScale`, Kb, (() => 2))],
			offset: [new Qb(Wg.ANIMATIONTYPE_FLOAT, `${e}.uOffset`, Yb, (() => 2)), new Qb(Wg.ANIMATIONTYPE_FLOAT, `${e}.vOffset`, Kb, (() => 2))],
			rotation: [new Qb(Wg.ANIMATIONTYPE_FLOAT, `${e}.wAng`, jb, (() => 1))]
		}
	}
	BA.RegisterExtension(Wb, (e => new zb(e)));
	var qb = class extends kA {
			buildAnimations(e, t, i, s, n) {
				n(e._babylonCamera, this._buildAnimation(t, i, s))
			}
		},
		Qb = class extends kA {
			buildAnimations(e, t, i, s, n) {
				for (const a in e._data) n(e._data[a].babylonMaterial, this._buildAnimation(t, i, s))
			}
		},
		Zb = class extends kA {
			buildAnimations(e, t, i, s, n) {
				n(e._babylonLight, this._buildAnimation(t, i, s))
			}
		},
		ex = {
			__array__: {
				__target__: !0,
				...OA
			}
		},
		tx = {
			__array__: {
				__target__: !0,
				orthographic: {
					xmag: [new qb(Wg.ANIMATIONTYPE_FLOAT, "orthoLeft", jb, (() => 1)), new qb(Wg.ANIMATIONTYPE_FLOAT, "orthoRight", Kb, (() => 1))],
					ymag: [new qb(Wg.ANIMATIONTYPE_FLOAT, "orthoBottom", jb, (() => 1)), new qb(Wg.ANIMATIONTYPE_FLOAT, "orthoTop", Kb, (() => 1))],
					zfar: [new qb(Wg.ANIMATIONTYPE_FLOAT, "maxZ", Yb, (() => 1))],
					znear: [new qb(Wg.ANIMATIONTYPE_FLOAT, "minZ", Yb, (() => 1))]
				},
				perspective: {
					yfov: [new qb(Wg.ANIMATIONTYPE_FLOAT, "fov", Yb, (() => 1))],
					zfar: [new qb(Wg.ANIMATIONTYPE_FLOAT, "maxZ", Yb, (() => 1))],
					znear: [new qb(Wg.ANIMATIONTYPE_FLOAT, "minZ", Yb, (() => 1))]
				}
			}
		},
		ix = {
			nodes: ex,
			materials: {
				__array__: {
					__target__: !0,
					pbrMetallicRoughness: {
						baseColorFactor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "albedoColor", Xb, (() => 4)), new Qb(Wg.ANIMATIONTYPE_FLOAT, "alpha", (function(e, t, i, s) {
							return t[i + 3] * s
						}), (() => 4))],
						metallicFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "metallic", Yb, (() => 1))],
						roughnessFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "roughness", Yb, (() => 1))],
						baseColorTexture: {
							extensions: {
								KHR_texture_transform: Jb("albedoTexture")
							}
						},
						metallicRoughnessTexture: {
							extensions: {
								KHR_texture_transform: Jb("metallicTexture")
							}
						}
					},
					emissiveFactor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "emissiveColor", Xb, (() => 3))],
					normalTexture: {
						scale: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "bumpTexture.level", Yb, (() => 1))],
						extensions: {
							KHR_texture_transform: Jb("bumpTexture")
						}
					},
					occlusionTexture: {
						strength: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", Yb, (() => 1))],
						extensions: {
							KHR_texture_transform: Jb("ambientTexture")
						}
					},
					emissiveTexture: {
						extensions: {
							KHR_texture_transform: Jb("emissiveTexture")
						}
					},
					extensions: {
						KHR_materials_anisotropy: {
							anisotropyStrength: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "anisotropy.intensity", Yb, (() => 1))],
							anisotropyRotation: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "anisotropy.angle", Yb, (() => 1))],
							anisotropyTexture: {
								extensions: {
									KHR_texture_transform: Jb("anisotropy.texture")
								}
							}
						},
						KHR_materials_clearcoat: {
							clearcoatFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", Yb, (() => 1))],
							clearcoatRoughnessFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", Yb, (() => 1))],
							clearcoatTexture: {
								extensions: {
									KHR_texture_transform: Jb("clearCoat.texture")
								}
							},
							clearcoatNormalTexture: {
								scale: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "clearCoat.bumpTexture.level", Yb, (() => 1))],
								extensions: {
									KHR_texture_transform: Jb("clearCoat.bumpTexture")
								}
							},
							clearcoatRoughnessTexture: {
								extensions: {
									KHR_texture_transform: Jb("clearCoat.textureRoughness")
								}
							}
						},
						KHR_materials_dispersion: {
							dispersion: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "subSurface.dispersion", Yb, (() => 1))]
						},
						KHR_materials_emissive_strength: {
							emissiveStrength: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "emissiveIntensity", Yb, (() => 1))]
						},
						KHR_materials_ior: {
							ior: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "indexOfRefraction", Yb, (() => 1))]
						},
						KHR_materials_iridescence: {
							iridescenceFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "iridescence.intensity", Yb, (() => 1))],
							iridescenceIor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", Yb, (() => 1))],
							iridescenceThicknessMinimum: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", Yb, (() => 1))],
							iridescenceThicknessMaximum: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", Yb, (() => 1))],
							iridescenceTexture: {
								extensions: {
									KHR_texture_transform: Jb("iridescence.texture")
								}
							},
							iridescenceThicknessTexture: {
								extensions: {
									KHR_texture_transform: Jb("iridescence.thicknessTexture")
								}
							}
						},
						KHR_materials_sheen: {
							sheenColorFactor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "sheen.color", Xb, (() => 3))],
							sheenRoughnessFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "sheen.roughness", Yb, (() => 1))],
							sheenColorTexture: {
								extensions: {
									KHR_texture_transform: Jb("sheen.texture")
								}
							},
							sheenRoughnessTexture: {
								extensions: {
									KHR_texture_transform: Jb("sheen.textureRoughness")
								}
							}
						},
						KHR_materials_specular: {
							specularFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "metallicF0Factor", Yb, (() => 1))],
							specularColorFactor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", Xb, (() => 3))],
							specularTexture: {
								extensions: {
									KHR_texture_transform: Jb("metallicReflectanceTexture")
								}
							},
							specularColorTexture: {
								extensions: {
									KHR_texture_transform: Jb("reflectanceTexture")
								}
							}
						},
						KHR_materials_transmission: {
							transmissionFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", Yb, (() => 1))],
							transmissionTexture: {
								extensions: {
									KHR_texture_transform: Jb("subSurface.refractionIntensityTexture")
								}
							}
						},
						KHR_materials_volume: {
							attenuationColor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", Xb, (() => 3))],
							attenuationDistance: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", Yb, (() => 1))],
							thicknessFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", Yb, (() => 1))],
							thicknessTexture: {
								extensions: {
									KHR_texture_transform: Jb("subSurface.thicknessTexture")
								}
							}
						},
						KHR_materials_diffuse_transmission: {
							diffuseTransmissionFactor: [new Qb(Wg.ANIMATIONTYPE_FLOAT, "subSurface.translucencyIntensity", Yb, (() => 1))],
							diffuseTransmissionTexture: {
								extensions: {
									KHR_texture_transform: Jb("subSurface.translucencyIntensityTexture")
								}
							},
							diffuseTransmissionColorFactor: [new Qb(Wg.ANIMATIONTYPE_COLOR3, "subSurface.translucencyColor", Xb, (() => 3))],
							diffuseTransmissionColorTexture: {
								extensions: {
									KHR_texture_transform: Jb("subSurface.translucencyColorTexture")
								}
							}
						}
					}
				}
			},
			cameras: tx,
			extensions: {
				KHR_lights_punctual: {
					lights: {
						__array__: {
							__target__: !0,
							color: [new Zb(Wg.ANIMATIONTYPE_COLOR3, "diffuse", Xb, (() => 3))],
							intensity: [new Zb(Wg.ANIMATIONTYPE_FLOAT, "intensity", Yb, (() => 1))],
							range: [new Zb(Wg.ANIMATIONTYPE_FLOAT, "range", Yb, (() => 1))],
							spot: {
								innerConeAngle: [new Zb(Wg.ANIMATIONTYPE_FLOAT, "innerAngle", $b, (() => 1))],
								outerConeAngle: [new Zb(Wg.ANIMATIONTYPE_FLOAT, "angle", $b, (() => 1))]
							}
						}
					}
				}
			}
		},
		sx = class {
			constructor(e, t) {
				this._gltf = e, this._infoTree = t
			}
			convert(e) {
				let t, i = this._gltf,
					s = this._infoTree;
				if (!e.startsWith("/")) throw new Error("Path must start with a /");
				const n = e.split("/");
				n.shift();
				for (const a of n) {
					if (s.__array__) s = s.__array__;
					else if (s = s[a], !s) throw new Error(`Path ${e} is invalid`);
					if (void 0 === i) throw new Error(`Path ${e} is invalid`);
					i = i[a], s.__target__ && (t = i)
				}
				return {
					object: t,
					info: s
				}
			}
		},
		nx = "KHR_animation_pointer",
		ax = class extends sx {
			constructor(e) {
				super(e, ix)
			}
		},
		rx = class {
			get enabled() {
				return this._loader.isExtensionUsed(nx)
			}
			constructor(e) {
				this.name = nx, this._loader = e, this._pathToObjectConverter = new ax(this._loader.gltf)
			}
			dispose() {
				this._loader = null, delete this._pathToObjectConverter
			}
			_loadAnimationChannelAsync(e, t, i, s, n) {
				const a = s.target.extensions?.KHR_animation_pointer;
				if (!a || !this._pathToObjectConverter) return null;
				"pointer" !== s.target.path && Qc.Warn(`${e}/target/path: Value (${s.target.path}) must be (pointer) when using the ${this.name} extension`), null != s.target.node && Qc.Warn(`${e}/target/node: Value (${s.target.node}) must not be present when using the ${this.name} extension`);
				const r = `${e}/extensions/${this.name}`,
					o = a.pointer;
				if (!o) throw new Error(`${r}: Pointer is missing`);
				try {
					const a = this._pathToObjectConverter.convert(o);
					return this._loader._loadAnimationChannelFromTargetInfoAsync(e, t, i, s, a, n)
				} catch (e) {
					return Qc.Warn(`${r}/pointer: Invalid pointer (${o}) skipped`), null
				}
			}
		};
	BA.RegisterExtension(nx, (e => new rx(e)));
	var ox = class e {
		getClassName() {
			return "Sound"
		}
		connectToSoundTrackAudioNode(e) {
			Fd.audioEngine?.canUseWebAudio && this._outputAudioNode && (this._isOutputConnected && this._outputAudioNode.disconnect(), this._outputAudioNode.connect(e), this._isOutputConnected = !0)
		}
		setAttenuationFunction(e) {
			this._customAttenuationFunction = e
		}
		attachToMesh(e) {
			this._connectedTransformNode && this._registerFunc && (this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null), this._connectedTransformNode = e, this._spatialSound || (this._spatialSound = !0, this._createSpatialParameters(), this.isPlaying && this.loop && (this.stop(), this.play(0, this._offset, this._length))), this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode), this._registerFunc = e => this._onRegisterAfterWorldMatrixUpdate(e), this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc)
		}
		setVolume(e, t) {
			Fd.audioEngine?.canUseWebAudio && this._soundGain && (t && Fd.audioEngine.audioContext ? (this._soundGain.gain.cancelScheduledValues(Fd.audioEngine.audioContext.currentTime), this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Fd.audioEngine.audioContext.currentTime), this._soundGain.gain.linearRampToValueAtTime(e, Fd.audioEngine.audioContext.currentTime + t)) : this._soundGain.gain.value = e), this._volume = e
		}
		get loop() {
			return this._loop
		}
		get currentTime() {
			if (this._htmlAudioElement) return this._htmlAudioElement.currentTime;
			if (Fd.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {
				const e = this.isPaused ? 0 : Fd.audioEngine.audioContext.currentTime - this._startTime;
				return this._currentTime + e
			}
			return 0
		}
		_onended() {
			this.isPlaying = !1, this._startTime = 0, this._currentTime = 0, this.onended && this.onended(), this.onEndedObservable.notifyObservers(this)
		}
		set spatialSound(e) {
			if (e == this._spatialSound) return;
			const t = this.isPlaying;
			this.pause(), e ? (this._spatialSound = e, this._updateSpatialParameters()) : this._disableSpatialSound(), t && this.play()
		}
		isReady() {
			return this._isReadyToPlay
		}
		switchPanningModelToEqualPower() {
			this._panningModel = "equalpower", this._switchPanningModel()
		}
		_setOffset(e) {
			this._offset !== e && (this.isPaused && (this.stop(), this.isPaused = !1), this._offset = e)
		}
		constructor(t, i, s, n = null, a) {
			if (this.autoplay = !1, this._loop = !1, this.useCustomAttenuation = !1, this.isPlaying = !1, this.isPaused = !1, this.refDistance = 1, this.rolloffFactor = 1, this.maxDistance = 100, this.distanceModel = "linear", this.metadata = null, this.onEndedObservable = new kc, this._spatialSound = !1, this._panningModel = "equalpower", this._playbackRate = 1, this._streaming = !1, this._startTime = 0, this._currentTime = 0, this._position = Lc.Zero(), this._localDirection = new Lc(1, 0, 0), this._volume = 1, this._isReadyToPlay = !1, this._isDirectional = !1, this._coneInnerAngle = 360, this._coneOuterAngle = 360, this._coneOuterGain = 0, this._isOutputConnected = !1, this._urlType = "Unknown", this.name = t, s = s || Dc.LastCreatedScene)
				if (this._scene = s, e._SceneComponentInitialization(s), this._readyToPlayCallback = n, this._customAttenuationFunction = (e, t, i, s, n) => t < i ? e * (1 - t / i) : 0, a && (this.autoplay = a.autoplay || !1, this._loop = a.loop || !1, void 0 !== a.volume && (this._volume = a.volume), this._spatialSound = a.spatialSound ?? !1, this.maxDistance = a.maxDistance ?? 100, this.useCustomAttenuation = a.useCustomAttenuation ?? !1, this.rolloffFactor = a.rolloffFactor || 1, this.refDistance = a.refDistance || 1, this.distanceModel = a.distanceModel || "linear", this._playbackRate = a.playbackRate || 1, this._streaming = a.streaming ?? !1, this._length = a.length, this._offset = a.offset), Fd.audioEngine?.canUseWebAudio && Fd.audioEngine.audioContext) {
					this._soundGain = Fd.audioEngine.audioContext.createGain(), this._soundGain.gain.value = this._volume, this._inputAudioNode = this._soundGain, this._outputAudioNode = this._soundGain, this._spatialSound && this._createSpatialParameters(), this._scene.mainSoundTrack.addSound(this);
					let e = !0;
					if (i) try {
						"string" == typeof i ? (this._urlType = "String", this._url = i) : i instanceof ArrayBuffer ? this._urlType = "ArrayBuffer" : i instanceof HTMLMediaElement ? this._urlType = "MediaElement" : i instanceof MediaStream ? this._urlType = "MediaStream" : i instanceof AudioBuffer ? this._urlType = "AudioBuffer" : Array.isArray(i) && (this._urlType = "Array");
						let t = [],
							s = !1;
						switch (this._urlType) {
							case "MediaElement":
								this._streaming = !0, this._isReadyToPlay = !0, this._streamingSource = Fd.audioEngine.audioContext.createMediaElementSource(i), this.autoplay && this.play(0, this._offset, this._length), this._readyToPlayCallback && this._readyToPlayCallback();
								break;
							case "MediaStream":
								this._streaming = !0, this._isReadyToPlay = !0, this._streamingSource = Fd.audioEngine.audioContext.createMediaStreamSource(i), this.autoplay && this.play(0, this._offset, this._length), this._readyToPlayCallback && this._readyToPlayCallback();
								break;
							case "ArrayBuffer":
								i.byteLength > 0 && (s = !0, this._soundLoaded(i));
								break;
							case "AudioBuffer":
								this._audioBufferLoaded(i);
								break;
							case "String":
								t.push(i);
							case "Array":
								0 === t.length && (t = i);
								for (let e = 0; e < t.length; e++) {
									const i = t[e];
									if (s = a && a.skipCodecCheck || -1 !== i.indexOf(".mp3", i.length - 4) && Fd.audioEngine.isMP3supported || -1 !== i.indexOf(".ogg", i.length - 4) && Fd.audioEngine.isOGGsupported || -1 !== i.indexOf(".wav", i.length - 4) || -1 !== i.indexOf(".m4a", i.length - 4) || -1 !== i.indexOf(".mp4", i.length - 4) || -1 !== i.indexOf("blob:"), s) {
										this._streaming ? (this._htmlAudioElement = new Audio(i), this._htmlAudioElement.controls = !1, this._htmlAudioElement.loop = this.loop, dd.SetCorsBehavior(i, this._htmlAudioElement), this._htmlAudioElement.preload = "auto", this._htmlAudioElement.addEventListener("canplaythrough", (() => {
											this._isReadyToPlay = !0, this.autoplay && this.play(0, this._offset, this._length), this._readyToPlayCallback && this._readyToPlayCallback()
										})), document.body.appendChild(this._htmlAudioElement), this._htmlAudioElement.load()) : this._scene._loadFile(i, (e => {
											this._soundLoaded(e)
										}), void 0, !0, !0, (e => {
											e && Qc.Error("XHR " + e.status + " error on: " + i + "."), Qc.Error("Sound creation aborted."), this._scene.mainSoundTrack.removeSound(this)
										}));
										break
									}
								}
								break;
							default:
								e = !1
						}
						e ? s || (this._isReadyToPlay = !0, this._readyToPlayCallback && setTimeout((() => {
							this._readyToPlayCallback && this._readyToPlayCallback()
						}), 1e3)) : Qc.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.")
					} catch (e) {
						Qc.Error("Unexpected error. Sound creation aborted."), this._scene.mainSoundTrack.removeSound(this)
					}
				} else this._scene.mainSoundTrack.addSound(this), Fd.audioEngine && !Fd.audioEngine.WarnedWebAudioUnsupported && (Qc.Error("Web Audio is not supported by your browser."), Fd.audioEngine.WarnedWebAudioUnsupported = !0), this._readyToPlayCallback && setTimeout((() => {
					this._readyToPlayCallback && this._readyToPlayCallback()
				}), 1e3)
		}
		setPlaybackRate(e) {
			this._playbackRate = e, this.isPlaying && (this._streaming && this._htmlAudioElement ? this._htmlAudioElement.playbackRate = this._playbackRate : this._soundSource && (this._soundSource.playbackRate.value = this._playbackRate))
		}
		setDirectionalCone(e, t, i) {
			t < e ? Qc.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.") : (this._coneInnerAngle = e, this._coneOuterAngle = t, this._coneOuterGain = i, this._isDirectional = !0, this.isPlaying && this.loop && (this.stop(), this.play(0, this._offset, this._length)))
		}
		get directionalConeInnerAngle() {
			return this._coneInnerAngle
		}
		stop(e) {
			if (this.isPlaying)
				if (this._clearTimeoutsAndObservers(), this._streaming) this._htmlAudioElement ? (this._htmlAudioElement.pause(), this._htmlAudioElement.currentTime > 0 && (this._htmlAudioElement.currentTime = 0)) : this._streamingSource.disconnect(), this.isPlaying = !1;
				else if (Fd.audioEngine?.audioContext && this._soundSource) {
				const t = e ? Fd.audioEngine.audioContext.currentTime + e : void 0;
				this._soundSource.onended = () => {
					this.isPlaying = !1, this.isPaused = !1, this._startTime = 0, this._currentTime = 0, this._soundSource && (this._soundSource.onended = () => {}), this._onended()
				}, this._soundSource.stop(t)
			} else this.isPlaying = !1;
			else this.isPaused && (this.isPaused = !1, this._startTime = 0, this._currentTime = 0)
		}
		detachFromMesh() {
			this._connectedTransformNode && this._registerFunc && (this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null, this._connectedTransformNode = null)
		}
		static Parse(t, i, s, n) {
			const a = t.name;
			let r;
			r = t.url ? s + t.url : s + a;
			const o = {
				autoplay: t.autoplay,
				loop: t.loop,
				volume: t.volume,
				spatialSound: t.spatialSound,
				maxDistance: t.maxDistance,
				rolloffFactor: t.rolloffFactor,
				refDistance: t.refDistance,
				distanceModel: t.distanceModel,
				playbackRate: t.playbackRate
			};
			let l;
			if (n) {
				const t = () => {
					n._isReadyToPlay ? (l._audioBuffer = n.getAudioBuffer(), l._isReadyToPlay = !0, l.autoplay && l.play(0, l._offset, l._length)) : setTimeout(t, 300)
				};
				l = new e(a, new ArrayBuffer(0), i, null, o), t()
			} else l = new e(a, r, i, (() => {
				i.removePendingData(l)
			}), o), i.addPendingData(l);
			if (t.position) {
				const e = Lc.FromArray(t.position);
				l.setPosition(e)
			}
			if (t.isDirectional && (l.setDirectionalCone(t.coneInnerAngle || 360, t.coneOuterAngle || 360, t.coneOuterGain || 0), t.localDirectionToMesh)) {
				const e = Lc.FromArray(t.localDirectionToMesh);
				l.setLocalDirectionToMesh(e)
			}
			if (t.connectedMeshId) {
				const e = i.getMeshById(t.connectedMeshId);
				e && l.attachToMesh(e)
			}
			return t.metadata && (l.metadata = t.metadata), l
		}
		set directionalConeInnerAngle(e) {
			if (e != this._coneInnerAngle) {
				if (this._coneOuterAngle < e) return void Qc.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
				this._coneInnerAngle = e, Fd.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && (this._soundPanner.coneInnerAngle = this._coneInnerAngle)
			}
		}
		getSoundSource() {
			return this._soundSource
		}
		_onRegisterAfterWorldMatrixUpdate(e) {
			if (e.getBoundingInfo) {
				const t = e.getBoundingInfo();
				this.setPosition(t.boundingSphere.centerWorld)
			} else this.setPosition(e.absolutePosition);
			Fd.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying && this._updateDirection()
		}
		_updateSpatialParameters() {
			this._spatialSound && (this._soundPanner ? this.useCustomAttenuation ? (this._soundPanner.distanceModel = "linear", this._soundPanner.maxDistance = Number.MAX_VALUE, this._soundPanner.refDistance = 1, this._soundPanner.rolloffFactor = 1, this._soundPanner.panningModel = this._panningModel) : (this._soundPanner.distanceModel = this.distanceModel, this._soundPanner.maxDistance = this.maxDistance, this._soundPanner.refDistance = this.refDistance, this._soundPanner.rolloffFactor = this.rolloffFactor, this._soundPanner.panningModel = this._panningModel) : this._createSpatialParameters())
		}
		getSoundGain() {
			return this._soundGain
		}
		pause() {
			this.isPlaying && (this._clearTimeoutsAndObservers(), this._streaming ? (this._htmlAudioElement ? this._htmlAudioElement.pause() : this._streamingSource.disconnect(), this.isPlaying = !1, this.isPaused = !0) : Fd.audioEngine?.audioContext && this._soundSource && (this._soundSource.onended = () => {}, this._soundSource.stop(), this.isPlaying = !1, this.isPaused = !0, this._currentTime += Fd.audioEngine.audioContext.currentTime - this._startTime))
		}
		setPosition(e) {
			e.equals(this._position) || (this._position.copyFrom(e), Fd.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z) && (this._soundPanner.positionX.value = this._position.x, this._soundPanner.positionY.value = this._position.y, this._soundPanner.positionZ.value = this._position.z))
		}
		set loop(e) {
			e !== this._loop && (this._loop = e, this.updateOptions({
				loop: e
			}))
		}
		_disableSpatialSound() {
			this._spatialSound && (this._inputAudioNode = this._soundGain, this._soundPanner?.disconnect(), this._soundPanner = null, this._spatialSound = !1)
		}
		updateOptions(e) {
			e && (this.loop = e.loop ?? this.loop, this.maxDistance = e.maxDistance ?? this.maxDistance, this.useCustomAttenuation = e.useCustomAttenuation ?? this.useCustomAttenuation, this.rolloffFactor = e.rolloffFactor ?? this.rolloffFactor, this.refDistance = e.refDistance ?? this.refDistance, this.distanceModel = e.distanceModel ?? this.distanceModel, this._playbackRate = e.playbackRate ?? this._playbackRate, this._length = e.length ?? void 0, this.spatialSound = e.spatialSound ?? this._spatialSound, this._setOffset(e.offset ?? void 0), this.setVolume(e.volume ?? this._volume), this._updateSpatialParameters(), this.isPlaying && (this._streaming && this._htmlAudioElement ? (this._htmlAudioElement.playbackRate = this._playbackRate, this._htmlAudioElement.loop !== this.loop && (this._htmlAudioElement.loop = this.loop)) : this._soundSource && (this._soundSource.playbackRate.value = this._playbackRate, this._soundSource.loop !== this.loop && (this._soundSource.loop = this.loop), void 0 !== this._offset && this._soundSource.loopStart !== this._offset && (this._soundSource.loopStart = this._offset), void 0 !== this._length && this._length !== this._soundSource.loopEnd && (this._soundSource.loopEnd = (0 | this._offset) + this._length))))
		}
		_audioBufferLoaded(e) {
			Fd.audioEngine?.audioContext && (this._audioBuffer = e, this._isReadyToPlay = !0, this.autoplay && this.play(0, this._offset, this._length), this._readyToPlayCallback && this._readyToPlayCallback())
		}
		serialize() {
			const e = {
				name: this.name,
				url: this._url,
				autoplay: this.autoplay,
				loop: this.loop,
				volume: this._volume,
				spatialSound: this._spatialSound,
				maxDistance: this.maxDistance,
				rolloffFactor: this.rolloffFactor,
				refDistance: this.refDistance,
				distanceModel: this.distanceModel,
				playbackRate: this._playbackRate,
				panningModel: this._panningModel,
				soundTrackId: this.soundTrackId,
				metadata: this.metadata
			};
			return this._spatialSound && (this._connectedTransformNode && (e.connectedMeshId = this._connectedTransformNode.id), e.position = this._position.asArray(), e.refDistance = this.refDistance, e.distanceModel = this.distanceModel, e.isDirectional = this._isDirectional, e.localDirectionToMesh = this._localDirection.asArray(), e.coneInnerAngle = this._coneInnerAngle, e.coneOuterAngle = this._coneOuterAngle, e.coneOuterGain = this._coneOuterGain), e
		}
		_clearTimeoutsAndObservers() {
			this._tryToPlayTimeout && (clearTimeout(this._tryToPlayTimeout), this._tryToPlayTimeout = null), this._audioUnlockedObserver && (Fd.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver), this._audioUnlockedObserver = null)
		}
		_switchPanningModel() {
			Fd.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && (this._soundPanner.panningModel = this._panningModel)
		}
		_soundLoaded(e) {
			Fd.audioEngine?.audioContext && Fd.audioEngine.audioContext.decodeAudioData(e, (e => {
				this._audioBufferLoaded(e)
			}), (e => {
				Qc.Error("Error while decoding audio data for: " + this.name + " / Error: " + e)
			}))
		}
		getPlaybackRate() {
			return this._playbackRate
		}
		_updateDirection() {
			if (!this._connectedTransformNode || !this._soundPanner) return;
			const e = this._connectedTransformNode.getWorldMatrix(),
				t = Lc.TransformNormal(this._localDirection, e);
			t.normalize(), this._soundPanner.orientationX.value = t.x, this._soundPanner.orientationY.value = t.y, this._soundPanner.orientationZ.value = t.z
		}
		clone() {
			if (this._streaming) return null;
			{
				const t = () => {
						this._isReadyToPlay ? (s._audioBuffer = this.getAudioBuffer(), s._isReadyToPlay = !0, s.autoplay && s.play(0, this._offset, this._length)) : setTimeout(t, 300)
					},
					i = {
						autoplay: this.autoplay,
						loop: this.loop,
						volume: this._volume,
						spatialSound: this._spatialSound,
						maxDistance: this.maxDistance,
						useCustomAttenuation: this.useCustomAttenuation,
						rolloffFactor: this.rolloffFactor,
						refDistance: this.refDistance,
						distanceModel: this.distanceModel
					},
					s = new e(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, i);
				return this.useCustomAttenuation && s.setAttenuationFunction(this._customAttenuationFunction), s.setPosition(this._position), s.setPlaybackRate(this._playbackRate), t(), s
			}
		}
		get directionalConeOuterAngle() {
			return this._coneOuterAngle
		}
		switchPanningModelToHRTF() {
			this._panningModel = "HRTF", this._switchPanningModel()
		}
		set directionalConeOuterAngle(e) {
			if (e != this._coneOuterAngle) {
				if (e < this._coneInnerAngle) return void Qc.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
				this._coneOuterAngle = e, Fd.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && (this._soundPanner.coneOuterAngle = this._coneOuterAngle)
			}
		}
		updateDistanceFromListener() {
			if (Fd.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
				const e = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
				this._soundGain.gain.value = this._customAttenuationFunction(this._volume, e, this.maxDistance, this.refDistance, this.rolloffFactor)
			}
		}
		_createSpatialParameters() {
			Fd.audioEngine?.canUseWebAudio && Fd.audioEngine.audioContext && (this._scene.headphone && (this._panningModel = "HRTF"), this._soundPanner = this._soundPanner ?? Fd.audioEngine.audioContext.createPanner(), this._soundPanner && this._outputAudioNode && (this._updateSpatialParameters(), this._soundPanner.connect(this._outputAudioNode), this._inputAudioNode = this._soundPanner))
		}
		getAudioBuffer() {
			return this._audioBuffer
		}
		play(e, t, i) {
			if (this._isReadyToPlay && this._scene.audioEnabled && Fd.audioEngine?.audioContext) try {
				this._clearTimeoutsAndObservers();
				let s = e ? Fd.audioEngine?.audioContext.currentTime + e : Fd.audioEngine?.audioContext.currentTime;
				if (this._soundSource && this._streamingSource || this._spatialSound && this._soundPanner && (isNaN(this._position.x) || isNaN(this._position.y) || isNaN(this._position.z) || (this._soundPanner.positionX.value = this._position.x, this._soundPanner.positionY.value = this._position.y, this._soundPanner.positionZ.value = this._position.z), this._isDirectional && (this._soundPanner.coneInnerAngle = this._coneInnerAngle, this._soundPanner.coneOuterAngle = this._coneOuterAngle, this._soundPanner.coneOuterGain = this._coneOuterGain, this._connectedTransformNode ? this._updateDirection() : this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z))), this._streaming) {
					if (this._streamingSource || (this._streamingSource = Fd.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement), this._htmlAudioElement.onended = () => {
							this._onended()
						}, this._htmlAudioElement.playbackRate = this._playbackRate), this._streamingSource.disconnect(), this._inputAudioNode && this._streamingSource.connect(this._inputAudioNode), this._htmlAudioElement) {
						const e = () => {
							if (Fd.audioEngine?.unlocked) {
								const t = this._htmlAudioElement.play();
								void 0 !== t && t.catch((() => {
									Fd.audioEngine?.lock(), (this.loop || this.autoplay) && (this._audioUnlockedObserver = Fd.audioEngine?.onAudioUnlockedObservable.addOnce((() => {
										e()
									})))
								}))
							} else(this.loop || this.autoplay) && (this._audioUnlockedObserver = Fd.audioEngine?.onAudioUnlockedObservable.addOnce((() => {
								e()
							})))
						};
						e()
					}
				} else {
					const n = () => {
						if (Fd.audioEngine?.audioContext) {
							if (i = i || this._length, void 0 !== t && this._setOffset(t), this._soundSource) {
								const e = this._soundSource;
								e.onended = () => {
									e.disconnect()
								}
							}
							if (this._soundSource = Fd.audioEngine?.audioContext.createBufferSource(), this._soundSource && this._inputAudioNode) {
								this._soundSource.buffer = this._audioBuffer, this._soundSource.connect(this._inputAudioNode), this._soundSource.loop = this.loop, void 0 !== t && (this._soundSource.loopStart = t), void 0 !== i && (this._soundSource.loopEnd = (0 | t) + i), this._soundSource.playbackRate.value = this._playbackRate, this._soundSource.onended = () => {
									this._onended()
								}, s = e ? Fd.audioEngine?.audioContext.currentTime + e : Fd.audioEngine.audioContext.currentTime;
								const n = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer.duration;
								this._soundSource.start(s, n, this.loop ? void 0 : i)
							}
						}
					};
					"suspended" === Fd.audioEngine?.audioContext.state ? this._tryToPlayTimeout = setTimeout((() => {
						"suspended" === Fd.audioEngine?.audioContext.state ? (Fd.audioEngine.lock(), (this.loop || this.autoplay) && (this._audioUnlockedObserver = Fd.audioEngine.onAudioUnlockedObservable.addOnce((() => {
							n()
						})))) : n()
					}), 500) : n()
				}
				this._startTime = s, this.isPlaying = !0, this.isPaused = !1
			} catch (e) {
				Qc.Error("Error while trying to play audio: " + this.name + ", " + e.message)
			}
		}
		dispose() {
			Fd.audioEngine?.canUseWebAudio && (this.isPlaying && this.stop(), this._isReadyToPlay = !1, -1 === this.soundTrackId ? this._scene.mainSoundTrack.removeSound(this) : this._scene.soundTracks && this._scene.soundTracks[this.soundTrackId].removeSound(this), this._soundGain && (this._soundGain.disconnect(), this._soundGain = null), this._soundPanner && (this._soundPanner.disconnect(), this._soundPanner = null), this._soundSource && (this._soundSource.disconnect(), this._soundSource = null), this._audioBuffer = null, this._htmlAudioElement && (this._htmlAudioElement.pause(), this._htmlAudioElement.src = "", document.body.removeChild(this._htmlAudioElement)), this._streamingSource && this._streamingSource.disconnect(), this._connectedTransformNode && this._registerFunc && (this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._connectedTransformNode = null), this._clearTimeoutsAndObservers())
		}
		setAudioBuffer(e) {
			Fd.audioEngine?.canUseWebAudio && (this._audioBuffer = e, this._isReadyToPlay = !0)
		}
		setLocalDirectionToMesh(e) {
			this._localDirection = e, Fd.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying && this._updateDirection()
		}
		getVolume() {
			return this._volume
		}
		get spatialSound() {
			return this._spatialSound
		}
	};
	ox._SceneComponentInitialization = e => {
		throw ic("AudioSceneComponent")
	}, cc("BABYLON.Sound", ox);
	var lx = class {
			_onended() {
				void 0 !== this._currentIndex && (this._sounds[this._currentIndex].autoplay = !1), this.loop && this.isPlaying ? this.play() : this.isPlaying = !1
			}
			play(e) {
				if (!this.isPaused) {
					this.stop();
					const e = Math.random();
					let t = 0;
					for (let i = 0; i < this._weights.length; i++)
						if (t += this._weights[i], e <= t) {
							this._currentIndex = i;
							break
						}
				}
				const t = this._sounds[this._currentIndex];
				t.isReady() ? t.play(0, this.isPaused ? void 0 : e) : t.autoplay = !0, this.isPlaying = !0, this.isPaused = !1
			}
			constructor(e, t, i) {
				if (this.loop = !1, this._coneInnerAngle = 360, this._coneOuterAngle = 360, this._volume = 1, this.isPlaying = !1, this.isPaused = !1, this._sounds = [], this._weights = [], t.length !== i.length) throw new Error("Sounds length does not equal weights length");
				this.loop = e, this._weights = i;
				let s = 0;
				for (const e of i) s += e;
				const n = s > 0 ? 1 / s : 0;
				for (let e = 0; e < this._weights.length; e++) this._weights[e] *= n;
				this._sounds = t;
				for (const e of this._sounds) e.onEndedObservable.add((() => {
					this._onended()
				}))
			}
			set directionalConeInnerAngle(e) {
				if (e !== this._coneInnerAngle) {
					if (this._coneOuterAngle < e) return void Qc.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
					this._coneInnerAngle = e;
					for (const t of this._sounds) t.directionalConeInnerAngle = e
				}
			}
			get directionalConeInnerAngle() {
				return this._coneInnerAngle
			}
			set volume(e) {
				if (e !== this._volume)
					for (const t of this._sounds) t.setVolume(e)
			}
			set directionalConeOuterAngle(e) {
				if (e !== this._coneOuterAngle) {
					if (e < this._coneInnerAngle) return void Qc.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
					this._coneOuterAngle = e;
					for (const t of this._sounds) t.directionalConeOuterAngle = e
				}
			}
			get directionalConeOuterAngle() {
				return this._coneOuterAngle
			}
			stop() {
				this.isPlaying = !1, void 0 !== this._currentIndex && this._sounds[this._currentIndex].stop()
			}
			get volume() {
				return this._volume
			}
			pause() {
				this.isPaused = !0, void 0 !== this._currentIndex && this._sounds[this._currentIndex].pause()
			}
		},
		hx = "MSFT_audio_emitter",
		cx = class {
			_loadEmitterAsync(e, t) {
				if (t._babylonSounds = t._babylonSounds || [], !t._babylonData) {
					const e = new Array,
						i = t.name || `emitter${t.index}`,
						s = {
							loop: !1,
							autoplay: !1,
							volume: null == t.volume ? 1 : t.volume
						};
					for (let n = 0; n < t.clips.length; n++) {
						const a = `/extensions/${this.name}/clips`,
							r = LA.Get(a, this._clips, t.clips[n].clip);
						e.push(this._loadClipAsync(`${a}/${t.clips[n].clip}`, r).then((e => {
							const a = t._babylonSounds[n] = new ox(i, e, this._loader.babylonScene, null, s);
							a.refDistance = t.refDistance || 1, a.maxDistance = t.maxDistance || 256, a.rolloffFactor = t.rolloffFactor || 1, a.distanceModel = t.distanceModel || "exponential"
						})))
					}
					const n = Promise.all(e).then((() => {
						const e = t.clips.map((e => e.weight || 1)),
							i = new lx(t.loop || !1, t._babylonSounds, e);
						t.innerAngle && (i.directionalConeInnerAngle = 2 * dd.ToDegrees(t.innerAngle)), t.outerAngle && (i.directionalConeOuterAngle = 2 * dd.ToDegrees(t.outerAngle)), t.volume && (i.volume = t.volume), t._babylonData.sound = i
					}));
					t._babylonData = {
						loaded: n
					}
				}
				return t._babylonData.loaded
			}
			_getEventAction(e, t, i, s, n) {
				switch (i) {
					case "play":
						return e => {
							const i = (n || 0) + (e - s);
							t.play(i)
						};
					case "stop":
						return () => {
							t.stop()
						};
					case "pause":
						return () => {
							t.pause()
						};
					default:
						throw new Error(`${e}: Unsupported action ${i}`)
				}
			}
			onLoading() {
				const e = this._loader.gltf.extensions;
				if (e && e[this.name]) {
					const t = e[this.name];
					this._clips = t.clips, this._emitters = t.emitters, LA.Assign(this._clips), LA.Assign(this._emitters)
				}
			}
			loadAnimationAsync(e, t) {
				return BA.LoadExtensionAsync(e, t, this.name, ((i, s) => this._loader.loadAnimationAsync(e, t).then((n => {
					const a = new Array;
					LA.Assign(s.events);
					for (const r of s.events) a.push(this._loadAnimationEventAsync(`${i}/events/${r.index}`, e, t, r, n));
					return Promise.all(a).then((() => n))
				}))))
			}
			loadSceneAsync(e, t) {
				return BA.LoadExtensionAsync(e, t, this.name, ((i, s) => {
					const n = new Array;
					n.push(this._loader.loadSceneAsync(e, t));
					for (const e of s.emitters) {
						const t = LA.Get(`${i}/emitters`, this._emitters, e);
						if (null != t.refDistance || null != t.maxDistance || null != t.rolloffFactor || null != t.distanceModel || null != t.innerAngle || null != t.outerAngle) throw new Error(`${i}: Direction or Distance properties are not allowed on emitters attached to a scene`);
						n.push(this._loadEmitterAsync(`${i}/emitters/${t.index}`, t))
					}
					return Promise.all(n).then((() => {}))
				}))
			}
			loadNodeAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((e, s) => {
					const n = new Array;
					return this._loader.loadNodeAsync(e, t, (t => {
						for (const i of s.emitters) {
							const s = LA.Get(`${e}/emitters`, this._emitters, i);
							n.push(this._loadEmitterAsync(`${e}/emitters/${s.index}`, s).then((() => {
								for (const e of s._babylonSounds) e.attachToMesh(t), null == s.innerAngle && null == s.outerAngle || (e.setLocalDirectionToMesh(Lc.Forward()), e.setDirectionalCone(2 * dd.ToDegrees(null == s.innerAngle ? Math.PI : s.innerAngle), 2 * dd.ToDegrees(null == s.outerAngle ? Math.PI : s.outerAngle), 0))
							})))
						}
						i(t)
					})).then((e => Promise.all(n).then((() => e))))
				}))
			}
			constructor(e) {
				this.name = hx, this._loader = e, this.enabled = this._loader.isExtensionUsed(hx)
			}
			_loadAnimationEventAsync(e, t, i, s, n) {
				if (0 == n.targetedAnimations.length) return Promise.resolve();
				const a = n.targetedAnimations[0],
					r = s.emitter,
					o = LA.Get(`/extensions/${this.name}/emitters`, this._emitters, r);
				return this._loadEmitterAsync(e, o).then((() => {
					const t = o._babylonData.sound;
					if (t) {
						const i = new uS(s.time, this._getEventAction(e, t, s.action, s.time, s.startOffset));
						a.animation.addEvent(i), n.onAnimationGroupEndObservable.add((() => {
							t.stop()
						})), n.onAnimationGroupPauseObservable.add((() => {
							t.pause()
						}))
					}
				}))
			}
			_loadClipAsync(e, t) {
				if (t._objectURL) return t._objectURL;
				let i;
				if (t.uri) i = this._loader.loadUriAsync(e, t, t.uri);
				else {
					const s = LA.Get(`${e}/bufferView`, this._loader.gltf.bufferViews, t.bufferView);
					i = this._loader.loadBufferViewAsync(`/bufferViews/${s.index}`, s)
				}
				return t._objectURL = i.then((e => URL.createObjectURL(new Blob([e], {
					type: t.mimeType
				})))), t._objectURL
			}
			dispose() {
				this._loader = null, this._clips = null, this._emitters = null
			}
		};
	BA.RegisterExtension(hx, (e => new cx(e)));
	var ux = "MSFT_lod",
		mx = class {
			loadSceneAsync(e, t) {
				const i = this._loader.loadSceneAsync(e, t);
				return this._loadBufferLOD(this._bufferLODs, 0), i
			}
			_disposeTransformNode(e) {
				const t = [],
					i = e.material;
				i && t.push(i);
				for (const i of e.getChildMeshes()) i.material && t.push(i.material);
				e.dispose();
				const s = t.filter((e => this._loader.babylonScene.meshes.every((t => t.material != e))));
				this._disposeMaterials(s)
			}
			dispose() {
				this._loader = null, this._nodeIndexLOD = null, this._nodeSignalLODs.length = 0, this._nodePromiseLODs.length = 0, this._nodeBufferLODs.length = 0, this._materialIndexLOD = null, this._materialSignalLODs.length = 0, this._materialPromiseLODs.length = 0, this._materialBufferLODs.length = 0, this.onMaterialLODsLoadedObservable.clear(), this.onNodeLODsLoadedObservable.clear()
			}
			loadNodeAsync(e, t, i) {
				return BA.LoadExtensionAsync(e, t, this.name, ((e, s) => {
					let n;
					const a = this._getLODs(e, t, this._loader.gltf.nodes, s.ids);
					this._loader.logOpen(`${e}`);
					for (let e = 0; e < a.length; e++) {
						const t = a[e];
						0 !== e && (this._nodeIndexLOD = e, this._nodeSignalLODs[e] = this._nodeSignalLODs[e] || new oA);
						const s = e => {
								i(e), e.setEnabled(!1)
							},
							r = this._loader.loadNodeAsync(`/nodes/${t.index}`, t, s).then((t => {
								if (0 !== e) {
									const t = a[e - 1];
									t._babylonTransformNode && (this._disposeTransformNode(t._babylonTransformNode), delete t._babylonTransformNode)
								}
								return t.setEnabled(!0), t
							}));
						this._nodePromiseLODs[e] = this._nodePromiseLODs[e] || [], 0 === e ? n = r : (this._nodeIndexLOD = null, this._nodePromiseLODs[e].push(r))
					}
					return this._loader.logClose(), n
				}))
			}
			constructor(e) {
				this.name = ux, this.order = 100, this.maxLODsToLoad = 10, this.onNodeLODsLoadedObservable = new kc, this.onMaterialLODsLoadedObservable = new kc, this._bufferLODs = new Array, this._nodeIndexLOD = null, this._nodeSignalLODs = new Array, this._nodePromiseLODs = new Array, this._nodeBufferLODs = new Array, this._materialIndexLOD = null, this._materialSignalLODs = new Array, this._materialPromiseLODs = new Array, this._materialBufferLODs = new Array, this._loader = e, this.maxLODsToLoad = this._loader.parent.extensionOptions[ux]?.maxLODsToLoad ?? this.maxLODsToLoad, this.enabled = this._loader.isExtensionUsed(ux)
			}
			_loadUriAsync(e, t, i) {
				if (null !== this._nodeIndexLOD) {
					this._loader.log("deferred");
					const s = this._nodeIndexLOD - 1;
					return this._nodeSignalLODs[s] = this._nodeSignalLODs[s] || new oA, this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then((() => this._loader.loadUriAsync(e, t, i)))
				}
				if (null !== this._materialIndexLOD) {
					this._loader.log("deferred");
					const s = this._materialIndexLOD - 1;
					return this._materialSignalLODs[s] = this._materialSignalLODs[s] || new oA, this._materialSignalLODs[s].promise.then((() => this._loader.loadUriAsync(e, t, i)))
				}
				return null
			}
			_loadMaterialAsync(e, t, i, s, n) {
				return this._nodeIndexLOD ? null : BA.LoadExtensionAsync(e, t, this.name, ((e, a) => {
					let r;
					const o = this._getLODs(e, t, this._loader.gltf.materials, a.ids);
					this._loader.logOpen(`${e}`);
					for (let e = 0; e < o.length; e++) {
						const t = o[e];
						0 !== e && (this._materialIndexLOD = e);
						const a = this._loader._loadMaterialAsync(`/materials/${t.index}`, t, i, s, (t => {
							0 === e && n(t)
						})).then((t => {
							if (0 !== e) {
								n(t);
								const i = o[e - 1]._data;
								i[s] && (this._disposeMaterials([i[s].babylonMaterial]), delete i[s])
							}
							return t
						}));
						this._materialPromiseLODs[e] = this._materialPromiseLODs[e] || [], 0 === e ? r = a : (this._materialIndexLOD = null, this._materialPromiseLODs[e].push(a))
					}
					return this._loader.logClose(), r
				}))
			}
			loadBufferAsync(e, t, i, s) {
				if (this._loader.parent.useRangeRequests && !t.uri) {
					if (!this._loader.bin) throw new Error(`${e}: Uri is missing or the binary glTF is missing its binary chunk`);
					const t = (e, t) => {
						const n = i,
							a = n + s - 1;
						let r = e[t];
						return r ? (r.start = Math.min(r.start, n), r.end = Math.max(r.end, a)) : (r = {
							start: n,
							end: a,
							loaded: new oA
						}, e[t] = r), r.loaded.promise.then((e => new Uint8Array(e.buffer, e.byteOffset + i - r.start, s)))
					};
					return this._loader.log("deferred"), null !== this._nodeIndexLOD ? t(this._nodeBufferLODs, this._nodeIndexLOD) : null !== this._materialIndexLOD ? t(this._materialBufferLODs, this._materialIndexLOD) : t(this._bufferLODs, 0)
				}
				return null
			}
			onReady() {
				for (let e = 0; e < this._nodePromiseLODs.length; e++) {
					const t = Promise.all(this._nodePromiseLODs[e]).then((() => {
						0 !== e && (this._loader.endPerformanceCounter(`Node LOD ${e}`), this._loader.log(`Loaded node LOD ${e}`)), this.onNodeLODsLoadedObservable.notifyObservers(e), e !== this._nodePromiseLODs.length - 1 && (this._loader.startPerformanceCounter(`Node LOD ${e+1}`), this._loadBufferLOD(this._nodeBufferLODs, e + 1), this._nodeSignalLODs[e] && this._nodeSignalLODs[e].resolve())
					}));
					this._loader._completePromises.push(t)
				}
				for (let e = 0; e < this._materialPromiseLODs.length; e++) {
					const t = Promise.all(this._materialPromiseLODs[e]).then((() => {
						0 !== e && (this._loader.endPerformanceCounter(`Material LOD ${e}`), this._loader.log(`Loaded material LOD ${e}`)), this.onMaterialLODsLoadedObservable.notifyObservers(e), e !== this._materialPromiseLODs.length - 1 && (this._loader.startPerformanceCounter(`Material LOD ${e+1}`), this._loadBufferLOD(this._materialBufferLODs, e + 1), this._materialSignalLODs[e] && this._materialSignalLODs[e].resolve())
					}));
					this._loader._completePromises.push(t)
				}
			}
			_disposeMaterials(e) {
				const t = {};
				for (const i of e) {
					for (const e of i.getActiveTextures()) t[e.ik] = e;
					i.dispose()
				}
				for (const e in t)
					for (const i of this._loader.babylonScene.materials) i.hasTexture(t[e]) && delete t[e];
				for (const e in t) t[e].dispose()
			}
			_loadBufferLOD(e, t) {
				const i = e[t];
				i && (this._loader.log(`Loading buffer range [${i.start}-${i.end}]`), this._loader.bin.readAsync(i.start, i.end - i.start + 1).then((e => {
					i.loaded.resolve(e)
				}), (e => {
					i.loaded.reject(e)
				})))
			}
			_getLODs(e, t, i, s) {
				if (this.maxLODsToLoad <= 0) throw new Error("maxLODsToLoad must be greater than zero");
				const n = [];
				for (let t = s.length - 1; t >= 0; t--)
					if (n.push(LA.Get(`${e}/ids/${s[t]}`, i, s[t])), n.length === this.maxLODsToLoad) return n;
				return n.push(t), n
			}
		};
	BA.RegisterExtension(ux, (e => new mx(e)));
	var dx = "MSFT_minecraftMesh",
		fx = class {
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtraAsync(e, t, this.name, ((s, n) => {
					if (n) {
						if (!(i instanceof wA)) throw new Error(`${s}: Material type not supported`);
						const n = this._loader.loadMaterialPropertiesAsync(e, t, i);
						return i.needAlphaBlending() && (i.forceDepthWrite = !0, i.separateCullingPass = !0), i.backFaceCulling = i.forceDepthWrite, i.twoSidedLighting = !0, n
					}
					return null
				}))
			}
			dispose() {
				this._loader = null
			}
			constructor(e) {
				this.name = dx, this._loader = e, this.enabled = this._loader.isExtensionUsed(dx)
			}
		};
	BA.RegisterExtension(dx, (e => new fx(e)));
	var px, _x, gx = "MSFT_sRGBFactors",
		vx = class {
			constructor(e) {
				this.name = gx, this._loader = e, this.enabled = this._loader.isExtensionUsed(gx)
			}
			loadMaterialPropertiesAsync(e, t, i) {
				return BA.LoadExtraAsync(e, t, this.name, ((s, n) => {
					if (n) {
						if (!(i instanceof wA)) throw new Error(`${s}: Material type not supported`);
						const n = this._loader.loadMaterialPropertiesAsync(e, t, i),
							a = i.getScene().getEngine().useExactSrgbConversions;
						return i.albedoTexture || i.albedoColor.toLinearSpaceToRef(i.albedoColor, a), i.reflectivityTexture || i.reflectivityColor.toLinearSpaceToRef(i.reflectivityColor, a), n
					}
					return null
				}))
			}
			dispose() {
				this._loader = null
			}
		};
	BA.RegisterExtension(gx, (e => new vx(e))), (_x = px || (px = {}))[_x.Input = 0] = "Input", _x[_x.Output = 1] = "Output";
	var yx = class {
			_isSingularConnection() {
				return !0
			}
			deserialize(e) {
				this.ik = e.ik, this.name = e.name, this._connectionType = e._connectionType, this.connectedPointIds = e.connectedPointIds
			}
			isConnected() {
				return this._connectedPoint.length > 0
			}
			getClassName() {
				return "FGConnection"
			}
			static Parse(e = {}, t) {
				const i = new(dd.Instantiate(e.className))(e.name, e._connectionType, t);
				return i.deserialize(e), i
			}
			serialize(e = {}) {
				e.ik = this.ik, e.name = this.name, e._connectionType = this._connectionType, e.connectedPointIds = [], e.className = this.getClassName();
				for (const t of this._connectedPoint) e.connectedPointIds.push(t.ik)
			}
			constructor(e, t, i) {
				this._ownerBlock = i, this._connectedPoint = [], this.ik = rd(), this.connectedPointIds = [], this.name = e, this._connectionType = t
			}
			connectTo(e) {
				if (this._connectionType === e._connectionType) throw new Error(`Cannot connect two points of type ${this.connectionType}`);
				if (this._isSingularConnection() && this._connectedPoint.length > 0 || e._isSingularConnection() && e._connectedPoint.length > 0) throw new Error("Max number of connections for point reached");
				this._connectedPoint.push(e), e._connectedPoint.push(this)
			}
			get connectionType() {
				return this._connectionType
			}
		},
		Sx = class e {
			divide(t) {
				return new e(this.value / t.value)
			}
			constructor(e) {
				this.value = this._toInt(e)
			}
			subtract(t) {
				return new e(this.value - t.value)
			}
			_toInt(e) {
				return 0 | e
			}
			static Parse(t) {
				return new e(t.value)
			}
			add(t) {
				return new e(this.value + t.value)
			}
			equals(e) {
				return this.value === e.value
			}
			multiply(t) {
				return new e(Math.imul(this.value, t.value))
			}
			getClassName() {
				return e.ClassName
			}
		};
	Sx.ClassName = "FlowGraphInteger", cc("FlowGraphInteger", Sx);
	var Ex = class e {
			static Parse(t) {
				return new e(t.typeName, t.defaultValue)
			}
			serialize(e) {
				e.typeName = this.typeName, e.defaultValue = this.defaultValue
			}
			constructor(e, t) {
				this.typeName = e, this.defaultValue = t
			}
		},
		Ax = new Ex("any", void 0),
		bx = (new Ex("string", ""), new Ex("number", 0)),
		xx = new Ex("boolean", !1),
		Mx = new Ex("Vector2", Fc.Zero()),
		Cx = new Ex("Vector3", Lc.Zero()),
		Tx = (new Ex("Vector4", Bc.Zero()), new Ex("Matrix", Hc.Identity())),
		wx = (new Ex("Color3", Tc.Black()), new Ex("Color4", new wc(0, 0, 0, 0)), new Ex("Quaternion", Gc.Identity()), new Ex("FlowGraphInteger", new Sx(0))),
		Rx = class extends yx {
			getValue(e) {
				return 1 === this.connectionType ? (e._notifyExecuteNode(this._ownerBlock), this._ownerBlock._updateOutputs(e), this._getValueOrDefault(e)) : this.isConnected() ? this._connectedPoint[0].getValue(e) : this._getValueOrDefault(e)
			}
			setValue(e, t) {
				t._setConnectionValue(this, e)
			}
			getClassName() {
				return "FGDataConnection"
			}
			connectTo(e) {
				super.connectTo(e)
			}
			_getValueOrDefault(e) {
				return e._hasConnectionValue(this) ? e._getConnectionValue(this) : this.richType.defaultValue
			}
			serialize(e = {}) {
				super.serialize(e), e.richType = {}, this.richType.serialize(e.richType)
			}
			_isSingularConnection() {
				return 0 === this.connectionType
			}
			static Parse(e, t) {
				const i = yx.Parse(e, t);
				return i.richType = Ex.Parse(e.richType), i
			}
			constructor(e, t, i, s) {
				super(e, t, i), this.richType = s
			}
		};

	function Nx(e) {
		return "Mesh" === e || "AbstractMesh" === e || "GroundMesh" === e || "InstanceMesh" === e || "LinesMesh" === e || "GoldbergMesh" === e || "GreasedLineMesh" === e || "TrailMesh" === e
	}

	function Ix(e) {
		return "Vector2" === e || "Vector3" === e || "Vector4" === e || "Quaternion" === e || "Color3" === e || "Color4" === e
	}

	function Px(e, t, i) {
		const s = t?.getClassName?.() ?? "";
		Nx(s) ? i[e] = {
			name: t.name,
			className: s
		} : Ix(s) ? i[e] = {
			value: t.asArray(),
			className: s
		} : i[e] = t
	}

	function kx(e, t, i) {
		const s = t[e];
		let n;
		const a = s?.className;
		return n = Nx(a) ? i.getMeshByName(s.name) : Ix(a) ? function(e, t) {
			if ("Vector2" === e) return Fc.FromArray(t);
			if ("Vector3" === e) return Lc.FromArray(t);
			if ("Vector4" === e) return Bc.FromArray(t);
			if ("Quaternion" === e) return Gc.FromArray(t);
			if ("Color3" === e) return new Tc(t[0], t[1], t[2]);
			if ("Color4" === e) return new wc(t[0], t[1], t[2], t[3]);
			throw new Error(`Unknown vector class name ${e}`)
		}(a, s.value) : "Matrix" === a ? Hc.FromArray(s.value) : a === Sx.ClassName ? Sx.Parse(s) : s && void 0 !== s.value ? s.value : s, n
	}
	cc("FGDataConnection", Rx);
	var Dx = class {
			registerDataInput(e, t) {
				const i = new Rx(e, 0, this, t);
				return this.dataInputs.push(i), i
			}
			getDataOutput(e) {
				return this.dataOutputs.find((t => t.name === e))
			}
			getClassName() {
				return "FGBlock"
			}
			constructor(e) {
				this.config = e, this.ik = rd(), this.name = this.config?.name ?? this.getClassName(), this.dataInputs = [], this.dataOutputs = []
			}
			getDataInput(e) {
				return this.dataInputs.find((t => t.name === e))
			}
			static Parse(e, t) {
				const i = dd.Instantiate(e.className),
					s = {},
					n = t.valueParseFunction ?? kx;
				if (e.config)
					for (const i in e.config) s[i] = n(i, e.config, t.scene);
				var a;
				("FGSetPropertyBlock" === (a = e.className) || "FGGetPropertyBlock" === a || "FGPlayAnimationBlock" === a || "FGMeshPickEventBlock" === a) && (s.pathConverter = t.pathConverter);
				const r = new i(s);
				r.ik = e.ik;
				for (let t = 0; t < e.dataInputs.length; t++) {
					const i = r.getDataInput(e.dataInputs[t].name);
					if (!i) throw new Error("Could not find data input with name " + e.dataInputs[t].name + " in block " + e.className);
					i.deserialize(e.dataInputs[t])
				}
				for (let t = 0; t < e.dataOutputs.length; t++) {
					const i = r.getDataOutput(e.dataOutputs[t].name);
					if (!i) throw new Error("Could not find data output with name " + e.dataOutputs[t].name + " in block " + e.className);
					i.deserialize(e.dataOutputs[t])
				}
				return r.metadata = e.metadata, r.deserialize && r.deserialize(e), r
			}
			serialize(e = {}, t = Px) {
				e.ik = this.ik, e.config = {}, this.config && (e.config.name = this.config.name), e.dataInputs = [], e.dataOutputs = [], e.className = this.getClassName();
				for (const t of this.dataInputs) {
					const i = {};
					t.serialize(i), e.dataInputs.push(i)
				}
				for (const t of this.dataOutputs) {
					const i = {};
					t.serialize(i), e.dataOutputs.push(i)
				}
			}
			registerDataOutput(e, t) {
				const i = new Rx(e, 1, this, t);
				return this.dataOutputs.push(i), i
			}
			_updateOutputs(e) {}
		},
		Ox = class extends yx {
			_activateSignal(e) {
				0 === this.connectionType ? (e._notifyExecuteNode(this._ownerBlock), this._ownerBlock._execute(e, this), e._increaseExecutionId()) : this._connectedPoint[0]?._activateSignal(e)
			}
			_isSingularConnection() {
				return 1 === this.connectionType
			}
		};
	cc("FlowGraphSignalConnection", Ox);
	var Fx = class extends Dx {
			getClassName() {
				return "FGExecutionBlock"
			}
			_registerSignalInput(e) {
				const t = new Ox(e, 0, this);
				return this.signalInputs.push(t), t
			}
			getSignalInput(e) {
				return this.signalInputs.find((t => t.name === e))
			}
			getSignalOutput(e) {
				return this.signalOutputs.find((t => t.name === e))
			}
			_registerSignalOutput(e) {
				const t = new Ox(e, 1, this);
				return this.signalOutputs.push(t), t
			}
			serialize(e = {}) {
				super.serialize(e), e.signalInputs = [], e.signalOutputs = [];
				for (const t of this.signalInputs) {
					const i = {};
					t.serialize(i), e.signalInputs.push(i)
				}
				for (const t of this.signalOutputs) {
					const i = {};
					t.serialize(i), e.signalOutputs.push(i)
				}
			}
			constructor(e) {
				super(e), this.signalInputs = [], this.signalOutputs = [], this.in = this._registerSignalInput("in")
			}
			deserialize(e) {
				for (let t = 0; t < e.signalInputs.length; t++) {
					const i = this.getSignalInput(e.signalInputs[t].name);
					if (!i) throw new Error("Could not find signal input with name " + e.signalInputs[t].name + " in block " + e.className);
					i.deserialize(e.signalInputs[t])
				}
				for (let t = 0; t < e.signalOutputs.length; t++) {
					const i = this.getSignalOutput(e.signalOutputs[t].name);
					if (!i) throw new Error("Could not find signal output with name " + e.signalOutputs[t].name + " in block " + e.className);
					i.deserialize(e.signalOutputs[t])
				}
			}
		},
		Lx = class extends Fx {
			_startPendingTasks(e) {
				this._preparePendingTasks(e), e._addPendingBlock(this)
			}
			constructor(e) {
				super(e), this.out = this._registerSignalOutput("out"), this.done = this._registerSignalOutput("done")
			}
		},
		Bx = class extends Lx {
			_execute(e) {
				e._notifyExecuteNode(this), this.out._activateSignal(e)
			}
		},
		Gx = class {
			serialize(e = {}, t = Px) {
				e.ik = this.ik, e._userVariables = {};
				for (const i in this._userVariables) t(i, this._userVariables[i], e._userVariables);
				e._connectionValues = {};
				for (const i in this._connectionValues) t(i, this._connectionValues[i], e._connectionValues)
			}
			_hasExecutionVariable(e, t) {
				return this._getUniqueIdPrefixedName(e, t) in this._executionVariables
			}
			get executionId() {
				return this._executionId
			}
			getVariable(e) {
				return this._userVariables[e]
			}
			_addPendingBlock(e) {
				this._pendingBlocks.push(e)
			}
			get userVariables() {
				return this._userVariables
			}
			getClassName() {
				return "FGContext"
			}
			_hasConnectionValue(e) {
				return e.ik in this._connectionValues
			}
			_increaseExecutionId() {
				this._executionId++
			}
			setVariable(e, t) {
				this._userVariables[e] = t
			}
			_getConnectionValue(e) {
				return this._connectionValues[e.ik]
			}
			_notifyExecuteNode(e) {
				this.onNodeExecutedObservable.notifyObservers(e)
			}
			constructor(e) {
				this.ik = rd(), this._userVariables = {}, this._executionVariables = {}, this._connectionValues = {}, this._pendingBlocks = [], this._executionId = 0, this.onNodeExecutedObservable = new kc, this._configuration = e
			}
			_setConnectionValue(e, t) {
				this._connectionValues[e.ik] = t
			}
			_setExecutionVariable(e, t, i) {
				this._executionVariables[this._getUniqueIdPrefixedName(e, t)] = i
			}
			static Parse(e, t) {
				const i = t.graph.createContext(),
					s = t.valueParseFunction ?? kx;
				i.ik = e.ik;
				for (const t in e._userVariables) {
					const n = s(t, e._userVariables, i._configuration.scene);
					i._userVariables[t] = n
				}
				for (const t in e._connectionValues) {
					const n = s(t, e._connectionValues, i._configuration.scene);
					i._connectionValues[t] = n
				}
				return i
			}
			_getExecutionVariable(e, t, i) {
				return this._hasExecutionVariable(e, t) ? this._executionVariables[this._getUniqueIdPrefixedName(e, t)] : i
			}
			hasVariable(e) {
				return e in this._userVariables
			}
			get configuration() {
				return this._configuration
			}
			_getUniqueIdPrefixedName(e, t) {
				return `${e.ik}_${t}`
			}
			_removePendingBlock(e) {
				const t = this._pendingBlocks.indexOf(e); - 1 !== t && this._pendingBlocks.splice(t, 1)
			}
			_deleteExecutionVariable(e, t) {
				delete this._executionVariables[this._getUniqueIdPrefixedName(e, t)]
			}
			_clearPendingBlocks() {
				for (const e of this._pendingBlocks) e._cancelPendingTasks(this);
				this._pendingBlocks.length = 0
			}
		};

	function Hx(e, t) {
		return !(!e.parent || e.parent !== t && !Hx(e.parent, t))
	}
	Gh([Xh()], Gx.prototype, "uniqueId", void 0);
	var Ux, Vx, Wx = class e extends Bx {
		_cancelPendingTasks(e) {
			const t = e._getExecutionVariable(this, "mesh"),
				i = e._getExecutionVariable(this, "meshPickObserver"),
				s = e._getExecutionVariable(this, "meshDisposeObserver");
			t.getScene().onPointerObservable.remove(i), t.onDisposeObservable.remove(s), e._deleteExecutionVariable(this, "mesh"), e._deleteExecutionVariable(this, "meshPickObserver"), e._deleteExecutionVariable(this, "meshDisposeObserver")
		}
		_onDispose(e) {
			this._cancelPendingTasks(e), e._removePendingBlock(this)
		}
		serialize(e) {
			super.serialize(e), e.config.path = this.config.path
		}
		constructor(e) {
			super(e), this.config = e
		}
		getClassName() {
			return e.ClassName
		}
		_preparePendingTasks(e) {
			let t = e._getExecutionVariable(this, "meshPickObserver");
			if (!t) {
				const i = this._getReferencedMesh();
				e._setExecutionVariable(this, "mesh", i), t = i.getScene().onPointerObservable.add((t => {
					t.type === H_.POINTERPICK && t.pickInfo?.pickedMesh && (t.pickInfo?.pickedMesh === i || Hx(t.pickInfo?.pickedMesh, i)) && this._execute(e)
				}));
				const s = i.onDisposeObservable.add((() => this._onDispose));
				e._setExecutionVariable(this, "meshPickObserver", t), e._setExecutionVariable(this, "meshDisposeObserver", s)
			}
		}
		_getReferencedMesh() {
			const e = this.config.pathConverter.convert(this.config.path),
				t = e.info.getObject(e.object);
			if (!(t && t instanceof jd)) throw new Error("Mesh pick event block requires a valid mesh");
			return t
		}
	};
	Wx.ClassName = "FGMeshPickEventBlock", cc(Wx.ClassName, Wx), (Vx = Ux || (Ux = {}))[Vx.Stopped = 0] = "Stopped", Vx[Vx.Started = 1] = "Started";
	var zx = class e {
			createContext() {
				const e = new Gx({
					scene: this._scene,
					coordinator: this._coordinator
				});
				return this._executionContexts.push(e), e
			}
			constructor(e) {
				this._eventBlocks = [], this._executionContexts = [], this.state = 0, this._scene = e.scene, this._coordinator = e.coordinator, this._sceneDisposeObserver = this._scene.onDisposeObservable.add((() => this.dispose()))
			}
			dispose() {
				if (0 !== this.state) {
					this.state = 0;
					for (const e of this._executionContexts) e._clearPendingBlocks();
					this._executionContexts.length = 0, this._eventBlocks.length = 0, this._scene.onDisposeObservable.remove(this._sceneDisposeObserver), this._sceneDisposeObserver = null
				}
			}
			static GetSignalInConnectionByUniqueId(e, t) {
				for (const i of e)
					if (i instanceof Fx)
						for (const e of i.signalInputs)
							if (e.ik === t) return e;
				throw new Error("Could not find signal in connection with unique id " + t)
			}
			addEventBlock(e) {
				this._eventBlocks.push(e)
			}
			static Parse(t, i) {
				const s = i.coordinator.createGraph(),
					n = [],
					a = i.valueParseFunction ?? kx;
				for (const e of t.allBlocks) {
					const t = Dx.Parse(e, {
						scene: i.coordinator.config.scene,
						pathConverter: i.pathConverter,
						valueParseFunction: a
					});
					n.push(t), t instanceof Bx && s.addEventBlock(t)
				}
				for (const t of n) {
					for (const i of t.dataInputs)
						for (const t of i.connectedPointIds) {
							const s = e.GetDataOutConnectionByUniqueId(n, t);
							i.connectTo(s)
						}
					if (t instanceof Fx)
						for (const i of t.signalOutputs)
							for (const t of i.connectedPointIds) {
								const s = e.GetSignalInConnectionByUniqueId(n, t);
								i.connectTo(s)
							}
				}
				for (const e of t.executionContexts) Gx.Parse(e, {
					graph: s,
					valueParseFunction: a
				});
				return s
			}
			static GetDataOutConnectionByUniqueId(e, t) {
				for (const i of e)
					for (const e of i.dataOutputs)
						if (e.ik === t) return e;
				throw new Error("Could not find data out connection with unique id " + t)
			}
			visitAllBlocks(e) {
				const t = [],
					i = new Set;
				for (const e of this._eventBlocks) t.push(e), i.add(e.ik);
				for (; t.length > 0;) {
					const s = t.pop();
					e(s);
					for (const e of s.dataInputs)
						for (const s of e._connectedPoint) i.has(s._ownerBlock.ik) || (t.push(s._ownerBlock), i.add(s._ownerBlock.ik));
					if (s instanceof Fx)
						for (const e of s.signalOutputs)
							for (const s of e._connectedPoint) i.has(s._ownerBlock.ik) || (t.push(s._ownerBlock), i.add(s._ownerBlock.ik))
				}
			}
			start() {
				if (1 !== this.state) {
					this.state = 1, 0 === this._executionContexts.length && this.createContext();
					for (const e of this._executionContexts) {
						const t = this._getContextualOrder();
						for (const i of t) i._startPendingTasks(e)
					}
				}
			}
			_getContextualOrder() {
				const e = [];
				for (const t of this._eventBlocks)
					if (t.getClassName() === Wx.ClassName) {
						const i = t._getReferencedMesh();
						let s = 0;
						for (; s < e.length; s++) {
							const t = e[s]._getReferencedMesh();
							if (i && t && Hx(i, t)) break
						}
						e.splice(s, 0, t)
					} else e.push(t);
				return e
			}
			serialize(e = {}, t) {
				e.allBlocks = [], this.visitAllBlocks((t => {
					const i = {};
					t.serialize(i), e.allBlocks.push(i)
				})), e.executionContexts = [];
				for (const i of this._executionContexts) {
					const s = {};
					i.serialize(s, t), e.executionContexts.push(s)
				}
			}
			getContext(e) {
				return this._executionContexts[e]
			}
		},
		Xx = class e {
			removeGraph(e) {
				const t = this._flowGraphs.indexOf(e); - 1 !== t && (e.dispose(), this._flowGraphs.splice(t, 1))
			}
			start() {
				this._flowGraphs.forEach((e => e.start()))
			}
			getCustomEventObservable(e) {
				let t = this._customEventsMap.get(e);
				return t || (t = new kc, this._customEventsMap.set(e, t)), t
			}
			notifyCustomEvent(e, t) {
				const i = this._customEventsMap.get(e);
				i && i.notifyObservers(t)
			}
			constructor(t) {
				this.config = t, this._flowGraphs = [], this._customEventsMap = new Map, this.config.scene.onDisposeObservable.add((() => {
					this.dispose()
				}));
				(e.SceneCoordinators.get(this.config.scene) ?? []).push(this)
			}
			get flowGraphs() {
				return this._flowGraphs
			}
			createGraph() {
				const e = new zx({
					scene: this.config.scene,
					coordinator: this
				});
				return this._flowGraphs.push(e), e
			}
			dispose() {
				this._flowGraphs.forEach((e => e.dispose())), this._flowGraphs.length = 0;
				const t = e.SceneCoordinators.get(this.config.scene) ?? [],
					i = t.indexOf(this); - 1 !== i && t.splice(i, 1)
			}
			serialize(e, t) {
				e._flowGraphs = [], this._flowGraphs.forEach((i => {
					const s = {};
					i.serialize(s, t), e._flowGraphs.push(s)
				}))
			}
			static Parse(t, i) {
				const s = i.valueParseFunction ?? kx,
					n = new e({
						scene: i.scene
					});
				return t._flowGraphs?.forEach((e => {
					zx.Parse(e, {
						coordinator: n,
						valueParseFunction: s,
						pathConverter: i.pathConverter
					})
				})), n
			}
		};
	Xx.SceneCoordinators = new Map;
	var Yx = class e extends Bx {
		_preparePendingTasks(e) {
			if (!e._getExecutionVariable(this, "sceneReadyObserver")) {
				const t = e.configuration.scene.onReadyObservable.add((() => {
					this._execute(e)
				}));
				e._setExecutionVariable(this, "sceneReadyObserver", t)
			}
		}
		getClassName() {
			return e.ClassName
		}
		_cancelPendingTasks(e) {
			const t = e._getExecutionVariable(this, "sceneReadyObserver");
			e.configuration.scene.onReadyObservable.remove(t), e._deleteExecutionVariable(this, "sceneReadyObserver")
		}
	};
	Yx.ClassName = "FGSceneReadyEventBlock", cc("FGSceneReadyEventBlock", Yx);
	var jx = class e extends Bx {
		_cancelPendingTasks(e) {
			const t = e._getExecutionVariable(this, "sceneBeforeRender");
			e.configuration.scene.onBeforeRenderObservable.remove(t), e._deleteExecutionVariable(this, "sceneBeforeRender")
		}
		_preparePendingTasks(e) {
			if (!e._getExecutionVariable(this, "sceneBeforeRender")) {
				const t = e.configuration.scene.onBeforeRenderObservable.add((() => {
					this._execute(e)
				}));
				e._setExecutionVariable(this, "sceneBeforeRender", t)
			}
		}
		getClassName() {
			return e.ClassName
		}
	};
	jx.ClassName = "FGSceneTickEventBlock", cc(jx.ClassName, jx);
	var Kx, $x, Jx = class extends Fx {
			constructor(e) {
				super(e), this.out = this._registerSignalOutput("out")
			}
		},
		qx = class e extends Jx {
			constructor(e) {
				super(e), this.message = this.registerDataInput("message", Ax)
			}
			_execute(e) {
				const t = this.message.getValue(e);
				Qc.Log(t), this.out._activateSignal(e)
			}
			getClassName() {
				return e.ClassName
			}
		};
	qx.ClassName = "FGConsoleLogBlock", cc(qx.ClassName, qx), ($x = Kx || (Kx = {}))[$x.INIT = 0] = "INIT", $x[$x.STARTED = 1] = "STARTED", $x[$x.ENDED = 2] = "ENDED";
	var Qx = class {
			set breakCondition(e) {
				this._breakCondition = e
			}
			_stop(e, t = !1) {
				this._contextObservable.remove(this._observer), this._setState(2), t ? this.onTimerAbortedObservable.notifyObservers(e) : this.onTimerEndedObservable.notifyObservers(e)
			}
			dispose() {
				this._observer && this._contextObservable.remove(this._observer), this.clearObservables()
			}
			start(e = this._timeToEnd) {
				if (1 === this._state) throw new Error("Timer already started. Please stop it before starting again");
				this._timeToEnd = e, this._startTime = Date.now(), this._timer = 0, this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope), this._setState(1)
			}
			clearObservables() {
				this.onEachCountObservable.clear(), this.onTimerAbortedObservable.clear(), this.onTimerEndedObservable.clear(), this.onStateChangedObservable.clear()
			}
			stop() {
				1 === this._state && (this._breakOnNextTick = !0)
			}
			_setState(e) {
				this._state = e, this.onStateChangedObservable.notifyObservers(this._state)
			}
			constructor(e) {
				this.onEachCountObservable = new kc, this.onTimerAbortedObservable = new kc, this.onTimerEndedObservable = new kc, this.onStateChangedObservable = new kc, this._observer = null, this._breakOnNextTick = !1, this._tick = e => {
					const t = Date.now();
					this._timer = t - this._startTime;
					const i = {
							startTime: this._startTime,
							currentTime: t,
							deltaTime: this._timer,
							completeRate: this._timer / this._timeToEnd,
							payload: e
						},
						s = this._breakOnNextTick || this._breakCondition(i);
					s || this._timer >= this._timeToEnd ? this._stop(i, s) : this.onEachCountObservable.notifyObservers(i)
				}, this._setState(0), this._contextObservable = e.contextObservable, this._observableParameters = e.observableParameters ?? {}, this._breakCondition = e.breakCondition ?? (() => !1), this._timeToEnd = e.timeout, e.onEnded && this.onTimerEndedObservable.add(e.onEnded), e.onTick && this.onEachCountObservable.add(e.onTick), e.onAborted && this.onTimerAbortedObservable.add(e.onAborted)
			}
		},
		Zx = class e extends Lx {
			_cancelPendingTasks(e) {
				const t = e._getExecutionVariable(this, "runningTimers") || [];
				for (const e of t) e.dispose();
				e._deleteExecutionVariable(this, "runningTimers")
			}
			constructor(e) {
				super(e), this.timeout = this.registerDataInput("timeout", bx)
			}
			_preparePendingTasks(e) {
				const t = this.timeout.getValue(e);
				if (void 0 !== t && t >= 0) {
					const i = e._getExecutionVariable(this, "runningTimers") || [],
						s = e.configuration.scene,
						n = new Qx({
							timeout: t,
							contextObservable: s.onBeforeRenderObservable,
							onEnded: () => this._onEnded(n, e)
						});
					n.start(), i.push(n), e._setExecutionVariable(this, "runningTimers", i)
				}
			}
			_execute(e) {
				this._startPendingTasks(e), this.out._activateSignal(e)
			}
			_onEnded(e, t) {
				const i = t._getExecutionVariable(this, "runningTimers") || [],
					s = i.indexOf(e); - 1 !== s ? i.splice(s, 1) : dd.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"), t._removePendingBlock(this), this.done._activateSignal(t)
			}
			getClassName() {
				return e.ClassName
			}
		};
	Zx.ClassName = "FGTimerBlock", cc("FGTimerBlock", Zx);
	var eM = class e extends Jx {
		getClassName() {
			return e.ClassName
		}
		_execute(e) {
			const t = this.config.eventId,
				i = this.dataInputs.map((t => t.getValue(e)));
			e.configuration.coordinator.notifyCustomEvent(t, i), this.out._activateSignal(e)
		}
		constructor(e) {
			super(e), this.config = e;
			for (let e = 0; e < this.config.eventData.length; e++) {
				const t = this.config.eventData[e];
				this.registerDataInput(t, Ax)
			}
		}
	};
	eM.ClassName = "FGSendCustomEventBlock", cc("FGSendCustomEventBlock", eM);
	var tM = class e extends Bx {
		_preparePendingTasks(e) {
			const t = e.configuration.coordinator.getCustomEventObservable(this.config.eventId);
			this._eventObserver = t.add((t => {
				for (let i = 0; i < t.length; i++) this.dataOutputs[i].setValue(t[i], e);
				this._execute(e)
			}))
		}
		_cancelPendingTasks(e) {
			const t = e.configuration.coordinator.getCustomEventObservable(this.config.eventId);
			t ? t.remove(this._eventObserver) : dd.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)
		}
		serialize(e) {
			super.serialize(e), e.eventId = this.config.eventId, e.eventData = this.config.eventData
		}
		constructor(e) {
			super(e), this.config = e;
			for (let e = 0; e < this.config.eventData.length; e++) {
				const t = this.config.eventData[e];
				this.registerDataOutput(t, Ax)
			}
		}
		getClassName() {
			return e.ClassName
		}
	};
	tM.ClassName = "FGReceiveCustomEventBlock", cc(tM.ClassName, tM);
	var iM = class e extends Fx {
		constructor(e) {
			super(e), this.config = e, this.outFlows = [];
			for (let e = 0; e < this.config.numberOutputFlows; e++) this.outFlows.push(this._registerSignalOutput(`${e}`))
		}
		getClassName() {
			return e.ClassName
		}
		_execute(e) {
			for (let t = 0; t < this.config.numberOutputFlows; t++) this.outFlows[t]._activateSignal(e)
		}
	};
	iM.ClassName = "FGSequenceBlock", cc(iM.ClassName, iM);
	var sM = new RegExp(/\{(\w+)\}/g),
		nM = class {
			constructor(e, t) {
				this.path = e, this.ownerBlock = t, this.templatedInputs = [];
				let i = sM.exec(e);
				for (; i;) {
					const [, s] = i;
					this.templatedInputs.push(t.registerDataInput(s, wx)), i = sM.exec(e)
				}
			}
			getAccessor(e, t) {
				let i = this.path;
				for (const e of this.templatedInputs) {
					const s = e.getValue(t).value;
					i = i.replace(`{${e.name}}`, s.toString())
				}
				return e.convert(i)
			}
		},
		aM = class e extends Dx {
			serialize(e = {}) {
				super.serialize(e), e.config.path = this.config.path
			}
			_updateOutputs(e) {
				const t = this.templateComponent.getAccessor(this.config.pathConverter, e),
					i = t.info.get(t.object);
				this.value.setValue(i, e)
			}
			getClassName() {
				return e.ClassName
			}
			constructor(e) {
				super(e), this.config = e, this.value = this.registerDataOutput("value", Ax), this.templateComponent = new nM(e.path, this)
			}
		};
	aM.ClassName = "FGGetPropertyBlock", cc(aM.ClassName, aM);
	var rM = class e extends Jx {
		_execute(e) {
			const t = this.a.getValue(e),
				i = this.templateComponent.getAccessor(this.config.pathConverter, e);
			i.info.set(t, i.object), this.out._activateSignal(e)
		}
		serialize(e = {}) {
			super.serialize(e), e.config.path = this.config.path
		}
		constructor(e) {
			super(e), this.config = e, this.a = this.registerDataInput("a", Ax), this.templateComponent = new nM(e.path, this)
		}
		getClassName() {
			return e.ClassName
		}
	};
	rM.ClassName = "FGSetPropertyBlock", cc("FGSetPropertyBlock", rM);
	var oM = "cachedOperationValue",
		lM = "cachedExecutionId",
		hM = class extends Dx {
			constructor(e, t) {
				super(t), this.value = this.registerDataOutput("value", e)
			}
			_updateOutputs(e) {
				const t = e._getExecutionVariable(this, lM),
					i = e._getExecutionVariable(this, oM);
				if (void 0 !== i && t === e.executionId) this.value.setValue(i, e);
				else {
					const t = this._doOperation(e);
					e._setExecutionVariable(this, oM, t), e._setExecutionVariable(this, lM, e.executionId), this.value.setValue(t, e)
				}
			}
		},
		cM = class extends hM {
			constructor(e, t, i, s, n, a) {
				super(i, a), this._operation = s, this._className = n, this.a = this.registerDataInput("a", e), this.b = this.registerDataInput("b", t)
			}
			getClassName() {
				return this._className
			}
			_doOperation(e) {
				return this._operation(this.a.getValue(e), this.b.getValue(e))
			}
		},
		uM = class extends hM {
			_doOperation(e) {
				return this._operation()
			}
			constructor(e, t, i, s) {
				super(e, s), this._operation = t, this._className = i
			}
			getClassName() {
				return this._className
			}
		},
		mM = class extends hM {
			_doOperation(e) {
				return this._operation(this.a.getValue(e))
			}
			constructor(e, t, i, s, n) {
				super(t, n), this._operation = i, this._className = s, this.a = this.registerDataInput("a", e)
			}
			getClassName() {
				return this._className
			}
		},
		dM = class extends hM {
			constructor(e, t, i, s, n, a, r) {
				super(s, r), this._operation = n, this._className = a, this.a = this.registerDataInput("a", e), this.b = this.registerDataInput("b", t), this.c = this.registerDataInput("c", i)
			}
			_doOperation(e) {
				return this._operation(this.a.getValue(e), this.b.getValue(e), this.c.getValue(e))
			}
			getClassName() {
				return this._className
			}
		};

	function fM(e) {
		return e.getClassName ? e.getClassName() : ""
	}

	function pM(e, t) {
		return "Vector2" === e && "Vector2" === t || "Vector3" === e && "Vector3" === t || "Vector4" === e && "Vector4" === t
	}

	function _M(e, t) {
		return "Matrix" === e && "Matrix" === t
	}

	function gM(e, t) {
		return "FlowGraphInteger" === e && "FlowGraphInteger" === t
	}
	var vM = class e extends cM {
		_polymorphicAdd(e, t) {
			const i = fM(e),
				s = fM(t);
			return pM(i, s) || _M(i, s) || gM(i, s) ? e.add(t) : e + t
		}
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicAdd(e, t)), e.ClassName, t)
		}
	};
	vM.ClassName = "FGAddBlock", cc(vM.ClassName, vM);
	var yM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicAdd(e, t)), e.ClassName, t)
		}
		_polymorphicAdd(e, t) {
			const i = fM(e),
				s = fM(t);
			return pM(i, s) || gM(i, s) ? e.subtract(t) : _M(i, s) ? e.add(t.scale(-1)) : e - t
		}
	};
	yM.ClassName = "FGSubBlock", cc(yM.ClassName, yM);
	var SM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicMultiply(e, t)), e.ClassName, t)
		}
		_polymorphicMultiply(e, t) {
			const i = fM(e),
				s = fM(t);
			return pM(i, s) || gM(i, s) ? e.multiply(t) : _M(i, s) ? Hc.FromValues(e.m[0] * t.m[0], e.m[4] * t.m[4], e.m[8] * t.m[8], e.m[12] * t.m[12], e.m[1] * t.m[1], e.m[5] * t.m[5], e.m[9] * t.m[9], e.m[13] * t.m[13], e.m[2] * t.m[2], e.m[6] * t.m[6], e.m[10] * t.m[10], e.m[14] * t.m[14], e.m[3] * t.m[3], e.m[7] * t.m[7], e.m[11] * t.m[11], e.m[15] * t.m[15]) : e * t
		}
	};
	SM.ClassName = "FGMultiplyBlock", cc(SM.ClassName, SM);
	var EM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicDivide(e, t)), e.ClassName, t)
		}
		_polymorphicDivide(e, t) {
			const i = fM(e),
				s = fM(t);
			return pM(i, s) || gM(i, s) ? e.divide(t) : _M(i, s) ? Hc.FromValues(e.m[0] / t.m[0], e.m[4] / t.m[4], e.m[8] / t.m[8], e.m[12] / t.m[12], e.m[1] / t.m[1], e.m[5] / t.m[5], e.m[9] / t.m[9], e.m[13] / t.m[13], e.m[2] / t.m[2], e.m[6] / t.m[6], e.m[10] / t.m[10], e.m[14] / t.m[14], e.m[3] / t.m[3], e.m[7] / t.m[7], e.m[11] / t.m[11], e.m[15] / t.m[15]) : e / t
		}
	};
	EM.ClassName = "FGDivideBlock", cc(EM.ClassName, EM);
	var AM = class e extends uM {
		constructor(t) {
			super(bx, (() => Math.random()), e.ClassName, t)
		}
	};
	AM.ClassName = "FGRandomBlock", cc(AM.ClassName, AM);
	var bM = class e extends cM {
		_polymorphicDot(e, t) {
			switch (fM(e)) {
				case "Vector2":
					return Fc.Dot(e, t);
				case "Vector3":
					return Lc.Dot(e, t);
				case "Vector4":
					return Bc.Dot(e, t);
				default:
					throw new Error(`Cannot get dot product of ${e} and ${t}`)
			}
		}
		constructor(t) {
			super(Ax, Ax, bx, ((e, t) => this._polymorphicDot(e, t)), e.ClassName, t)
		}
	};
	bM.ClassName = "FGDotBlock", cc(bM.ClassName, bM);
	var xM = class e extends uM {
		constructor(t) {
			super(bx, (() => Math.E), e.ClassName, t)
		}
	};
	xM.ClassName = "FGEBlock", cc(xM.ClassName, xM);
	var MM = class e extends uM {
		constructor(t) {
			super(bx, (() => Math.PI), e.ClassName, t)
		}
	};
	MM.ClassName = "FGPIBlock", cc(MM.ClassName, MM);
	var CM = class e extends uM {
		constructor(t) {
			super(bx, (() => Number.POSITIVE_INFINITY), e.ClassName, t)
		}
	};
	CM.ClassName = "FGInfBlock", cc(CM.ClassName, CM);
	var TM = class e extends uM {
		constructor(t) {
			super(bx, (() => Number.NaN), e.ClassName, t)
		}
	};

	function wM(e, t) {
		switch (fM(e)) {
			case "FlowGraphInteger":
				return new Sx(t(e.value));
			case "Vector2":
				return new Fc(t(e.x), t(e.y));
			case "Vector3":
				return new Lc(t(e.x), t(e.y), t(e.z));
			case "Vector4":
				return new Bc(t(e.x), t(e.y), t(e.z), t(e.w));
			case "Matrix":
				return Hc.FromValues(t(e.m[0]), t(e.m[4]), t(e.m[8]), t(e.m[12]), t(e.m[1]), t(e.m[5]), t(e.m[9]), t(e.m[13]), t(e.m[2]), t(e.m[6]), t(e.m[10]), t(e.m[14]), t(e.m[3]), t(e.m[7]), t(e.m[11]), t(e.m[15]));
			default:
				return t(e)
		}
	}
	TM.ClassName = "FGNaNBlock", cc(TM.ClassName, TM);
	var RM = class e extends mM {
		_polymorphicAbs(e) {
			return wM(e, Math.abs)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicAbs(e)), e.ClassName, t)
		}
	};
	RM.ClassName = "FGAbsBlock", cc(RM.ClassName, RM);
	var NM = class e extends mM {
		_polymorphicSign(e) {
			return wM(e, Math.sign)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicSign(e)), e.ClassName, t)
		}
	};
	NM.ClassName = "FGSignBlock", cc(NM.ClassName, NM);
	var IM = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicTrunc(e)), e.ClassName, t)
		}
		_polymorphicTrunc(e) {
			return wM(e, Math.trunc)
		}
	};
	IM.ClassName = "FGTruncBlock", cc(IM.ClassName, IM);
	var PM = class e extends mM {
		_polymorphicFloor(e) {
			return wM(e, Math.floor)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicFloor(e)), e.ClassName, t)
		}
	};
	PM.ClassName = "FGFloorBlock", cc(PM.ClassName, PM);
	var kM = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicCeiling(e)), e.ClassName, t)
		}
		_polymorphicCeiling(e) {
			return wM(e, Math.ceil)
		}
	};
	kM.ClassName = "FGCeilBlock", cc(kM.ClassName, kM);
	var DM = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicFract(e)), e.ClassName, t)
		}
		_polymorphicFract(e) {
			return wM(e, (e => e - Math.floor(e)))
		}
	};
	DM.ClassName = "FGFractBlock", cc(DM.ClassName, DM);
	var OM = class e extends mM {
		_polymorphicNeg(e) {
			return wM(e, (e => -e))
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicNeg(e)), e.ClassName, t)
		}
	};

	function FM(e, t, i) {
		switch (fM(e)) {
			case "FlowGraphInteger":
				return new Sx(i(e.value, t.value));
			case "Vector2":
				return new Fc(i(e.x, t.x), i(e.y, t.y));
			case "Vector3":
				return new Lc(i(e.x, t.x), i(e.y, t.y), i(e.z, t.z));
			case "Vector4":
				return new Bc(i(e.x, t.x), i(e.y, t.y), i(e.z, t.z), i(e.w, t.w));
			case "Matrix":
				return Hc.FromValues(i(e.m[0], t.m[0]), i(e.m[4], t.m[4]), i(e.m[8], t.m[8]), i(e.m[12], t.m[12]), i(e.m[1], t.m[1]), i(e.m[5], t.m[5]), i(e.m[9], t.m[9]), i(e.m[13], t.m[13]), i(e.m[2], t.m[2]), i(e.m[6], t.m[6]), i(e.m[10], t.m[10]), i(e.m[14], t.m[14]), i(e.m[3], t.m[3]), i(e.m[7], t.m[7]), i(e.m[11], t.m[11]), i(e.m[15], t.m[15]));
			default:
				return i(e, t)
		}
	}
	OM.ClassName = "FGNegBlock", cc(OM.ClassName, OM);
	var LM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicRemainder(e, t)), e.ClassName, t)
		}
		_polymorphicRemainder(e, t) {
			return FM(e, t, ((e, t) => e % t))
		}
	};
	LM.ClassName = "FGRemainderBlock", cc(LM.ClassName, LM);
	var BM = class e extends cM {
		_polymorphicMin(e, t) {
			return FM(e, t, Math.min)
		}
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicMin(e, t)), e.ClassName, t)
		}
	};
	BM.ClassName = "FGMinBlock", cc(BM.ClassName, BM);
	var GM = class e extends cM {
		_polymorphicMax(e, t) {
			return FM(e, t, Math.max)
		}
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicMax(e, t)), e.ClassName, t)
		}
	};

	function HM(e, t, i) {
		return Math.min(Math.max(e, Math.min(t, i)), Math.max(t, i))
	}

	function UM(e, t, i, s) {
		switch (fM(e)) {
			case "FlowGraphInteger":
				return new Sx(s(e.value, t.value, i.value));
			case "Vector2":
				return new Fc(s(e.x, t.x, i.x), s(e.y, t.y, i.y));
			case "Vector3":
				return new Lc(s(e.x, t.x, i.x), s(e.y, t.y, i.y), s(e.z, t.z, i.z));
			case "Vector4":
				return new Bc(s(e.x, t.x, i.x), s(e.y, t.y, i.y), s(e.z, t.z, i.z), s(e.w, t.w, i.w));
			case "Matrix":
				return Hc.FromValues(s(e.m[0], t.m[0], i.m[0]), s(e.m[4], t.m[4], i.m[4]), s(e.m[8], t.m[8], i.m[8]), s(e.m[12], t.m[12], i.m[12]), s(e.m[1], t.m[1], i.m[1]), s(e.m[5], t.m[5], i.m[5]), s(e.m[9], t.m[9], i.m[9]), s(e.m[13], t.m[13], i.m[13]), s(e.m[2], t.m[2], i.m[2]), s(e.m[6], t.m[6], i.m[6]), s(e.m[10], t.m[10], i.m[10]), s(e.m[14], t.m[14], i.m[14]), s(e.m[3], t.m[3], i.m[3]), s(e.m[7], t.m[7], i.m[7]), s(e.m[11], t.m[11], i.m[11]), s(e.m[15], t.m[15], i.m[15]));
			default:
				return s(e, t, i)
		}
	}
	GM.ClassName = "FGMaxBlock", cc(GM.ClassName, GM);
	var VM = class e extends dM {
		constructor(t) {
			super(Ax, Ax, Ax, Ax, ((e, t, i) => this._polymorphicClamp(e, t, i)), e.ClassName, t)
		}
		_polymorphicClamp(e, t, i) {
			return UM(e, t, i, HM)
		}
	};

	function WM(e) {
		return Math.min(Math.max(e, 0), 1)
	}
	VM.ClassName = "FGClampBlock", cc(VM.ClassName, VM);
	var zM = class e extends mM {
		_polymorphicSaturate(e) {
			return wM(e, WM)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicSaturate(e)), e.ClassName, t)
		}
	};
	zM.ClassName = "FGSaturateBlock", cc(zM.ClassName, zM);
	var XM = class e extends dM {
		constructor(t) {
			super(Ax, Ax, Ax, Ax, ((e, t, i) => this._polymorphicInterpolate(e, t, i)), e.ClassName, t)
		}
		_polymorphicInterpolate(e, t, i) {
			return UM(e, t, i, this._interpolate)
		}
		_interpolate(e, t, i) {
			return (1 - i) * e + i * t
		}
	};
	XM.ClassName = "FGInterpolateBlock", cc(XM.ClassName, XM);
	var YM = class e extends cM {
		_polymorphicEq(e, t) {
			const i = fM(e),
				s = fM(t);
			return pM(i, s) || _M(i, s) || gM(i, s) ? e.equals(t) : e === t
		}
		constructor(t) {
			super(Ax, Ax, xx, ((e, t) => this._polymorphicEq(e, t)), e.ClassName, t)
		}
	};

	function jM(e, t, i) {
		const s = fM(e);
		if (s === fM(t)) {
			if ("" === s) return i(e, t);
			if ("FlowGraphInteger" === s) return i(e.value, t.value);
			throw new Error(`Cannot compare ${e} and ${t}`)
		}
		throw new Error(`${e} and ${t} are of different types.`)
	}
	YM.ClassName = "FGEqBlock", cc(YM.ClassName, YM);
	var KM = class e extends cM {
		_polymorphicLessThan(e, t) {
			return jM(e, t, ((e, t) => e < t))
		}
		constructor(t) {
			super(Ax, Ax, xx, ((e, t) => this._polymorphicLessThan(e, t)), e.ClassName, t)
		}
	};
	KM.ClassName = "FGLessThanBlock", cc(KM.ClassName, KM);
	var $M = class e extends cM {
		_polymorphicLessThanOrEqual(e, t) {
			return jM(e, t, ((e, t) => e <= t))
		}
		constructor(t) {
			super(Ax, Ax, xx, ((e, t) => this._polymorphicLessThanOrEqual(e, t)), e.ClassName, t)
		}
	};
	$M.ClassName = "FGLessThanOrEqualBlock";
	var JM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, xx, ((e, t) => this._polymorphicGreaterThan(e, t)), e.ClassName, t)
		}
		_polymorphicGreaterThan(e, t) {
			return jM(e, t, ((e, t) => e > t))
		}
	};
	JM.ClassName = "FGGreaterThanBlock", cc(JM.ClassName, JM);
	var qM = class e extends cM {
		constructor(t) {
			super(Ax, Ax, xx, ((e, t) => this._polymorphicGreaterThanOrEqual(e, t)), e.ClassName, t)
		}
		_polymorphicGreaterThanOrEqual(e, t) {
			return jM(e, t, ((e, t) => e >= t))
		}
	};
	qM.ClassName = "FGGreaterThanOrEqualBlock", cc(qM.ClassName, qM);
	var QM = class e extends mM {
		_polymorphicIsNan(e) {
			const t = fM(e);
			if ("" === t) return isNaN(e);
			if ("FlowGraphInteger" === t) return isNaN(e.value);
			throw new Error(`Cannot get NaN of ${e}`)
		}
		constructor(t) {
			super(Ax, xx, (e => this._polymorphicIsNan(e)), e.ClassName, t)
		}
	};
	QM.ClassName = "FGIsNanBlock", cc(QM.ClassName, QM);
	var ZM = class e extends mM {
		constructor(t) {
			super(Ax, xx, (e => this._polymorphicIsInf(e)), e.ClassName, t)
		}
		_polymorphicIsInf(e) {
			const t = fM(e);
			if ("" === t) return !isFinite(e);
			if ("FlowGraphInteger" === t) return !isFinite(e.value);
			throw new Error(`Cannot get isInf of ${e}`)
		}
	};
	ZM.ClassName = "FGIsInfBlock";
	var eC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicDegToRad(e)), e.ClassName, t)
		}
		_polymorphicDegToRad(e) {
			return wM(e, this._degToRad)
		}
		_degToRad(e) {
			return e * Math.PI / 180
		}
	};
	eC.ClassName = "FGDegToRadBlock", cc(eC.ClassName, eC);
	var tC = class e extends mM {
		_polymorphicRadToDeg(e) {
			return wM(e, this._radToDeg)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicRadToDeg(e)), e.ClassName, t)
		}
		_radToDeg(e) {
			return 180 * e / Math.PI
		}
	};
	tC.ClassName = "FGRadToDegBlock", cc(tC.ClassName, tC);
	var iC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicSin(e)), e.ClassName, t)
		}
		_polymorphicSin(e) {
			return wM(e, Math.sin)
		}
	};
	iC.ClassName = "FGSinBlock", cc(iC.ClassName, iC);
	var sC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicCos(e)), e.ClassName, t)
		}
		_polymorphicCos(e) {
			return wM(e, Math.cos)
		}
	};
	sC.ClassName = "FGCosBlock", cc(sC.ClassName, sC);
	var nC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicTan(e)), e.ClassName, t)
		}
		_polymorphicTan(e) {
			return wM(e, Math.tan)
		}
	};
	nC.ClassName = "FGTanBlock", cc(nC.ClassName, nC);
	var aC = class e extends mM {
		_polymorphicAsin(e) {
			return wM(e, Math.asin)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicAsin(e)), e.ClassName, t)
		}
	};
	aC.ClassName = "FGAsinBlock", cc(aC.ClassName, aC);
	var rC = class e extends mM {
		_polymorphicAcos(e) {
			return wM(e, Math.acos)
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicAcos(e)), e.ClassName, t)
		}
	};
	rC.ClassName = "FGAcosBlock", cc(rC.ClassName, rC);
	var oC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicAtan(e)), e.ClassName, t)
		}
		_polymorphicAtan(e) {
			return wM(e, Math.atan)
		}
	};
	oC.ClassName = "FGAtanBlock", cc(oC.ClassName, oC);
	var lC = class e extends cM {
		_polymorphicAtan2(e, t) {
			return FM(e, t, Math.atan2)
		}
		constructor(t) {
			super(Ax, Ax, Ax, ((e, t) => this._polymorphicAtan2(e, t)), e.ClassName, t)
		}
	};
	lC.ClassName = "FGAtan2Block", cc(lC.ClassName, lC);
	var hC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicSinh(e)), e.ClassName, t)
		}
		_polymorphicSinh(e) {
			return wM(e, Math.sinh)
		}
	};
	hC.ClassName = "FGSinhBlock", cc(hC.ClassName, hC);
	var cC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicCosh(e)), e.ClassName, t)
		}
		_polymorphicCosh(e) {
			return wM(e, Math.cosh)
		}
	};
	cC.ClassName = "FGCoshBlock", cc(cC.ClassName, cC);
	var uC = class e extends mM {
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicTanh(e)), e.ClassName, t)
		}
		_polymorphicTanh(e) {
			return wM(e, Math.tanh)
		}
	};
	uC.ClassName = "FGTanhBlock", cc(uC.ClassName, uC);
	var mC = class e extends mM {
		_polymorphicAsinh(e) {
			return wM(e, Math.asinh)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicAsinh(e)), e.ClassName, t)
		}
	};
	mC.ClassName = "FGAsinhBlock", cc(mC.ClassName, mC);
	var dC = class e extends mM {
		_polymorphicAcosh(e) {
			return wM(e, Math.acosh)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicAcosh(e)), e.ClassName, t)
		}
	};
	dC.ClassName = "FGAcoshBlock", cc(dC.ClassName, dC);
	var fC = class e extends mM {
		_polymorphicAtanh(e) {
			return wM(e, Math.atanh)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicAtanh(e)), e.ClassName, t)
		}
	};
	fC.ClassName = "FGAtanhBlock", cc(fC.ClassName, fC);
	var pC = class e extends mM {
		_polymorphicExp(e) {
			return wM(e, Math.exp)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicExp(e)), e.ClassName, t)
		}
	};
	pC.ClassName = "FGExpBlock", cc(pC.ClassName, pC);
	var _C = class e extends mM {
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicLog(e)), e.ClassName, t)
		}
		_polymorphicLog(e) {
			return wM(e, Math.log)
		}
	};
	_C.ClassName = "FGLogBlock", cc(_C.ClassName, _C);
	var gC = class e extends mM {
		_polymorphicLog2(e) {
			return wM(e, Math.log2)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicLog2(e)), e.ClassName, t)
		}
	};
	gC.ClassName = "FGLog2Block", cc(gC.ClassName, gC);
	var vC = class e extends mM {
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicLog10(e)), e.ClassName, t)
		}
		_polymorphicLog10(e) {
			return wM(e, Math.log10)
		}
	};
	vC.ClassName = "FGLog10Block", cc(vC.ClassName, vC);
	var yC = class e extends mM {
		_polymorphicSqrt(e) {
			return wM(e, Math.sqrt)
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicSqrt(e)), e.ClassName, t)
		}
	};
	yC.ClassName = "FGSqrtBlock", cc(yC.ClassName, yC);
	var SC = class e extends mM {
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicCubeRoot(e)), e.ClassName, t)
		}
		_polymorphicCubeRoot(e) {
			return wM(e, Math.cbrt)
		}
	};
	SC.ClassName = "FGCubeRootBlock", cc(SC.ClassName, SC);
	var EC = class e extends cM {
		constructor(t) {
			super(Ax, bx, bx, ((e, t) => this._polymorphicPow(e, t)), e.ClassName, t)
		}
		_polymorphicPow(e, t) {
			return FM(e, t, Math.pow)
		}
	};
	EC.ClassName = "FGPowBlock", cc(EC.ClassName, EC);
	var AC = class e extends mM {
		_polymorphicLength(e) {
			switch (fM(e)) {
				case "Vector2":
				case "Vector3":
				case "Vector4":
					return e.length();
				default:
					throw new Error(`Cannot compute length of value ${e}`)
			}
		}
		constructor(t) {
			super(Ax, bx, (e => this._polymorphicLength(e)), e.ClassName, t)
		}
	};
	AC.ClassName = "FGLengthBlock", cc(AC.ClassName, AC);
	var bC = class e extends mM {
		_polymorphicNormalize(e) {
			switch (fM(e)) {
				case "Vector2":
				case "Vector3":
				case "Vector4":
					return e.normalize();
				default:
					throw new Error(`Cannot normalize value ${e}`)
			}
		}
		constructor(t) {
			super(Ax, Ax, (e => this._polymorphicNormalize(e)), e.ClassName, t)
		}
	};
	bC.ClassName = "FGNormalizeBlock", cc(bC.ClassName, bC);
	var xC = class e extends cM {
		constructor(t) {
			super(Cx, Cx, Cx, ((e, t) => Lc.Cross(e, t)), e.ClassName, t)
		}
	};
	xC.ClassName = "FGCrossBlock", cc(xC.ClassName, xC);
	var MC = class e extends cM {
		constructor(t) {
			super(Mx, bx, Mx, ((e, t) => Fc.Transform(e, Hc.RotationZ(t))), e.ClassName, t)
		}
	};
	MC.ClassName = "FGRotate2DBlock", cc(MC.ClassName, MC);
	var CC = class e extends dM {
		constructor(t) {
			super(Cx, Cx, bx, Cx, ((e, t, i) => Lc.TransformCoordinates(e, Hc.RotationAxis(t, i))), e.ClassName, t)
		}
	};
	CC.ClassName = "FGRotate3DBlock", cc(CC.ClassName, CC);
	var TC = class e extends mM {
		constructor(t) {
			super(Tx, Tx, (e => Hc.Transpose(e)), e.ClassName, t)
		}
	};
	TC.ClassName = "FGTransposeBlock", cc(TC.ClassName, TC);
	var wC = class e extends mM {
		constructor(t) {
			super(Tx, bx, (e => e.determinant()), e.ClassName, t)
		}
	};
	wC.ClassName = "FGDeterminantBlock", cc(wC.ClassName, wC);
	var RC = class e extends mM {
		constructor(t) {
			super(Tx, Tx, (e => Hc.Invert(e)), e.ClassName, t)
		}
	};
	RC.ClassName = "FGInvertMatrixBlock", cc(RC.ClassName, RC);
	var NC = class e extends cM {
		constructor(t) {
			super(Tx, Tx, Tx, ((e, t) => t.multiply(e)), e.ClassName, t)
		}
	};
	NC.ClassName = "FGMatMulBlock", cc(NC.ClassName, NC);
	var IC = class e extends mM {
		constructor(t) {
			super(wx, wx, (e => new Sx(~e.value)), e.ClassName, t)
		}
	};
	IC.ClassName = "FGBitwiseNotBlock", cc(IC.ClassName, IC);
	var PC = class e extends cM {
		constructor(t) {
			super(wx, wx, wx, ((e, t) => new Sx(e.value & t.value)), e.ClassName, t)
		}
	};
	PC.ClassName = "FGBitwiseAndBlock", cc(PC.ClassName, PC);
	var kC = class e extends cM {
		constructor(t) {
			super(wx, wx, wx, ((e, t) => new Sx(e.value | t.value)), e.ClassName, t)
		}
	};
	kC.ClassName = "FGBitwiseOrBlock", cc(kC.ClassName, kC);
	var DC = class e extends cM {
		constructor(t) {
			super(wx, wx, wx, ((e, t) => new Sx(e.value ^ t.value)), e.ClassName, t)
		}
	};
	DC.ClassName = "FGBitwiseXorBlock", cc(DC.ClassName, DC);
	var OC = class e extends cM {
		constructor(t) {
			super(wx, wx, wx, ((e, t) => new Sx(e.value << t.value)), e.ClassName, t)
		}
	};
	OC.ClassName = "FGBitwiseLeftShiftBlock", cc(OC.ClassName, OC);
	var FC = class e extends cM {
		constructor(t) {
			super(wx, wx, wx, ((e, t) => new Sx(e.value >> t.value)), e.ClassName, t)
		}
	};
	FC.ClassName = "FGBitwiseRightShiftBlock", cc(FC.ClassName, FC);
	var LC = class e extends mM {
		constructor(t) {
			super(wx, wx, (e => new Sx(Math.clz32(e.value))), e.ClassName, t)
		}
	};
	LC.ClassName = "FGCountLeadingZerosBlock", cc(LC.ClassName, LC);
	var BC = class e extends mM {
		constructor(t) {
			super(wx, wx, (e => new Sx(e.value ? 31 - Math.clz32(e.value & -e.value) : 32)), e.ClassName, t)
		}
	};
	BC.ClassName = "FGCountTrailingZerosBlock", cc(BC.ClassName, BC);
	var GC = class e extends mM {
		constructor(t) {
			super(wx, wx, (e => new Sx(function(e) {
				let t = 0;
				for (; e;) t += 1 & e, e >>= 1;
				return t
			}(e.value))), e.ClassName, t)
		}
	};
	GC.ClassName = "FGCountOneBitsBlock", cc(GC.ClassName, GC);
	var HC = class e extends Jx {
		constructor(e = {
			startIndex: new Sx(0)
		}) {
			super(e), this.config = e, this.reset = this._registerSignalInput("reset"), this.n = this.registerDataInput("n", wx), this.value = this.registerDataOutput("value", wx)
		}
		_execute(e, t) {
			if (t === this.reset) this.value.setValue(this.config.startIndex, e);
			else {
				const t = this.value.getValue(e);
				t.value < this.n.getValue(e).value && (this.value.setValue(new Sx(t.value + 1), e), this.out._activateSignal(e))
			}
		}
		getClassName() {
			return e.ClassName
		}
	};
	HC.ClassName = "FGDoNBlock", cc(HC.ClassName, HC);
	var UC = class e extends Dx {
		serialize(e) {
			super.serialize(e), e.config.variableName = this.config.variableName
		}
		getClassName() {
			return e.ClassName
		}
		constructor(e) {
			super(e), this.config = e, this.output = this.registerDataOutput(e.variableName, Ax)
		}
		_updateOutputs(e) {
			const t = this.config.variableName;
			e.hasVariable(t) && this.output.setValue(e.getVariable(t), e)
		}
	};
	UC.ClassName = "FGGetVariableBlock", cc(UC.ClassName, UC);
	var VC = class e extends Jx {
		constructor(e) {
			super(e), this.config = e, this.input = this.registerDataInput(e.variableName, Ax)
		}
		_execute(e) {
			const t = this.config.variableName,
				i = this.input.getValue(e);
			e.setVariable(t, i), this.out._activateSignal(e)
		}
		getClassName() {
			return e.ClassName
		}
	};
	VC.ClassName = "FGSetVariableBlock", cc(VC.ClassName, VC);
	var WC = class e extends Jx {
		constructor(e) {
			super(e), this.config = e, this.condition = this.registerDataInput("condition", xx), this.loopBody = this._registerSignalOutput("loopBody")
		}
		_execute(e, t) {
			let i = this.condition.getValue(e);
			for (this.config?.isDo && !i && this.loopBody._activateSignal(e); i;) this.loopBody._activateSignal(e), i = this.condition.getValue(e);
			this.out._activateSignal(e)
		}
		getClassName() {
			return e.ClassName
		}
		serialize(e) {
			super.serialize(e), e.isDo = this.config?.isDo
		}
	};
	WC.ClassName = "FGWhileLoopBlock", cc(WC.ClassName, WC);
	var zC = {
			"lifecycle/onStart": Yx.ClassName,
			"lifecycle/onTick": jx.ClassName,
			log: qx.ClassName,
			"flow/delay": Zx.ClassName,
			"customEvent/send": eM.ClassName,
			"customEvent/receive": tM.ClassName,
			"flow/sequence": iM.ClassName,
			"world/get": aM.ClassName,
			"world/set": rM.ClassName,
			"flow/doN": HC.ClassName,
			"variable/get": UC.ClassName,
			"variable/set": VC.ClassName,
			"flow/whileLoop": WC.ClassName,
			"math/random": AM.ClassName,
			"math/e": xM.ClassName,
			"math/pi": MM.ClassName,
			"math/inf": CM.ClassName,
			"math/nan": TM.ClassName,
			"math/abs": RM.ClassName,
			"math/sign": NM.ClassName,
			"math/trunc": IM.ClassName,
			"math/floor": PM.ClassName,
			"math/ceil": kM.ClassName,
			"math/fract": DM.ClassName,
			"math/neg": OM.ClassName,
			"math/add": vM.ClassName,
			"math/sub": yM.ClassName,
			"math/mul": SM.ClassName,
			"math/div": EM.ClassName,
			"math/rem": LM.ClassName,
			"math/min": BM.ClassName,
			"math/max": GM.ClassName,
			"math/clamp": VM.ClassName,
			"math/saturate": zM.ClassName,
			"math/mix": XM.ClassName,
			"math/eq": YM.ClassName,
			"math/lt": KM.ClassName,
			"math/le": $M.ClassName,
			"math/gt": JM.ClassName,
			"math/ge": qM.ClassName,
			"math/isnan": QM.ClassName,
			"math/isinf": ZM.ClassName,
			"math/rad": eC.ClassName,
			"math/deg": tC.ClassName,
			"math/sin": iC.ClassName,
			"math/cos": sC.ClassName,
			"math/tan": nC.ClassName,
			"math/asin": aC.ClassName,
			"math/acos": rC.ClassName,
			"math/atan": oC.ClassName,
			"math/atan2": lC.ClassName,
			"math/sinh": hC.ClassName,
			"math/cosh": cC.ClassName,
			"math/tanh": uC.ClassName,
			"math/asinh": mC.ClassName,
			"math/acosh": dC.ClassName,
			"math/atanh": fC.ClassName,
			"math/exp": pC.ClassName,
			"math/log": _C.ClassName,
			"math/log2": gC.ClassName,
			"math/log10": vC.ClassName,
			"math/sqrt": yC.ClassName,
			"math/cbrt": SC.ClassName,
			"math/pow": EC.ClassName,
			"math/length": AC.ClassName,
			"math/normalize": bC.ClassName,
			"math/dot": bM.ClassName,
			"math/cross": xC.ClassName,
			"math/rotate2d": MC.ClassName,
			"math/rotate3d": CC.ClassName,
			"math/transpose": TC.ClassName,
			"math/determinant": wC.ClassName,
			"math/inverse": RC.ClassName,
			"math/matmul": NC.ClassName,
			"math/not": IC.ClassName,
			"math/and": PC.ClassName,
			"math/or": kC.ClassName,
			"math/xor": DC.ClassName,
			"math/asr": FC.ClassName,
			"math/lsl": OC.ClassName,
			"math/clz": LC.ClassName,
			"math/ctz": BC.ClassName,
			"math/popcnt": GC.ClassName
		},
		XC = {
			float2: "Vector2",
			float3: "Vector3",
			float4: "Vector4",
			float4x4: "Matrix",
			int: "FlowGraphInteger"
		};

	function YC(e, t, i) {
		if (void 0 !== e.type) {
			const s = t.types && t.types[e.type];
			if (!s) throw new Error(`${i}: Unknown type: ${e.type}`);
			const n = s.signature;
			if (!n) throw new Error(`${i}: Type ${e.type} has no signature`);
			const a = XC[n];
			return {
				value: e.value,
				className: a
			}
		}
		return e.value
	}

	function jC(e, t, i) {
		const s = zC[t.type];
		if (!s) throw new Error(`/extensions/KHR_interactivity/nodes/${e}: Unknown block type: ${t.type}`);
		const n = e.toString(),
			a = function(e, t, i) {
				const s = {},
					n = e.configuration ?? [];
				for (const e of n)
					if ("customEvent" === e.id) {
						const n = t.customEvents && t.customEvents[e.value];
						if (!n) throw new Error(`/extensions/KHR_interactivity/nodes/${i}: Unknown custom event: ${e.value}`);
						s.eventId = n.id, s.eventData = n.values.map((e => e.id))
					} else if ("variable" === e.id) {
					const n = t.variables && t.variables[e.value];
					if (!n) throw new Error(`/extensions/KHR_interactivity/nodes/${i}: Unknown variable: ${e.value}`);
					s.variableName = n.id
				} else if ("path" === e.id) {
					const t = e.value;
					s.path = t
				} else s[e.id] = YC(e, t, `/extensions/KHR_interactivity/nodes/${i}`);
				return s
			}(t, i, n);
		return {
			className: s,
			config: a,
			ik: n,
			metadata: t.metadata,
			dataInputs: [],
			dataOutputs: [],
			signalInputs: [],
			signalOutputs: []
		}
	}
	var KC = class extends sx {
			constructor(e) {
				super(e, $C)
			}
		},
		$C = {
			nodes: {
				__array__: {
					__target__: !0,
					translation: {
						type: "Vector3",
						get: e => e._babylonTransformNode.position,
						set: (e, t) => {
							t._babylonTransformNode.position = e
						},
						getObject: e => e._babylonTransformNode
					}
				}
			}
		},
		JC = "KHR_interactivity",
		qC = class {
			dispose() {
				this._loader = null, delete this._pathConverter
			}
			onReady() {
				if (!this._loader.babylonScene || !this._pathConverter) return;
				const e = this._loader.babylonScene,
					t = this._loader.gltf.extensions?.KHR_interactivity,
					i = function(e) {
						const t = {
								ik: rd(),
								_userVariables: {},
								_connectionValues: {}
							},
							i = [t],
							s = [];
						for (let t = 0; t < e.nodes.length; t++) {
							const i = jC(t, e.nodes[t], e);
							s.push(i)
						}
						for (let i = 0; i < e.nodes.length; i++) {
							const n = e.nodes[i],
								a = s[i],
								r = n.flows ?? [];
							for (const e of r) {
								const t = e.id,
									n = {
										ik: rd(),
										name: t,
										_connectionType: 1,
										connectedPointIds: []
									};
								a.signalOutputs.push(n);
								const r = e.node,
									o = e.socket,
									l = s[r];
								if (!l) throw new Error(`/extensions/KHR_interactivity/nodes/${i}: Could not find node with id ${r} that connects its input with with node ${i}'s output ${t}`);
								let h = l.signalInputs.find((e => e.name === o));
								h || (h = {
									ik: rd(),
									name: o,
									_connectionType: 0,
									connectedPointIds: []
								}, l.signalInputs.push(h)), h.connectedPointIds.push(n.ik), n.connectedPointIds.push(h.ik)
							}
							const o = n.values ?? [];
							for (const n of o) {
								const r = n.id,
									o = {
										ik: rd(),
										name: r,
										_connectionType: 0,
										connectedPointIds: []
									};
								if (a.dataInputs.push(o), void 0 !== n.value) {
									const s = YC(n, e, `/extensions/KHR_interactivity/nodes/${i}`);
									t._connectionValues[o.ik] = s
								} else {
									if (void 0 === n.node || void 0 === n.socket) throw new Error(`/extensions/KHR_interactivity/nodes/${i}: Invalid socket ${r} in node ${i}`);
									{
										const e = n.node,
											t = n.socket,
											a = s[e];
										if (!a) throw new Error(`/extensions/KHR_interactivity/nodes/${i}: Could not find node with id ${e} that connects its output with node${i}'s input ${r}`);
										let l = a.dataOutputs.find((e => e.name === t));
										l || (l = {
											ik: rd(),
											name: t,
											_connectionType: 1,
											connectedPointIds: []
										}, a.dataOutputs.push(l)), o.connectedPointIds.push(l.ik), l.connectedPointIds.push(o.ik)
									}
								}
							}
						}
						const n = e.variables ?? [];
						for (let i = 0; i < n.length; i++) {
							const s = n[i],
								a = s.id;
							t._userVariables[a] = YC(s, e, `/extensions/KHR_interactivity/variables/${i}`)
						}
						return {
							allBlocks: s,
							executionContexts: i
						}
					}(t),
					s = new Xx({
						scene: e
					});
				zx.Parse(i, {
					coordinator: s,
					pathConverter: this._pathConverter
				}), s.start()
			}
			constructor(e) {
				this._loader = e, this.name = JC, this.enabled = this._loader.isExtensionUsed(JC), this._pathConverter = new KC(this._loader.gltf)
			}
		};
	BA.RegisterExtension(JC, (e => new qC(e)));
	var QC = "ExtrasAsMetadata",
		ZC = class {
			loadCameraAsync(e, t, i) {
				return this._loader.loadCameraAsync(e, t, (e => {
					this._assignExtras(e, t), i(e)
				}))
			}
			_assignExtras(e, t) {
				if (t.extras && Object.keys(t.extras).length > 0) {
					const i = e.metadata = e.metadata || {};
					(i.gltf = i.gltf || {}).extras = t.extras
				}
			}
			constructor(e) {
				this.name = QC, this.enabled = !0, this._loader = e
			}
			createMaterial(e, t, i) {
				const s = this._loader.createMaterial(e, t, i);
				return this._assignExtras(s, t), s
			}
			dispose() {
				this._loader = null
			}
			loadNodeAsync(e, t, i) {
				return this._loader.loadNodeAsync(e, t, (e => {
					this._assignExtras(e, t), i(e)
				}))
			}
		};
	BA.RegisterExtension(QC, (e => new ZC(e))), h(), _s(), aa(), gs(), Da();
	e.ShadersStore.outlinePixelShader = "#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nuniform vec4 color;\n#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#include<logDepthFragment>\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}", h(), G(), bs(), xs(), Ms(), ks(), Zn(), aa(), Ds(), Os(), Fs(), z(), Ls(), Gs(), da();
	e.ShadersStore.outlineVertexShader = "attribute vec3 position;attribute vec3 normal;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\nuniform float offset;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nvec3 offsetPosition=positionUpdated+(normalUpdated*offset);\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(offsetPosition,1.0);gl_Position=viewProjection*worldPos;\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\n", bg.prototype.getOutlineRenderer = function() {
		return this._outlineRenderer || (this._outlineRenderer = new eT(this)), this._outlineRenderer
	}, Object.defineProperty(Vf.prototype, "renderOutline", {
		get: function() {
			return this._renderOutline
		},
		set: function(e) {
			e && this.getScene().getOutlineRenderer(), this._renderOutline = e
		},
		enumerable: !0,
		configurable: !0
	}), Object.defineProperty(Vf.prototype, "renderOverlay", {
		get: function() {
			return this._renderOverlay
		},
		set: function(e) {
			e && this.getScene().getOutlineRenderer(), this._renderOverlay = e
		},
		enumerable: !0,
		configurable: !0
	});
	var eT = class e {
		rebuild() {}
		dispose() {
			for (let e = 0; e < this._passIdForDrawWrapper.length; ++e) this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])
		}
		constructor(e) {
			this.name = Df.NAME_OUTLINERENDERER, this.zOffset = 1, this.zOffsetUnits = 4, this.scene = e, this._engine = e.getEngine(), this.scene._addComponent(this), this._passIdForDrawWrapper = [];
			for (let e = 0; e < 4; ++e) this._passIdForDrawWrapper[e] = this._engine.createRenderPassId(`Outline Renderer (${e})`)
		}
		register() {
			this.scene._beforeRenderingMeshStage.registerStep(Df.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh), this.scene._afterRenderingMeshStage.registerStep(Df.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh)
		}
		render(e, t, i = !1, s) {
			s = s ?? this._passIdForDrawWrapper[0];
			const n = this.scene,
				a = n.getEngine(),
				r = a.getCaps().instancedArrays && (null !== t.visibleInstances[e._id] && void 0 !== t.visibleInstances[e._id] || e.getRenderingMesh().hasThinInstances);
			if (!this.isReady(e, r, s)) return;
			const o = e.getMesh(),
				l = o._internalAbstractMeshDataInfo._actAsRegularMesh ? o : null,
				h = e.getRenderingMesh(),
				c = l || h,
				u = e.getMaterial();
			if (!u || !n.activeCamera) return;
			const m = e._getDrawWrapper(s),
				d = Au.GetEffect(m);
			if (a.enableEffect(m), u.useLogarithmicDepth && d.setFloat("logarithmicDepthConstant", 2 / (Math.log(n.activeCamera.maxZ + 1) / Math.LN2)), d.setFloat("offset", i ? 0 : h.outlineWidth), d.setColor4("color", i ? h.overlayColor : h.outlineColor, i ? h.overlayAlpha : u.alpha), d.setMatrix("viewProjection", n.getTransformMatrix()), d.setMatrix("world", c.getWorldMatrix()), h.useBones && h.computeBonesUsingShaders && h.skeleton && d.setMatrices("mBones", h.skeleton.getTransformMatrices(h)), h.morphTargetManager && h.morphTargetManager.isUsingTextureForTargets && h.morphTargetManager._bind(d), lf(h, d), r || h._bind(e, d, u.fillMode), u && u.needAlphaTesting()) {
				const e = u.getAlphaTestTexture();
				e && (d.setTexture("diffuseSampler", e), d.setMatrix("diffuseMatrix", e.getTextureMatrix()))
			}
			Qd(d, u, n), a.setZOffset(-this.zOffset), a.setZOffsetUnits(-this.zOffsetUnits), h._processRendering(c, e, d, u.fillMode, t, r, ((e, t) => {
				d.setMatrix("world", t)
			})), a.setZOffset(0), a.setZOffsetUnits(0)
		}
		isReady(e, t, i) {
			i = i ?? this._passIdForDrawWrapper[0];
			const s = [],
				n = [eu.PositionKind, eu.NormalKind],
				a = e.getMesh(),
				r = e.getMaterial();
			if (!r) return !1;
			const o = a.getScene();
			r.needAlphaTesting() && (s.push("#define ALPHATEST"), a.isVerticesDataPresent(eu.UVKind) && (n.push(eu.UVKind), s.push("#define UV1")), a.isVerticesDataPresent(eu.UV2Kind) && (n.push(eu.UV2Kind), s.push("#define UV2"))), r.useLogarithmicDepth && s.push("#define LOGARITHMICDEPTH"), qd(r, o, s), a.useBones && a.computeBonesUsingShaders ? (n.push(eu.MatricesIndicesKind), n.push(eu.MatricesWeightsKind), a.numBoneInfluencers > 4 && (n.push(eu.MatricesIndicesExtraKind), n.push(eu.MatricesWeightsExtraKind)), s.push("#define NUM_BONE_INFLUENCERS " + a.numBoneInfluencers), s.push("#define BonesPerMesh " + (a.skeleton ? a.skeleton.bones.length + 1 : 0))) : s.push("#define NUM_BONE_INFLUENCERS 0");
			const l = a.morphTargetManager;
			let h = 0;
			l && (h = l.numMaxInfluencers || l.numInfluencers, h > 0 && (s.push("#define MORPHTARGETS"), s.push("#define NUM_MORPH_INFLUENCERS " + h), l.isUsingTextureForTargets && s.push("#define MORPHTARGETS_TEXTURE"), af(n, a, h))), t && (s.push("#define INSTANCES"), of(n), e.getRenderingMesh().hasThinInstances && s.push("#define THIN_INSTANCES"));
			const c = e._getDrawWrapper(i, !0),
				u = c.defines,
				m = s.join("\n");
			if (u !== m) {
				const e = ["world", "mBones", "viewProjection", "diffuseMatrix", "offset", "color", "logarithmicDepthConstant", "morphTargetInfluences", "morphTargetCount", "morphTargetTextureInfo", "morphTargetTextureIndices"];
				Jd(e), c.setEffect(this.scene.getEngine().createEffect("outline", n, e, ["diffuseSampler", "morphTargets"], m, void 0, void 0, void 0, {
					maxSimultaneousMorphTargets: h
				}), m)
			}
			return c.effect.isReady()
		}
		_beforeRenderingMesh(t, i, s) {
			if (this._savedDepthWrite = this._engine.getDepthWrite(), t.renderOutline) {
				const n = i.getMaterial();
				n && n.needAlphaBlendingForMesh(t) && (this._engine.cacheStencilState(), this._engine.setDepthWrite(!1), this._engine.setColorWrite(!1), this._engine.setStencilBuffer(!0), this._engine.setStencilOperationPass(7681), this._engine.setStencilFunction(519), this._engine.setStencilMask(e._StencilReference), this._engine.setStencilFunctionReference(e._StencilReference), this._engine.stencilStateComposer.useStencilGlobalOnly = !0, this.render(i, s, !0, this._passIdForDrawWrapper[1]), this._engine.setColorWrite(!0), this._engine.setStencilFunction(517)), this._engine.setDepthWrite(!1), this.render(i, s, !1, this._passIdForDrawWrapper[0]), this._engine.setDepthWrite(this._savedDepthWrite), n && n.needAlphaBlendingForMesh(t) && (this._engine.stencilStateComposer.useStencilGlobalOnly = !1, this._engine.restoreStencilState())
			}
		}
		_afterRenderingMesh(e, t, i) {
			if (e.renderOverlay) {
				const e = this._engine.getAlphaMode(),
					s = this._engine.alphaState.alphaBlend;
				this._engine.setAlphaMode(2), this.render(t, i, !0, this._passIdForDrawWrapper[3]), this._engine.setAlphaMode(e), this._engine.setDepthWrite(this._savedDepthWrite), this._engine.alphaState.alphaBlend = s
			}
			e.renderOutline && this._savedDepthWrite && (this._engine.setDepthWrite(!0), this._engine.setColorWrite(!1), this.render(t, i, !1, this._passIdForDrawWrapper[2]), this._engine.setColorWrite(!0))
		}
	};
	eT._StencilReference = 4;
	var tT, iT, sT, nT, aT, rT, oT, lT, hT, cT, uT, mT, dT, fT, pT, _T, gT, vT, yT, ST, ET, AT, bT, xT, MT, CT, TT = null,
		wT = null,
		RT = void 0,
		NT = !1,
		IT = !1,
		PT = !1,
		kT = !1,
		DT = !1,
		OT = "",
		FT = {},
		LT = !1,
		BT = !1,
		GT = null,
		HT = !1,
		UT = {},
		VT = !1,
		WT = null,
		zT = {},
		XT = !1,
		YT = !1,
		jT = !1,
		KT = null,
		$T = null,
		JT = null,
		qT = !1,
		QT = !1,
		ZT = [],
		ew = {},
		tw = 0,
		iw = null,
		sw = null,
		nw = !1,
		aw = null,
		rw = null,
		ow = null,
		lw = [],
		hw = document.createElement("canvas"),
		cw = !1,
		uw = !0,
		mw = navigator.language,
		dw = parsedUrl.query.debug,
		fw = null,
		pw = !1,
		_w = null,
		gw = !1,
		vw = null,
		yw = !1,
		Sw = !1,
		Ew = !1,
		Aw = null,
		bw = !1,
		xw = !1,
		Mw = null,
		Cw = !1,
		Tw = !1,
		ww = null,
		Rw = [],
		Nw = null,
		Iw = null,
		Pw = !0,
		kw = !1,
		Dw = "pass_welcome",
		Ow = 15084,
		Fw = !1,
		Lw = null,
		Bw = !1,
		Gw = !1,
		Hw = {
			discord: 0,
			ticTok: 0
		},
		Uw = {},
		Vw = {},
		Ww = ["midMonthGiveMeEggs", "newYolkerSignupReward", "newYolkerItemReward", "newYolkerWelcomeBack", "WelcomeBack", "mercZoneFinalGift"],
		zw = {
			premFeatOne: 0,
			premFeatTwo: 0
		},
		Xw = {
			text: ["#fff100", "#00ffff", "#f53e40"],
			meBackground: ["rgba(255, 192, 64, 0.75)", "rgba(0, 192, 255, 0.8)", "rgba(192, 64, 32, 0.8)"],
			themBackground: ["rgba(0, 0, 0, 0.25)", "rgba(0, 64, 192, 0.3)", "rgba(192, 64, 32, 0.3)"],
			summaryBackground: ["rgba(64, 64, 64, 0.75)", "rgba(0, 64, 192, 0.75)", "rgba(192, 64, 32, 0.75)"],
			outline: [new wc(1, 1, 1, -1), new wc(0, .75, 1, .3), new wc(1, .25, .25, .3)],
			textColor: [new wc(1, 1, 1, 1), new wc(0, .75, 1, 1), new wc(1, .25, .25, 1)],
			meClass: ["playerSlot-me", "playerSlot-me-blue", "playerSlot-me-red"],
			aa: ["playerSlot-them", "playerSlot-them-blue", "playerSlot-them-red"]
		},
		Yw = {
			isCaseSensitive: !1,
			includeScore: !0,
			shouldSort: !0,
			includeMatches: !0,
			findAllMatches: !1,
			minMatchCharLength: 1,
			location: 0,
			threshold: .2,
			distance: 100,
			useExtendedSearch: !0,
			keys: ["name", "unlock", "item_data.tags", "item_data.meshName"]
		},
		jw = !1,
		Kw = {},
		$w = [{
			version: "1.0.8",
			date: "May 3 2025",
			content: ["Hit the gas with the latest Shell Shockers update introducing our smash new game - Kartbros.io.", "Enjoy the new Kart Bros items, plus some of the other faves from the Kart and Bros sets in-store now.", "Start your engines - a new VIP item has entered the store - Try the Premium Banana Grenade!", "The Ridge Racer Bundle features The slick F1 racer Melee - wipe out your frenemies!", "So we kinda broke controllers a little bit - fixed for all the joystick jockeys.", "Another range of bug fixes, optimizations, ratchet tightening and squeegeeing has taken place behind the scenes.", "Buckle up for the eggsciting new map: Zoomies - in public & private lobbies.", "The Public Map pool has been switched and now contains 15 of your favorite Shell Shockers Maps."]
		}],
		Jw = [{
			itemIds: null,
			sku: "egg_pack_small",
			name: "Small Pack",
			price: 3,
			salePrice: 5,
			flagText: "",
			type: "currency",
			inStore: 1,
			currency: 3e4,
			isActive: !0,
			id: 1
		}, {
			itemIds: null,
			sku: "egg_pack_medium",
			name: "Medium Pack",
			price: 6,
			salePrice: 10,
			flagText: "",
			type: "currency",
			inStore: 1,
			currency: 65e3,
			isActive: !0,
			id: 2
		}, {
			itemIds: null,
			sku: "egg_pack_large",
			name: "Large Pack",
			price: 12,
			salePrice: 20,
			flagText: "",
			type: "currency",
			inStore: 1,
			currency: 15e4,
			isActive: !0,
			id: 3
		}, {
			itemIds: null,
			sku: "egg_pack_giant",
			name: "Giant Pack",
			price: 50,
			salePrice: 25,
			flagText: "p_egg_shop_bestvalue",
			type: "currency",
			inStore: 0,
			currency: 5e4,
			isActive: !0,
			id: 4
		}, {
			itemIds: [4223],
			sku: "item_gun_m24_techno",
			name: "Untz Untz Gun",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 8
		}, {
			itemIds: [1112],
			sku: "item_hat_yolk_arms",
			name: "Yolk Arms",
			price: 1,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 9
		}, {
			itemIds: [1105],
			sku: "item_hat_cape",
			name: "Magic Cape",
			price: 1,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 10
		}, {
			itemIds: [1092],
			sku: "item_hat_dragon",
			name: "GoE Dragon",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 11
		}, {
			itemIds: [1110],
			sku: "item_hat_space_gladi",
			name: "Space Gladiator",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 12
		}, {
			itemIds: [1126],
			sku: "item_hat_zombie_mask",
			name: "Zombie Mask",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 13
		}, {
			itemIds: [3016],
			sku: "item_gun_9mm_space",
			name: "Cluck 9mm Space Egg",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 14
		}, {
			itemIds: [1125],
			sku: "item_hat_oni",
			name: "Oni Hat",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 15
		}, {
			itemIds: [3416],
			sku: "item_gun_csg1_space",
			name: "CSG1 Space Egg Skin",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 16
		}, {
			itemIds: [1160],
			sku: "item_hat_galeggsy",
			name: "Galeggsy Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 17
		}, {
			itemIds: [3025],
			sku: "item_gun_9mm_techno",
			name: "Cluck 9mm Techno",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 18
		}, {
			itemIds: [1171],
			sku: "item_hat_rooter_wing",
			name: "Rooster Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 19
		}, {
			itemIds: [4026],
			sku: "item_gun_smg_techno",
			name: "Tuh SMG",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 20
		}, {
			itemIds: [1174],
			sku: "item_hat_demon_wings",
			name: "Demon Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 21
		}, {
			itemIds: [3627],
			sku: "gun_gauge_techno",
			name: "Badoosh Dozen Gauge",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 22
		}, {
			itemIds: [1184],
			sku: "item_hat_fallen_wing",
			name: "Fallen Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 23
		}, {
			itemIds: [3426],
			sku: "item_gun_csg1_techno",
			name: "CSG1 Techno Catz",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 24
		}, {
			itemIds: [1185, 2204, 16011],
			sku: "1oOnkjL7",
			name: "1 month membership",
			price: 699,
			salePrice: null,
			flagText: "",
			type: "subscription",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 25
		}, {
			itemIds: [1185, 2204, 16011],
			sku: "K5JjxL1z",
			name: "3 month membership",
			price: 1499,
			salePrice: null,
			flagText: "",
			type: "subscription",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 26
		}, {
			itemIds: [1185, 2204, 16011],
			sku: "TymKKdoQ",
			name: "12 month membership",
			price: 4999,
			salePrice: null,
			flagText: "p_egg_shop_bestvalue",
			type: "subscription",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 27
		}, {
			itemIds: [1186],
			sku: "item_hat_chrome_wing",
			name: "Chrome Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 29
		}, {
			itemIds: [3126],
			sku: "gun_eggk47_techno",
			name: "Eggk Poggers",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 30
		}, {
			itemIds: [1193],
			sku: "item_hat_steamWings",
			name: "Steampunk Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 31
		}, {
			itemIds: [3828],
			sku: "item_gun_rpeggTechno",
			name: "RPEGGTechno",
			price: 10,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 32
		}, {
			itemIds: [3029],
			sku: "item_gun_retro_9mm",
			name: "Retro Skin Cluck9mm",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 33
		}, {
			itemIds: [1195],
			sku: "item_hat_pixel_wings",
			name: "Angel Pixel Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 34
		}, {
			itemIds: [16014],
			sku: "item_gre_skullnado",
			name: "Skullnado",
			price: 7,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 35
		}, {
			itemIds: [1202],
			sku: "item_hat_skull_wings",
			name: "Skull Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 36
		}, {
			itemIds: [4512],
			sku: "item_gun_aug_retro",
			name: "Retro TriHard",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 37
		}, {
			itemIds: [1215],
			sku: "item_hat_robot_wings",
			name: "Robot Pixel Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 38
		}, {
			itemIds: [16019],
			sku: "item_gre_unicorn",
			name: "Unicorn Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 39
		}, {
			itemIds: [1222],
			sku: "item_hat_uni_wing",
			name: "Unicorn Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 40
		}, {
			itemIds: [4229],
			sku: "item_gun_m24_retro",
			name: "M2DZ Retro Skin",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 41
		}, {
			itemIds: [1226],
			sku: "item_hat_fairy_wings",
			name: "Fairy Pixel Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 42
		}, {
			itemIds: [16023],
			sku: "item_gre_toilet_papr",
			name: "Grenade Toilet Paper",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 43
		}, {
			itemIds: [3431],
			sku: "item_gun_csg1_retro",
			name: "CSG1 Retro",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 45
		}, {
			itemIds: [1235],
			sku: "item_hat_pixel_fire",
			name: "Fire Pixel Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 46
		}, {
			itemIds: [16027],
			sku: "item_gre_glitterbomb",
			name: "Grenade Glitterbomb",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 47
		}, {
			itemIds: [1241],
			sku: "item_hat_glitch_wing",
			name: "Glitch Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 48
		}, {
			itemIds: [3634],
			sku: "item_gun_crack_retro",
			name: "Scrambler Retro",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 49
		}, {
			itemIds: [1245],
			sku: "item_hat_moth_wings",
			name: "Moth Pixel Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 50
		}, {
			itemIds: [16032],
			sku: "item_gre_thermal",
			name: "Grenade Thermal Detonator",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 51
		}, {
			itemIds: [1248],
			sku: "hat_thermal_wings",
			name: "Thermal Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 52
		}, {
			itemIds: [4032],
			sku: "item_gun_smg_retro",
			name: "SMEGG Retro",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 53
		}, {
			itemIds: [1269],
			sku: "item_hat_pixel_butt",
			name: "Pixel Butterfly Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 54
		}, {
			itemIds: [1272],
			sku: "item_hat_pixel_bird",
			name: "Pixel Bird Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 55
		}, {
			itemIds: [16036],
			sku: "item_gre_supernova",
			name: "Grenade Supernova",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 56
		}, {
			itemIds: [16038],
			sku: "item_gre_octopus",
			name: "Grenade Octopus",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 57
		}, {
			itemIds: [3835],
			sku: "item_gun_rpegg_retro",
			name: "RPEGG Retro",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 58
		}, {
			itemIds: [1212],
			sku: "item_hat_dog_cap",
			name: "Dog Cap",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 59
		}, {
			itemIds: [1044],
			sku: "item_hat_egg_glasses",
			name: "Egg Glasses",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 60
		}, {
			itemIds: [1288],
			sku: "item_hat_luckywings",
			name: "Lucky Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 61
		}, {
			itemIds: [3637],
			sku: "item_gun_bros",
			name: "Dozen Gauge Bros",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 63
		}, {
			itemIds: [4528],
			sku: "item_gun_valk_aug",
			name: "Trihard Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 64
		}, {
			itemIds: [16041],
			sku: "item_gre_diablo",
			name: "Grenade Diablo",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 65
		}, {
			itemIds: [3134],
			sku: "item_gun_ak_retro",
			name: "Eggk47 Retro",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 66
		}, {
			itemIds: [3136],
			sku: "item_gun_ak_valkyrie",
			name: "Eggk47 Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 67
		}, {
			itemIds: [1312],
			sku: "item_hat_dinowings",
			name: "Dino Pterodactyl Win",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 68
		}, {
			itemIds: [1316],
			sku: "item_hat_airplane",
			name: "Airplane Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 69
		}, {
			itemIds: [16044],
			sku: "item_gre_bumble",
			name: "Grenade Bumblebee",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 71
		}, {
			itemIds: [3642],
			sku: "item_gauge_valk",
			name: "Valkyrie Scrambler",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 72
		}, {
			itemIds: [16046],
			sku: "item_gre_football",
			name: "Grenade Football",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 73
		}, {
			itemIds: [16048],
			sku: "item_gre_valk",
			name: "Grenade Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 74
		}, {
			itemIds: [3439],
			sku: "item_csg1_rubchick",
			name: "CSG1 Rubber Chicken",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 75
		}, {
			itemIds: [16049],
			sku: "item_gre_milk",
			name: "Grenade Milk",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 76
		}, {
			itemIds: [4240],
			sku: "item_gun_m24_scav",
			name: "Crackshot Scavenger",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 77
		}, {
			itemIds: [3045],
			sku: "item_gun_9mm_valk",
			name: "Cluck 9mm Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 78
		}, {
			itemIds: [1341],
			sku: "item_hat_rainbow",
			name: "Rainbow Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 79
		}, {
			itemIds: [3441],
			sku: "item_range_valk",
			name: "Free-Ranger Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 80
		}, {
			itemIds: [1349],
			sku: "item_hat_teggtris",
			name: "Teggtris wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 81
		}, {
			itemIds: [16054],
			sku: "item_gre_blood",
			name: "Grenade Blood",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 82
		}, {
			itemIds: [1356],
			sku: "item_hat_bloodwing",
			name: "Blood Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 83
		}, {
			itemIds: [3843],
			sku: "item_gun_rpegg_valk",
			name: "RPEGG Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 84
		}, {
			itemIds: [4040],
			sku: "item_gun_smg_turk",
			name: "Turkey-Supreme Whipp",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 85
		}, {
			itemIds: [4242],
			sku: "item_gun_m24_valk",
			name: "Crackshot Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 86
		}, {
			itemIds: [1363],
			sku: "item_hat_fall",
			name: "Fall Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 87
		}, {
			itemIds: [3844],
			sku: "item_rpegg_christ",
			name: "RPEGG Santa Boot",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 88
		}, {
			itemIds: [1369],
			sku: "item_holy_wings",
			name: "Holly Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 89
		}, {
			itemIds: [4042],
			sku: "item_gun_smg_valk",
			name: "Whipper Valkyrie",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 90
		}, {
			itemIds: [3443],
			sku: "item_csg1_fusion",
			name: "Free-Ranger Fusion",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 92
		}, {
			itemIds: [1372],
			sku: "item_hat_soundwave",
			name: "Sound Wave Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 93
		}, {
			itemIds: [3650],
			sku: "item_gauge_octopus",
			name: "Octopus Scrambler",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 94
		}, {
			itemIds: [3050],
			sku: "item_9mm_cloud",
			name: "Cluck 9mm Clouds",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 95
		}, {
			itemIds: [3142],
			sku: "item_ak47_fusion",
			name: "Eggk47 Fusion",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 96
		}, {
			itemIds: [4044],
			sku: "item_smg_fusion",
			name: "Whipper Fusion",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 99
		}, {
			itemIds: [1394],
			sku: "item_hat_hooped",
			name: "Hooped",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 100
		}, {
			itemIds: [3654],
			sku: "item_gauge_monster",
			name: "Beholder Scrambler",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 101
		}, {
			itemIds: [1400],
			sku: "item_qwings",
			name: "Question Block Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 102
		}, {
			itemIds: [3054],
			sku: "item_9mm_fusion",
			name: "Cluck 9mm Fusion",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 103
		}, {
			itemIds: [15023],
			sku: "item_melee_stone",
			name: "Stone Hammer Melee",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 104
		}, {
			itemIds: [3445],
			sku: "item_csg1_shellpreme",
			name: "Free-Ranger Shellpre",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 105
		}, {
			itemIds: [3655],
			sku: "item_gauge_fusion",
			name: "Fusion Scrambler",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 106
		}, {
			itemIds: [3055],
			sku: "item_9mm_camera",
			name: "Cluck 9mm Camera",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 107
		}, {
			itemIds: [1417],
			sku: "item_hat_surf",
			name: "Octopus Surfboard",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 108
		}, {
			itemIds: [15013],
			sku: "item_melee_valk",
			name: "Melee Valkyrie",
			price: 6,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 109
		}, {
			itemIds: [15030],
			sku: "item_melee_fusion",
			name: "The Fusion Melee",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 110
		}, {
			itemIds: [1423],
			sku: "item_hat_scales",
			name: "Scales of Justice",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 111
		}, {
			itemIds: [4540],
			sku: "item_aug_fusion",
			name: "Fusion Trihard",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 113
		}, {
			itemIds: [16064],
			sku: "item_gre_timebomb",
			name: "Timebomb Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 115
		}, {
			itemIds: [15037],
			sku: "item_melee_cat",
			name: "Harrison Cat Melee",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 120
		}, {
			itemIds: [3059],
			sku: "item_9mm_mega",
			name: "Megaphone Cluck 9mm",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 121
		}, {
			itemIds: [1445],
			sku: "item_hat_wbs",
			name: "The Grand Entrance W",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 123
		}, {
			itemIds: [4248],
			sku: "item_m24_fusion",
			name: "The Fusion Crackshot",
			price: 6,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 124
		}, {
			itemIds: [3951],
			sku: "item_rpegg_fusion",
			name: "Fusion RPEGG",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 126
		}, {
			itemIds: [3952],
			sku: "item_rpegg_skele",
			name: "Skellington RPEGG",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 128
		}, {
			itemIds: [3149],
			sku: "item_ak_infernal",
			name: "Infernal Eggk47",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 129
		}, {
			itemIds: [1461],
			sku: "item_hat_mayan",
			name: "Ruins Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 131
		}, {
			itemIds: [15045],
			sku: "item_melee_mayan",
			name: "Mayan Macuahuitl",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 132
		}, {
			itemIds: [15047],
			sku: "item_melee_turkcar",
			name: "The Turkey Carver",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 134
		}, {
			itemIds: [1470],
			sku: "item_hat_owl",
			name: "Snow Owl Wings",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 136
		}, {
			itemIds: [4253],
			sku: "item_m24_infernal",
			name: "Infernal Crackshot",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 138
		}, {
			itemIds: [3455],
			sku: "item_csg1_infernal",
			name: "Infernal CSG1",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 140
		}, {
			itemIds: [3662],
			sku: "item_gauge_cloud",
			name: "Cloudkicker Scramble",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 144
		}, {
			itemIds: [16074],
			sku: "item_gre_fusion",
			name: "Fusion Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 146
		}, {
			itemIds: [3663],
			sku: "item_gauge_irish",
			name: "Irish Scrambler",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 148
		}, {
			itemIds: [3058],
			sku: "item_9mm_infernal",
			name: "Infernal Cluck 9mm",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 150
		}, {
			itemIds: [3154],
			sku: "item_ak_choc",
			name: "gun_eggk47_Chocolate",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 151
		}, {
			itemIds: [4256],
			sku: "item_m24_cyborg",
			name: "Cyborg Crackshot",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 152
		}, {
			itemIds: [4550],
			sku: "item_aug_infernal",
			name: "Infernal Tri-hard",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 155
		}, {
			itemIds: [4054],
			sku: "item_smg_infernal",
			name: "Infernal SMG",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 159
		}, {
			itemIds: [15063],
			sku: "item_melee_infernal",
			name: "Infernal Melee",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 163
		}, {
			itemIds: [3665],
			sku: "item_gauge_infernal",
			name: "Infernal Scrambler",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 166
		}, {
			itemIds: [3958],
			sku: "item_rpegg_infernal",
			name: "Infernal RPEGG",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 172
		}, {
			itemIds: [16082],
			sku: "item_gre_infernal",
			name: "Infernal Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 176
		}, {
			itemIds: [15072],
			sku: "item_melee_pan",
			name: "Frying Pan Melee",
			price: 1,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 180
		}, {
			itemIds: [15074],
			sku: "item_melee_panegg",
			name: "Let Them Cook Melee",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 181
		}, {
			itemIds: [1565],
			sku: "item_hat_sleigh",
			name: "Santa's Sleigh",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 185
		}, {
			itemIds: [1073, 4216, 15084, 16038],
			sku: "pass_welcome",
			name: "Welcome Bonus",
			price: 1,
			salePrice: null,
			flagText: "",
			type: "pass",
			inStore: 1,
			currency: 5e4,
			isActive: !0,
			id: 187
		}, {
			itemIds: [15083],
			sku: "item_melee_frost",
			name: "Frostfall Whisk",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 188
		}, {
			itemIds: [1569],
			sku: "item_hat_equal",
			name: "The Equalizer",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 190
		}, {
			itemIds: [1578],
			sku: "item_hat_frost",
			name: "The Frostfall Wings",
			price: 2,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 197
		}, {
			itemIds: [3070],
			sku: "item_9mm_frost",
			name: "Frostfall 9mm",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 200
		}, {
			itemIds: [1594],
			sku: "item_hat_sunvis",
			name: "Sun Visor",
			price: 3,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 1,
			currency: 0,
			isActive: !0,
			id: 205
		}, {
			itemIds: [16092],
			sku: "item_gre_mayan",
			name: "Mayan Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 1,
			currency: 0,
			isActive: !0,
			id: 207
		}, {
			itemIds: [3026],
			sku: "item_9mm_ccwand",
			name: "Cubic Castles Cluck ",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 0,
			currency: 0,
			isActive: !0,
			id: 209
		}, {
			itemIds: [16093],
			sku: "item_gre_banana",
			name: "Banana Grenade",
			price: 5,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 1,
			currency: 0,
			isActive: !0,
			id: 210
		}, {
			itemIds: [1597],
			sku: "item_hat_kartbros",
			name: "Bro Kart Sigma",
			price: 4,
			salePrice: null,
			flagText: "",
			type: "item",
			inStore: 1,
			currency: 0,
			isActive: !0,
			id: 211
		}, {
			itemIds: [1480, 2635, 3437, 15090],
			sku: "bun_ridge",
			name: "Ridge Racer",
			price: 7,
			salePrice: null,
			flagText: "",
			type: "bundle",
			inStore: 1,
			currency: 0,
			isActive: !0,
			id: 212
		}],
		qw = [{
			id: 1001,
			name: "Ball Cap",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ballCap",
				tags: ["Green", "White"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.12075649338775385,
				y: -.2670312477499075,
				z: -.05526682671835026
			}
		}, {
			id: 1002,
			name: "Boat Fedora",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_boatHat",
				tags: ["Blue", "Yellow"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.06794416359249578,
				y: -.2926280197469384,
				z: -.031091489433501096
			}
		}, {
			id: 1003,
			name: "Top Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_topHat",
				tags: ["Black", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.07981952093539624,
				y: -.3437907063524166,
				z: -.036536185440272706
			}
		}, {
			id: 1004,
			name: "Derby Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_derby",
				tags: ["Orange", "Brown"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.07446247955425545,
				y: -.32070966531188816,
				z: -.03407966061498702
			}
		}, {
			id: 1005,
			name: "Mountie Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mounty",
				tags: ["Brown", "Police"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.07281390620627182,
				y: -.313607479576798,
				z: -.03332383477670581
			}
		}, {
			id: 1006,
			name: "Pablo Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cowSheriff",
				tags: ["Orange", "Brown", "Police", "Meme"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.07552652492916812,
				y: -.3252818085896001,
				z: -.03455986096692204
			}
		}, {
			id: 1007,
			name: "Blue Bandana",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaBlue",
				tags: ["Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.007368110577478548,
				y: -.19183106931370097,
				z: -.0033645168072600345
			}
		}, {
			id: 1008,
			name: "Hero Mask",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_batman",
				tags: ["Black", "Brown", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08850633059890223,
				y: -.20411254048573135,
				z: -.04050447716602543
			}
		}, {
			id: 1009,
			name: "Cop Hat",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cop",
				tags: ["Blue", "Gold", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09346306940354143,
				y: -.3048509545616378,
				z: -.04277696469919828
			}
		}, {
			id: 1010,
			name: "Robber Mask",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_badEgg2",
				tags: ["Black", "Purple"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.06208516448358958,
				y: -.23382330506514326,
				z: -.030489917048234644
			}
		}, {
			id: 1011,
			name: "Red Bandana",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaRed",
				tags: ["Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.03329404211409126,
				y: -.09315583255063686,
				z: -.0338189869509566
			}
		}, {
			id: 1012,
			name: "Pink Bow",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bowPink",
				tags: ["Pink"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07152407629324964,
				y: -.16299272012141341,
				z: -.03272766766614457
			}
		}, {
			id: 1013,
			name: "Glasses",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_glasses",
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.11215674530971143,
				y: -.12985890272324596,
				z: -.05132938270796705
			}
		}, {
			id: 1014,
			name: "Pompadour",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pompadour",
				tags: ["Black", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.04210170142754954,
				y: -.1703824912060592,
				z: -.01927515951061251
			}
		}, {
			id: 1015,
			name: "Plague Doctor Mask",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_plagueDoctor",
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.14593688893752033,
				y: -.1458279454647442,
				z: -.06679311948184694
			}
		}, {
			id: 1016,
			name: "Poop Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_poop",
				tags: ["Brown", "Yellow", "Gold", "Poop"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07576287181211017,
				y: -.2815449537609993,
				z: -.047155212248999545
			}
		}, {
			id: 1017,
			name: "Unicorn Hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_unicorn",
				tags: ["Red", "Orange", "Yellow", "Green", "Blue", "Silver", "Rainbow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.008777315183921996,
				y: -.2019233629032106,
				z: -.004008638766223961
			}
		}, {
			id: 1018,
			name: "Baws Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pimp",
				tags: ["Black", "White", "Grey", "Gray", "Purple"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07524018320712944,
				y: -.2980561083433546,
				z: -.04214661518926316
			}
		}, {
			id: 1019,
			name: "Pirate Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pirateHat",
				tags: ["Black", "Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .038701332916645015,
				y: -.33612905457241826,
				z: .017725198966349165
			}
		}, {
			id: 1023,
			name: "Hunting Hat",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hunting",
				tags: ["Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07052450007171451,
				y: -.24257874509170918,
				z: -.032275120288940806
			}
		}, {
			id: 1024,
			name: "Happy Bear Hat",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_huntingBear",
				tags: ["Pink", "Heart", "Cute"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09769183784970448,
				y: -.23620789822747934,
				z: -.04470940837408727
			}
		}, {
			id: 1025,
			name: "Crown",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_crown",
				tags: ["Gold", "Red", "Royal"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07916117268462308,
				y: -.3409402733304543,
				z: -.036456397957456144
			}
		}, {
			id: 1020,
			name: "ShellShockers Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shellshockers",
				unlock: "physical",
				physicalUnlockLocKey: "p_physical_unlock_hat",
				physicalItemStoreURL: "https://shell-shockers.myshopify.com/products/splat-hat",
				tags: ["White", "Brown", "Egg"]
			},
			is_available: !1,
			unlock: "physical",
			align: {
				x: -.12105426939220987,
				y: -.26831388754484853,
				z: -.055403073383391954
			}
		}, {
			id: 1021,
			name: "Frying Pan",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fryingPan",
				unlock: "physical",
				physicalUnlockLocKey: "p_physical_unlock_pan",
				physicalItemStoreURL: "https://shell-shockers.myshopify.com/products/no-pans-tee",
				tags: ["Black", "Silver"]
			},
			is_available: !1,
			unlock: "physical",
			align: {
				x: -.11201926980773491,
				y: -.22758383372001356,
				z: .11466896053477657
			}
		}, {
			id: 1022,
			name: "Viking Horns",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_horns",
				unlock: "physical",
				physicalUnlockLocKey: "p_physical_unlock_shirt",
				physicalItemStoreURL: "https://shell-shockers.myshopify.com/products/logo-tee",
				tags: ["Brown", "Bone"]
			},
			is_available: !1,
			unlock: "physical",
			align: {
				x: -.1099168405070956,
				y: -.28237664010873953,
				z: -.05142539504200483
			}
		}, {
			id: 1026,
			name: "Jack O' Lantern Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pumpkin",
				tags: ["Halloween", "Oct23", "Orange", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08877468412138612,
				y: -.35784089569708666,
				z: -.040628405489095076
			}
		}, {
			id: 1027,
			name: "Bat Wings",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_batWings",
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02978222309901922,
				y: -.31216370123269704,
				z: .013630059749994518
			}
		}, {
			id: 1028,
			name: "Witch Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_witch",
				tags: ["Halloween", "Purple", "Gold", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08843731903919094,
				y: -.3808892641791377,
				z: -.040473991412663834
			}
		}, {
			id: 1029,
			name: "Axe-in-head",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_axe",
				tags: ["Halloween", "Oct23", "Red", "Brown", "Wood", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11495007537093782,
				y: -.36874335549165216,
				z: .049209529757712867
			}
		}, {
			id: 1030,
			name: "Executioner's Cowl",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_executioner",
				tags: ["Halloween", "Oct23", "Red", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0390971212209168,
				y: -.2468287543633152,
				z: -.017893093144459582
			}
		}, {
			id: 1031,
			name: "Devil Horns",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_devilHorns",
				tags: ["Halloween", "Oct23", "Red", "Oct24", "bun_demon"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.15973168149370132,
				y: -.25177154715062167,
				z: -.0731024120297798
			}
		}, {
			id: 1032,
			name: "Angel Wings & Halo",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_angel",
				tags: ["Halloween", "Oct23", "Gold", "White", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0716592226014976,
				y: -.3086211609886207,
				z: -.032795385093542906
			}
		}, {
			id: 1033,
			name: "Hockey Mask",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hockeyMask",
				tags: ["Halloween", "Oct23", "Black", "White", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07589509037547937,
				y: -.16818670050730733,
				z: -.0347356499804236
			}
		}, {
			id: 1034,
			name: "Pilgrim Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pilgrim",
				tags: ["NovM23", "Thanksgiving", "Black", "Brown", "Gold", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08367638664963417,
				y: -.3603847907294966,
				z: -.03829511470354685
			}
		}, {
			id: 1035,
			name: "Cooked Turkey Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_turkeyDead",
				tags: ["NovM23", "Thanksgiving", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08560931605836686,
				y: -.3608351087257782,
				z: -.039177128845210685
			}
		}, {
			id: 1036,
			name: "Turkey Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_turkeyAlive",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11404848303094717,
				y: -.39460177972163324,
				z: -.051068506334921826
			}
		}, {
			id: 1037,
			name: "Golden Chicken Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_Top1Percent",
				tags: ["Reward", "RewardTopPercent", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.12167748309378656,
				y: -.39821262976584126,
				z: -.055643594750763914
			}
		}, {
			id: 1038,
			name: "Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KillTier1",
				tags: ["Reward", "RewardKills", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10368928049503356,
				y: -.30866668214003234,
				z: -.03454567398459779
			}
		}, {
			id: 1039,
			name: "Bronze Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KillTier2",
				tags: ["Reward", "RewardKills", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10368928049503356,
				y: -.30866668214003234,
				z: -.03454567398459779
			}
		}, {
			id: 1040,
			name: "Silver Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KillTier3",
				tags: ["Reward", "RewardKills", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10368928049503356,
				y: -.30866668214003234,
				z: -.03454567398459779
			}
		}, {
			id: 1041,
			name: "Gold Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KillTier4",
				tags: ["Reward", "RewardKills", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10368928049503356,
				y: -.30866668214003234,
				z: -.03454567398459779
			}
		}, {
			id: 1042,
			name: "Cracked Egg Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_DeathTier1",
				tags: ["Reward", "RewardDeaths", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.11030323640447248,
				y: -.2896262491678324,
				z: .020385131504372322
			}
		}, {
			id: 1043,
			name: "Egg Headphones",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_DeathTier2",
				tags: ["Reward", "RewardDeaths", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.048033927839143065,
				y: -.2180969454203714,
				z: -.021983090293065694
			}
		}, {
			id: 1044,
			name: "Egg Glasses",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_DeathTier3",
				tags: ["Reward", "RewardDeaths", "Yellow", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_egg_glasses"],
			align: {
				x: -.12332005541021429,
				y: -.14104254579369258,
				z: -.0564383560017033
			}
		}, {
			id: 1045,
			name: "Cracked Egg Crown",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_DeathTier4",
				tags: ["Reward", "RewardDeaths", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0981315547263597,
				y: -.3846123488611959,
				z: -.04491118067578559
			}
		}, {
			id: 1046,
			name: "Chicken Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KDRTier1",
				tags: ["Reward", "RewardKDR", "Bone"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.16209354742210902,
				y: -.21191916844016578,
				z: -.07417661895069405
			}
		}, {
			id: 1047,
			name: "Bronze Chicken Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KDRTier2",
				tags: ["Reward", "RewardKDR", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.16209354742210902,
				y: -.21191916844016578,
				z: -.07417661895069405
			}
		}, {
			id: 1048,
			name: "Silver Chicken Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KDRTier3",
				tags: ["Reward", "RewardKDR", "Silver", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.16209354742210902,
				y: -.21191916844016578,
				z: -.07417661895069405
			}
		}, {
			id: 1049,
			name: "Gold Chicken Skull Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_KDRTier4",
				tags: ["Reward", "RewardKDR", "Yellow", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.16209354742210902,
				y: -.21191916844016578,
				z: -.07417661895069405
			}
		}, {
			id: 1050,
			name: "Golden Egg Trophy",
			price: 100,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_GoldenEggTier1",
				tags: ["Eggflation", "MayM23", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0890999824704708,
				y: -.3863056827916843,
				z: -.04038368444876095
			}
		}, {
			id: 1051,
			name: "Golden Faberge Egg Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_GoldenEggTier2",
				tags: ["Eggflation", "MayM23", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09461650809618338,
				y: -.4080207829771313,
				z: -.043304410336916344
			}
		}, {
			id: 1052,
			name: "Dollar Sign Glasses",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_GoldenEggTier3",
				tags: ["Eggflation", "MayM23", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.12722235142344962,
				y: -.16985672809344665,
				z: -.05822427127650384
			}
		}, {
			id: 1053,
			name: "Golden Baws Hat",
			price: 1e5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_GoldenEggTier4",
				tags: ["Eggflation", "MayM23", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0767370155249445,
				y: -.3045029212488539,
				z: -.04283165181820048
			}
		}, {
			id: 1054,
			name: "Nate's Headphones",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_headphones",
				tags: ["Nate", "Green", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05333618875843271,
				y: -.23311434767345263,
				z: -.024409710099744658
			}
		}, {
			id: 1055,
			name: "Reindeer Antlers",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_reindeer",
				tags: ["Dec23", "Christmas", "Green", "Red", "Brown", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08044681365354378,
				y: -.3563788865655062,
				z: -.036817092584971345
			}
		}, {
			id: 1056,
			name: "Elf Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_elf",
				tags: ["Dec23", "Christmas", "Green", "Red", "Gold", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10117501028704234,
				y: -.3587848770061639,
				z: .0009369108254608793
			}
		}, {
			id: 1057,
			name: "Santa Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_santa",
				tags: ["Dec23", "Christmas", "White", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08867192605372676,
				y: -.3103943980263475,
				z: .00330065841716054
			}
		}, {
			id: 1058,
			name: "Party Hat 2019",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party",
				tags: ["NewYears", "2019", "Black", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064355390021284,
				y: -.39039936988703516,
				z: -.041483707867384534
			}
		}, {
			id: 1059,
			name: "Headband 2019",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2019",
				tags: ["NewYears", "2019", "Black", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09701051785922554,
				y: -.36462418466845886,
				z: -.044397597085921225
			}
		}, {
			id: 1060,
			name: "Happy New Yolk Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_newYolk",
				tags: ["NewYears", "Black", "Gold", "Yellow", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08047965861827411,
				y: -.44975516111728364,
				z: -.08518973241487715
			}
		}, {
			id: 1061,
			name: "Ski Mask",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_badEgg1",
				tags: ["Newsletter", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.03748757324468832,
				y: -.16145836066470826,
				z: -.017156471367526203
			}
		}, {
			id: 1062,
			name: "Pirate Bandana",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaPirate",
				tags: ["Newsletter", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04209499130342831,
				y: -.11506229870273388,
				z: .012622500466411724
			}
		}, {
			id: 1063,
			name: "Colander Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_colander",
				tags: ["Newsletter", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04228013671699182,
				y: -.2435412902962173,
				z: -.015922203388946482
			}
		}, {
			id: 1064,
			name: "Hamburger Earmuffs",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_earmuffsHamburger",
				tags: ["Newsletter", "Brown", "Pickles"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.061589629342688745,
				y: -.24315872165034946,
				z: -.028186959601940453
			}
		}, {
			id: 1065,
			name: "Fez Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fez",
				tags: ["Newsletter", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08950497321590545,
				y: -.33408258825568216,
				z: -.009421125014752674
			}
		}, {
			id: 1066,
			name: "Blue Wizard Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_blueWizard",
				tags: ["Newsletter", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08360071955828996,
				y: -.3600554455273177,
				z: -.03825404477815042
			}
		}, {
			id: 1067,
			name: "Chef Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chef",
				tags: ["Newsletter", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08918353428454662,
				y: -.3841111684404195,
				z: -.04081551884995449
			}
		}, {
			id: 1068,
			name: "Jester Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_jester",
				tags: ["Newsletter", "Black", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.020359835690789474,
				y: -.33615386721409024,
				z: -.013314527764688
			}
		}, {
			id: 1069,
			name: "Straw Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_straw",
				tags: ["Newsletter", "Blue", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.052496549211439536,
				y: -.30300028377516663,
				z: -.02402367283223006
			}
		}, {
			id: 1070,
			name: "Spring Sapling Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spring",
				tags: ["Groundhog", "Feb23", "Green", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09172522689294382,
				y: -.40464863138897356,
				z: -.035806813799312165
			}
		}, {
			id: 1071,
			name: "Winter Sapling Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_winter",
				tags: ["Groundhog", "Feb23", "White", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09121137445390537,
				y: -.39284191237794097,
				z: -.04174510747384019
			}
		}, {
			id: 1072,
			name: "Groundhog Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06865825713552098,
				y: -.27690700557536063,
				z: -.03141564496555199
			}
		}, {
			id: 1073,
			name: "Skull Bandana",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaSkull",
				tags: ["Promotional", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.015739329783290512,
				y: -.12197913424975876,
				z: -.007196258564224477
			}
		}, {
			id: 1074,
			name: "Firefighter Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fireFighter",
				tags: ["Promotional", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .00029003301364083356,
				y: -.2815446091386393,
				z: .00013425993600540975
			}
		}, {
			id: 1075,
			name: "Sunglasses",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sunglasses",
				tags: ["Promotional", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.11162996980256423,
				y: -.1299960469185888,
				z: -.05108829991299102
			}
		}, {
			id: 1076,
			name: "Monocle",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_monocle",
				tags: ["Newsletter", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.2250944940320183,
				y: -.07000462146414632,
				z: .009119977687944966
			}
		}, {
			id: 1077,
			name: "Gas Mask",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gasMask",
				tags: ["Promotional", "Black", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.11600129068485865,
				y: -.16795717258715603,
				z: -.05462135011036057
			}
		}, {
			id: 1078,
			name: "Aviator Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_aviator",
				tags: ["Promotional", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04615350218817005,
				y: -.19552917505354284,
				z: -.020616418825203403
			}
		}, {
			id: 1079,
			name: "Red Goggles",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gogglesRed",
				tags: ["Promotional", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.056151049789669116,
				y: -.16989981310822988,
				z: -.025692511892349168
			}
		}, {
			id: 1080,
			name: "Astronaut Helmet",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_astronaut",
				tags: ["Promotional", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04205338420983762,
				y: -.1810887170833807,
				z: -.0192440499996792
			}
		}, {
			id: 1081,
			name: "Heart Glasses",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_glassesHeart",
				tags: ["ValentinesDay", "Pink", "Red", "Feb24", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11678575639135991,
				y: -.13217398099861333,
				z: -.05344788463866976
			}
		}, {
			id: 1082,
			name: "Baws Fedora",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fedoraPimp",
				tags: ["ValentinesDay", "Pink", "Brown", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0742835205682435,
				y: -.3193658969606836,
				z: -.0340018064079084
			}
		}, {
			id: 1083,
			name: "Valentine's Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_valentines",
				tags: ["ValentinesDay", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08518905206413807,
				y: -.3668995553978778,
				z: -.03898739746891
			}
		}, {
			id: 1084,
			name: "Shamrock Glasses",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_glassesShamrock",
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12025224778385146,
				y: -.14696498652850365,
				z: -.05503435063727033
			}
		}, {
			id: 1085,
			name: "Pot O' Gold Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_potOfGold",
				tags: ["StPatricksDay", "MarM23", "Black", "Gold", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.063050017457572,
				y: -.3813351352595771,
				z: -.09620290937519904
			}
		}, {
			id: 1086,
			name: "Leprechaun Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_leprechaun",
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07051683154538146,
				y: -.30371404636288934,
				z: -.032272561188218196
			}
		}, {
			id: 1087,
			name: "Bunny Ears",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bunnyEars",
				tags: ["Easter", "White", "Pink", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.19599893671002944,
				y: -.39234999864297326,
				z: -.09717267795762519
			}
		}, {
			id: 1088,
			name: "Egg Nest",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggNest",
				tags: ["Easter", "Brown", "Grey", "Gray", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11291007649482054,
				y: -.3417085298117506,
				z: -.051628527402411084
			}
		}, {
			id: 1089,
			name: "Egg Basket",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggBasket",
				tags: ["Easter", "Brown", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12958749591523677,
				y: -.3491056580469325,
				z: -.033891141085516274
			}
		}, {
			id: 1090,
			name: "Egg Crown",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggCrown",
				tags: ["Easter", "Blue", "Yellow", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09516800672925507,
				y: -.37943767643095594,
				z: -.04250190002299581
			}
		}, {
			id: 1091,
			name: "GoE Ice Crown",
			price: 15e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_iceCrown",
				tags: ["GameOfEggs", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.10376858078351825,
				y: -.23115996005856543,
				z: -.046543193158390894
			}
		}, {
			id: 1092,
			name: "GoE Dragon",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dragon",
				tags: ["GameOfEggs", "May23", "Green", "July24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_dragon"],
			align: {
				x: -.11122381511525159,
				y: -.22438668422477548,
				z: -.05123433364416541
			}
		}, {
			id: 1093,
			name: "Green Bandana",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaGreen",
				tags: ["Green"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .004054956862579839,
				y: -.14563528059130337,
				z: .00186138626719895
			}
		}, {
			id: 1094,
			name: "Mohawk Hair",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_moHawk",
				tags: ["Purple", "Pink"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .006255775047743578,
				y: -.2945871342626449,
				z: .0028594610992341285
			}
		}, {
			id: 1095,
			name: "Bihawk Hair",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_biHawk",
				tags: ["Green", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .022753773112818454,
				y: -.29021241960514166,
				z: .010408569345783436
			}
		}, {
			id: 1096,
			name: "Trihawk Hair",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_triHawk",
				tags: ["Red", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .008256199193995034,
				y: -.3011313509430575,
				z: .0037766439203970395
			}
		}, {
			id: 1097,
			name: "Pigtails Hair",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pigtails",
				tags: ["Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07467920777476911,
				y: -.28400226572156007,
				z: -.034177504156685634
			}
		}, {
			id: 1098,
			name: "Side Pony",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sidePony",
				tags: ["Black", "Pink", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.2048439206899455,
				y: -.23961453155660994,
				z: .15926519498135824
			}
		}, {
			id: 1099,
			name: "Egg Helmet",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggHelmet",
				tags: ["Aveggers", "Gold", "Bone", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06476139106979284,
				y: -.2427274343340584,
				z: -.029638540345020253
			}
		}, {
			id: 1100,
			name: "Fohawk Wig",
			price: 5e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_arrow",
				tags: ["Aveggers", "Brown", "Black", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0424208650320651,
				y: -.2345596826772796,
				z: .013231958207907298
			}
		}, {
			id: 1101,
			name: "American Bandana",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaAmerica",
				tags: ["Aveggers", "JulyM23", "Red", "White", "Blue", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0017704487943540625,
				y: -.15880670916438272,
				z: -.0011344025820544876
			}
		}, {
			id: 1102,
			name: "Bike Helmet",
			price: 25e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bikeHelmet",
				tags: ["Aveggers", "Red", "Yellow", "Blue", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.051070299137746744,
				y: -.31222624951636146,
				z: -.02337270855193546
			}
		}, {
			id: 1103,
			name: "Bucket Hero Hat",
			price: 25e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bucketMan",
				tags: ["Aveggers", "Red", "Yellow", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06696777176977298,
				y: -.26648197543203245,
				z: -.030655009661612387
			}
		}, {
			id: 1104,
			name: "Bug Mask",
			price: 25e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bugMask",
				tags: ["Aveggers", "Jun23", "Red", "Brown", "Jun24", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09202838165917981,
				y: -.24281215767282105,
				z: -.042112847134861325
			}
		}, {
			id: 1105,
			name: "Magic Cape",
			price: 1,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cape",
				tags: ["Aveggers", "Jun23", "Red", "Purple", "Pink", "Jun24", "JulyM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_cape"],
			align: {
				x: -.04266781721470947,
				y: -.21042771527528292,
				z: -.019527249183542233
			}
		}, {
			id: 1106,
			name: "Eyepatch",
			price: 15e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eyepatch",
				tags: ["Aveggers", "May23", "Black", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.043774138824827946,
				y: -.13452079563909275,
				z: -.008427424416465414
			}
		}, {
			id: 1107,
			name: "Panther Mask",
			price: 5e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pantherMask",
				tags: ["Aveggers", "Black", "Yellow", "JulyM24", "bun_mayan", "premFeatOne", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08867675721627499,
				y: -.21152161186369334,
				z: -.03961583791196849
			}
		}, {
			id: 1108,
			name: "Red Hair Wig",
			price: 12500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_redHair",
				tags: ["Aveggers", "Black", "Red", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.03884946332902017,
				y: -.21260971107733917,
				z: -.029016434478789557
			}
		}, {
			id: 1109,
			name: "Helmet of Sight",
			price: 1e5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sightHelmet",
				tags: ["Aveggers", "Purple", "Black", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.046740069611680646,
				y: -.20162379194021973,
				z: -.017085394972692097
			}
		}, {
			id: 1110,
			name: "Space Gladiator Hat",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spaceGladiator",
				tags: ["Aveggers", "JunM23", "Red", "Brown", "MayM24", "JulyM24", "MarM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_space_gladi"],
			align: {
				x: -.017042282162588518,
				y: -.19924159541308178,
				z: -.011752371250181241
			}
		}, {
			id: 1111,
			name: "Spider Mask",
			price: 12e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spiderMask",
				tags: ["Aveggers", "Sep23", "Red", "Black", "White", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06870616529405815,
				y: -.2201279271430785,
				z: -.03144389611102072
			}
		}, {
			id: 1112,
			name: "Yolk Arms Hat",
			price: 1,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_yolkArms",
				tags: ["Aveggers", "Mar23", "Yellow", "MarM24", "JulyM24", "Feb25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_yolk_arms"],
			align: {
				x: -.09824611395142124,
				y: -.25366739592574794,
				z: -.04496307701845989
			}
		}, {
			id: 1113,
			name: "Guy Fawkes Mask",
			price: 1105,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fawkes",
				tags: ["Bone"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.17510285990363794,
				y: -.16123009897717056,
				z: -.0801371481130441
			}
		}, {
			id: 1114,
			name: "Birthday Hat 1",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_birthday1",
				tags: ["HappyBirthday", "Yellow", "Red", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09004528014090063,
				y: -.38780118220464077,
				z: -.041205839243954934
			}
		}, {
			id: 1115,
			name: "Birthday Hat 2",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_birthday2",
				tags: ["HappyBirthday", "Red", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0900442074975476,
				y: -.38780141753043695,
				z: -.0412062578498793
			}
		}, {
			id: 1116,
			name: "Birthday Cake Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cake",
				tags: ["HappyBirthday", "Red", "Blue", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08715138787708865,
				y: -.375358800154143,
				z: -.039885508067528885
			}
		}, {
			id: 1117,
			name: "League Staff Sash",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_leagueStaff",
				tags: ["League", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.005004015304724163,
				y: -.09218018923075544,
				z: .024480075383928684
			}
		}, {
			id: 1118,
			name: "Cat Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cat",
				tags: ["Orange", "Black", "Ears", "bun_cat"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .2530345577929287,
				y: -.14335075697889277,
				z: .11579685356438585
			}
		}, {
			id: 1119,
			name: "Egg Shell Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggshell",
				tags: ["Bone"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05005480363389614,
				y: -.2332627400135887,
				z: -.021899960910532007
			}
		}, {
			id: 1120,
			name: "Dino Shell Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinoShell",
				tags: ["Orange", "Brown", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04136180758052088,
				y: -.2322692477439574,
				z: -.018399734357048114
			}
		}, {
			id: 1121,
			name: "Penguin Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_penguin",
				tags: ["Black", "White"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0460468107990728,
				y: -.1449311872766339,
				z: -.0210736711744981
			}
		}, {
			id: 1122,
			name: "Pot Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pot",
				tags: ["Black", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.1274127231102291,
				y: -.27853762228909873,
				z: .10954927288677535
			}
		}, {
			id: 1123,
			name: "Tiny Tophat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tophatTiny",
				tags: ["Black", "Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09473700016832165,
				y: -.28327946990930697,
				z: .10673072112087173
			}
		}, {
			id: 1124,
			name: "Nurse Hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_nurse",
				tags: ["White", "Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07263141897925252,
				y: -.3124360336056615,
				z: -.03320790353491676
			}
		}, {
			id: 1125,
			name: "Oni Hat",
			price: 4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_oni",
				tags: ["Sidearms", "White", "Red", "Black", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_oni"],
			align: {
				x: -.02850137689570731,
				y: -.19644521944177756,
				z: -.01721496207172566
			}
		}, {
			id: 1126,
			name: "Zombie Mask",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_zombieMask",
				tags: ["July23", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_zombie_mask"],
			align: {
				x: -.20507391906817896,
				y: -.19136930956056042,
				z: -.0938526467524887
			}
		}, {
			id: 1127,
			name: "Cinnamon Bun Hair",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cinnamonBun",
				tags: ["Eggwalker", "Brown", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.025574859788104032,
				y: -.16097458820901694,
				z: -.011704527956558644
			}
		}, {
			id: 1128,
			name: "Bounty Egger",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bountyEgger",
				tags: ["Eggwalker", "Green", "Black", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09010359208146834,
				y: -.3096931721367018,
				z: -.041236590283360686
			}
		}, {
			id: 1129,
			name: "Good Robes Hat",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_goodRobes",
				tags: ["Eggwalker", "Brown", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.003294669149456579,
				y: -.20397595543931507,
				z: -.004414162955776901
			}
		}, {
			id: 1130,
			name: "Bad Robes Hat",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_badRobes",
				tags: ["Eggwalker", "Black", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.005494201510522094,
				y: -.20397595543931507,
				z: .00039190273387446073
			}
		}, {
			id: 1131,
			name: "Space Emo Hair",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spaceEmo",
				tags: ["Eggwalker", "Black", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04992203535431816,
				y: -.2453196733532348,
				z: -.03147177018283026
			}
		}, {
			id: 1132,
			name: "Space Monk Cloak",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spaceMonk",
				tags: ["Eggwalker", "Blue", "Bone", "May24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.01596096538967145,
				y: -.15676441899143595,
				z: -.028658131445658874
			}
		}, {
			id: 1133,
			name: "Eggperor Hat",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggperor",
				tags: ["Eggwalker", "Black", "Yellow", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04922442032078411,
				y: -.23044239490212748,
				z: -.022527928177171253
			}
		}, {
			id: 1134,
			name: "BBEgg Hat",
			price: 65e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bbEgg",
				tags: ["Eggwalker", "Orange", "White", "MarM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09303705158508402,
				y: -.40071116169074616,
				z: -.042576668436322795
			}
		}, {
			id: 1135,
			name: "C3PYolk Mask",
			price: 1e5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_c3pYolk",
				tags: ["Eggwalker", "Rainbow", "Gold", "Mar24", "Jun25", "premFeatTwo"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05234545439905691,
				y: -.1644001004459974,
				z: -.023951376783042433
			}
		}, {
			id: 1136,
			name: "2020 Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2020",
				tags: ["NewYears", "2020", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09511683446205477,
				y: -.3564681457999029,
				z: -.04353093855962348
			}
		}, {
			id: 1137,
			name: "Eggy Cash Ensemble",
			price: 75e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggyCash",
				tags: ["EggyCash", "Brown", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0350094254989175,
				y: -.20970473415592883,
				z: .009832643987000289
			}
		}, {
			id: 1138,
			name: "Soda Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_drinkdew",
				tags: ["Newsletter", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.12717812078732038,
				y: -.29468604465734005,
				z: -.05820376655005444
			}
		}, {
			id: 1139,
			name: "Surgical Mask",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_surgicalMask",
				tags: ["Surgical", "Green"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05816313573477583,
				y: -.15443180825077962,
				z: -.026618798915909347
			}
		}, {
			id: 1140,
			name: "Surgical Mask White",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_surgicalWhite",
				tags: ["Surgical", "White"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05816313573477583,
				y: -.15443180825077962,
				z: -.026618798915909347
			}
		}, {
			id: 1141,
			name: "Surgical Mask Smile",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_surgicalSmile",
				tags: ["Surgical", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05816313573477583,
				y: -.15443180825077962,
				z: -.026618798915909347
			}
		}, {
			id: 1142,
			name: "Falcon Hunter Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_falconHunter",
				tags: ["RaidLand", "Yellow", "Nov23"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.019465021575194363,
				y: -.16061997810856643,
				z: -.018786977876343564
			}
		}, {
			id: 1143,
			name: "Shadow Hunter Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shadowHunter",
				tags: ["RaidLand", "Mar23", "Purple", "Aug24", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .040752448565812394,
				y: -.1410023327458786,
				z: .01865425522337505
			}
		}, {
			id: 1144,
			name: "Frost Berserker Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_frostBerserker",
				tags: ["RaidLand", "Blue", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09647713804661162,
				y: -.25489461130332036,
				z: -.04415349181618433
			}
		}, {
			id: 1145,
			name: "Grim Berserker Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_grimBerserker",
				tags: ["RaidLand", "Blue", "Gray", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12139285377596032,
				y: -.2813697501715835,
				z: -.05555635755260763
			}
		}, {
			id: 1146,
			name: "Golem Warrior Hat",
			price: 1200,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_golemWarrior",
				tags: ["RaidLand", "Green", "Mar24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.047041600207025525,
				y: -.25179530384755866,
				z: -.02146208281435391
			}
		}, {
			id: 1147,
			name: "Immortal Warrior Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_immortalWarrior",
				tags: ["RaidLand", "Blue", "Gray", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1087318992256816,
				y: -.3323169847959204,
				z: -.046798794735782745
			}
		}, {
			id: 1148,
			name: "Sheep Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sheep",
				tags: ["Newsletter", "White", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06234328566352154,
				y: -.2657714995353031,
				z: -.02853187610986624
			}
		}, {
			id: 1149,
			name: "Blue Toxic  Bandana",
			price: 7500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toxicBlue",
				tags: ["Rotten", "Blue", "Green"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.020208838470678003,
				y: -.12523480985630764,
				z: -.009249284905003152
			}
		}, {
			id: 1150,
			name: "Green Toxic Bandana",
			price: 7500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toxicGreen",
				tags: ["Rotten", "Green"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.020208838470678003,
				y: -.12523480985630764,
				z: -.009249284905003152
			}
		}, {
			id: 1151,
			name: "Orange Toxic Bandana",
			price: 7500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toxicOrange",
				tags: ["Rotten", "Orange", "Green"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.020208838470678003,
				y: -.12523480985630764,
				z: -.009249284905003152
			}
		}, {
			id: 1152,
			name: "Double Filter Gas Mask",
			price: 75e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_doubleFilter",
				tags: ["Black", "Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07869036843854582,
				y: -.1670771929647512,
				z: -.03601121015262934
			}
		}, {
			id: 1153,
			name: "Brown Rockstar Hair",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rockstar1",
				tags: ["Rockstar", "JanM23", "Brown", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.02668556941149891,
				y: -.2766025877174578,
				z: -.012212852578724787
			}
		}, {
			id: 1154,
			name: "Black & Red Rockstar Hair",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rockstar3",
				tags: ["Rockstar", "JanM23", "Black", "Red", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.017915658211507868,
				y: -.22147999618357828,
				z: -.008199236407690325
			}
		}, {
			id: 1155,
			name: "Black & White Rockstar Hair",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rockstar2",
				tags: ["Rockstar", "JanM23", "Black", "White", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.009818349718689667,
				y: -.2951244655343809,
				z: -.004493441910886048
			}
		}, {
			id: 1156,
			name: "Umbrella Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_umbrella",
				tags: ["Newsletter", "Rainbow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09443312459641184,
				y: -.2901235633645569,
				z: .07806251993890007
			}
		}, {
			id: 1157,
			name: "Star Glasses",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_glassesStar",
				tags: ["Galeggsy", "AprM23", "Pink", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12484232000679674,
				y: -.15004544071299453,
				z: -.05713503190453892
			}
		}, {
			id: 1158,
			name: "Star Bandana",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaStars",
				tags: ["Galeggsy", "AprM23", "Purple", "Pink", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.001362708306832383,
				y: -.10213714959788034,
				z: -.01903713589631366
			}
		}, {
			id: 1159,
			name: "Alien Antennae",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_headbandAlien",
				tags: ["Galeggsy", "AprM23", "Purple", "Pink", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08112413050090228,
				y: -.3190124338524207,
				z: -.03712708816247562
			}
		}, {
			id: 1160,
			name: "Galeggsy Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premiumButterfly",
				tags: ["Galeggsy", "AprM23", "Purple", "Pink", "Aug24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_galeggsy"],
			align: {
				x: .060713865081625795,
				y: -.19942954633235135,
				z: .028818182231672013
			}
		}, {
			id: 1161,
			name: "Black Suit Ensemble",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mercZoneBlack",
				tags: ["MercZone", "Black", "Suit"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.02678216325299232,
				y: -.1177158487880896,
				z: -.012284197322337875
			}
		}, {
			id: 1162,
			name: "Red Suit Ensemble",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mercZoneRed",
				tags: ["MercZone", "Red", "Suit"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.02678216325299232,
				y: -.1177158487880896,
				z: -.012284197322337875
			}
		}, {
			id: 1163,
			name: "Pink Suit Ensemble",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mercZonePink",
				tags: ["MercZone", "Pink", "Suit"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.02678216325299232,
				y: -.1177158487880896,
				z: -.012284197322337875
			}
		}, {
			id: 1164,
			name: "Academic Cap",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_academic",
				tags: ["Newsletter", "Black", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07093971494621032,
				y: -.3224853891775712,
				z: -.03574759001854644
			}
		}, {
			id: 1166,
			name: "Fuzzy Earmuffs",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_earmuffs",
				tags: ["Newsletter", "Pink"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05017462989413346,
				y: -.23629499324838232,
				z: -.022962798773102838
			}
		}, {
			id: 1167,
			name: "Chains Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chains",
				tags: ["Newsletter", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07525641311957942,
				y: -.1397572844128152,
				z: -.014165312798006618
			}
		}, {
			id: 1168,
			name: "Hen Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hen",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10092032091586889,
				y: -.29804565019893214,
				z: -.04618398189947076
			}
		}, {
			id: 1169,
			name: "Rooster Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rooster",
				tags: ["Chicken", "Brown", "Red", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09455461013304145,
				y: -.28662472287303387,
				z: -.04326614325353481
			}
		}, {
			id: 1170,
			name: "Rooster Tail Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_roosterTail",
				tags: ["Chicken", "Green", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .037684122283645705,
				y: -.3188342003436098,
				z: .02145330553469857
			}
		}, {
			id: 1171,
			name: "Rooster Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_RoosterWings",
				tags: ["MayM23", "Chicken", "Green", "Red", "May24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_rooter_wing"],
			align: {
				x: -.014848230007995955,
				y: -.21470955736788944,
				z: -.006795404693105883
			}
		}, {
			id: 1172,
			name: "Bee Wings",
			price: 1e5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_BeeWings",
				tags: ["Rainbow", "Pink", "Green", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.009994370735535885,
				y: -.19329762292182273,
				z: -.004573999293501552
			}
		}, {
			id: 1173,
			name: "Jason Mask",
			price: 75e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_F13",
				tags: ["f13", "Bone", "Red", "Nov24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .024964612025391908,
				y: -.000438791196881283,
				z: -.04600707116643499
			}
		}, {
			id: 1174,
			name: "Demon Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_DemonWings",
				tags: ["Premium", "Red", "OctM23", "FebM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_demon_wings"],
			align: {
				x: .0685948197299946,
				y: -.18782834752363142,
				z: .03139293810363847
			}
		}, {
			id: 1175,
			name: "Among Egg Hat 1",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_01",
				tags: ["AmongEgg", "Blue", "White", "Meme"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1176,
			name: "Among Egg Hat 2",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_02",
				tags: ["AmongEgg", "Blue", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1177,
			name: "Among Egg Hat 3",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_03",
				tags: ["AmongEgg", "Blue", "Brown", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1178,
			name: "Among Egg Hat 4",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_04",
				tags: ["AmongEgg", "Blue", "Brown", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1179,
			name: "Among Egg Hat 5",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_05",
				tags: ["AmongEgg", "Blue", "Brown", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1180,
			name: "Among Egg Hat 6",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_06",
				tags: ["AmongEgg", "Blue", "Brown", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1181,
			name: "Among Egg Hat 7",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_amongEgg_07",
				tags: ["AmongEgg", "Blue", "Brown", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .02161537822779458,
				y: -.049224838353181144,
				z: .00733596647313256
			}
		}, {
			id: 1182,
			name: "Eggolorian Helmet",
			price: 75e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggolorianBig",
				tags: ["Eggolorian", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.026411921972668395,
				y: -.13509385847251787,
				z: -.024761750354195478
			}
		}, {
			id: 1183,
			name: "Toadstool Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toadstool",
				tags: ["Newsletter", "Red", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.055709877852442524,
				y: -.2792171461306885,
				z: .0021067564280323192
			}
		}, {
			id: 1184,
			name: "Fallen Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_FallenWings",
				tags: ["Premium", "FebM23", "Gray", "Brown", "bun_dove"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_fallen_wing"],
			align: {
				x: -.016135329117298647,
				y: -.21346623949778282,
				z: -.007384455335413202
			}
		}, {
			id: 1185,
			name: "Golden Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_GoldenWings",
				tags: ["Premium", "vipItem", "Gray", "Silver"]
			},
			is_available: !1,
			unlock: "vip",
			align: {
				x: .02761299490618674,
				y: -.14516558338113816,
				z: .012637296007242005
			}
		}, {
			id: 1186,
			name: "Chrome Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_ChromeWings",
				tags: ["July23", "Gold", "Yellow", "DecM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_chrome_wing"],
			align: {
				x: .01674006510310644,
				y: -.247877226408992,
				z: .007661217482458432
			}
		}, {
			id: 1187,
			name: "Wero Viking Hair",
			price: 4e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wero",
				tags: ["Wero", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .056303593911419814,
				y: -.14612210750057109,
				z: .025765045299767086
			}
		}, {
			id: 1188,
			name: "Mech Energy Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_MechEnergyWings",
				tags: ["Newsletter", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .015330953250958235,
				y: -.19451067287062584,
				z: .007016326768703868
			}
		}, {
			id: 1189,
			name: "Egg Sandwich Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sandwich",
				tags: ["Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07130919700923943,
				y: -.30712692187370716,
				z: -.032635193234431537
			}
		}, {
			id: 1190,
			name: "Party Hat 2021",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party2021",
				tags: ["NewYears", "2021", "Red", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064355390021284,
				y: -.39039936988703516,
				z: -.041483707867384534
			}
		}, {
			id: 1191,
			name: "Headband 2021",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2021",
				tags: ["NewYears", "2021", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09511683446205477,
				y: -.3564681457999029,
				z: -.04353093855962348
			}
		}, {
			id: 1192,
			name: "Hindsight Glasses",
			price: 25e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_glassesHindsight",
				tags: ["NewYears", "Black", "Purple", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0547271990742301,
				y: -.20063102866948732,
				z: .025046316631686674
			}
		}, {
			id: 1193,
			name: "Steampunk Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_SteampunkWings",
				tags: ["Premium", "JulyM23", "Gold"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_steamWings"],
			align: {
				x: -.03198825591038429,
				y: -.2260334318073813,
				z: -.014639667176367683
			}
		}, {
			id: 1194,
			name: "Thee_Owl Hat",
			price: 1e5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_theeowl",
				tags: ["TheeOwl", "Red", "Orange", "Green", "Blue", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.018544171968607248,
				y: -.19240670414833727,
				z: -.008486880491591603
			}
		}, {
			id: 1195,
			name: "Angel Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelAngel",
				tags: ["Jun23", "Blue", "Yellow", "White", "Dec24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_pixel_wings"],
			align: {
				x: .0472404788655226,
				y: -.2091868482273766,
				z: .021619962507704864
			}
		}, {
			id: 1196,
			name: "C4bra Hair",
			price: 15e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_c4bra",
				tags: ["C4bra", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05256816415156407,
				y: -.21887927713761113,
				z: -.04389734348691249
			}
		}, {
			id: 1197,
			name: "C4bra Ram Hat",
			price: 35e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_c4brahorn",
				tags: ["C4bra", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.023596361624323547,
				y: -.20407749696274824,
				z: -.010799053294252028
			}
		}, {
			id: 1198,
			name: "Hazmatt Mask",
			price: 5e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hazmat",
				tags: ["Hazmat", "Yellow", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.11308287904866399,
				y: -.16479260690206332,
				z: -.05328025989807142
			}
		}, {
			id: 1199,
			name: "Slashy Camp Mask",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_slashy",
				tags: ["SlashyCamp", "White", "Bone", "Red", "Brown", "Skullface", "Slayaway"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08886748152911006,
				y: -.1743046148683261,
				z: .010484776937821606
			}
		}, {
			id: 1200,
			name: "Discord Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_discord",
				tags: ["Discord", "Black", "Purple", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.12105425626384658,
				y: -.2683138912314549,
				z: -.055403067375097204
			}
		}, {
			id: 1201,
			name: "Definitely not Egg",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_funnyGlasses",
				tags: ["Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.1835774998200077,
				y: -.16995815775748346,
				z: -.08400750293600584
			}
		}, {
			id: 1202,
			name: "Skull Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_SkullWings",
				tags: ["Red", "Brown", "Black", "Bone", "Oct23"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_skull_wings"],
			align: {
				x: -.00010832741414268376,
				y: -.12452614579911303,
				z: -.0003290829473785589
			}
		}, {
			id: 1203,
			name: "Egg Earpods",
			price: 25e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_airpods",
				tags: ["White"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.019127507470631577,
				y: -.16649293479814636,
				z: -.008753848404344206
			}
		}, {
			id: 1204,
			name: "Paper Bag Mask",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bag",
				tags: ["Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.0570301614362152,
				y: -.2653326619474974,
				z: -.025899324044152905
			}
		}, {
			id: 1205,
			name: "Backwards Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hipster",
				tags: ["Egg", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.011468426131167497,
				y: -.2906639602185078,
				z: -.04635516963121872
			}
		}, {
			id: 1206,
			name: "Beret",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_beret",
				tags: ["White", "Red", "Egg"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.055021973188496,
				y: -.27189908716968936,
				z: -.056135607980478675
			}
		}, {
			id: 1207,
			name: "Spike Hat",
			price: 7500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spike",
				tags: ["Gold", "Black", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08330871023780784,
				y: -.32247434428827937,
				z: -.03728431149234124
			}
		}, {
			id: 1208,
			name: "TikTok Bowler",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tiktok",
				tags: ["Pink", "Blue", "Black", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05193614209106312,
				y: -.2747381724486184,
				z: -.030040690041946927
			}
		}, {
			id: 1209,
			name: "Propeller Beanie",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_beanie",
				tags: ["Newsletter", "Rainbow", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07773122740157001,
				y: -.33478619745174276,
				z: -.03557433316800812
			}
		}, {
			id: 1210,
			name: "Riddler Bowler",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_riddler",
				tags: ["Purple", "Yellow", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06902895424785793,
				y: -.29730062114783573,
				z: -.031588443706486946
			}
		}, {
			id: 1211,
			name: "Miner Helmet",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_miner",
				tags: ["Yellow", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07637135947582285,
				y: -.26818667179554234,
				z: -.03494866906248434
			}
		}, {
			id: 1212,
			name: "Dog Ears",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dog",
				tags: ["sale", "Mar23", "Brown", "NovM23"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_dog_cap"],
			align: {
				x: .15090627867947326,
				y: -.148499481909677,
				z: .06644016204783357
			}
		}, {
			id: 1213,
			name: "Satellite Headgear",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_satellite",
				tags: ["Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.1003526479958019,
				y: -.3126854219834809,
				z: -.031678792439267967
			}
		}, {
			id: 1214,
			name: "Diablo Hat",
			price: 100,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_evilpablo",
				tags: ["EGGORG", "Black", "Red", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07552652492916812,
				y: -.3252818085896001,
				z: -.03455986096692204
			}
		}, {
			id: 1215,
			name: "Robot Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelRobot",
				tags: ["Aug23", "Green", "Gray", "Black"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_robot_wings"],
			align: {
				x: .010422668079778596,
				y: -.15195166020488457,
				z: .004770012924198996
			}
		}, {
			id: 1216,
			name: "Train Conductor",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_conductor",
				tags: ["Trains", "Cars", "Yellow", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07447285699071271,
				y: -.27373920004456487,
				z: -.034084459105144516
			}
		}, {
			id: 1217,
			name: "Train Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_train",
				tags: ["Trains", "Cars", "Red", "Gray"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.12181852358880674,
				y: -.25462191713874516,
				z: -.02548535493101492
			}
		}, {
			id: 1218,
			name: "Bindle Hat",
			price: 4500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bindle",
				tags: ["Trains", "Cars", "Red", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07625396127772457,
				y: -.19259195468605367,
				z: .1997715437643714
			}
		}, {
			id: 1219,
			name: "Instagram Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_instagram",
				tags: ["Purple", "Orange", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10458216013544197,
				y: -.3038086237336537,
				z: -.0051294333925099855
			}
		}, {
			id: 1220,
			name: "UFO Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ufo",
				tags: ["Newsletter", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06048177152047618,
				y: -.32833299960741713,
				z: -.0693053769660591
			}
		}, {
			id: 1221,
			name: "RandomLife Headgear",
			price: 5e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_randomlife",
				tags: ["Random", "Red", "Brown", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.049085380484119145,
				y: -.18555836262817182,
				z: -.022464295558879216
			}
		}, {
			id: 1222,
			name: "Unicorn Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_UnicornWings",
				tags: ["Mar23", "Pink", "White", "OctM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_uni_wing"],
			align: {
				x: -.008910853390342588,
				y: -.2650553005622003,
				z: -.004078119362420363
			}
		}, {
			id: 1223,
			name: "Steam Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_steam",
				tags: ["Pink"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0956015549521565,
				y: -.2864809679826543,
				z: -.043752774580604115
			}
		}, {
			id: 1224,
			name: "Ice Cream Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_icecream",
				tags: ["Newsletter", "Blue", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.057938759706054554,
				y: -.2783004123624848,
				z: .03933975026677053
			}
		}, {
			id: 1225,
			name: "Ethan Gamer Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ethangamer",
				tags: ["EthanGamer", "Brown", "Green", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.03556352559610376,
				y: -.19568013520375716,
				z: -.017074842448833144
			}
		}, {
			id: 1226,
			name: "Fairy Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelFairy",
				tags: ["Dec23", "Pink", "Blue"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_fairy_wings"],
			align: {
				x: .025487516259037335,
				y: -.11036003837934794,
				z: .01166455461777266
			}
		}, {
			id: 1227,
			name: "Facebook Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_facebook",
				tags: ["Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.13911162234386953,
				y: -.24736789717254104,
				z: -.0659173981798371
			}
		}, {
			id: 1228,
			name: "Sun Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sun",
				tags: ["Summer", "JunM23", "Yellow", "Brown", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.050488251857767175,
				y: -.25609643737374777,
				z: -.023112360850326363
			}
		}, {
			id: 1229,
			name: "Picnic Basket Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_picnic",
				tags: ["Summer", "JunM23", "Brown", "White", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06391937586354324,
				y: -.3049931703225548,
				z: -.0372255670228166
			}
		}, {
			id: 1230,
			name: "Beehive Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_beehive",
				tags: ["Summer", "JunM23", "Yellow", "Black", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09472312087566159,
				y: -.34840081463281347,
				z: -.035276375097910984
			}
		}, {
			id: 1231,
			name: "Parrot Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_parrot",
				tags: ["Newsletter", "Red", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10044149920045642,
				y: -.27678159126613106,
				z: .12029495213527525
			}
		}, {
			id: 1232,
			name: "Toilet Paper Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_ToiletPaperWings",
				tags: ["Premium", "White", "Brown", "bun_toilet"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .010997881077290383,
				y: -.24427555574888432,
				z: .00503326353283963
			}
		}, {
			id: 1233,
			name: "Watermelon Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_watermelon",
				tags: ["Newsletter", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.03885382911933832,
				y: -.19948565389743578,
				z: -.0065169765907116955
			}
		}, {
			id: 1234,
			name: "Twitter Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_twitter",
				tags: ["Blue", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.12276427275929835,
				y: -.2736920598170087,
				z: -.05496658279849259
			}
		}, {
			id: 1235,
			name: "Fire Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelFire",
				tags: ["Premium", "Red", "Yellow", "Mar24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_pixel_fire"],
			align: {
				x: -.0030721007352483287,
				y: -.1384340684230544,
				z: -.001405970091427386
			}
		}, {
			id: 1236,
			name: "Backpack Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_backpack",
				tags: ["Pencil", "Sep23", "Red", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .12218146949814168,
				y: -.16622138475595996,
				z: .05686431041429582
			}
		}, {
			id: 1237,
			name: "Backpack Rainbow Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_backpackrainbow",
				tags: ["Pencil", "Sep23", "Rainbow", "White", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .122528399626321,
				y: -.16631880701545823,
				z: .05702308561137556
			}
		}, {
			id: 1238,
			name: "Round Glasses",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_roundglasses",
				tags: ["Pencil", "Sep23", "Black", "Sep24"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.11772619456545064,
				y: -.1430215058655926,
				z: -.053878283278210176
			}
		}, {
			id: 1239,
			name: "Books Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_books",
				tags: ["Newsletter", "Yellow", "Brown", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09433236283052882,
				y: -.3004764423791535,
				z: -.026153673415162615
			}
		}, {
			id: 1240,
			name: "Wero Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_weroShort",
				tags: ["Wero", "Brown", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.053723864256666864,
				y: -.2665844331860534,
				z: -.019579849924790615
			}
		}, {
			id: 1241,
			name: "Glitch Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_GlitchWings",
				tags: ["Premium", "Purple", "Pink", "Black", "NovM23", "Apr24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_glitch_wing"],
			align: {
				x: .05340656668026472,
				y: -.22606012536383804,
				z: .02444191923667508
			}
		}, {
			id: 1242,
			name: "Sherlock Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sherlock",
				tags: ["Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05668436102263996,
				y: -.2441306698166108,
				z: -.025937601815962552
			}
		}, {
			id: 1243,
			name: "Grave Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_RIP",
				tags: ["Halloween2", "Oct23", "Grey", "Gray", "Egg", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11837364791910598,
				y: -.3453135657676538,
				z: -.02841929196202969
			}
		}, {
			id: 1244,
			name: "Ghost Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ghost",
				tags: ["Halloween2", "Oct23", "White", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0525359727521153,
				y: -.13535000874785352,
				z: -.00785241763098675
			}
		}, {
			id: 1245,
			name: "Moth Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelMoth",
				tags: ["Nov23", "Brown", "Black", "Skull", "Lambs"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_moth_wings"],
			align: {
				x: .06648429136962275,
				y: -.18018318464573405,
				z: .030427038834781373
			}
		}, {
			id: 1246,
			name: "Android Hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_android",
				tags: ["Mobile", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0686633228481126,
				y: -.2957310387488832,
				z: -.03142428891712207
			}
		}, {
			id: 1247,
			name: "Bravo Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bravo",
				tags: ["Newsletter", "Yellow", "Hair"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06819602391192303,
				y: -.25251405511395886,
				z: -.03364586243139556
			}
		}, {
			id: 1248,
			name: "Thermal Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_ThermalWings",
				tags: ["Red", "DecM23"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["hat_thermal_wings"],
			align: {
				x: -.04496152602050674,
				y: -.22804447072723255,
				z: -.020576982360488452
			}
		}, {
			id: 1249,
			name: "Apple Pie Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_applepie",
				tags: ["Food", "Brown", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07402118177510753,
				y: -.3129973850256931,
				z: -.034363178649461035
			}
		}, {
			id: 1250,
			name: "Pumpkin Pie Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pumpkinpie",
				tags: ["Food", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07684515275051185,
				y: -.3226497851796406,
				z: -.035164717517768396
			}
		}, {
			id: 1251,
			name: "Cheese Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cheese",
				tags: ["Food", "Yellow", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09736025924578184,
				y: -.30784507348091106,
				z: -.044840917772301314
			}
		}, {
			id: 1252,
			name: "Gravy hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gravy",
				tags: ["Food", "Brown", "Yellow", "NovM23"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10764049404297893,
				y: -.3242807539480268,
				z: -.04858410689496345
			}
		}, {
			id: 1253,
			name: "Dollar Sign Glasses Black",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_PremiumEggTier3",
				tags: ["Black Fryday", "MayM23", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1272223463951172,
				y: -.16985670643656636,
				z: -.05822426897524949
			}
		}, {
			id: 1254,
			name: "Pink Hair",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pinkwarrior",
				tags: ["Eggs of Legends", "Pink"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.051101478189649496,
				y: -.21837873885616244,
				z: -.04886738805522073
			}
		}, {
			id: 1255,
			name: "Blue Braids",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bluebraids",
				tags: ["Eggs of Legends", "Blue", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .014294459551864591,
				y: -.0564965739245884,
				z: .00654219696920838
			}
		}, {
			id: 1256,
			name: "Weather Vane",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_weathervane",
				tags: ["KotC", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08938104127416624,
				y: -.3949801858969135,
				z: -.047053257971897744
			}
		}, {
			id: 1257,
			name: "Red Crown Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_winnerRed",
				tags: ["KotC", "Gold", "Red"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.024404769481507493,
				y: -.4032693734415156,
				z: -.010993647592823785
			}
		}, {
			id: 1258,
			name: "Blue Crown Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_winnerBlue",
				tags: ["KotC", "Gold", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.024742434488183473,
				y: -.4031638504834284,
				z: -.011144839475885127
			}
		}, {
			id: 1259,
			name: "Bison Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bison",
				tags: ["Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09099733428325463,
				y: -.28127430856860536,
				z: -.041638129058378215
			}
		}, {
			id: 1260,
			name: "Egg Cluster Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggcluster",
				tags: ["KotC", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07079690890193824,
				y: -.3420100851495165,
				z: -.045823917581105156
			}
		}, {
			id: 1261,
			name: "Party Hat 2022",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party2022",
				tags: ["NewYears", "2022", "Brown", "Red", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064355390021284,
				y: -.39039936988703516,
				z: -.041483707867384534
			}
		}, {
			id: 1262,
			name: "Headband 2022",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2022",
				tags: ["NewYears", "2022", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09499434428437392,
				y: -.3559405841960604,
				z: -.04347488000356631
			}
		}, {
			id: 1263,
			name: "Nervous Elf Belt",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_nervouself",
				tags: ["Christmas2", "Elf", "Brown", "Gold", "Green", "Red", "bun_mistle", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.02412197895070589,
				y: -.06700092007771397,
				z: -.011163725420193032
			}
		}, {
			id: 1264,
			name: "Bugs Hair",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bluehair",
				tags: ["Meggtrix", "JulyM23", "Blue", "Jun24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06755290806472969,
				y: -.2574267838016908,
				z: -.05731751448656369
			}
		}, {
			id: 1265,
			name: "Meggtrix Glasses",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_clampglasses",
				tags: ["Meggtrix", "Black", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.19919493077297812,
				y: -.13104190797669846,
				z: -.09116306656828238
			}
		}, {
			id: 1266,
			name: "Agent Smithe Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_smith",
				tags: ["Meggtrix", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.018096408130339636,
				y: -.07236629676634476,
				z: -.00827871328761573
			}
		}, {
			id: 1267,
			name: "Dreadlocks Hair",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_twins",
				tags: ["Meggtrix", "Gray"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .013752778058945037,
				y: -.1260515983702566,
				z: .004499134103787522
			}
		}, {
			id: 1268,
			name: "Twitch Bits",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bits",
				tags: ["Purple", "Green", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07625784724232476,
				y: -.3212491848476593,
				z: -.03724174556834575
			}
		}, {
			id: 1269,
			name: "Butterfly Pixel Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelButterfly",
				tags: ["Purple", "Blurple", "Jun24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_pixel_butt"],
			align: {
				x: .06842190316438235,
				y: -.1664346465616369,
				z: .03131380152266161
			}
		}, {
			id: 1270,
			name: "Mandrake Glasses",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mandrake",
				tags: ["Drops", "Blue", "Black", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.045350248619579814,
				y: -.18856227419506955,
				z: -.02203309706400762
			}
		}, {
			id: 1271,
			name: "Lyerpald Wolf Helmut",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_lyerpald",
				tags: ["Drops", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09070205347941274,
				y: -.2946872575472672,
				z: -.04097567283638698
			}
		}, {
			id: 1272,
			name: "Pixel Bird Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelBird",
				tags: ["Premium", "AugM23"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_pixel_bird"],
			align: {
				x: -.006167608731298957,
				y: -.23009693766193717,
				z: -.002822652707942727
			}
		}, {
			id: 1273,
			name: "xSerpius Hair",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_xserpiusbeard",
				tags: ["Drops", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.03782371298281717,
				y: -.08324704596677912,
				z: -.020377304636828963
			}
		}, {
			id: 1274,
			name: "Blue & Yellow Toque ",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toque",
				tags: ["Chilly", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04545315805478767,
				y: -.23604199770916368,
				z: -.020801981476676862
			}
		}, {
			id: 1275,
			name: "Purple & Red Toque",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pufftoque",
				tags: ["Chilly", "Purple", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0520856055559209,
				y: -.24271405955948588,
				z: -.023837371235649107
			}
		}, {
			id: 1276,
			name: "Ear Flaps Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_greenearhat",
				tags: ["Chilly", "Sep23", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07667842259454893,
				y: -.21881040618974978,
				z: -.035092459960448186
			}
		}, {
			id: 1277,
			name: "Bow Headband",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pinkbow",
				tags: ["Kawaii", "Blue", "Pink", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .013242936048015075,
				y: -.1033230738103943,
				z: -.008508166486768332
			}
		}, {
			id: 1278,
			name: "Cute Ponytail",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pinkpony",
				tags: ["Kawaii", "Pink", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .025839573329109022,
				y: -.12563835757091635,
				z: .03822514136542354
			}
		}, {
			id: 1279,
			name: "High Pigtails",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hightails",
				tags: ["Kawaii", "Purple", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .0276683407182281,
				y: -.06620158453736735,
				z: .012662625411135664
			}
		}, {
			id: 1280,
			name: "Orange Hair Buns",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spacebuns",
				tags: ["Kawaii", "Orange"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.023154355564313445,
				y: -.1721316874022778,
				z: -.010596765888274434
			}
		}, {
			id: 1281,
			name: "Cat Braids",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_catbraids",
				tags: ["Kawaii", "Brown", "Hair"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .04942305559527016,
				y: -.08275381442845631,
				z: .022625504948921016
			}
		}, {
			id: 1282,
			name: "Sashimi Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sushi",
				tags: ["Kawaii", "Pink", "White"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.06607460559824174,
				y: -.3145620311388375,
				z: -.023349608686141055
			}
		}, {
			id: 1283,
			name: "Big Cat Ears",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bigears",
				tags: ["Kawaii", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08912079570999865,
				y: -.2812066668309523,
				z: -.04078680610014129
			}
		}, {
			id: 1284,
			name: "Spiky Hair",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spikyband",
				tags: ["Kawaii", "White", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.023430270261315833,
				y: -.29978976104196253,
				z: .01652652925006237
			}
		}, {
			id: 1285,
			name: "Gamer Hair",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gamerhair",
				tags: ["Yellow"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.013377586824752985,
				y: -.1219796445900333,
				z: -.015800351731837636
			}
		}, {
			id: 1286,
			name: "Purple Hair",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_purplehair",
				tags: ["Purple"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .023129168688115875,
				y: -.11083660530794659,
				z: .006054604634013971
			}
		}, {
			id: 1287,
			name: "Mmm Donut Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_donut",
				tags: ["Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08550644276840513,
				y: -.27604362378568936,
				z: -.026332007285230108
			}
		}, {
			id: 1288,
			name: "Lucky Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_LuckyWings",
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_luckywings"],
			align: {
				x: -.033786312351363645,
				y: -.1967396243343998,
				z: -.015462594090161368
			}
		}, {
			id: 1289,
			name: "Turtle Power Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_turtle",
				tags: ["Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.019347811387824265,
				y: -.2317573148140306,
				z: -.008854672137101616
			}
		}, {
			id: 1290,
			name: "Ukraine Bandana",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bandanaUkraine",
				tags: ["UA", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.037327876564546614,
				y: -.09202308400058623,
				z: -.03566510179609639
			}
		}, {
			id: 1291,
			name: "Sweatband",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sweatband",
				tags: ["BBros", "Egg", "Purple", "Gold", "JunM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.03139999298521712,
				y: -.20010309398013404,
				z: -.014370444207938982
			}
		}, {
			id: 1292,
			name: "Spartan Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_spartan",
				tags: ["BBros", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11924556069189718,
				y: -.28847717682052254,
				z: -.05456955212903192
			}
		}, {
			id: 1293,
			name: "Gators Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gators",
				tags: ["BBros", "Blue", "Orange", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11924556069189718,
				y: -.28847717682052254,
				z: -.05456955212903192
			}
		}, {
			id: 1294,
			name: "Rams Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rams",
				tags: ["BBros", "Aug23", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11924556069189718,
				y: -.28847717682052254,
				z: -.05456955212903192
			}
		}, {
			id: 1295,
			name: "Knight Hat",
			price: 1520,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_knight",
				tags: ["EGGORG", "Blue", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0714147299793606,
				y: -.23565709532673618,
				z: -.0326814591627768
			}
		}, {
			id: 1296,
			name: "Viking Helmet",
			price: 1520,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_viking",
				tags: ["EGGORG", "Yellow", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0695631630520892,
				y: -.18345971679684459,
				z: -.03183610762846864
			}
		}, {
			id: 1297,
			name: "Egg Cape",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggcape",
				tags: ["EGGORG", "Yellow", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.005960168837245927,
				y: -.06521101336169344,
				z: -.0027277491000435583
			}
		}, {
			id: 1298,
			name: "Joker Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_joker",
				tags: ["EGGORG", "Blue", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.004737473505517453,
				y: -.30091891990419384,
				z: -.006680355253004977
			}
		}, {
			id: 1299,
			name: "Shield Hat",
			price: 1520,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shield",
				tags: ["EGGORG", "Apr23", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.001314076285751753,
				y: -.145188741690077,
				z: -.007500360642775039
			}
		}, {
			id: 1300,
			name: "Valkyrie Helmet",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_valkyrie",
				tags: ["Newsletter", "Blue", "Gray"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.057175017244421866,
				y: -.20885034996221186,
				z: -.026166578997877943
			}
		}, {
			id: 1301,
			name: "Tattered Cape",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggcapeRust",
				tags: ["Relic", "Drops2", "Brown", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0032140950995573903,
				y: -.05338375428872988,
				z: -.0014709876888352458
			}
		}, {
			id: 1302,
			name: "Gold Joker Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_jokerGold",
				tags: ["Relic", "Drops2", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.004737473505517453,
				y: -.30091891990419384,
				z: -.006680355253004977
			}
		}, {
			id: 1303,
			name: "Rusty Viking Helmet",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_vikingRust",
				tags: ["Relic", "Drops2", "Brown", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0695631630520892,
				y: -.18345971679684459,
				z: -.03183610762846864
			}
		}, {
			id: 1304,
			name: "Rusty Knight Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_knightRust",
				tags: ["Relic", "Drops2", "Brown", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07254534842625415,
				y: -.2387070727526709,
				z: -.03319142252026157
			}
		}, {
			id: 1305,
			name: "JWBerry3D Glasses",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gamerglasses",
				tags: ["Relic", "Red", "Black"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.11078425287591509,
				y: -.1237525930467187,
				z: -.05070125116724264
			}
		}, {
			id: 1306,
			name: "Ocean Glasses",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_oceanglasses",
				tags: ["Relic", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.12495636346710981,
				y: -.13507479491885022,
				z: -.05737283020232181
			}
		}, {
			id: 1307,
			name: "Tooth Survivor Bandana",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toothbandana",
				tags: ["Dino", "May23", "Gray", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04755004110646732,
				y: -.12795363370519897,
				z: -.006119485827542431
			}
		}, {
			id: 1308,
			name: "Steggasauras Scales",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_stego",
				tags: ["Dino", "May23", "Orange", "Green", "Dec23", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .10516669405657098,
				y: -.14039272566488192,
				z: .048125859170304874
			}
		}, {
			id: 1309,
			name: "Red Dino Tail",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinotailred",
				tags: ["Dino", "May23", "Yellow", "Red", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .10781959893149307,
				y: -.13401897970572288,
				z: .14210710777705432
			}
		}, {
			id: 1310,
			name: "Green Dino Tail",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinotailgreen",
				tags: ["Dino", "May23", "Green", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .10781959893149307,
				y: -.13401897970572288,
				z: .14210710777705432
			}
		}, {
			id: 1311,
			name: "Dino Mouth Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinomouth",
				tags: ["Dino", "May23", "Red", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.031831313732059385,
				y: -.3524354179999527,
				z: -.013994178632266319
			}
		}, {
			id: 1312,
			name: "Alpha Pterodactyl Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_DinoWings",
				tags: ["Dino", "May23", "Green", "AugM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_dinowings"],
			align: {
				x: -.07859264188282022,
				y: -.20860363417986472,
				z: -.035968582448789366
			}
		}, {
			id: 1313,
			name: "Dino Triceratops Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dino",
				tags: ["Dino", "Newsletter", "Orange"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09452825597300052,
				y: -.3315847405619863,
				z: -.04468450251659173
			}
		}, {
			id: 1314,
			name: "Tablet Backpack",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tabletpack",
				tags: ["Mobile", "SepM23", "Red", "Egg"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .11079876174309317,
				y: -.19012561884289186,
				z: .05168685108465057
			}
		}, {
			id: 1315,
			name: "Telephone Hat ",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_telephone",
				tags: ["Mobile", "AugM23", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .05860631546825945,
				y: -.13663260348863965,
				z: .12487819389459201
			}
		}, {
			id: 1316,
			name: "Airplane Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Airplane",
				tags: ["Sep23", "Premium", "White", "Blue"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_airplane"],
			align: {
				x: .23034786490917902,
				y: -.1547492657728725,
				z: .10487083678434686
			}
		}, {
			id: 1317,
			name: "Head Tail",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_headtails",
				tags: ["Eggwalker2", "White", "Green", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0196740573061005,
				y: -.19606196947358268,
				z: -.009000703549737338
			}
		}, {
			id: 1318,
			name: "Eggpire Cap",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_imperial",
				tags: ["Eggwalker2", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06259811515829705,
				y: -.2829860136744101,
				z: -.02864312563205662
			}
		}, {
			id: 1319,
			name: "Sci-fi Visor",
			price: 6500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_obiwan",
				tags: ["Eggwalker2", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.24271137738414206,
				y: -.13328460556968547,
				z: -.1197112186589378
			}
		}, {
			id: 1320,
			name: "Cross Fighter Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_CrossWing",
				tags: ["Eggwalker2", "Premium", "White", "Grey", "Gray", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .15930024282913313,
				y: -.18075422946571956,
				z: .07290496100199528
			}
		}, {
			id: 1321,
			name: "Pineapple Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pineapple",
				tags: ["Summer", "JunM23", "Green", "White", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09812463178535724,
				y: -.4156135499303326,
				z: -.04060392769329296
			}
		}, {
			id: 1322,
			name: "Kite Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kite",
				tags: ["Summer", "JunM23", "Rainbow", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .017159674628105748,
				y: -.31965418856758354,
				z: .007851239309207725
			}
		}, {
			id: 1323,
			name: "UK Bucket Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_buckethat",
				tags: ["Summer", "Newsletter", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05810470285745151,
				y: -.2502452533755086,
				z: -.02659205663663128
			}
		}, {
			id: 1324,
			name: "Baseball Helmet",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_baseball",
				tags: ["Sports", "JulyM23", "Black", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05151488588494635,
				y: -.19998687433606954,
				z: -.0245622817722769
			}
		}, {
			id: 1325,
			name: "Football Helmet",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_football",
				tags: ["Sports", "JulyM23", "Blue", "Yellow", "Fbros", "JunM24", "SepM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04832931417978026,
				y: -.1352946574924434,
				z: -.024871745773064752
			}
		}, {
			id: 1326,
			name: "Swim Cap",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_swimcap",
				tags: ["Sports", "JulyM23", "Oct23", "Blue", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.056393739829843526,
				y: -.2477807183539309,
				z: -.02621372851028153
			}
		}, {
			id: 1327,
			name: "Frisbee Damage Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_frisbee",
				tags: ["Sports", "JulyM23", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1388062207676577,
				y: -.2588205395914731,
				z: .05984669179307067
			}
		}, {
			id: 1328,
			name: "SPORTS headband",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_headband",
				tags: ["Sports", "JulyM23", "Green", "Egg", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.028531595495777218,
				y: -.19854721990374058,
				z: -.013057700403261097
			}
		}, {
			id: 1329,
			name: "Cone Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cone",
				tags: ["Newsletter", "Sports", "JulyM23", "Orange"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08905438095940177,
				y: -.42381444261433376,
				z: -.01246906664059666
			}
		}, {
			id: 1330,
			name: "Egg Yolk Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggyolk",
				tags: ["Breakfast", "Egg", "White", "Yellow", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05723363847063201,
				y: -.2392488492437903,
				z: -.029219959301922005
			}
		}, {
			id: 1331,
			name: "Waffles Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_waffles",
				tags: ["Breakfast", "Brown", "Yellow", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.042130070070243164,
				y: -.31705850027197235,
				z: -.03466427348870399
			}
		}, {
			id: 1332,
			name: "Pancakes Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pancakes",
				tags: ["Breakfast", "Brown", "Yellow", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06990694206534798,
				y: -.29184377670850803,
				z: -.026418624087968023
			}
		}, {
			id: 1333,
			name: "Teacup Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_teacup",
				tags: ["Breakfast", "White", "Red", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.020174507966058464,
				y: -.3111035460059972,
				z: -.05108915694622945
			}
		}, {
			id: 1334,
			name: "Captain Breakfast Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_captaincrunch",
				tags: ["Breakfast", "Newsletter", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0795272416879782,
				y: -.34252532281063364,
				z: -.03639624352455051
			}
		}, {
			id: 1335,
			name: "Keyhole Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_keyhole",
				tags: ["Scavenger", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06380360008562347,
				y: -.2806049993457588,
				z: -.029200200044923463
			}
		}, {
			id: 1336,
			name: "Distinguished Gentlemen Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pipe",
				tags: ["Dec23", "Scavenger", "Brown", "Hair"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07267364803907439,
				y: -.07707951378019828,
				z: -.030264409392351255
			}
		}, {
			id: 1337,
			name: "Wizskull Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wizskull",
				tags: ["Scavenger", "Blue", "White", "Bone", "BWD"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07311251264431373,
				y: -.3864593884402616,
				z: -.026130767254658238
			}
		}, {
			id: 1338,
			name: "Tucked Pencil Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pencilhair",
				tags: ["Pencil2", "Sep23", "Yellow", "Hair"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0013188852656638161,
				y: -.17071437423368385,
				z: -.00400523791892099
			}
		}, {
			id: 1339,
			name: "Slide Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_slide",
				tags: ["Pencil2", "Sep23", "Blue", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.061648028991867276,
				y: -.29935279262378456,
				z: -.05595923369651101
			}
		}, {
			id: 1340,
			name: "Scavenger Hunt Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scavenger",
				tags: ["Pencil2", "Sep23", "Red", "Black", "bun_tactic"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .021280807735962526,
				y: -.08324928006068566,
				z: -.03461372436507171
			}
		}, {
			id: 1341,
			name: "Rainbow Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_RainbowWings",
				tags: ["Pencil2", "Feb24", "Sep24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_rainbow"],
			align: {
				x: -.028255568232114003,
				y: -.20604891688816965,
				z: -.012931374435978412
			}
		}, {
			id: 1342,
			name: "Paper Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_paper",
				tags: ["Newsletter", "Pencil2", "Blue", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07504639711106442,
				y: -.32322996356140976,
				z: -.03434997576052584
			}
		}, {
			id: 1343,
			name: "Albino Book Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_snake",
				tags: ["Sep22", "Drops3", "ABHS"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10654993328936069,
				y: -.3049933511591818,
				z: .010810588651829045
			}
		}, {
			id: 1344,
			name: "Heart Backpack",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_heartpack",
				tags: ["Sep22", "Drops3", "Red", "Pink"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .1192583355157325,
				y: -.1421948706555937,
				z: .05552651603134384
			}
		}, {
			id: 1345,
			name: "Deal with it Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_deal",
				tags: ["Sep22", "Drops3", "Black", "Meme"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.11043058566823083,
				y: -.16601334249151134,
				z: -.050539409068671715
			}
		}, {
			id: 1346,
			name: "Kilzomatic Hat",
			price: 6e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kilzomatic",
				tags: ["Sep22", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.12905256312871272,
				y: -.24911179539016315,
				z: -.0594282252578634
			}
		}, {
			id: 1347,
			name: "Sharkbucks Hat",
			price: 6900,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sharkbucks",
				tags: ["Sep22", "Pink", "Blue"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .21499460632334902,
				y: -.03987941087591835,
				z: .0983899090714259
			}
		}, {
			id: 1348,
			name: "The cap cap",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cap",
				tags: ["Newsletter", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.033141315905745206,
				y: -.25396539010293706,
				z: -.03265648318202702
			}
		}, {
			id: 1349,
			name: "Teggtris Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Tetris",
				tags: ["Sep22", "Premium", "Rainbow", "AprM24", "bun_gamer"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_teggtris"],
			align: {
				x: .053994584418046276,
				y: -.24203561520647465,
				z: .02471099723170675
			}
		}, {
			id: 1350,
			name: "Scary Balloon Hat",
			price: 1990,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_balloon",
				tags: ["Halloween3", "OctM23", "Blue", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09396296415455252,
				y: -.40272741126518463,
				z: -.0441197548395883
			}
		}, {
			id: 1351,
			name: "Witch Cobwebs Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cobweb",
				tags: ["Halloween3", "Newsletter", "OctM23", "Purple", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05431075864222201,
				y: -.3132789494852095,
				z: -.028827580904545458
			}
		}, {
			id: 1352,
			name: "Cauldron Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cauldron",
				tags: ["Halloween3", "OctM23", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06636454224849953,
				y: -.3565532588626168,
				z: -.07375228691929708
			}
		}, {
			id: 1353,
			name: "Mummy Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mummy",
				tags: ["Halloween3", "OctM23", "White", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.030624381654509758,
				y: -.13131398433488894,
				z: -.013650365127290592
			}
		}, {
			id: 1354,
			name: "Black Cat Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kitten",
				tags: ["Halloween3", "OctM23", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08157292019093898,
				y: -.3068674371149698,
				z: -.03979017085383357
			}
		}, {
			id: 1355,
			name: "Dracula Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dracula",
				tags: ["Halloween3", "OctM23", "White", "Grey", "Gray", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0319311755874756,
				y: -.22035354384456102,
				z: .014534916593597402
			}
		}, {
			id: 1356,
			name: "Blood Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_BloodWings",
				tags: ["Jun23", "Red", "Oct24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_bloodwing"],
			align: {
				x: -.0031766899539928672,
				y: -.257898661391988,
				z: -.001453836099716374
			}
		}, {
			id: 1357,
			name: "It's Corn Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_corn",
				tags: ["NovM23", "Thanksgiving2", "Meme", "Yellow", "Food", "Nov23"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.08300421788058454,
				y: -.3452676390577907,
				z: -.04519249290448918
			}
		}, {
			id: 1358,
			name: "NPS Clan Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_NPS",
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0698797704830616,
				y: -.30096415980790403,
				z: -.03198100537574555
			}
		}, {
			id: 1359,
			name: "Drone Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_drone",
				tags: ["Badegg", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.070109722971063,
				y: -.312839052884192,
				z: -.02738976843544816
			}
		}, {
			id: 1360,
			name: "Tactical Vest",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tacticalvest",
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.005726648924688327,
				y: -.0279753566254346,
				z: -.0026208441828656226
			}
		}, {
			id: 1361,
			name: "Medbox Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_medbox",
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08406234297441406,
				y: -.36207676320852444,
				z: -.0384744708681079
			}
		}, {
			id: 1362,
			name: "Crash Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_crash",
				tags: ["Badegg", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.015373292358376367,
				y: -.10284669633262417,
				z: -.025062619631484602
			}
		}, {
			id: 1363,
			name: "Fall Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Fall",
				tags: ["Badegg", "SepM23", "Orange", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_fall"],
			align: {
				x: -.018163515810662334,
				y: -.19512975431341528,
				z: -.008312670321063961
			}
		}, {
			id: 1364,
			name: "Ribbon Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ribbon",
				tags: ["Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0526775922207674,
				y: -.10401408076862528,
				z: -.024770748952875912
			}
		}, {
			id: 1365,
			name: "Santa Hat & Beard",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_santabeard",
				tags: ["Christmas2", "Newsletter", "Red", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06458211428133787,
				y: -.09819808490009518,
				z: .018212343046531076
			}
		}, {
			id: 1366,
			name: "Sailor Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sailor",
				tags: ["Mar24", "Newsletter", "White", "Seaman"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06435460038219576,
				y: -.2767952786517658,
				z: -.04267529046957927
			}
		}, {
			id: 1367,
			name: "Party Hat 2023",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064355390021284,
				y: -.39039936988703516,
				z: -.041483707867384534
			}
		}, {
			id: 1368,
			name: "2023 Headband",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09492951642647074,
				y: -.3559587886582341,
				z: -.04344521104408777
			}
		}, {
			id: 1369,
			name: "Holly Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Holly",
				tags: ["Dec23", "Red", "Green"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_holy_wings"],
			align: {
				x: -.005623716634233666,
				y: -.18569631620346605,
				z: -.002573736390560827
			}
		}, {
			id: 1370,
			name: "Piano Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_piano",
				tags: ["Rockstar", "JanM23", "Black", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08104278879501514,
				y: -.366555756379946,
				z: -.03708692812794501
			}
		}, {
			id: 1371,
			name: "Gramophone Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gramaphone",
				tags: ["Rockstar", "JanM23", "Gold", "Yellow", "Brown", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.16684042187958514,
				y: -.448131830052956,
				z: -.06255529683169103
			}
		}, {
			id: 1372,
			name: "Sound Wave Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Music",
				tags: ["Rockstar", "Premium", "JanM23", "Blue", "Purple", "Blurple", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_soundwave"],
			align: {
				x: .1473629434689976,
				y: -.10723354724906936,
				z: .06744176564235072
			}
		}, {
			id: 1373,
			name: "Fancy Band Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fancyband",
				tags: ["Rockstar", "JanM23", "Blue", "Green", "Gold", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.00973114550144527,
				y: -.21567867185108125,
				z: -.05196604239560981
			}
		}, {
			id: 1374,
			name: "Winter Scarf",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarf",
				tags: ["Groundhog", "Feb23", "Red", "Feb24", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.00784791552887576,
				y: -.02390157873911347,
				z: .0015132619478031017
			}
		}, {
			id: 1375,
			name: "Bull Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bull",
				tags: ["farm", "FebM23", "Bone", "Brown", "Gray", "Grey", "May24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11597261106923407,
				y: -.21024345924677446,
				z: -.05307577528187574
			}
		}, {
			id: 1376,
			name: "Farmer Shirt",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_farmer",
				tags: ["farm", "FebM23", "Red", "May24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.002040217164151592,
				y: .004750899815876952,
				z: -.0012440683218514215
			}
		}, {
			id: 1377,
			name: "Cowbell Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cowbell",
				tags: ["farm", "FebM23", "Silver", "May24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1137706593369594,
				y: -.34387384785790454,
				z: -.06759212950473148
			}
		}, {
			id: 1378,
			name: "Barrel Eye",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_barrel",
				tags: ["Drops4", "Mar23", "AugM23", "Brown", "Silver", "Gray", "Grey", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04510483699042789,
				y: -.16127109706054976,
				z: -.021459554866939207
			}
		}, {
			id: 1379,
			name: "Kiwi Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kiwi",
				tags: ["Drops4", "Mar23", "AugM23", "Yellow", "Brown", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11486035543267459,
				y: -.10621039239967178,
				z: -.05256110579263329
			}
		}, {
			id: 1380,
			name: "Eggscellent Hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggscellent",
				tags: ["Drops4", "Mar23", "AugM23", "Blue", "White", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10978212137635612,
				y: -.2845944901731632,
				z: -.05023481757921583
			}
		}, {
			id: 1381,
			name: "KJs Dad",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_oldman",
				tags: ["Drops4", "Mar23", "Old", "Grey", "Gray", "Meme", "Hair"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08705671410668012,
				y: -.14984666212434217,
				z: -.03983416645942446
			}
		}, {
			id: 1382,
			name: "Novosuper Helmet",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_novo",
				tags: ["Drops4", "Mar23", "Black", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06499036673467007,
				y: -.2604408479505427,
				z: -.02975142823595156
			}
		}, {
			id: 1383,
			name: "Bracket Shell Sombrero",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_banana",
				tags: ["Drops4", "Mar23", "Yellow", "Blue", "Bananas"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.014458675665466547,
				y: -.2596999000231326,
				z: -.007485859219670016
			}
		}, {
			id: 1384,
			name: "The Mask of Paradise",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_paradise",
				tags: ["Drops4", "Mar23", "Black"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06563638857843951,
				y: -.23343711723846364,
				z: -.030038989575604757
			}
		}, {
			id: 1385,
			name: "xQc Hair",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_xhair",
				tags: ["Drops4", "Mar23", "White", "Black", "Meme"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04473346186974193,
				y: -.17901427823277163,
				z: -.011890543194713117
			}
		}, {
			id: 1386,
			name: "Marshmallow Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_marshmallow",
				tags: ["Drops4", "Mar23", "White", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.02750959876124981,
				y: -.22266327721726858,
				z: -.018605044079386478
			}
		}, {
			id: 1387,
			name: "Big Brain Hat",
			price: 100,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_brain",
				tags: ["Drops4", "Mar23", "AugM23", "OctM23", "Pink", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07430287969300897,
				y: -.2543552689406354,
				z: .008162311590720062
			}
		}, {
			id: 1388,
			name: "Fusion Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fusion",
				tags: ["Newsletter", "Mar23", "White", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.1272141776982595,
				y: -.1666806724852818,
				z: -.058220546897934496
			}
		}, {
			id: 1389,
			name: "Harp Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Harp",
				tags: ["Premium", "Mar23", "Gold", "bun_cupid"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .1072334707841979,
				y: -.146697731985604,
				z: .05092813371967474
			}
		}, {
			id: 1390,
			name: "Longhorn Bros",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_longhorns",
				tags: ["BBros", "MarM23", "Bone", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06454526283356454,
				y: -.2600443036405822,
				z: -.029539627617489794
			}
		}, {
			id: 1391,
			name: "Purdue Bros",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_purdue",
				tags: ["BBros", "MarM23", "Yellow", "White", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08672038099648693,
				y: -.25892611471854643,
				z: -.039685665312970575
			}
		}, {
			id: 1392,
			name: "Scoreboard Bros",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scoreboard",
				tags: ["BBros", "MarM23", "Blue", "Red", "SepM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11214738641040467,
				y: -.3311205910061972,
				z: -.08632608055886049
			}
		}, {
			id: 1393,
			name: "Drenched Bros",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gamerjuice",
				tags: ["BBros", "MarM23", "Blue", "Grey", "Gray", "Orange", "Electrolytes", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.09519071283078828,
				y: -.3547416629903286,
				z: -.00511330334446225
			}
		}, {
			id: 1394,
			name: "Hooped Hat",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Hoop",
				tags: ["BBros", "MarM23", "White", "Red", "AprM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_hooped"],
			align: {
				x: -.01236207382970056,
				y: -.18682160652455493,
				z: -.005657596523953062
			}
		}, {
			id: 1395,
			name: "Brown Wizard Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_brownwizard",
				tags: ["Heroes", "Apr23", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0804820787820959,
				y: -.34663407402899415,
				z: -.03683323194092522
			}
		}, {
			id: 1396,
			name: "Elf Ears Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_elfear",
				tags: ["Heroes", "Apr23", "Grey", "Gray", "Hair"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .008861862981141222,
				y: -.14702279082100755,
				z: .005539460612354219
			}
		}, {
			id: 1397,
			name: "Dwarf Beard",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dwarf",
				tags: ["Heroes", "Apr23", "Orange"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.16295681170247578,
				y: .09907638184290868,
				z: -.07457841737562876
			}
		}, {
			id: 1398,
			name: "Gelatinous Cube Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cube",
				tags: ["Monsters", "Apr23", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11104016614231416,
				y: -.3456780036754328,
				z: -.03357725521046473
			}
		}, {
			id: 1399,
			name: "Purple Worm Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wurm",
				tags: ["Monsters", "Apr23", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.011546657671685487,
				y: -.19726818778411098,
				z: -.03183251542878959
			}
		}, {
			id: 1400,
			name: "Question Block Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_MysteryWings",
				tags: ["AprM23", "Aug23", "JanM24", "White", "Yellow", "?"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_qwings"],
			align: {
				x: .11004874508599694,
				y: -.20316619077538176,
				z: .050364640570313604
			}
		}, {
			id: 1401,
			name: "Green Dino Head",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_greendino",
				tags: ["Dino2", "May23", "Green", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10805242748329436,
				y: -.27514999829643605,
				z: -.04945692647317679
			}
		}, {
			id: 1402,
			name: "Blue Dino Tail",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinotailblue",
				tags: ["Dino2", "May23", "Blue", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .09757484018737961,
				y: -.13401897970572288,
				z: .16449231309178208
			}
		}, {
			id: 1403,
			name: "Caveman Hair",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_caveman",
				tags: ["Dino2", "May23", "Brown", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.010869634182571808,
				y: -.07848510092529004,
				z: -.010236613975144027
			}
		}, {
			id: 1404,
			name: "Leopard Sash",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_skinsash",
				tags: ["Dino2", "May23", "Orange", "Black", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .018109172961424003,
				y: .014556123753856731,
				z: -.03063797581379002
			}
		}, {
			id: 1405,
			name: "Tiger Sash",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tigersash",
				tags: ["Dino2", "May23", "Newsletter", "Orange", "Black", "AugM24"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .01876618405057595,
				y: .013850888481395263,
				z: -.03046859499892196
			}
		}, {
			id: 1406,
			name: "Egg Chest Hat",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_goldchest",
				tags: ["Eggflation", "MayM23", "Gold", "Brown"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.05230654862607875,
				y: -.380141103214434,
				z: -.0239331287279429
			}
		}, {
			id: 1407,
			name: "Golden Nugget Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_goldnugget",
				tags: ["Eggflation", "MayM23", "Gold"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.04822470318959571,
				y: -.213927101437404,
				z: -.02207040007641481
			}
		}, {
			id: 1408,
			name: "Photobooth Top Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_boothtophat",
				tags: ["Photo", "Jun23", "Black", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.21431328988746134,
				y: -.16351137409181637,
				z: -.09961284301516274
			}
		}, {
			id: 1409,
			name: "Photobooth Bow",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_boothbow",
				tags: ["Photo", "Jun23", "Black", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.2098841731917156,
				y: -.15178669997345284,
				z: -.12104457557040586
			}
		}, {
			id: 1410,
			name: "Photobooth Crown",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_boothcrown",
				tags: ["Photo", "Jun23", "Gold"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.19827018482043246,
				y: -.21454857065154342,
				z: -.08740226191376034
			}
		}, {
			id: 1411,
			name: "Photobooth Cake",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_boothcake",
				tags: ["Newsletter", "Photo", "Jun23", "White"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.17442659431714547,
				y: -.2307127983402863,
				z: -.0585189294705932
			}
		}, {
			id: 1412,
			name: "Red Snorkel",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_snorkelred",
				tags: ["Summer2", "JunM23", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08452722773723353,
				y: -.08806286153092957,
				z: -.024090441006014318
			}
		}, {
			id: 1413,
			name: "Blue Snorkel",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_snorkelblue",
				tags: ["Summer2", "JunM23", "Red", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08452722773723353,
				y: -.08806286153092957,
				z: -.024090441006014318
			}
		}, {
			id: 1414,
			name: "Beach Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_beach",
				tags: ["Summer2", "JunM23", "Yellow", "Green", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07565028269552926,
				y: -.25895549324911094,
				z: .006404318418288427
			}
		}, {
			id: 1415,
			name: "Sandcastle Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sandcastle",
				tags: ["Summer2", "JunM23", "Gold", "Yellow", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12876061452866017,
				y: -.4097997603581035,
				z: -.030514806124142535
			}
		}, {
			id: 1416,
			name: "Crab Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_crab",
				tags: ["Summer2", "JunM23", "Red", "Meme"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10068510003333841,
				y: -.24499355337767836,
				z: -.02337243991233373
			}
		}, {
			id: 1417,
			name: "Octopus Surfboard",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Octopus",
				tags: ["Summer2", "JunM23", "Brown", "JunM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_surf"],
			align: {
				x: .22393085055634598,
				y: -.11030590875211177,
				z: .11750241492051972
			}
		}, {
			id: 1418,
			name: "Equinox Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_equinox",
				tags: ["Equinox", "July23", "Gold", "Yellow", "Blue", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.037617305074609586,
				y: -.2172802487320009,
				z: -.019265288039641393
			}
		}, {
			id: 1419,
			name: "Equinox Sun Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_equinoxSun",
				tags: ["Equinox", "July23", "Gold", "Yellow", "Blue", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06938082193720652,
				y: -.2592012664240997,
				z: -.03174618472965968
			}
		}, {
			id: 1420,
			name: "Equinox Moon Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_equinoxMoon",
				tags: ["Equinox", "July23", "Blue", "White", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07093676588009012,
				y: -.23125672830481214,
				z: -.032460175208326225
			}
		}, {
			id: 1421,
			name: "Bonsai Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bonsai",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Green", "Brown", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09619353264858921,
				y: -.4061319323215409,
				z: -.03900086303481454
			}
		}, {
			id: 1422,
			name: "Skull Trio Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_skulls",
				tags: ["Newsletter", "July23", "Bone", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07507010492730903,
				y: -.3635214269340585,
				z: -.03551129767586808
			}
		}, {
			id: 1423,
			name: "Scales of Justice Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Scales",
				tags: ["July23", "Gold", "JanM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_scales"],
			align: {
				x: .19150246040586572,
				y: -.19256754847920388,
				z: .08764254943023048
			}
		}, {
			id: 1424,
			name: "Biker Helmet",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_extremehelm",
				tags: ["Sports2", "JulyM23", "Black", "Red", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.050801832540607994,
				y: -.20212157456782848,
				z: -.023253939707554898
			}
		}, {
			id: 1425,
			name: "Climbing Gear Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_extremeclimb",
				tags: ["Sports2", "JulyM23", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .021732529407735512,
				y: -.029624623104741232,
				z: -.005432548962853279
			}
		}, {
			id: 1426,
			name: "Ski Bum Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_extremeskis",
				tags: ["Sports2", "JulyM23", "Rainbow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .058974643037587815,
				y: -.25217970728432826,
				z: .03644558094795056
			}
		}, {
			id: 1427,
			name: "Stickers Helmet",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_stickers",
				tags: ["Sports2", "JulyM23", "Black", "Egg"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.029612593507459373,
				y: -.1538837240702784,
				z: -.020693402475527256
			}
		}, {
			id: 1428,
			name: "Hang Glider Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Glider",
				tags: ["Sports2", "JulyM23", "Rainbow"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .15806814144004577,
				y: -.19535527419964233,
				z: .07234108048743282
			}
		}, {
			id: 1429,
			name: "Red Kart",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartRed",
				tags: ["Kart", "Aug23", "Red", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .021915916439513516,
				y: .13129564198078736,
				z: .010018611906794539
			}
		}, {
			id: 1430,
			name: "Green Kart",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartGreen",
				tags: ["Kart", "Aug23", "Green", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .0208010053824621,
				y: .12650892279592885,
				z: .009517672561720425
			}
		}, {
			id: 1431,
			name: "Pink Kart",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartPink",
				tags: ["Kart", "Aug23", "Pink", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .021915916439513516,
				y: .13129564198078736,
				z: .010018611906794539
			}
		}, {
			id: 1432,
			name: "Yellow Kart",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartYellow",
				tags: ["Kart", "Aug23", "Yellow", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .02370142462174929,
				y: .1390009434188464,
				z: .01084507135885926
			}
		}, {
			id: 1433,
			name: "Piranha Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_piranha",
				tags: ["Kart", "Aug23", "Red", "White", "Green", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: .0006045990621803554,
				y: -.4501550155901276,
				z: .0002854995959842843
			}
		}, {
			id: 1434,
			name: "Big Biter Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chomp",
				tags: ["Kart", "Aug23", "Blue", "Chomp", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.03449437859488835,
				y: -.4255526254165696,
				z: -.01578687531337597
			}
		}, {
			id: 1435,
			name: "Gang Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gang",
				tags: ["SL", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0742216025570741,
				y: -.31996611618895443,
				z: -.03396807765621901
			}
		}, {
			id: 1436,
			name: "Fluffly Meteor Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fluffy",
				tags: ["Drops5", "AugM23", "Blue"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.10687674474070041,
				y: -.3963768688642315,
				z: -.009694370022676202
			}
		}, {
			id: 1437,
			name: "King Hayden Crown",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_hayden",
				tags: ["Drops5", "AugM23", "Gold"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09881768637038846,
				y: -.27704802426136776,
				z: .02766423062606671
			}
		}, {
			id: 1438,
			name: "Anarchy Aiden",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_academymale",
				tags: ["Sep23", "Pencil3", "Egg", "Blue", "White", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.003854125100355432,
				y: .02120377863344247,
				z: -.0017562001329524124
			}
		}, {
			id: 1439,
			name: "Anarchy Ashley",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_academyfemale",
				tags: ["Sep23", "Pencil3", "Egg", "Blue", "White", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .00533333956619142,
				y: .02741258526573187,
				z: .0024410398311239256
			}
		}, {
			id: 1440,
			name: "Dunce Cap",
			price: 4e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dunce",
				tags: ["Sep23", "Pencil3", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08967990138936432,
				y: -.3866815477837924,
				z: -.04443854680037673
			}
		}, {
			id: 1441,
			name: "The Toolbelt",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toolbelt",
				tags: ["Sep23", "Pencil3", "Newsletter", "Brown"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.013502744844512193,
				y: .020367655645501692,
				z: .04201065787545022
			}
		}, {
			id: 1442,
			name: "Wrestle Shoes Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shoetie",
				tags: ["SepM23", "WBros", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10093822397363705,
				y: -.1473264329539556,
				z: -.020321618573445617
			}
		}, {
			id: 1443,
			name: "Wrestling Belt",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wrestlebelt",
				tags: ["SepM23", "WBros", "Gold", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0110659387040144,
				y: .10248215404849947,
				z: .005069916726395229
			}
		}, {
			id: 1444,
			name: "Wrestling Ring Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wrestlering",
				tags: ["SepM23", "WBros", "White", "Black", "Red", "White", "Blue"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07282671191567625,
				y: -.3136625998694875,
				z: -.03332971179400285
			}
		}, {
			id: 1445,
			name: "The Grand Entrance Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Firework",
				tags: ["SepM23", "WBros", "Red", "Yellow", "Jun25", "premFeatTwo"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_wbs"],
			align: {
				x: -.0572610207721147,
				y: -.2426137142559055,
				z: -.026205906376740168
			}
		}, {
			id: 1446,
			name: "Angler Fish Hat",
			price: 3500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_angler",
				tags: ["Oct23", "Halloween4", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11856385818199167,
				y: -.2454609004466619,
				z: -.05426164633452166
			}
		}, {
			id: 1447,
			name: "Hungry Shark Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shark",
				tags: ["Oct23", "Halloween4", "Grey", "Gray", "Silver"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0482715334959154,
				y: -.36548575131680006,
				z: -.022096797700171797
			}
		}, {
			id: 1448,
			name: "Baby Ghost Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_babyghost",
				tags: ["Oct23", "Halloween4", "White", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07443624059748011,
				y: -.31585657908966125,
				z: -.03406634115519175
			}
		}, {
			id: 1449,
			name: "Captain Inksalot Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_squidpatch",
				tags: ["Oct23", "Halloween4", "Newsletter", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04399797329171973,
				y: -.32983261562076716,
				z: -.0164697814700632
			}
		}, {
			id: 1450,
			name: "Demon Pixel Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelDemon",
				tags: ["Oct23", "Halloween4", "Black"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .05466192320814933,
				y: -.14156134563379286,
				z: .02501634429342456
			}
		}, {
			id: 1451,
			name: "Purple Witch's Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_purplewitch",
				tags: ["OctM23", "Halloween4", "Purple"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07349753031540551,
				y: -.3165613774455478,
				z: -.033642337838353575
			}
		}, {
			id: 1452,
			name: "Wednesday Morning Hair",
			price: 2020,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_addams",
				tags: ["OctM23", "Halloween4", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.02403582432085649,
				y: -.07057495271745284,
				z: -.011000176764286496
			}
		}, {
			id: 1453,
			name: "Ectoplasmic Goo",
			price: 1980,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_slime",
				tags: ["OctM23", "Halloween4", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.012645094542945934,
				y: -.13571641390181843,
				z: -.011392387757339667
			}
		}, {
			id: 1454,
			name: "Stapled Bear Friend",
			price: 2010,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bear",
				tags: ["OctM23", "Halloween4", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07585449914001297,
				y: -.31015195172031684,
				z: -.03912391584435121
			}
		}, {
			id: 1455,
			name: "Ancient Egg Hat",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ruins",
				tags: ["Nov23", "Mayan", "Green", "Gray", "Grey", "Stone", "Plant", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09525324482895936,
				y: -.25954823271889493,
				z: -.016011557004969507
			}
		}, {
			id: 1456,
			name: "The Ruins Explorer",
			price: 250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ruinsexplorer",
				tags: ["Nov23", "Mayan", "Brown", "Stone", "Plant", "Gray", "Grey", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04924187010309966,
				y: -.27254017384302986,
				z: -.022536471365236677
			}
		}, {
			id: 1457,
			name: "Indianapolis Jones",
			price: 1750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_explorer",
				tags: ["Nov23", "Mayan", "Brown", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.02506490018106522,
				y: -.14141917816246918,
				z: -.010903410658237134
			}
		}, {
			id: 1458,
			name: "Mayan Warrior Mask",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan",
				tags: ["Nov23", "Mayan", "Brown", "Green", "Yellow", "Nov24", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10286629613972376,
				y: -.2713354927050634,
				z: -.047070442523333575
			}
		}, {
			id: 1459,
			name: "Meso-Mage Mask",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan2",
				tags: ["Nov23", "Mayan", "Brown", "Yellow", "May25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10069550360080193,
				y: -.26879019980348207,
				z: -.044534697383819294
			}
		}, {
			id: 1460,
			name: "The Fallen Explorer",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_overgrown",
				tags: ["Nov23", "Newsletter", "Mayan", "Red", "Green", "Mushroom", "May25"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06364583554386138,
				y: -.24908473548113697,
				z: -.029127965144288642
			}
		}, {
			id: 1461,
			name: "Ruins Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Ruins",
				tags: ["Nov23", "Mayan", "Green", "Gray", "Grey", "May25", "premFeatOne"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_mayan"],
			align: {
				x: .13483230162508453,
				y: -.28814409860433626,
				z: .05063336225019538
			}
		}, {
			id: 1462,
			name: "Fall Pilgrim Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fallhat",
				tags: ["NovM23", "Thanksgiving3", "Green", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07658982353458921,
				y: -.3118313473182215,
				z: -.014616762701649633
			}
		}, {
			id: 1463,
			name: "Kindergarden Turkey",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sillyturkey",
				tags: ["NovM23", "Thanksgiving3", "Green", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08171040609951863,
				y: -.2591170302455612,
				z: -.03739115726709469
			}
		}, {
			id: 1464,
			name: "All the Fixin's Hat",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dinner",
				tags: ["NovM23", "Thanksgiving3", "Green", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12748192914777334,
				y: -.26717934205433513,
				z: -.058343003403527716
			}
		}, {
			id: 1465,
			name: "Bread Cat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_toastcat",
				tags: ["Xsolla", "Brown", "Meow", "Kitty", "Kitten"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.106919336396047,
				y: -.2016934352689943,
				z: -.048926035350258745
			}
		}, {
			id: 1466,
			name: "Wreathed Egg",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wreath",
				tags: ["Christmas3", "Dec23", "Green", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07670957484040786,
				y: -.26026926108724013,
				z: -.035110142006809786
			}
		}, {
			id: 1467,
			name: "Frosty",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_snowman",
				tags: ["Christmas3", "Dec23", "White", "Yellow", "Carrot", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12526994807970437,
				y: -.31664436738973323,
				z: -.08257601239245954
			}
		}, {
			id: 1468,
			name: "Mistletoe Hat",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mistletoe",
				tags: ["Christmas3", "Dec23", "Green", "Red", "Kiss", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04957526960208325,
				y: -.2876501081983409,
				z: .013757112569296626
			}
		}, {
			id: 1469,
			name: "Eggsmas Tree",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_christmastree",
				tags: ["Christmas3", "Dec23", "Green", "Red", "Star", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10231905708142319,
				y: -.4406982411880487,
				z: -.046825533367968686
			}
		}, {
			id: 1470,
			name: "Snow Owl Wings",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_SnowOwl",
				tags: ["Christmas3", "Dec23", "Green", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_owl"],
			align: {
				x: .061815243583282165,
				y: -.25447310305349125,
				z: .02258718103042709
			}
		}, {
			id: 1471,
			name: "Egg'Noggin",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggnog",
				tags: ["Christmas3", "Dec23", "Yellow", "Red", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09318399398619048,
				y: -.4116537111213029,
				z: .07701051516243501
			}
		}, {
			id: 1472,
			name: "Party Hat 2024",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party2024",
				tags: ["NewYears", "2024", "DecM23", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064355390021284,
				y: -.39039936988703516,
				z: -.041483707867384534
			}
		}, {
			id: 1473,
			name: "2024 Headband",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2024",
				tags: ["NewYears", "2024", "DecM23", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09492951642647074,
				y: -.3559587886582341,
				z: -.04344521104408777
			}
		}, {
			id: 1474,
			name: "Discord Dev Day Crown",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_discorders",
				tags: ["promo", "Blurple"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06795442489383152,
				y: -.3035879729134885,
				z: -.031096382242767784
			}
		}, {
			id: 1475,
			name: "Disco Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_NewYearsDisco",
				tags: ["NewYears", "2024", "DecM23", "Blurple"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .030166434329798042,
				y: -.27482812378136545,
				z: .013805896913517343
			}
		}, {
			id: 1476,
			name: "The CyberCluck",
			price: 125e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cybercar",
				tags: ["Cybertruck", "Truck", "Musk", "Silver", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.013474577056496795,
				y: .16930203481819195,
				z: -.006157352086425649
			}
		}, {
			id: 1477,
			name: "Lightning Helmet",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_lightninghelm",
				tags: ["JanM24", "Racer", "Orange"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07491807008118823,
				y: -.20432339514493747,
				z: -.0349436672778321
			}
		}, {
			id: 1478,
			name: "Skull Helmet",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_skullhelm",
				tags: ["JanM24", "Racer", "Gray", "Grey", "Silver"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.07931754284925585,
				y: -.21385281959261682,
				z: -.03630409160686873
			}
		}, {
			id: 1479,
			name: "Targeted Bandana",
			price: 7500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_targetbandana",
				tags: ["JanM24", "Black", "Racer"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.024794948123451288,
				y: -.21502251051068977,
				z: -.01141950405570527
			}
		}, {
			id: 1480,
			name: "The Racing Spoiler Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_SpoilerWings",
				tags: ["JanM24", "Egg", "Racer", "Orange"]
			},
			is_available: !0,
			unlock: "premium",
			align: {
				x: -.00825870243090332,
				y: -.07832172595582376,
				z: -.0037842788943276418
			}
		}, {
			id: 1481,
			name: "Cute Fox Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fox",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.16077933302191028,
				y: -.19580449761747687,
				z: -.07358187769334479
			}
		}, {
			id: 1482,
			name: "Cute Mouse Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mouse",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08480075319980385,
				y: -.30491564699774754,
				z: -.038809705964513
			}
		}, {
			id: 1483,
			name: "Cute Deer Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fawn",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08048338470361305,
				y: -.3416960134560574,
				z: -.03683382960738385
			}
		}, {
			id: 1484,
			name: "Cute Squirrel Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_squirrel",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .11650162262118846,
				y: -.2758969224198887,
				z: .053319864471162576
			}
		}, {
			id: 1485,
			name: "Cute Owl Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_owl",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06367038537844705,
				y: -.24437293359297874,
				z: -.02914298608834659
			}
		}, {
			id: 1486,
			name: "Shell Wiki Staff Headphones",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_wikiStaff",
				tags: ["Feb24", "Critters", "Brown", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.04096624685909722,
				y: -.20852336490380108,
				z: -.021048325634382775
			}
		}, {
			id: 1487,
			name: "Argentina Scarf",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarfArgentina",
				tags: ["FebM24", "SBros", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05244075537132131,
				y: -.1593111862268879,
				z: -.03961551049545556
			}
		}, {
			id: 1488,
			name: "England Scarf",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarfEngland",
				tags: ["FebM24", "SBros", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05224789100823646,
				y: -.15928168615741,
				z: -.040297181127995435
			}
		}, {
			id: 1489,
			name: "America Scarf",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarfAmerica",
				tags: ["FebM24", "SBros", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05224791201296153,
				y: -.1592816425351442,
				z: -.04029725629118422
			}
		}, {
			id: 1490,
			name: "Brazil Scarf",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarfBrazil",
				tags: ["FebM24", "SBros", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05244074224295803,
				y: -.15931118991349424,
				z: -.03961550448716081
			}
		}, {
			id: 1491,
			name: "Portugal Scarf",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_scarfPortugal",
				tags: ["FebM24", "SBros", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.05244074224295803,
				y: -.15931118991349424,
				z: -.03961550448716081
			}
		}, {
			id: 1492,
			name: "Patchwork Cap",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_patchwork",
				tags: ["Mar24", "StPatricksDay", "Brown", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07898811547084694,
				y: -.25701601472386404,
				z: -.03585440128238787
			}
		}, {
			id: 1493,
			name: "Leprechaun Mini Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_leprechaunsmall",
				tags: ["Mar24", "StPatricksDays", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10272882257863225,
				y: -.32481178931668575,
				z: .025166638590053192
			}
		}, {
			id: 1494,
			name: "Bad Bunny Mask",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_ScaryBunny",
				tags: ["Mar24", "Darko", "Grey", "Gray", "Teeth", "bun_badbunny"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.009802806022177979,
				y: -.18623701441787288,
				z: -.0044903104315981435
			}
		}, {
			id: 1495,
			name: "Slayaway Bunnyface",
			price: 1750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_slashbunny",
				tags: ["MarM24", "Skullface", "Camp", "White", "Red", "Teeth", "Easter", "Bunny", "Carrot", "Nov24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09468929728517828,
				y: -.2524876583691392,
				z: -.02302245686535491
			}
		}, {
			id: 1496,
			name: "Chocolate Drip",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chocolate",
				tags: ["MarM24", "Egg", "Brown", "Easter", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.040914625540970695,
				y: -.1707145084561087,
				z: -.0023571459506205733
			}
		}, {
			id: 1497,
			name: "Trucker Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_trucker",
				tags: ["MarM24", "Default", "Brown"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.011117594625622118,
				y: -.15517299675012275,
				z: .00012578030894222492
			}
		}, {
			id: 1498,
			name: "Winner Winner Chicken Dinner",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chicknwinner",
				tags: ["MarM24", "Default", "Brown"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.08098020615453727,
				y: -.34813780272226147,
				z: -.03706120369985133
			}
		}, {
			id: 1499,
			name: "Newsboi Hat",
			price: 0,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_newsboy",
				tags: ["MarM24", "Default", "Brown"]
			},
			is_available: !0,
			unlock: "default",
			align: {
				x: -.08738006395461273,
				y: -.265458179063754,
				z: -.03999385063925037
			}
		}, {
			id: 1500,
			name: "Cyborg Happy Bear",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bearSteambot",
				tags: ["Apr24", "EGGORG"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10475418436508388,
				y: -.26662521760024394,
				z: -.047941544660631885
			}
		}, {
			id: 1501,
			name: "Cyborg Train Hat",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_trainSteambot",
				tags: ["Apr24", "EGGORG"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12178592407166589,
				y: -.2588505491467472,
				z: -.02727616374253189
			}
		}, {
			id: 1502,
			name: "Cyborg Gas Mask",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_gasSteambot",
				tags: ["Apr24", "EGGORG"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11636451395311953,
				y: -.1695215645537993,
				z: -.05478758198568795
			}
		}, {
			id: 1503,
			name: "Cyboregg",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_steambot",
				tags: ["Apr24", "EGGORG", "Borg", "Brown", "bun_borg"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09077302794951159,
				y: -.1406921107433129,
				z: -.06263409753259673
			}
		}, {
			id: 1504,
			name: "30/30 Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_3030",
				tags: ["Apr24", "Nate"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.12075649171164304,
				y: -.2670312405309474,
				z: -.055266825951265475
			}
		}, {
			id: 1505,
			name: "iMoRTaL_Mafia Lion Hat ",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_lion",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05523263519859323,
				y: -.20578154478727628,
				z: -.02608652284875536
			}
		}, {
			id: 1506,
			name: "Red Stag Antlers",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_antlerRed",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08392912196785507,
				y: -.3869049059653415,
				z: -.03841079731237207
			}
		}, {
			id: 1507,
			name: "Blue Stag Antlers",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_antlerBlue",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.08392912196785507,
				y: -.3869049059653415,
				z: -.03841079731237207
			}
		}, {
			id: 1508,
			name: "Duck Bill",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_duck",
				tags: ["May24", "Farm", "Quack"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.25727256982514657,
				y: -.08503653969461433,
				z: -.11774476940243431
			}
		}, {
			id: 1509,
			name: "Piggums",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pig",
				tags: ["May24", "Farm", "Oink"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .0340176834848851,
				y: -.11904433109192025,
				z: .015571891552903672
			}
		}, {
			id: 1510,
			name: "Golden Waffle Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_WaffleWings",
				tags: ["MayM24", "Chicken&Waffles", "Yellow", "Food"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .11523366883526381,
				y: -.19511899730781984,
				z: .052737560135949865
			}
		}, {
			id: 1511,
			name: "Ant Antennae",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_redantenna",
				tags: ["Jun24", "Bugs", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1412809402214923,
				y: -.2904071127570663,
				z: -.06465829072819218
			}
		}, {
			id: 1512,
			name: "Blue Antennae",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_blueantenna",
				tags: ["Jun24", "Bugs", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1412809402214923,
				y: -.2904071127570663,
				z: -.06465829072819218
			}
		}, {
			id: 1513,
			name: "Ladybug",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_ladybug",
				tags: ["Jun24", "Bugs", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0816662276945972,
				y: -.27816936896021205,
				z: -.03737829669169529
			}
		}, {
			id: 1514,
			name: "Snail Shell",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shell",
				tags: ["Jun24", "Bugs", "Red"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09442372996202719,
				y: -.2958729805626792,
				z: .007481968370596004
			}
		}, {
			id: 1515,
			name: "Tarantula Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Tarantula",
				tags: ["Jun24", "Bugs", "Red", "bun_arach"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: .023468912065839564,
				y: -.279627927938108,
				z: .01074072519656108
			}
		}, {
			id: 1516,
			name: "Dragonfly Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_DragonflyWings",
				tags: ["Jun24", "Bugs", "Red"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .11760358438311785,
				y: -.204291946057281,
				z: .05382216991343898
			}
		}, {
			id: 1517,
			name: "The Beekeeper",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_beekeeper",
				tags: ["Jun24", "Bugs", "Statham", "Jason", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.051595910871738315,
				y: -.22910633203368747,
				z: -.026408647788614875
			}
		}, {
			id: 1518,
			name: "White Pawn",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pawnWhite",
				tags: ["July24", "Chess", "Piece", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09967709355043963,
				y: -.4300108501066764,
				z: -.04561455059869335
			}
		}, {
			id: 1519,
			name: "White Bishop",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bishopWhite",
				tags: ["July24", "Chess", "Piece", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08994075415156222,
				y: -.47119862188630207,
				z: -.04115369218057641
			}
		}, {
			id: 1520,
			name: "White Knight",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_knightWhite",
				tags: ["July24", "Chess", "Piece", "White", "Horse"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08731390904576974,
				y: -.4432797369028318,
				z: -.03995624085670224
			}
		}, {
			id: 1521,
			name: "White Rook",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rookWhite",
				tags: ["July24", "Chess", "Piece", "White", "Castle"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08311623226752252,
				y: -.41111796217322916,
				z: -.038035953525808575
			}
		}, {
			id: 1522,
			name: "White Queen",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_queenWhite",
				tags: ["July24", "Chess", "Piece", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09676844906929438,
				y: -.4813948621908833,
				z: -.044282912197643465
			}
		}, {
			id: 1523,
			name: "White King",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kingWhite",
				tags: ["July24", "Chess", "Piece", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10104719864936396,
				y: -.4825457105896669,
				z: -.0462449489911656
			}
		}, {
			id: 1524,
			name: "Black Pawn",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pawnBlack",
				tags: ["July24", "Chess", "Piece", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09967707086878352,
				y: -.43001083935536255,
				z: -.04561455660581626
			}
		}, {
			id: 1525,
			name: "Black Bishop",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bishopBlack",
				tags: ["July24", "Chess", "Piece", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08994075415156222,
				y: -.47119862188630207,
				z: -.04115369218057641
			}
		}, {
			id: 1526,
			name: "Black Knight",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_knightBlack",
				tags: ["July24", "Chess", "Piece", "Black", "Horse"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08731400739706996,
				y: -.4432797255345075,
				z: -.03995627767414145
			}
		}, {
			id: 1527,
			name: "Black Rook",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rookBlack",
				tags: ["July24", "Chess", "Piece", "Black", "Castle"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0831161830361602,
				y: -.411117975998003,
				z: -.03803593099470326
			}
		}, {
			id: 1528,
			name: "Black Queen",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_queenBlack",
				tags: ["July24", "Chess", "Piece", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09676844906929438,
				y: -.4813948621908833,
				z: -.044282912197643465
			}
		}, {
			id: 1529,
			name: "Black King",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kingBlack",
				tags: ["July24", "Chess", "Piece", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10104719864936396,
				y: -.4825457105896669,
				z: -.0462449489911656
			}
		}, {
			id: 1530,
			name: "Sciclops Visor",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_cyclops",
				tags: ["JulyM24", "Eggx-men", "xmen", "marvel", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10551757425891828,
				y: -.09622404746099888,
				z: -.04829089948682046
			}
		}, {
			id: 1531,
			name: "Wolfverine Mask",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_yellowmask",
				tags: ["JulyM24", "Eggx-men", "xmen", "marvel", "Nov24"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06162407556999916,
				y: -.18689179115304871,
				z: -.02820272419661591
			}
		}, {
			id: 1532,
			name: "Deadpond Swords",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_deadswords",
				tags: ["JulyM24", "Eggx-men", "xmen", "marvel"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .11204319930156603,
				y: -.23497365642615092,
				z: .046029418062671246
			}
		}, {
			id: 1534,
			name: "Tempest Hair",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_lightning",
				tags: ["JulyM24", "Eggx-men", "xmen", "marvel"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .007895889724584215,
				y: -.14803468788029917,
				z: .0043091670559296524
			}
		}, {
			id: 1535,
			name: "Collossal Headgear",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_chromeegg",
				tags: ["JulyM24", "Eggx-men", "xmen", "marvel"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.036094262557422985,
				y: -.15544419146008914,
				z: -.01651084784419639
			}
		}, {
			id: 1536,
			name: "Little Green Man",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_alien",
				tags: ["Aug24", "Galeggsy", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.1551552243277312,
				y: -.28629906630445223,
				z: -.07353908510677121
			}
		}, {
			id: 1537,
			name: "The UFO",
			price: 2e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_alienufo",
				tags: ["Aug24", "Galeggsy"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .03848398917924367,
				y: .148136853763829,
				z: .01312069278266803
			}
		}, {
			id: 1538,
			name: "ZORG",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_alienChill",
				tags: ["Aug24", "Galeggsy", "bun_zorg"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05840094009621888,
				y: -.25156516666717677,
				z: -.026727631849014305
			}
		}, {
			id: 1539,
			name: "Rizz Lightyear",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_LightyearWings",
				tags: ["Aug24", "Galeggsy"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .16984050226076874,
				y: -.1521365675214874,
				z: .0777287904392478
			}
		}, {
			id: 1540,
			name: "Pterodactyl Buddy",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pterodactyl",
				tags: ["AugM24", "Dino"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09900159122890684,
				y: -.3764694998272551,
				z: -.04531206341050714
			}
		}, {
			id: 1541,
			name: "Fossil Fedora",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_bonehat",
				tags: ["AugM24", "Dino"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07596886143235793,
				y: -.32452148246261436,
				z: -.03477332843740433
			}
		}, {
			id: 1542,
			name: "ATV - All Teeth Vehicle",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_atvteeth",
				tags: ["AugM24", "Dino"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .024516817859058904,
				y: .10342963067335154,
				z: .011220307084232828
			}
		}, {
			id: 1543,
			name: "T-Rex Skull Mask",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_rexskull",
				tags: ["AugM24", "Dino"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11496248534634868,
				y: -.28550241077441996,
				z: -.052610582983558585
			}
		}, {
			id: 1544,
			name: "Dracolich Wings ",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_BoneWings",
				tags: ["AugM24", "Dino"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: .1090015378592365,
				y: -.17438504153549697,
				z: .04988537825347225
			}
		}, {
			id: 1545,
			name: "Eggy Potter Glasses",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_lightningglasses",
				tags: ["Sep24", "EggyP"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12228432910310749,
				y: -.15101147204329735,
				z: -.055964364408221
			}
		}, {
			id: 1546,
			name: "Mandrake Leaves",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mandrakeplant",
				tags: ["Sep24", "EggP", "bun_plant"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.01732750010110795,
				y: -.42800164534284146,
				z: .019524762330098366
			}
		}, {
			id: 1547,
			name: "The Sorta Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_leatherface",
				tags: ["Sep24", "EggyP", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09513927360790042,
				y: -.4097619414724307,
				z: -.04354120798716887
			}
		}, {
			id: 1548,
			name: "The Guardian",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_guardian",
				tags: ["SepM24", "Football", "Fbros"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.03805563218712571,
				y: -.13664976044984156,
				z: -.022544277484762232
			}
		}, {
			id: 1549,
			name: "Shell Shoulders",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_shoulderpads",
				tags: ["SepM24", "Football", "Fbros"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0393742662174601,
				y: -.1719689816208525,
				z: -.018019930672465434
			}
		}, {
			id: 1550,
			name: "The Raiders Garb",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Raiders",
				tags: ["SepM24", "Football", "Fbros"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.06081399440956914,
				y: -.17548223840044253,
				z: -.027831984430469872
			}
		}, {
			id: 1551,
			name: "Quoth, the Raven",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_raven",
				tags: ["Oct24", "Black", "Newsletter", "Halloween5"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.09488753792390403,
				y: -.42974676410640456,
				z: -.02479746319860554
			}
		}, {
			id: 1552,
			name: "Neon Birdo Mask",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Neon",
				tags: ["Oct24", "Black", "Newsletter", "Halloween5"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.04860903410989448,
				y: -.21843568312173384,
				z: -.0222462920273842
			}
		}, {
			id: 1553,
			name: "Shellraiser",
			price: 1e4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pins",
				tags: ["OctM24", "Halloween5"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07104303718679184,
				y: -.30597407514043984,
				z: -.032509614041548285
			}
		}, {
			id: 1554,
			name: "Frankenstein's Egg",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_frank",
				tags: ["OctM24", "Halloween5"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.03692161325411414,
				y: -.19505344100900457,
				z: -.01689742271140579
			}
		}, {
			id: 1555,
			name: "Skullface's Mom",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_skullfacemom",
				tags: ["Nov24", "SC2", "Mum"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.04055684615546595,
				y: -.2479488495980653,
				z: -.019373281719983523
			}
		}, {
			id: 1556,
			name: "Tentacle",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tentacleshoe",
				tags: ["Nov24", "SC2", "Mum"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08424219372301156,
				y: -.4331324392171507,
				z: -.03587487569002756
			}
		}, {
			id: 1557,
			name: "Werewolf",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_werewolf",
				tags: ["Nov24", "SC2", "Mum"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.2021165432797547,
				y: -.2291966245935364,
				z: -.09134325242098038
			}
		}, {
			id: 1558,
			name: "Pinhead",
			price: 1e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_pinhead",
				tags: ["Nov24", "SC2", "Mum"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09987235365705205,
				y: -.4212577560245392,
				z: -.04740130297262457
			}
		}, {
			id: 1559,
			name: "Robot Police Person",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_RobotCop",
				tags: ["Nov24", "SC2", "Robot Cop"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.10415364027513307,
				y: -.2544572301225956,
				z: -.04766670111979801
			}
		}, {
			id: 1560,
			name: "Fall Umbrella",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_umbrellaleaf",
				tags: ["NovM24", "Thanksgiving4", "Autumn", "Orange", "Leaf"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09502903508809402,
				y: -.2927051280029007,
				z: .07778037415249078
			}
		}, {
			id: 1561,
			name: "Figgy Pudding",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_figgy",
				tags: ["Dec24", "Christmas4", "Brown", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06450817292254918,
				y: -.27783474915880446,
				z: -.02952265313343455
			}
		}, {
			id: 1562,
			name: "Santa Legs",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_santachimney",
				tags: ["Dec24", "Christmas4", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09512430063418353,
				y: -.4090560627386247,
				z: -.04314762559715851
			}
		}, {
			id: 1563,
			name: "Eggsmas Lights",
			price: 50,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_tangledlights",
				tags: ["Dec24", "Christmas4", "Green"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09478732170786897,
				y: -.3294985211809085,
				z: -.039072026783508906
			}
		}, {
			id: 1564,
			name: "Mrs Clause",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mrsclause",
				tags: ["Dec24", "Christmas4", "Pink", "Red", "White"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.0870902407010874,
				y: -.22809935452291707,
				z: .011340604815113259
			}
		}, {
			id: 1565,
			name: "Santa's Sleigh",
			price: 5,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sleigh",
				tags: ["Dec24", "Christmas4", "Gold", "Yellow", "Red"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_sleigh"],
			align: {
				x: -.002264615090964206,
				y: .10781845061085127,
				z: -.00103009266295373
			}
		}, {
			id: 1566,
			name: "2025 Headband",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09491965599983421,
				y: -.3559159888243681,
				z: -.043440698345275475
			}
		}, {
			id: 1567,
			name: "Party Hat 2025",
			price: 200,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_party2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09064361647033081,
				y: -.3903993984543703,
				z: -.041483736503072244
			}
		}, {
			id: 1568,
			name: "Fulcrum Hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_weaponbalancing",
				tags: ["JanM25", "Text", "Blue", "Weapon", "Balancing", "Vol1"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07463817271286866,
				y: -.3199311981528352,
				z: -.03321799658001279
			}
		}, {
			id: 1569,
			name: "The Equalizer",
			price: 3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Equalizer",
				tags: ["JanM25", "Green", "Yellow", "Orange", "Red", "Rainbow", "Sound", "Speaker"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_equal"],
			align: {
				x: -.006203978958753131,
				y: -.30640164779834417,
				z: -.0028392977928960728
			}
		}, {
			id: 1570,
			name: "DogEgg Hat",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dogpolice",
				tags: ["Feb25", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09273167319622111,
				y: -.2413060385365855,
				z: -.042439351504266865
			}
		}, {
			id: 1571,
			name: "Chief Hat",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_dogchief",
				tags: ["Feb25", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.11216442427732165,
				y: -.32501694753736765,
				z: -.0513318154037718
			}
		}, {
			id: 1572,
			name: "Egg Pro Shops hat",
			price: 5e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_eggproshop",
				tags: ["Feb25", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.12075653081620974,
				y: -.2670311680328412,
				z: -.0552668438477662
			}
		}, {
			id: 1573,
			name: "Fisherman Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_fisherman",
				tags: ["Feb25", "green", "Yellow"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.06995068405252614,
				y: -.30127548502043777,
				z: -.0320134595070406
			}
		}, {
			id: 1574,
			name: "Rogue Contractor Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_roguecontractor",
				tags: ["Drops7", "D7W1", "FebM25", "Grey", "Camo"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.029641633446784166,
				y: -.16266604575850696,
				z: -.013520061952077694
			}
		}, {
			id: 1575,
			name: "dropoutbrent Parachute",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_parachute",
				tags: ["Drops7", "D7W2", "FebM25", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.0025717114230223714,
				y: -.29312739006009203,
				z: -.001177618590234658
			}
		}, {
			id: 1576,
			name: "WinterX AngelCat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_winterx",
				tags: ["Drops7", "D7W2", "FebM25", "Pink", "Yellow", "Cat", "Angel", "Halo"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.03185250516164617,
				y: -.1915971925455225,
				z: -.014577539830657259
			}
		}, {
			id: 1577,
			name: "Henchmen Hat",
			price: 2e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_minion",
				tags: ["Drops7", "D7W2", "FebM25", "Yellow", "Face", "Eye"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.06015336519728054,
				y: -.25544530674481103,
				z: -.027529658836678406
			}
		}, {
			id: 1578,
			name: "The Frostfall Wings",
			price: 2,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_Frostfall",
				tags: ["Drops7", "Premium", "FebM25", "Perm", "Permanent"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_frost"],
			align: {
				x: -.04832250932301607,
				y: -.1581391004944373,
				z: -.022115194586275998
			}
		}, {
			id: 1579,
			name: "St Patrick Sideburns",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_leprechaunhair",
				tags: ["Mar25", "Bundle", "Irish", "Green", "Orange", "Buckle"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.05185480455074476,
				y: -.17136269562496276,
				z: -.023735905871966445
			}
		}, {
			id: 1580,
			name: "Lucky Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_luckycap",
				tags: ["Mar25", "Stpatricksday", "Green", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.1210543003967457,
				y: -.268313840390229,
				z: -.05540308757285228
			}
		}, {
			id: 1581,
			name: "Island Crown",
			price: 500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_paradisecrown",
				tags: ["MarM25", "Easter", "Green", "Moana", "Grass", "Flower", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.07105644648360965,
				y: -.2733141440835456,
				z: -.02992035560734979
			}
		}, {
			id: 1582,
			name: "Snow Blight",
			price: 750,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_snowhair",
				tags: ["MarM25", "White", "Hair", "Fairest", "Red", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: .016196499136843734,
				y: -.12718797275005234,
				z: .006757112068581955
			}
		}, {
			id: 1583,
			name: "Malcontent Crown",
			price: 1250,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_evilhorns",
				tags: ["MarM25", "White", "Queen", "Fairest", "Black"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08221047186945785,
				y: -.27911238654565806,
				z: -.03762758719242561
			}
		}, {
			id: 1584,
			name: "Eggfu Master Robe",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_faction1",
				tags: ["Apr25", "White", "EGGORG", "Shadow", "Blue", "Fairest"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.01449132984450241,
				y: -.0009178330569876714,
				z: -.006627248762252735
			}
		}, {
			id: 1585,
			name: "Eggsassin Robe",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_faction2",
				tags: ["Apr25", "Black", "EGGORG", "Shadow", "Red", "Black"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.014150440215876081,
				y: -.0010135521043506124,
				z: -.006471303595696698
			}
		}, {
			id: 1586,
			name: "Yellow Dragon Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_yellowDragon",
				tags: ["Apr25", "Yellow", "EGGORG", "Shadow", "Black", "Eyes", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07748001937217763,
				y: -.23917631028239605,
				z: -.035459316781735556
			}
		}, {
			id: 1587,
			name: "Red Dragon Hat",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_redDragon",
				tags: ["Apr25", "Red", "EGGORG", "Shadow", "Black", "Eyes", "Bundle"]
			},
			is_available: !1,
			unlock: "manual",
			align: {
				x: -.07950583309832826,
				y: -.24790143060378877,
				z: -.03638644575222899
			}
		}, {
			id: 1588,
			name: "Sumo suit",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_sumo",
				tags: ["Apr25", "EGGORG", "Shadow", "Black", "Eyes", "Premium"]
			},
			is_available: !1,
			unlock: "premium",
			align: {
				x: -.002183832012569553,
				y: -.07013694363675205,
				z: .0006322943492174105
			}
		}, {
			id: 1589,
			name: "Pixel Airplane Wings",
			price: 2147483647,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_premium_PixelAirplane",
				tags: ["AprM25", "Retro", "Wes", "Premium"]
			},
			is_available: !0,
			unlock: "premium",
			align: {
				x: .213094379983787,
				y: -.16645957884834417,
				z: .09752425471968085
			}
		}, {
			id: 1590,
			name: "Ancient Snake Mask",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan3",
				tags: ["May25", "Mayan", "Snek", "Red", "Brown", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.10602932412084898,
				y: -.23633922947462704,
				z: -.04852258195282173
			}
		}, {
			id: 1591,
			name: "Ancient Trader Mask",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan4",
				tags: ["May25", "Mayan", "Pink", "Yellow", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09475807861801155,
				y: -.2364283586542485,
				z: -.043363735963146785
			}
		}, {
			id: 1592,
			name: "Ancient Witch Mask",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan5",
				tags: ["May25", "Mayan", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.09475807861801155,
				y: -.2364283586542485,
				z: -.043363735963146785
			}
		}, {
			id: 1593,
			name: "Ancient Stonemason Mask",
			price: 3e3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_mayan6",
				tags: ["May25", "Mayan", "Grey", "Grey", "Brown"]
			},
			is_available: !1,
			unlock: "purchase",
			align: {
				x: -.08686266749938598,
				y: -.21174403499034677,
				z: -.03975737161929621
			}
		}, {
			id: 1594,
			name: "Sun Visor",
			price: 3,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_suncool",
				tags: ["May25", "Mayan", "Gold", "Ace", "Spade"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_sunvis"],
			align: {
				x: -.09003252940963913,
				y: -.19177304881571922,
				z: -.04119685742841103
			}
		}, {
			id: 1595,
			name: "Cow Racer",
			price: 1500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartcow",
				tags: ["Jun25", "Kartbros", "White", "Black", "Eyes"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.13533271945095926,
				y: -.3602916782544503,
				z: -.06193604248259671
			}
		}, {
			id: 1596,
			name: "Velocity Raptor",
			price: 2500,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_velociraptor",
				tags: ["Jun25", "Kartbros", "Eyes", "Face", "Orange"]
			},
			is_available: !0,
			unlock: "purchase",
			align: {
				x: -.16291756742233354,
				y: -.36748988947567973,
				z: -.07455728579112153
			}
		}, {
			id: 1597,
			name: "The Green Machine",
			price: 4,
			item_type_id: 1,
			item_type_name: "Hat",
			category_name: "Hats",
			exclusive_for_class: null,
			item_data: {
				meshName: "hat_kartbros",
				tags: ["Jun25", "Kartbros", "Green"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_hat_kartbros"],
			align: {
				x: .013567821915410505,
				y: .1229279294691179,
				z: .0061995837427129
			}
		}, {
			id: 2001,
			name: "Target Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 0,
				tags: ["Default", "Red", "Blue", "Yellow"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2002,
			name: "No Sign Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 0,
				tags: ["Default", "Red"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2003,
			name: "Question Mark Stamp?",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 0,
				tags: ["Default", "Black", "?"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2004,
			name: "Peace Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 0,
				tags: ["Default", "Black"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2005,
			name: "Thumbs Up Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 0,
				tags: ["Default", "White"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2006,
			name: "Pablo Smile Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 0,
				tags: ["Default", "Happy", "Face", "Yellow"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2007,
			name: "Skull & Crossbones Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 2,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2008,
			name: "Tyrant Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 3,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2009,
			name: "Shifty Eye Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 5,
				tags: ["Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2010,
			name: "Arrow & Heart Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 6,
				tags: ["Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2011,
			name: "Grade A Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 1,
				tags: ["Red", "USDA"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2012,
			name: "Anarchy Sign Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 1,
				tags: ["Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2013,
			name: "Derp Face Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 2,
				tags: ["Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2014,
			name: "Wolf Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 5,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2015,
			name: "Chicken Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 6,
				tags: ["Brown", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2016,
			name: "Phoenix Stamp",
			price: 600,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 7,
				tags: ["Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2017,
			name: "Alien Stamp",
			price: 600,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 7,
				tags: ["Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2018,
			name: "Dapper Mustache Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 5,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2019,
			name: "Happy Bear Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 8,
				tags: ["Pink", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2020,
			name: "Ghost Face Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 8,
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2021,
			name: "Jack Face Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 8,
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2022,
			name: "Cracks Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 9,
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2023,
			name: "Bat Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 9,
				tags: ["Halloween", "Oct23", "Grey", "Gray", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2024,
			name: "Cthulhu Fhtagn Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 9,
				tags: ["Halloween", "Oct23", "Green", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2025,
			name: "Elder Sign Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 9,
				tags: ["Halloween", "Oct23", "Red", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2026,
			name: "Scary Teeth Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 9,
				tags: ["Halloween", "Oct23", "Smile", "Green", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2027,
			name: "Monster Tongue Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 9,
				tags: ["Halloween", "Oct23", "Face", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2028,
			name: "Spooky Lady Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 9,
				tags: ["Halloween", "Oct23", "Face", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2029,
			name: "Clown Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 10,
				tags: ["Halloween", "Oct23", "Smile", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2030,
			name: "Stitch Face Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 10,
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2031,
			name: "Devil Face Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 10,
				tags: ["Halloween", "Oct23", "Smile", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2032,
			name: "Face Mask Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 10,
				tags: ["Halloween", "Oct23", "Black", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2033,
			name: "Hand Turkey Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 10,
				tags: ["NovM23", "Thanksgiving", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2034,
			name: "Turkey Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 10,
				tags: ["NovM23", "Thanksgiving", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2035,
			name: "Turkey Crossbones Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 10,
				tags: ["NovM23", "Thanksgiving", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2036,
			name: "Reindeer Face Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 11,
				tags: ["Dec23", "Christmas", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2037,
			name: "Gingerbread Cookie Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 11,
				tags: ["Dec23", "Christmas", "Brown", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2038,
			name: "Santa Skull Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 11,
				tags: ["Christmas2", "Red", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2039,
			name: "2019 Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 11,
				tags: ["NewYears", "2019", "Yellow", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2040,
			name: "Fireworks Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 11,
				tags: ["NewYears", "Blue", "Yellow", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2041,
			name: "Midnight Clock Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 11,
				tags: ["NewYears", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2042,
			name: "Stressed Out Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 7,
				tags: ["Newsletter", "Face"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2043,
			name: "Chicken Finger Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 8,
				tags: ["Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2044,
			name: "Lyerpald Stamp ",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 8,
				tags: ["Contentcreator"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2045,
			name: "Groundhog Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 11,
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2046,
			name: "Winter Snowflake Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 12,
				tags: ["Groundhog", "Feb23", "Blue", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2047,
			name: "Spring Flower Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 12,
				tags: ["Groundhog", "Feb23", "Pink", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2048,
			name: "Broken Heart Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 12,
				tags: ["ValentinesDay", "Red", "Feb24", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2049,
			name: "Rose Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 12,
				tags: ["ValentinesDay", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2050,
			name: "Anatomical Heart Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 12,
				tags: ["ValentinesDay", "Heart", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2051,
			name: "Shamrock Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 12,
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2052,
			name: "Ginger Beard Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 12,
				tags: ["StPatricksDay", "MarM23", "Brown", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2053,
			name: "Pot of Gold Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 13,
				tags: ["StPatricksDay", "MarM23", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2054,
			name: "Bunny Face Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 13,
				tags: ["Easter", "AprM23", "Heart", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2055,
			name: "Easter Egg Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 13,
				tags: ["Easter", "AprM23", "Blue", "White", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2056,
			name: "Golden Easter Egg Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 13,
				tags: ["Easter", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2057,
			name: "Shell League Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 13,
				tags: ["League"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2058,
			name: "TXC Clan Logo Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 13,
				tags: ["Green", "Blue", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2071,
			name: "GOD Clan Logo",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 15,
				tags: ["Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2059,
			name: "Sherrif Star Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 6,
				tags: ["Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2060,
			name: "Rainbow Cloud Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 5,
				tags: ["Cute"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2061,
			name: "Angel Wings Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 6,
				tags: ["Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2062,
			name: "GoE Sigil - Wolf Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 13,
				tags: ["GameOfEggs", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2063,
			name: "GoE Sigil - Lion Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 14,
				tags: ["GameOfEggs", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2064,
			name: "GoE Sigil - Bird Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 14,
				tags: ["GameOfEggs", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2065,
			name: "GoE Sigil - Stag Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 14,
				tags: ["GameOfEggs", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2066,
			name: "GoE Sigil - Fish Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 14,
				tags: ["GameOfEggs", "Orange"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2067,
			name: "GoE Sigil - Squid Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 14,
				tags: ["GameOfEggs", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2068,
			name: "GoE Sigil - Sun Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 14,
				tags: ["GameOfEggs", "Orange", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2069,
			name: "GoE Sigil - Flower Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 14,
				tags: ["GameOfEggs", "Green", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2070,
			name: "GoE Sigil - Dragon Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 15,
				tags: ["GameOfEggs", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2072,
			name: "4th of July Stamp",
			price: 1770,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 15,
				tags: ["July4", "Red", "Blue", "forth", "Fireworks", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2073,
			name: "SL MVP Division A Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 15,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2074,
			name: "SL MVP Division B Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 15,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2075,
			name: "CRGI Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 15,
				tags: ["League", "Dog"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2076,
			name: "Robot Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 6,
				tags: ["Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2077,
			name: "Poop Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 7,
				tags: ["Brown", "Poop"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2078,
			name: "Heart Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 1,
				tags: ["Cards", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2079,
			name: "Spade Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 1,
				tags: ["Cards", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2080,
			name: "Club Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 1,
				tags: ["Cards", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2081,
			name: "Diamond Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 1,
				tags: ["Cards", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2082,
			name: "What Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 2,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2083,
			name: "Yes Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 2,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2084,
			name: "No Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 2,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2085,
			name: "Ribcage Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 5,
				tags: ["Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2086,
			name: "Angry Cartridge Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 8,
				tags: ["Grey", "Gray", "Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2087,
			name: "DXG Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 0,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2088,
			name: "Tired Space Goblin Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 2,
				tags: ["Eggwalker", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2089,
			name: "Angry Space Dog Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 3,
				tags: ["Eggwalker", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2090,
			name: "No Trying Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 4,
				tags: ["Eggwalker", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2091,
			name: "Disgruntled Space Weasel Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 5,
				tags: ["Eggwalker", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2092,
			name: "White Beard Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 1,
				tags: ["Newsletter", "Christmas", "Santa"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2093,
			name: "Strong Egg Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 5,
				tags: ["Newsletter", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2094,
			name: "New Year 2020 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 6,
				tags: ["NewYears", "2020", "Yellow", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2095,
			name: "Bad Eggs For Life Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 8,
				tags: ["BadEggsForLife", "Jun23", "MarM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2096,
			name: "Pixel Heart Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 9,
				tags: ["Newsletter", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2097,
			name: "Eggy Cash Face Stamp",
			price: 5e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 15,
				tags: ["EggyCash", "Face", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2098,
			name: "DXG Clan Logo 2 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 10,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2099,
			name: "Raid Land Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 11,
				tags: ["RaidLand"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2100,
			name: "Egg Org Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 12,
				tags: ["AprilFools", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2101,
			name: "MVP 2020 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 13,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2102,
			name: "TXC Clan Skull Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 14,
				tags: ["League", "Purple"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2103,
			name: "Toxic Skull Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 15,
				tags: ["Rotten", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2104,
			name: "Toxic Nuke Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 0,
				tags: ["Rotten", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2105,
			name: "Toxic Derp Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 1,
				tags: ["Rotten", "Green", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2106,
			name: "Facepaint Heart Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 5,
				tags: ["Rockstar", "JanM23", "Pink", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2107,
			name: "Facepaint Star Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 6,
				tags: ["Rockstar", "JanM23", "Black", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2108,
			name: "Facepaint Lightning Bolt Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 4,
				tags: ["Rockstar", "JanM23", "Yellow", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2109,
			name: "Pink Starburst Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 7,
				tags: ["Galeggsy", "AprM23", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2110,
			name: "Alien Eyes 1 Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 8,
				tags: ["Galeggsy", "AprM23", "Face", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2111,
			name: "Alien Eyes 2 Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 9,
				tags: ["Galeggsy", "AprM23", "Face", "Cute", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2112,
			name: "Flame Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 7,
				tags: ["Newsletter", "Fire", "Red", "Orange", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2113,
			name: "Discord Mod Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 13,
				tags: ["mod"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2114,
			name: "Black Tie Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 14,
				tags: ["MercZone", "Suit", "Tie"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2115,
			name: "Red Tie Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 15,
				tags: ["MercZone", "Suit", "Tie"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2116,
			name: "Pink Tie Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 0,
				tags: ["MercZone", "Suit", "Tie"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2117,
			name: "Killstreak Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 1,
				tags: ["Killstreak", "Smile", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2118,
			name: "Red Rooster Wings Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 10,
				tags: ["Chicken", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2119,
			name: "White Rooster Wings Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 11,
				tags: ["Chicken", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2120,
			name: "Gold Rooster Wings Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 12,
				tags: ["Chicken", "July23", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2121,
			name: "Ugly Jason Face Stamp",
			price: 1300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 2,
				tags: ["f13"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2122,
			name: "Little Happy Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 3,
				tags: ["Stampede", "Face", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2123,
			name: "Angry Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 4,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2124,
			name: "Why Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 5,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2125,
			name: "Influenced Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 6,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2126,
			name: "Nervous Crush Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 7,
				tags: ["Stampede", "Face", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2127,
			name: "Girly Eyes Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 8,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2128,
			name: "Big Smile Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 9,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2129,
			name: "Cyclops Face Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 10,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2130,
			name: "Grumpy Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 11,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2131,
			name: "Big Happy Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 12,
				tags: ["Stampede", "Smile", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2132,
			name: "Scared Stamp",
			price: 1005,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 13,
				tags: ["Stampede", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2133,
			name: "This Guy Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 14,
				tags: ["Stampede", "Face", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2134,
			name: "Tumble Dude Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 15,
				tags: ["Stampede", "White", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2135,
			name: "Thee_Owl Angry Face Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 0,
				tags: ["Stampede"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2136,
			name: "Blow Face Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 1,
				tags: ["Stampede"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2137,
			name: "Whip Em Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 2,
				tags: ["Stampede", "Blue", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2138,
			name: "Baby on Board Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 3,
				tags: ["Stampede", "Chick", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2139,
			name: "Thee_Owl Scared Face Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 4,
				tags: ["Stampede"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2140,
			name: "Yin Yang Chicken Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 5,
				tags: ["Stampede", "Black", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2141,
			name: "Blue Wizard Guy Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 8,
				tags: ["Newsletter", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2142,
			name: "God Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 6,
				tags: ["League", "Red", "Orange"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2143,
			name: "Wero Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 7,
				tags: ["Wero", "Beard"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2144,
			name: "New Year 2021 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 8,
				tags: ["NewYears", "2021", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2145,
			name: "Thee_Owl Logo Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 9,
				tags: ["Thee_Owl", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2146,
			name: "Biggest Mouth Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 5,
				tags: ["Newsletter", "Ahh"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2147,
			name: "C4bra Ram Outfit Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 7,
				tags: ["C4bra"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2148,
			name: "Hazmatt Thumbs Up Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 8,
				tags: ["Hazmat", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2149,
			name: "Hazmatt POG Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 9,
				tags: ["Hazmat", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2150,
			name: "Pixel Tech Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 10,
				tags: ["Pixel", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2151,
			name: "Pixel Chicken Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 11,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2152,
			name: "Pixel Gun Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 12,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2153,
			name: "Pixel Robot Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 13,
				tags: ["Pixel", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2154,
			name: "Pixel Shield Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 14,
				tags: ["Pixel", "Eggs"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2155,
			name: "Pixel Egg Splat Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 15,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2156,
			name: "Pixel Swords Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 0,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2157,
			name: "Pixel Happy Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 1,
				tags: ["Pixel", "Smile", "bun_gamer"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2158,
			name: "Pixel Angry Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 2,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2159,
			name: "Pixel Annoyed Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 3,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2160,
			name: "Pixel Dead Face Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 4,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2161,
			name: "Pixel Deal With It Sunglasses Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 5,
				tags: ["Pixel"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2162,
			name: "Angry Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 12,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2163,
			name: "Cat Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 13,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2164,
			name: "Crazy Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 14,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2165,
			name: "Dog Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 15,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2166,
			name: "Evil Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 0,
				tags: ["Mouth", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2167,
			name: "Grinning Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 1,
				tags: ["Mouth", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2168,
			name: "Happy Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 2,
				tags: ["Mouth", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2169,
			name: "Laughing Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 3,
				tags: ["Mouth", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2170,
			name: "Pirate Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 4,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2171,
			name: "Sick Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 5,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2172,
			name: "Smiling Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 6,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2173,
			name: "Tongue-Out Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 7,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2174,
			name: "Upset Mouth Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 8,
				tags: ["Mouth"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2175,
			name: "Dead BW Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 10,
				tags: ["EGGORG", "Wizard", "Blue", "Apr24", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2176,
			name: "Egg Org Spokesperson Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 11,
				tags: ["EGGORG", "Apr24", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2177,
			name: "Aries Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 12,
				tags: ["League", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2178,
			name: "Diablo Frown Stamp",
			price: 100,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 9,
				tags: ["EGGORG", "Apr24", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2179,
			name: "Train Ticket Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 11,
				tags: ["Trains", "Cars"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2180,
			name: "Train Engine Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 13,
				tags: ["Trains", "Cars", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2181,
			name: "All Aboard Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 14,
				tags: ["Trains", "Cars"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2182,
			name: "Pain Train's Comin Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 15,
				tags: ["Trains", "Cars"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2183,
			name: "Random Life Logo Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 0,
				tags: ["Random", "RL"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2184,
			name: "Mystery QR Code",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 5
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2185,
			name: "Ethan Gamer Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 4,
				tags: ["EthanGamer", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2186,
			name: "Red Aries Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 10,
				tags: ["League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2187,
			name: "Toilet Paper Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 6,
				tags: ["TP", "Poop", "2ply", "Text", "bun_toilet"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2188,
			name: "Water Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 8,
				tags: ["Summer", "JunM23", "Blue", "Water", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2189,
			name: "Popsicle Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 6,
				tags: ["Summer", "JunM23", "Pink", "Food", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2190,
			name: "Sun Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 7,
				tags: ["Summer", "JunM23", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2191,
			name: "Postage Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 9,
				tags: ["Summer", "JunM23", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2192,
			name: "Blue Wizard Skull Stamp",
			price: 1200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 6,
				tags: ["BWD"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2193,
			name: "Lyerpald Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 8,
				tags: ["Dog", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2194,
			name: "SL NA#1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 1,
				tags: ["League", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2195,
			name: "SL EU#1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 2,
				tags: ["League", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2196,
			name: "SL OCE#1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 3,
				tags: ["League", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2197,
			name: "I <3 New Yolker Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 11,
				tags: ["Newsletter", "Heart", "NY"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2198,
			name: "Egg Heart Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 12,
				tags: ["White"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2199,
			name: "Chantigg Face Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 13,
				tags: ["Chantigg", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2200,
			name: "Chantigg Cake Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 14,
				tags: ["Chantigg", "Food"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2201,
			name: "Grade A+ Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 0,
				tags: ["Pencil", "Sep23", "Red", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2202,
			name: "Globe Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 1,
				tags: ["Pencil", "Sep23", "Earth", "Green", "Blue", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2203,
			name: "Nerd Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 15,
				tags: ["Pencil", "Sep23", "Smile", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2204,
			name: "Gold Beak Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 13,
				tags: ["vipItem", "Premium", "Yellow"]
			},
			is_available: !0,
			unlock: "vip"
		}, {
			id: 2205,
			name: "Zombie Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 10,
				tags: ["Halloween2", "Oct23", "Yellow", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2206,
			name: "Werewolf Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 9,
				tags: ["Halloween2", "Oct23", "Pink", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2207,
			name: "Vampire Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 8,
				tags: ["Halloween2", "Oct23", "Red", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2208,
			name: "Sasquatch Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 7,
				tags: ["Halloween2", "Oct23", "Brown", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2209,
			name: "Medusa Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 6,
				tags: ["Halloween2", "Oct23", "Green", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2210,
			name: "Blue Cyclops Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 5,
				tags: ["Halloween2", "Oct23", "Blue", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2211,
			name: "Cthulu Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 4,
				tags: ["Halloween2", "Oct23", "Green", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2212,
			name: "Baldwiz Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 3,
				tags: ["Halloween2", "Oct23", "Skull", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2213,
			name: "Fang Pablo Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 11,
				tags: ["Halloween2", "Oct23", "Smile", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2214,
			name: "Jack O' Lantern Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 12,
				tags: ["Halloween2", "Oct23", "Face", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2215,
			name: "Circle Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 0,
				tags: ["Egg Game", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2216,
			name: "Square Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 15,
				tags: ["Egg Game", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2217,
			name: "Umbrella Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 1,
				tags: ["Egg Game", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2218,
			name: "Triangle Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 14,
				tags: ["Egg Game", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2219,
			name: "NACL Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 2,
				tags: ["League", "Yellow", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2220,
			name: "RBL Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 3,
				tags: ["League", "Black", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2221,
			name: "Sheesh Face Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 11
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2222,
			name: "Black Eggs Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 10,
				tags: ["Black Fryday", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2223,
			name: "Black Fries Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 9,
				tags: ["Black Fryday", "AprM24", "FebM24"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2224,
			name: "Red Wins Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 4,
				tags: ["KotC", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2225,
			name: "Blue Wins Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 5,
				tags: ["KotC", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2226,
			name: "I put the OP in Coop Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 6,
				tags: ["KotC"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2227,
			name: "I rule the Roost Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 7,
				tags: ["KotC"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2228,
			name: "2022 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 12,
				tags: ["2022", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2229,
			name: "Nervous Elf Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 14,
				tags: ["Christmas2", "Face", "Smile", "bun_mistle", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2230,
			name: "Pro Plays Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 13,
				tags: ["Drops", "White"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2231,
			name: "Ganbaru Okan Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 15,
				tags: ["Drops", "Black", "Pink"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2232,
			name: "Cold Face Stamp",
			price: 1750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 0,
				tags: ["Chilly", "Ice"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2233,
			name: "Snowman Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 1,
				tags: ["Chilly", "Smile", "Face"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2234,
			name: "Hockey Sticks Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 2,
				tags: ["Chilly", "Brown", "Canada"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2235,
			name: "Happy Aww Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 3,
				tags: ["Kawaii", "Cute", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2236,
			name: "Sad Aww Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 4,
				tags: ["Kawaii", "Cute", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2237,
			name: "Heart Eyes Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 5,
				tags: ["Kawaii", "Cute", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2238,
			name: "Star Eyes Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 6,
				tags: ["Kawaii", "Cute", "Face", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2239,
			name: "Shocked Eyes Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 7,
				tags: ["Kawaii", "Cute", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2240,
			name: "Ecstatic Eyes Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 8,
				tags: ["Kawaii", "Cute", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2241,
			name: "Pleased Eyes Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 9,
				tags: ["Kawaii", "Cute", "Face", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2242,
			name: "Cat Wink Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 10,
				tags: ["Kawaii", "Cute", "Face", "bun_cat"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2243,
			name: "Nate's Monies Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 11,
				tags: ["Nate", "MayM23", "Yellow", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2244,
			name: "Nate's Bomb Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 12,
				tags: ["Nate", "Black", "Apr24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2245,
			name: "Nate's Eel Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 13,
				tags: ["Nate", "Oct23", "Black", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2246,
			name: "Nate's Skypunch Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 14,
				tags: ["Nate", "MarM23", "Pixel", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2247,
			name: "Nate's Stonks Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 15,
				tags: ["Nate", "Yellow", "Ahh", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2248,
			name: "Nate's Dead Jason Stamp",
			price: 5e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 15,
				tags: ["Nate", "Black", "White", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2249,
			name: "Nate's Alive Jason Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 14,
				tags: ["Nate", "Black", "White", "July24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2250,
			name: "Nate's Noodly Appendages Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 13,
				tags: ["Nate", "Smile", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2251,
			name: "Phoenix BLZ Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 10,
				tags: ["SL", "Orange", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2252,
			name: "Navi Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 9,
				tags: ["SL", "Blue", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2253,
			name: "NCR Clan Logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 8,
				tags: ["SL", "Black", "Purple"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2254,
			name: "Ukraine Stamp",
			price: 100,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 7,
				tags: ["UA", "Blue", "Yellow", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2255,
			name: "Nothin' but Net Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 11,
				tags: ["BBros", "Basketball"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2256,
			name: "On Fire Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 12,
				tags: ["BBros", "Basketball", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2257,
			name: "Diamonds Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 6,
				tags: ["EGGORG", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2258,
			name: "Clubs Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 5,
				tags: ["EGGORG", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2259,
			name: "Spades Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 4,
				tags: ["EGGORG", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2260,
			name: "Hearts Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 3,
				tags: ["EGGORG", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2261,
			name: "Egg Org Shield Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 2,
				tags: ["EGGORG", "Apr23", "Red", "Yellow", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2262,
			name: "Polarized Moon Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 1,
				tags: ["Relic", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2263,
			name: "Shattered EGG ORG Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 0,
				tags: ["Relic", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2264,
			name: "Wizard Neko Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 15,
				tags: ["Relic", "Mar23", "AugM23", "Dog"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2265,
			name: "Jason Eyes Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 14,
				tags: ["Relic", "Mar23", "AugM23"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2266,
			name: "Wizard Cheer Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 13,
				tags: ["Relic", "Mar23", "AugM23", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2267,
			name: "Egg Love Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 12,
				tags: ["Relic", "Mar23", "AugM23", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2268,
			name: "Going Eggstinct Stamp",
			price: 350,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 11,
				tags: ["Dino", "May23", "Black", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2269,
			name: "No Tar Pits Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 10,
				tags: ["Dino", "May23", "Red", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2270,
			name: "Clutch Up! Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 9,
				tags: ["Dino", "May23", "Eggs", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2271,
			name: "No Meteors Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 8,
				tags: ["Dino", "May23", "Red", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2272,
			name: "No Volcanos Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 7,
				tags: ["Dino", "May23", "Red", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2273,
			name: "RAWR Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 6,
				tags: ["Dino", "MarM23", "Yellow", "Purple", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2274,
			name: "Baby Dino Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 5,
				tags: ["Dino", "May23", "Green", "Eggs", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2275,
			name: "Bluetooth Stamp",
			price: 1750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 0,
				tags: ["Mobile", "JunM23", "Smile"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2276,
			name: "Happy Phone Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 1,
				tags: ["Mobile", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2277,
			name: "Mad Phone Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 2,
				tags: ["Mobile", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2278,
			name: "Signal Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 3,
				tags: ["Mobile", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2279,
			name: "Charging! Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 4,
				tags: ["Mobile", "Black", "Apr24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2280,
			name: "Eggy-wan Beard Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 0,
				tags: ["Eggwalker2", "Face", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2281,
			name: "Control Panel Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 1,
				tags: ["Eggwalker2", "Red", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2282,
			name: "Evader face Stamp",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 2,
				tags: ["Eggwalker2", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2283,
			name: "Ladybug Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 3,
				tags: ["Summer", "JunM23", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2284,
			name: "Camper Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 4,
				tags: ["Summer", "JunM23", "Green", "Tent", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2285,
			name: "Oasis Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 5,
				tags: ["Summer", "JunM23", "Black", "Red", "Blue", "Tree", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2286,
			name: "Hot Face Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 6,
				tags: ["Summer", "JunM23", "Orange", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2287,
			name: "Sun's out Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 7,
				tags: ["Summer", "JunM23", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2288,
			name: "Blue's #1 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 8,
				tags: ["Sports", "JulyM23", "Blue", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2289,
			name: "Red's #1 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 9,
				tags: ["Sports", "JulyM23", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2290,
			name: "Football Laces Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 10,
				tags: ["Sports", "JulyM23", "White", "Fbros", "JunM24", "SepM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2291,
			name: "Hockey crossed sticks Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 11,
				tags: ["Sports", "JulyM23", "Black", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2292,
			name: "Trophy #1 Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 12,
				tags: ["Sports", "JulyM23", "Yellow", "Gold", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2293,
			name: "What's the play? Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 13,
				tags: ["Sports", "JulyM23", "Eggs", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2294,
			name: "Whistle Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 14,
				tags: ["Sports", "JulyM23", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2295,
			name: "Go Team Eggs Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 15,
				tags: ["Sports", "JulyM23", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2296,
			name: "GOAL Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 0,
				tags: ["Sports", "JulyM23", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2297,
			name: "Cooked Chicken Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 1,
				tags: ["Chicken", "Food", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2298,
			name: "Lil Nugz Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 2,
				tags: ["Chicken", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2299,
			name: "Toast Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 3,
				tags: ["Breakfast", "Eggs", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2300,
			name: "Butter believe it Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 4,
				tags: ["Breakfast", "Food", "NovM23", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2301,
			name: "Sour Face Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 5,
				tags: ["Breakfast", "July23", "MayM24", "Jun25", "premFeatTwo"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2302,
			name: "Pancakes Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 6,
				tags: ["Breakfast", "Brown", "Food", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2303,
			name: "Hard Boiled Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 7,
				tags: ["Breakfast", "Eggs", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2304,
			name: "Coffee makes me happy! Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 8,
				tags: ["Breakfast", "Smile", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2305,
			name: "Bacon Bacon Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 9,
				tags: ["Breakfast", "Red", "Food", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2306,
			name: "Scavenger Statue Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 10,
				tags: ["Scavenger", "Blue", "Wizard"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2307,
			name: "Scavenger Map Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 11,
				tags: ["Scavenger", "Wizard"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2308,
			name: "Scavenger Magnifeye Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 12,
				tags: ["Scavenger", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2309,
			name: "Scavenger Compass Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 13,
				tags: ["Scavenger", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2310,
			name: "Scavenger Monocle Face Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 14,
				tags: ["Scavenger", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2311,
			name: "Paint Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 15,
				tags: ["Pencil2", "Sep23", "Rainbow", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2312,
			name: "Science Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 0,
				tags: ["Pencil2", "Sep23", "Blue", "Purple", "Red", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2313,
			name: "Schoolbus Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 1,
				tags: ["Pencil2", "Sep23", "Yellow", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2314,
			name: "Math Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 2,
				tags: ["Pencil2", "Sep23", "Black", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2315,
			name: "Sharkbucks Stamp",
			price: 6900,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 3,
				tags: ["Sep22", "Green", "Face"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2316,
			name: "Kilzomatic Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 4,
				tags: ["Sep22", "Drops3", "Blue", "Eggs"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2317,
			name: "Diablo Sticker Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 5,
				tags: ["Sep22", "Mar23", "AugM23", "Eggs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2318,
			name: "Pablo Sticker Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 6,
				tags: ["Sep22", "Mar23", "AugM23", "Eggs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2319,
			name: "The Jaw Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 8,
				tags: ["Sep22", "Drops3", "Face", "Black", "Stan", "Dad"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2320,
			name: "Pablo GG Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 7,
				tags: ["Sep22", "Mar23", "AugM23", "Eggs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2321,
			name: "Trick Or Treat Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 9,
				tags: ["Halloween3", "OctM23", "Orange", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2322,
			name: "Scary Clown Face Stamp",
			price: 1990,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 10,
				tags: ["Halloween3", "OctM23", "It", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2323,
			name: "KJDCitsme Jacko Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 14,
				tags: ["Halloween3", "OctM23", "Face", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2324,
			name: "KJDCitsme Shock Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 11,
				tags: ["Halloween3", "OctM23", "Face", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2325,
			name: "Thee_Owl Breakout Yolk Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 13,
				tags: ["Halloween3", "OctM23", "Yellow", "Face", "OctM24"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2326,
			name: "Thee_Owl Peekout Yolk Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 9,
				tags: ["Halloween3", "OctM23", "Yellow", "Face", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2327,
			name: "Zamsgod Scratch Face Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 12,
				tags: ["Halloween3", "OctM23", "Face", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2328,
			name: "Artshocks Half Asleep Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 10,
				tags: ["Halloween3", "OctM23", "Face", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2329,
			name: "Scared Stupid Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 8,
				tags: ["Halloween3", "OctM23", "Face", "Black", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2330,
			name: "One Cluck Man Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 7,
				tags: ["Halloween3", "OctM23", "Face", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2331,
			name: "Skullface Kills Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 6,
				tags: ["Halloween3", "OctM23", "Eggs", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2332,
			name: "Witches Broom Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 15,
				tags: ["Halloween3", "OctM23", "Brown", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2333,
			name: "Fall Leaf Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 11,
				tags: ["NovM23", "Thanksgiving", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2334,
			name: "Turkey head on Stamp",
			price: 400,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 12,
				tags: ["NovM23", "Thanksgiving", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2335,
			name: "Forest Shroom Stamp",
			price: 600,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 13,
				tags: ["NovM23", "Thanksgiving2", "Red", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2336,
			name: "Apple Core Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 14,
				tags: ["NovM23", "Thanksgiving2", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2337,
			name: "Drumstick Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 15,
				tags: ["NovM23", "Thanksgiving2", "Brown", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2338,
			name: "It's Corn Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 4,
				tags: ["NovM23", "Thanksgiving2", "Yellow", "Green", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2339,
			name: "Corntastic Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 5,
				tags: ["NovM23", "Thanksgiving", "Yellow", "Orange", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2340,
			name: "You won a 1v1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 3,
				tags: ["Badegg", "Purple", "Blue", "Eggs"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2341,
			name: "Wizard Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 2,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2342,
			name: "Reload the clip Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 1,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2343,
			name: "Regeneration Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 0,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2344,
			name: "Upgrade Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 0,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2345,
			name: "Health Drop Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 1,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2346,
			name: "Sleeps Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 2,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2347,
			name: "Marksman Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 3,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2348,
			name: "Restocked Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 4,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2349,
			name: "Rambod Face Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 5,
				tags: ["Badegg", "Black", "DecM23", "July24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2350,
			name: "Surprise! Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 6,
				tags: ["Badegg", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2351,
			name: "Goose Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 7,
				tags: ["Badegg", "Black", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2352,
			name: "New Year 2023 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 8,
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2353,
			name: "Mixtape Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 9,
				tags: ["Rockstar", "JanM23", "Grey", "Gray", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2354,
			name: "Treble clef Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 10,
				tags: ["Rockstar", "JanM23", "Black", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2355,
			name: "Rock on Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 11,
				tags: ["Rockstar", "JanM23", "Yellow", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2356,
			name: "Buck Teeth",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 13,
				tags: ["Groundhog", "Feb23", "Face", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2357,
			name: "Alarm Clock Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 12,
				tags: ["Groundhog", "Newsletter", "Feb23", "White", "Silver", "Feb24"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2358,
			name: "Horseshoe Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 15,
				tags: ["farm", "FebM23", "Brown", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2359,
			name: "Sunflower Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 14,
				tags: ["farm", "FebM23", "Yellow", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2360,
			name: "CEO Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 0,
				tags: ["League", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2361,
			name: "LEV Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 1,
				tags: ["League", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2362,
			name: "RTV Clan Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 2,
				tags: ["League", "Blue", "Purple"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2363,
			name: "Shell Tournaments Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 3,
				tags: ["League", "Orange"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2364,
			name: "NPS Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 4,
				tags: ["League", "White"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2365,
			name: "Shell Tournaments #1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 5,
				tags: ["League", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2366,
			name: "Hello my name is Pablo Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 6,
				tags: ["Drops4", "Mar23", "AugM23", "Red", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2367,
			name: "Happily Fried Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 7,
				tags: ["Drops4", "Mar23", "AugM23", "White", "Eggs", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2368,
			name: "Game Of The Year Stamp",
			price: 350,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 8,
				tags: ["Drops4", "Mar23", "Yellow", "GOTY", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2369,
			name: "Wizards on Fire! Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 9,
				tags: ["Drops4", "Mar23", "Blue", "BWD", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2370,
			name: "Banned Aid Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 10,
				tags: ["Drops4", "Mar23", "Brown", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2371,
			name: "xQc Ape Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 11,
				tags: ["Drops4", "Mar23", "White"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2372,
			name: "Shell Shockers Logo Stamp",
			price: 50,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 12,
				tags: ["Drops4", "Mar23", "Eggs", "White", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2373,
			name: "Griffen Chin Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 13,
				tags: ["Drops4", "Mar23", "Face", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2374,
			name: "That's a Fowl Stamp",
			price: 150,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 14,
				tags: ["BBros", "MarM23", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2375,
			name: "Stuffed Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 15,
				tags: ["BBros", "MarM23"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2376,
			name: "Bear Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 0,
				tags: ["BBros", "MarM23", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2377,
			name: "Tiger Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 1,
				tags: ["BBros", "MarM23", "Tiger", "Cat"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2378,
			name: "Basket Bros Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 2,
				tags: ["BBros", "MarM23", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2379,
			name: "Hydrate! Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 3,
				tags: ["BBros", "MarM23", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2380,
			name: "Egg Jordan Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 4,
				tags: ["BBros", "MarM23", "Black", "Eggs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2381,
			name: "Kiss me I'm Irish Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 5,
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2382,
			name: "Monster Talisman Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 6,
				tags: ["Monsters", "Apr23"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2383,
			name: "Hero Talisman Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 7,
				tags: ["Heroes", "Apr23"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2384,
			name: "Judgement arrow Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 8,
				tags: ["Apr23", "Gold", "Green", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2385,
			name: "Critical Hit Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 9,
				tags: ["Apr23", "Red", "Gold", "D20", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2386,
			name: "Breath Weapon Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 10,
				tags: ["Apr23", "Red", "Gold", "Dragon"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2387,
			name: "Egg Org & Eggventure Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 11,
				tags: ["Apr23", "Red", "Gold", "Dragon"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2388,
			name: "Heroes Potion Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 12,
				tags: ["Heroes", "Apr23", "Green", "Heart"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2389,
			name: "Monsters Potion Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 13,
				tags: ["Apr23", "Monsters", "Red", "Skull"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2390,
			name: "Monobrow Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 14,
				tags: ["May23", "Dino2", "Black", "Face", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2391,
			name: "Slay the Beast Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 15,
				tags: ["May23", "Dino2", "Black", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2392,
			name: "Caveman Classic Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 0,
				tags: ["May23", "Dino2", "Face", "Smile", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2393,
			name: "Stone Tools Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 1,
				tags: ["May23", "Dino2", "Brown", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2394,
			name: "Chart Stamp",
			price: 10,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 3,
				tags: ["MayM23", "Eggflation", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2395,
			name: "Money Tree Stamp",
			price: 100,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 4,
				tags: ["MayM23", "Eggflation", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2396,
			name: "Eggflation Rollercoaster Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 2,
				tags: ["MayM23", "Eggflation", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2397,
			name: "HODL Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 5,
				tags: ["MayM23", "Eggflation"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2398,
			name: "Polaroid Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 6,
				tags: ["Jun23", "Photo", "Eggs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2399,
			name: "Wedding Crasher Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 7,
				tags: ["Jun23", "Photo", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2400,
			name: "Apature Stamp",
			price: 825,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 8,
				tags: ["Jun23", "Photo", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2401,
			name: "Dour Mustache Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 9,
				tags: ["Jun23", "Photo", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2402,
			name: "Starfish Stamp",
			price: 505,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 10,
				tags: ["JunM23", "Summer2", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2403,
			name: "Jellyfish Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 11,
				tags: ["JunM23", "Summer2", "White", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2404,
			name: "Beach Vibes Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 12,
				tags: ["JunM23", "Summer2", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2405,
			name: "Beach Ball Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 13,
				tags: ["JunM23", "Summer2", "White", "Blue", "Yellow", "Red", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2406,
			name: "Equinox Sun Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 0,
				tags: ["July23", "Equinox", "Yellow", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2407,
			name: "Equinox Moon Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 1,
				tags: ["July23", "Equinox", "Grey", "Gray", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2408,
			name: "Equinox YinYang Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 14,
				tags: ["July23", "Equinox", "Blue", "Yellow", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2409,
			name: "Pablodala Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 15,
				tags: ["July23", "Equinox", "Mandala", "Blue", "Yellow", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2410,
			name: "Star Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 2,
				tags: ["JulyM23", "Sports2"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2411,
			name: "Grind Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 4,
				tags: ["JulyM23", "Sports2", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2412,
			name: "Fellow Kids Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 3,
				tags: ["JulyM23", "Sports2", "Red", "Skateboard"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2413,
			name: "Safety Team Approved Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 5,
				tags: ["JulyM23", "Sports2", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2414,
			name: "The MenoXD Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 6,
				tags: ["JulyM23", "Red", "xd"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2415,
			name: "Red S-tier Racing Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 7,
				tags: ["Aug23", "Eggs", "Kart", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2416,
			name: "Green S-tier Racing Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 8,
				tags: ["Aug23", "Eggs", "Kart", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2417,
			name: "Question block Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 9,
				tags: ["Aug23", "Yellow", "?", "JanM24", "Kart", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2418,
			name: "Racing Flags Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 10,
				tags: ["Aug23", "Black", "White", "Kart", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2419,
			name: "Stopwatch Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 11,
				tags: ["Newsletter", "Aug23", "White", "Clock", "Kart"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2420,
			name: "Shy Egg Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 12,
				tags: ["Aug23", "White", "Kart", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2421,
			name: "Banana Peel Stamp",
			price: 1200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 13,
				tags: ["Aug23", "Yellow", "Kart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2422,
			name: "Respawn Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 14,
				tags: ["Aug23", "Mushroom", "Green", "1up", "Kart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2423,
			name: "Om Nom Stamp",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 15,
				tags: ["AugM23", "Drops5", "Yellow", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2424,
			name: "Harrison Cat Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 0,
				tags: ["AugM23", "Drops5", "Thumb", "Black", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2425,
			name: "Flushed Face Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 1,
				tags: ["AugM23", "Drops5", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2426,
			name: "Albino Snake Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 2,
				tags: ["AugM23", "Drops5", "Grey", "Gray", "ABHS"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2427,
			name: "Shell Wiki Stamp",
			price: 3210,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 3,
				tags: ["AugM23", "Drops5", "Egg", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2428,
			name: "Wiz Ears Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 4,
				tags: ["AugM23", "Drops5", "Blue", "BWD", "AprM24", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2429,
			name: "r/place Pablo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 5,
				tags: ["AugM23", "Drops5", "Yellow", "Orange", "Smile"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2430,
			name: "r/place BWD skull Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 6,
				tags: ["AugM23", "Drops5", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2431,
			name: "r/place BWD logo Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 7,
				tags: ["AugM23", "Drops5", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2432,
			name: "Solve for X Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 8,
				tags: ["Sep23", "Pencil3", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2433,
			name: "Anarchy Academy",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 9,
				tags: ["Sep23", "Pencil3", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2434,
			name: "Egg-lectrons Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 10,
				tags: ["Sep23", "Pencil3", "Science", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2435,
			name: "Blue Wizard Wrestling Federation Logo",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 12,
				tags: ["SepM23", "WBros", "Wrestle", "BWD", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2436,
			name: "Bron Lester Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 13,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2437,
			name: "Jan Seeya Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 14,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2438,
			name: "Rocky Star Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 15,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2439,
			name: "Brogan Paw Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 0,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2440,
			name: "Romeo Rain Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 1,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2441,
			name: "Nacho Mann Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 2,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2442,
			name: "Death Brawlin Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 3,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2443,
			name: "Bulk Logan Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 4,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2444,
			name: "Ray Mystery Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 5,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2445,
			name: "Binky Flinch Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 6,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2446,
			name: "Bonka Beware Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 7,
				tags: ["SepM23", "WBros", "Wrestle"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2447,
			name: "Wrestlebros 1v1 Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 11,
				tags: ["SepM23", "WBros", "Blue", "Purple"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2448,
			name: "Rotting Zombie Fish Stamp",
			price: 1750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 8,
				tags: ["Oct23", "Halloween4", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2449,
			name: "Shark Chomp Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 9,
				tags: ["Oct23", "Halloween4", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2450,
			name: "Squiddy Friend Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 10,
				tags: ["Oct23", "Halloween4", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2451,
			name: "Venomous Sea Snake Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 11,
				tags: ["Oct23", "Halloween4", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2452,
			name: "Bait Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 12,
				tags: ["Oct23", "Halloween4", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2453,
			name: "Wilson. Wilson... WILSON!",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 13,
				tags: ["Oct23", "Halloween4", "Red", "Hand"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2454,
			name: "Demonic Face Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 14,
				tags: ["Oct23", "Face", "bun_demon"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2455,
			name: "Boo Crew Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 15,
				tags: ["OctM23", "Text", "Purple"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2456,
			name: "Cool Maid Face",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 0,
				tags: ["OctM23", "Face"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2457,
			name: "Ghoul Power Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 1,
				tags: ["OctM23", "Text", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2458,
			name: "Ghost Malone",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 2,
				tags: ["OctM23", "Meme", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2459,
			name: "Seen too much Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 3,
				tags: ["OctM23", "Purple", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2460,
			name: "Pumpkin Wizard Digital",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 4,
				tags: ["OctM23", "Orange", "BWD", "Infinite Smasher"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2461,
			name: "Get Ghosted Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 5,
				tags: ["OctM23", "Black", "Ghost", "Text"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2462,
			name: "Sacred Sun Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 6,
				tags: ["Nov23", "Mayan", "Calendar", "Red", "Yellow", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2463,
			name: "Sea to Sun Totem Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 7,
				tags: ["Nov23", "Mayan", "Red", "Orange", "Blue", "Eye", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2464,
			name: "Ancient Skull Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 8,
				tags: ["Nov23", "Mayan", "Bone", "Yellow", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2465,
			name: "Snake Deity Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 9,
				tags: ["Nov23", "Mayan", "Green", "Snek", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2466,
			name: "Raven Lord Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 10,
				tags: ["Nov23", "Mayan", "Black", "Nevermore", "Oct24", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2467,
			name: "Tepey\xf3llotl Stamp",
			price: 5e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 11,
				tags: ["Nov23", "Mayan", "Leopard", "Orange", "bun_mayan", "May25", "premFeatOne"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2468,
			name: "Give Thanksing Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 12,
				tags: ["NovM23", "Text", "Thanksgiving3", "Orange", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2469,
			name: "Football Turkey Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 13,
				tags: ["NovM23", "Thanksgiving3", "Brown", "Basted"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2470,
			name: "Basted Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 14,
				tags: ["NovM23", "Thanksgiving3", "Yellow", "Text"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2471,
			name: "Feast Mode Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 15,
				tags: ["NovM23", "Thanksgiving3", "Red", "Text"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2472,
			name: "HoHoHo Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 3,
				tags: ["Dec23", "Christmas3", "Red", "Green", "Text", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2473,
			name: "Nice Egg Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 1,
				tags: ["Dec23", "Christmas3", "Red", "Green", "Text", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2474,
			name: "Naughty Egg Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 0,
				tags: ["Dec23", "Christmas3", "Pink", "Purple", "Text", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2475,
			name: "Big Baubles Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 2,
				tags: ["Dec23", "Christmas3", "Red", "Green", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2476,
			name: "New Year 2024 Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 6,
				tags: ["NewYears", "DecM23", "2024", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2477,
			name: "Out with the Old",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 4,
				tags: ["NewYears", "DecM23", "2024", "Blue", "White", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2478,
			name: "In with the New",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 5,
				tags: ["NewYears", "DecM23", "2024", "Blue", "White", "DecM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2479,
			name: "Yolk Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 8,
				tags: ["JanM24", "Text", "Racer", "Grey", "Gray", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2480,
			name: "Crown Stamp",
			price: 25e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 9,
				tags: ["JanM24", "Winner", "Racer", "Gold", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2481,
			name: "Stop Healing Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 10,
				tags: ["JanM24", "Winner", "Racer"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2482,
			name: "Chinese Egg Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 11,
				tags: ["JanM24", "Purple", "Yellow", "Text", "Racer"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2483,
			name: "Pireggi Logo",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 7,
				tags: ["JanM24", "Text", "Black", "Pireggi"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2484,
			name: "Deez Acorns",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 12,
				tags: ["Feb24", "Nuts", "Nutz", "Brown", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2485,
			name: "Cute Bear Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 13,
				tags: ["Feb24", "Tongue", "Face", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2486,
			name: "Truth or Deer Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 14,
				tags: ["Feb24", "Text", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2487,
			name: "Cute Owl Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 15,
				tags: ["Feb24", "Face", "Who", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2488,
			name: "Cupid Squee Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 16,
				tags: ["Feb24", "Pink", "Red", "Face", "bun_cupid"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2489,
			name: "Kyler Bappy",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2490,
			name: "Nay Moore",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2491,
			name: "Davey Bendem",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2492,
			name: "Meggy Repo",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2493,
			name: "Lion Messy",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2494,
			name: "Chris Ronald",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2495,
			name: "SUUIII",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 16,
				tags: ["FebM24", "Player", "Face", "Blue", "Sbros", "Ronaldo", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2496,
			name: "Red Card!",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 16,
				tags: ["FebM24", "Foul", "Penalty", "Red", "Sbros"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2497,
			name: "Triskelion Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 16,
				tags: ["Mar24", "StPatricksDay", "Irish", "Celtic", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2498,
			name: "Negative Ward Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 16,
				tags: ["StPatricksDay", "Irish", "Celtic", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2499,
			name: "Celtic Knot Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 16,
				tags: ["StPatricksDay", "Irish", "Celtic", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2500,
			name: "Bad Bunny Patch",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 16,
				tags: ["Mar24", "Rabbit", "Fur", "White", "bun_badbunny"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2501,
			name: "Triquetra Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 16,
				tags: ["StPatricksDay", "Irish", "Celtic", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2502,
			name: "Finest Emeralds",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 16,
				tags: ["StPatricksDay", "Irish", "Celtic", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2503,
			name: "Lucky Horseshoe Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 16,
				tags: ["StPatricksDay", "Irish", "Celtic", "Green", "Gold", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2504,
			name: "Gang Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 16,
				tags: ["Clan", "Mar24"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2505,
			name: "Wooly Beard",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 16,
				tags: ["Future"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2506,
			name: "Jelly Beanz!",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 16,
				tags: ["MarM24", "Easter", "Food", "Rainbow", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2507,
			name: "Full of Eggs Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 16,
				tags: ["MarM24", "Easter", "Food", "Rainbow", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2508,
			name: "Chocolate Egg",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 16,
				tags: ["MarM24", "Easter", "Food", "Brown", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2509,
			name: "Candy Coma Bunny Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 16,
				tags: ["MarM24", "Easter", "Food", "Rabbit", "White", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2510,
			name: "Outta Chocolate Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 16,
				tags: ["MarM24", "Easter", "Food", "Rabbit", "Face", "Brown", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2511,
			name: "E&E stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 16,
				tags: ["MarM24", "Easter", "Text", "Food", "Brown", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2512,
			name: "Recycled Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 16,
				tags: ["MarM24", "Default", "Green", "Symbol"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2513,
			name: "Yum Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 16,
				tags: ["MarM24", "Default", "Emoji", "Tongue", "Yellow"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2514,
			name: "Moai Stamp",
			price: 0,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 16,
				tags: ["MarM24", "Default", "Emoji", "Easter", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 2515,
			name: "Cyborg Bear Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 16,
				tags: ["Apr24", "Brown", "RotR"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2516,
			name: "Resistance is Futile Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 16,
				tags: ["Apr24", "Text", "RotR"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2517,
			name: "Cyborg Wiz Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 16,
				tags: ["Apr24", "Blue", "RotR", "Purple", "Blurple"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2518,
			name: "Cyborg Scared Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 16,
				tags: ["Apr24", "Gray", "Thee_Owl", "RotR", "Grey", "Face", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2519,
			name: "Cyborg Angry Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 16,
				tags: ["Apr24", "Gray", "Thee_Owl", "RotR", "Grey", "Face", "Red", "bun_borg"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2520,
			name: "Rise of the Robots Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 17,
				tags: ["Apr24", "Yellow", "RotR", "Blue", "Text", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2521,
			name: "Cut Diamond Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 17,
				tags: ["Apr24", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2522,
			name: "Mecha-Nate Down Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 17,
				tags: ["Apr24", "Face", "Red", "Mouth", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2523,
			name: "Mecha-Nate Up Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 17,
				tags: ["Apr24", "Face", "Green", "Mouth", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2524,
			name: "Mecha-Nate Squaree Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 17,
				tags: ["Apr24", "Punchable", "Face", "White", "Mouth", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2525,
			name: "Mecha-Nate Creep Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 17,
				tags: ["Apr24", "Face", "White", "Mouth", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2526,
			name: "Mecha-Nate Suckerguy Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 17,
				tags: ["Apr24", "Face", "White", "Mouth", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2527,
			name: "Mecha-Nate Bottle Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 17,
				tags: ["Apr24", "Alien", "Green", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2528,
			name: "Mecha-Nate Moai Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 17,
				tags: ["Apr24", "Stone", "Gray", "Grey", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2529,
			name: "Mecha-Nate Gurfield Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 17,
				tags: ["Apr24", "Cat", "Face", "White", "RotR"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2530,
			name: "Joining Forces",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 17,
				tags: ["Apr24", "Pablo", "Face", "Diablo", "RotR"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2531,
			name: "Shell Shockers Cyborged Logo",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 17,
				tags: ["Apr24", "Text", "Logo", "RotR"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2532,
			name: "Mount Rushmore Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 17,
				tags: ["AprM24", "Pablo", "Rock", "Smile", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2533,
			name: "Bald Meno Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 17,
				tags: ["AprM24", "Face", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2534,
			name: "Oink Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 17,
				tags: ["May24", "Farm", "Pink", "Text", "Pig"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2535,
			name: "Moo Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 17,
				tags: ["May24", "Farm", "Black", "White", "Text", "Cow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2536,
			name: "Quack Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 17,
				tags: ["May24", "Farm", "White", "Yellow", "Text", "Duck"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2537,
			name: "Scarecrow Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 17,
				tags: ["May24", "Farm", "Face", "Yellow", "Brown", "Badoi"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2538,
			name: "Farm Life Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 17,
				tags: ["May24", "Farm", "Yellow", "Text", "Eat", "Sleep", "Repeat"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2539,
			name: "Farm Tools Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 17,
				tags: ["May24", "Farm", "Brown", "Silver", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2540,
			name: "Robots Defeated Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 17,
				tags: ["May24", "Red", "Black", "Eye", "EGGORG"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2541,
			name: "USDA Organic",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 1,
				tags: ["May24", "Farm", "Newsletter", "Text"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2542,
			name: "Shell Leaks Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 17,
				tags: ["May24", "Community", "Egg"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2543,
			name: "Clucky Charms",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 17,
				tags: ["MayM24", "Rooster", "Wizard", "Chicken&Waffles", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2544,
			name: "Toast Ghost",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 17,
				tags: ["MayM24", "Bread", "White", "Brown", "Chicken&Waffles", "OctM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2545,
			name: "Breakfast of Champions",
			price: 5e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 17,
				tags: ["MayM24", "Trophy", "Egg", "Gold", "Blue", "Chicken&Waffles"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2546,
			name: "Caffeine Rush",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 17,
				tags: ["MayM24", "Egg", "Face", "White", "Chicken&Waffles"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2547,
			name: "Skipped Breakfast",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 17,
				tags: ["MayM24", "Chicken", "Face", "White", "Chicken&Waffles"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2548,
			name: "Chicken & Waffles",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 17,
				tags: ["MayM24", "Chicken", "Face", "White", "Chicken&Waffles"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2549,
			name: "Ant Face Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 17,
				tags: ["Jun24", "Eyes", "Face", "Brown", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2550,
			name: "Worker Bee Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 17,
				tags: ["Jun24", "Eyes", "Yellow", "Black", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2551,
			name: "Spider Web Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 17,
				tags: ["Jun24", "Black", "Bugs", "bun_arach"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2552,
			name: "Spider Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 17,
				tags: ["Jun24", "Eyes", "Face", "Red", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2553,
			name: "Grasshopper Face Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 18,
				tags: ["Jun24", "Eyes", "Face", "Blue", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2554,
			name: "Fly Eyes Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 18,
				tags: ["Jun24", "Eyes", "Face", "Red", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2555,
			name: "Catapiller Stamp",
			price: 300,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 18,
				tags: ["Jun24", "Eyes", "Egg", "Green", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2556,
			name: "Dill With It Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 18,
				tags: ["JunM24", "Text", "Pickle", "Green", "Blue", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2557,
			name: "Shell Yeah Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 18,
				tags: ["JunM24", "Text", "Blue", "Summer"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2558,
			name: "Wiffle Ball Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 18,
				tags: ["JunM24", "Purple", "Blue", "Blurple", "Sports"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2559,
			name: "Summer Vibes Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 18,
				tags: ["JunM24", "Pink", "Text", "Summer"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2560,
			name: "SL MVP 2024+ Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 18,
				tags: ["July24", "Purple", "Text", "League"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2561,
			name: "Chess Clock Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 18,
				tags: ["July24", "Newsletter", "Brown", "Chess"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2562,
			name: "Tactical Pawns Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 18,
				tags: ["July24", "Bundle", "Chess", "bun_tactic"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2563,
			name: "Magnus Stamp",
			price: 1e4,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 18,
				tags: ["July24", "Face", "Chess", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2564,
			name: "Checkmate Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 18,
				tags: ["July24", "Text", "Chess"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2565,
			name: "Short King",
			price: 5800,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 18,
				tags: ["July24", "Text", "Chess", "Wizups"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2566,
			name: "Knight Moves",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 18,
				tags: ["July24", "Text", "Chess", "Night"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2567,
			name: "Botez Gambit",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 18,
				tags: ["July24", "Text", "Chess", "Sacrifice"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2568,
			name: "Time Varience Face",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 18,
				tags: ["JulyM24", "Face", "Clock", "Minutes"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2569,
			name: "Deadpond Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 18,
				tags: ["JulyM24", "Face", "Black", "Eyes"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2570,
			name: "Claw Slash Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 18,
				tags: ["JulyM24", "Claws", "Wolverine", "X", "Eggx-men"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2571,
			name: "Eggx-Men Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 18,
				tags: ["JulyM24", "Text", "Logo", "X", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2572,
			name: "Maximum Effort Stamp",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 18,
				tags: ["JulyM24", "Text", "Deadpond", "Deadpool", "Red", "Face"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2573,
			name: "Take me to your Leader",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 18,
				tags: ["Aug24", "Text", "Alien", "Galeggsy", "White", "Yellow", "bun_zorg"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2574,
			name: "Peeking Alien Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 18,
				tags: ["Aug24", "Eyes", "Egg", "White", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2575,
			name: "Three eyes Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 18,
				tags: ["Aug24", "Eyes", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2576,
			name: "Gray Space Alien Face",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 18,
				tags: ["Aug24", "Eyes", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2577,
			name: "Alien Side Eye",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 18,
				tags: ["Aug24", "Eyes", "Green", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2578,
			name: "Eggventure Jeep Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 18,
				tags: ["AugM24", "White", "Kart", "Jun25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2579,
			name: "Dino Derby Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 18,
				tags: ["AugM24", "White", "Kart", "Text", "Logo", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2580,
			name: "Gryffinhatch House",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 18,
				tags: ["Sep24", "EggyP", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2581,
			name: "Ravencluck House",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 18,
				tags: ["Sep24", "EggyP", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2582,
			name: "Slytheregg House",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 18,
				tags: ["Sep24", "EggyP", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2583,
			name: "Hugglepeck House",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 18,
				tags: ["Sep24", "EggyP", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2584,
			name: "Shellshriek Face",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 18,
				tags: ["Sep24", "EggyP", "Eyes", "Teeth", "bun_plant"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2585,
			name: "Platform 9 3/4 Stamp",
			price: 9340,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 19,
				tags: ["Sep24", "EggyP", "Text", "Red", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2586,
			name: "Pixel Football Stamp",
			price: 100,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 19,
				tags: ["SepM24", "Fbros", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2587,
			name: "Football Bros Logo Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 19,
				tags: ["SepM24", "Fbros", "Text", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2588,
			name: "Quarterback Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 19,
				tags: ["SepM24", "Fbros", "Red", "Football"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2589,
			name: "Neon Chicken Breast",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 19,
				tags: ["Oct24", "Halloween5", "Bones", "Purple"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2590,
			name: "Flock of the Damned",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 19,
				tags: ["Oct24", "Halloween5", "Text", "Wings", "Silver", "Grey", "Gray", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2591,
			name: "Zombozo",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 19,
				tags: ["Oct24", "Halloween5", "Brown", "White", "Beak", "Eye"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2592,
			name: "Dovely face",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 19,
				tags: ["Oct24", "Halloween5", "Brown", "White", "Beak", "Eye", "bun_dove"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2593,
			name: "Eggar Allen Poe",
			price: 2500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 19,
				tags: ["OctM24", "Halloween5", "Face", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2594,
			name: "Shellraiser Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 19,
				tags: ["OctM24", "Halloween5", "Text", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2595,
			name: "Peek-a-BOO Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 19,
				tags: ["OctM24", "Halloween5", "Text", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2596,
			name: "Trigger Warning Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 19,
				tags: ["Nov24", "SC2", "Text", "Red", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2597,
			name: "Killer Fridge Faded Face Stamp",
			price: 3e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 19,
				tags: ["Nov24", "SC2", "Face", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2598,
			name: "Damaged Target Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 19,
				tags: ["Nov24", "SC2", "Yellow", "Black", "Yolk"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2599,
			name: "Swamp Thing Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 19,
				tags: ["Nov24", "SC2", "Face", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2600,
			name: "Now on Steam Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 19,
				tags: ["Nov24", "SC2", "Text", "Black", "Logo", "Gear"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2601,
			name: "Mad Mouth Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 19,
				tags: ["Nov24", "SC2", "Teeth", "Black", "White", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2602,
			name: "Slayaway Camp 2 Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 19,
				tags: ["Nov24", "SC2", "Logo", "Text", "Black", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2603,
			name: "Killer Fridge Face Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 19,
				tags: ["Nov24", "SC2", "Face", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2604,
			name: "Terrortube Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 19,
				tags: ["Nov24", "SC2", "Text", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2605,
			name: "Honey Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 19,
				tags: ["NovM24", "Thanksgiving4", "Food", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2606,
			name: "Jam Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 19,
				tags: ["NovM24", "Thanksgiving4", "Food", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2607,
			name: "Gnome Gnose Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 19,
				tags: ["Dec24", "Christmas4", "White", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2608,
			name: "Sleigh Me Stamp",
			price: 1250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 19,
				tags: ["Dec24", "Thanksgiving4", "Text", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2609,
			name: "LCC stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 19,
				tags: ["League", "Community", "Text", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2610,
			name: "New Year 2025 Stamp",
			price: 2e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 19,
				tags: ["NewYears", "DecM24", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2611,
			name: "Algebruh Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 19,
				tags: ["JanM25", "Red", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2612,
			name: "Fractal Target Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 19,
				tags: ["JanM25", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2613,
			name: "Perfectly Balanced Stamp",
			price: 1500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 28,
				y: 19,
				tags: ["JanM25", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2614,
			name: "I love Feesh Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 29,
				y: 19,
				tags: ["Feb25", "Pink", "Fish", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2615,
			name: "I'm Hooked Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 30,
				y: 19,
				tags: ["Feb25", "Green", "Fish", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2616,
			name: "Swedish Fish Stamp",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 31,
				y: 19,
				tags: ["Feb25", "Sweet", "Red", "Fish", "Candy"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2617,
			name: "Heart Shaped Box Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 0,
				y: 20,
				tags: ["Feb25", "Sweet", "Red", "White", "Candy"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2618,
			name: "Zaxonius Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 1,
				y: 20,
				tags: ["FebM25", "Drops7", "D7W2", "Pink", "Purple"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2619,
			name: "The Pixel Fox",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 2,
				y: 20,
				tags: ["FebM25", "Drops7", "Orange", "Eye"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2620,
			name: "PLANS Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 3,
				y: 20,
				tags: ["FebM25", "Drops7", "D7W1", "Egg", "White", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2621,
			name: "Angry Snipes Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 4,
				y: 20,
				tags: ["FebM25", "Drops7", "Blue", "Crackshot"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2622,
			name: "Grotesque Grin Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 5,
				y: 20,
				tags: ["FebM25", "Drops7", "D7W1", "Face", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2623,
			name: "Grotesque Grief Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 6,
				y: 20,
				tags: ["FebM25", "Drops7", "D7W2", "Face", "Black"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2624,
			name: "#Blame Harrison",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 7,
				y: 20,
				tags: ["FebM25", "Drops7", "D7W2", "Face", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2625,
			name: "Shamrocked Stamp",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 8,
				y: 20,
				tags: ["Mar25", "StPatricksDay", "Clover", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2627,
			name: "Easter Island",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 9,
				y: 20,
				tags: ["MarM25", "Text", "Orange"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2628,
			name: "Dwarf #8",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 10,
				y: 20,
				tags: ["MarM25", "Snow", "White", "Tipsy"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2629,
			name: "The Healer Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 11,
				y: 20,
				tags: ["May25", "Mayan", "Face", "Blue", "Green", "Yellow", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2630,
			name: "The Warrior Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 12,
				y: 20,
				tags: ["May25", "Mayan", "Face", "Blue", "Green", "Yellow", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2631,
			name: "The Trickster Stamp",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 13,
				y: 20,
				tags: ["May25", "Mayan", "Face", "Blue", "Green", "Yellow", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 2632,
			name: "Eggfu Masters Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 14,
				y: 20,
				tags: ["May25", "EGGORG", "Faction"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2633,
			name: "Eggsassin Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 15,
				y: 20,
				tags: ["May25", "EGGORG", "Faction"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2634,
			name: "Temple of the Sun Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 16,
				y: 20,
				tags: ["May25", "Mayan", "Newsletter", "Pyramid", "Itza"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2635,
			name: "Stressed Out Driver Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 17,
				y: 20,
				tags: ["Jun25", "Kartbros", "Face", "Wheel"]
			},
			is_available: !0,
			unlock: "manual"
		}, {
			id: 2636,
			name: "Invader Zip Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 18,
				y: 20,
				tags: ["Jun25", "Kartbros", "Face", "Alien", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2637,
			name: "Miss Meow Stamp",
			price: 750,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 19,
				y: 20,
				tags: ["Jun25", "Kartbros", "Face", "Cat", "Orange"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2638,
			name: "Lightning Bolt Power-up",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 20,
				y: 20,
				tags: ["Jun25", "Kartbros", "Yellow", "Orange"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2639,
			name: "Tornado Power-up",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 21,
				y: 20,
				tags: ["Jun25", "Kartbros", "Blue", "Gray", "Grey", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2640,
			name: "Shield Power-up",
			price: 250,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 22,
				y: 20,
				tags: ["Jun25", "Kartbros", "Blue", "Gray", "Grey", "Silver", "Newsletter"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2641,
			name: "Speed boost Power-up",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 23,
				y: 20,
				tags: ["Jun25", "Kartbros", "Blue", "Orange"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2642,
			name: "Rocket Power-up",
			price: 500,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 24,
				y: 20,
				tags: ["Jun25", "Kartbros", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2643,
			name: "Kart Bros Logo",
			price: 200,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 25,
				y: 20,
				tags: ["Jun25", "Kartbros", "Orange", "Blue", "Text"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 2644,
			name: "Tuff Clan Stamp",
			price: 2147483647,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 26,
				y: 20,
				tags: ["Jun25", "SL", "Community"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 2645,
			name: "Mark Andreggsen",
			price: 1e3,
			item_type_id: 2,
			item_type_name: "Stamp",
			category_name: "Stamps",
			exclusive_for_class: null,
			item_data: {
				x: 27,
				y: 20,
				tags: ["Jun25", "Perm", "Community"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3100,
			name: "The Eggk-47",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47",
				tags: ["default", "Blue", "Purple"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 3101,
			name: "GOLD Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3102,
			name: "Happy Bear Eggk-47",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3103,
			name: "Halloween Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3104,
			name: "Thanksgiving Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3105,
			name: "Christmas Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3106,
			name: "2019 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3107,
			name: "Groundhog Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3108,
			name: "Buck Rogers Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3109,
			name: "Valentines Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3110,
			name: "St Patricks Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3111,
			name: "Easter Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Easter",
				tags: ["Easter", "Red", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3112,
			name: "Flame Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3113,
			name: "Rainbow Eggk-47",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3114,
			name: "Steampunk Eggk-47",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3115,
			name: "Memphis Eggk-47",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Memphis",
				tags: ["Memphis", "Blue", "Orange", "Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3116,
			name: "Eggwalker Eggk-47",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3117,
			name: "Nuke Zone Eggk-47",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NukeZone",
				tags: ["NukeZone", "Black", "Neon", "Pink"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3118,
			name: "2020 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3119,
			name: "Country Singer Eggk-47",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3120,
			name: "Albino Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3121,
			name: "Raid Land Eggk-47",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_RaidLand",
				tags: ["RaidLand", "Blue", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3122,
			name: "Toxic Eggk-47",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3123,
			name: "Music Eggk-47",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Music",
				tags: ["Rockstar", "JanM23", "Black", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3124,
			name: "Galeggsy Eggk-47",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3125,
			name: "Chicken Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3126,
			name: "Techno Eggk-47",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Techno",
				tags: ["Dec23", "Blue", "Yellow", "Black", "Pog", "DecM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["gun_eggk47_techno"]
		}, {
			id: 3127,
			name: "2021 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3128,
			name: "Car Eggk-47",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_car",
				tags: ["Cars", "Trains", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3129,
			name: "Merc Zone Eggk-47",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3130,
			name: "Summer Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3131,
			name: "Pencil Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Pencil",
				tags: ["Pencil", "Sep23", "Yellow", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3132,
			name: "2022 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3133,
			name: "Cards Eggk-47",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3134,
			name: "Retro Eggk-47",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Retro",
				tags: ["Retro", "Pixel", "FebM23", "Blue", "Purple", "Wings", "DecM23"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_ak_retro"]
		}, {
			id: 3135,
			name: "Dino Eggk-47",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Dino",
				tags: ["Dino", "May23", "Red", "Brown", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3136,
			name: "Valkyrie Eggk-47",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Valkyrie",
				tags: ["Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_ak_valkyrie"]
		}, {
			id: 3137,
			name: "Eggwalker Alt Eggk-47",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3138,
			name: "SPORTS Eggk-47",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Sports",
				tags: ["Sports", "JulyM23", "Brown", "Orange", "Cricket", "Bat", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3139,
			name: "Breakfast Eggk-47",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Breakfast",
				tags: ["Breakfast", "Food", "Brown", "Syrup", "Waffles", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3140,
			name: "2023 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3141,
			name: "Farm Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Farm",
				tags: ["Farm", "FebM23", "Food", "Orange", "Green", "Carrot", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3142,
			name: "Fusion Eggk-47",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Fusion",
				tags: ["Premium", "fusion", "FebM23", "White", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_ak47_fusion"]
		}, {
			id: 3143,
			name: "Hero Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Fantasy",
				tags: ["Heroes", "Apr23", "Sword", "Silver"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3144,
			name: "Monster Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_FantasyEvil",
				tags: ["Monsters", "Apr23", "Purple", "Sword"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3145,
			name: "Equinox Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3146,
			name: "Paintball Eggk-47",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Paintball",
				tags: ["Sports2", "JulyM23", "Grey", "Gray", "Yellow", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3147,
			name: "Kart Eggk-47",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Kart",
				tags: ["Kart", "Aug23", "Blue", "Green", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3148,
			name: "BWD Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Wizard",
				tags: ["Drops5", "AugM23", "Blue", "Brown", "Crystal"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3149,
			name: "Infernal Eggk-47",
			price: 4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Infernal",
				tags: ["OctM23", "Infernal", "Black", "Orange", "Red", "Grey", "Gray", "Burn"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_ak_infernal"]
		}, {
			id: 3150,
			name: "Ancient Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3151,
			name: "Holideggs Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3152,
			name: "2024 Eggk-47",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2024",
				tags: ["DecM23", "NewYears", "2024", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3153,
			name: "Racer Eggk-47",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3154,
			name: "Chocolate Eggk-47",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Chocolate",
				tags: ["MarM24", "Brown", "Gold", "MarM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_ak_choc"]
		}, {
			id: 3155,
			name: "Mecha-Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Steambot",
				tags: ["Apr24", "Brown", "Gold", "Premium"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3156,
			name: "MenoXD Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Meno",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3157,
			name: "Alien Eggk-47",
			price: 5e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Alien",
				tags: ["Aug24", "Perm", "Premium", "eggyp"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3158,
			name: "Spore Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3159,
			name: "2025 Eggk-47",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_NewYear2025",
				tags: ["NewYears", "DecM24", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3160,
			name: "Sleigh Eggk-47",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_Christmas",
				tags: ["Newsletter", "Gift", "DecM24", "Gold", "Red"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3161,
			name: "Golden Dragon Eggk-47",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Soldier Primary Weapons",
			exclusive_for_class: 0,
			item_data: {
				meshName: "gun_eggk47_dragongold",
				tags: ["EGGORG", "Shadows", "Apr25", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3400,
			name: "The Free Ranger",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1",
				tags: ["default", "Orange", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 3401,
			name: "GOLD Free Ranger",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3402,
			name: "Happy Bear Free Ranger",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3403,
			name: "Halloween Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3404,
			name: "Thanksgiving Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3405,
			name: "Christmas Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3406,
			name: "2019 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3407,
			name: "Groundhog Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3408,
			name: "Buck Rogers Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3409,
			name: "Valentines Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3410,
			name: "St Patricks Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3411,
			name: "Easter Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Easter",
				tags: ["Easter", "Blue", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3412,
			name: "Flame Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3413,
			name: "Rainbow Free Ranger",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3414,
			name: "Steampunk Free Ranger",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3415,
			name: "Memphis Free Ranger",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Memphis",
				tags: ["Memphis", "Blue", "Orange", "Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3416,
			name: "Eggwalker Free Ranger",
			price: 3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_spaceEgg",
				tags: ["sale", "Eggwalker", "July23", "Black", "Grey", "Gray", "Yellow", "MarM24", "Welcome", "Bundle"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_csg1_space"]
		}, {
			id: 3417,
			name: "Nuke Zone Free Ranger",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NukeZone",
				tags: ["NukeZone", "Yellow", "Black", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3418,
			name: "2020 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3419,
			name: "Country Singer Free Ranger",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3420,
			name: "Albino Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3421,
			name: "Raid Land Free Ranger",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_RaidLand",
				tags: ["RaidLand", "Blue", "Yellow", "Brown", "Wings"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3422,
			name: "Toxic Free Ranger",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3423,
			name: "Music Free Ranger",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Music",
				tags: ["Rockstar", "JanM23", "Black", "Guitar", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3424,
			name: "Galeggsy Free Ranger",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3425,
			name: "Chicken Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3426,
			name: "Techno Free Ranger",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Techno",
				tags: ["Premium", "Techno", "Cats", "Catz", "Purple", "Yellow", "Black", "AprM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_csg1_techno"]
		}, {
			id: 3427,
			name: "2021 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3428,
			name: "Car Free Ranger",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_car",
				tags: ["Cars", "Trains", "Red", "Firetruck"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3429,
			name: "Merc Zone Free Ranger",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3430,
			name: "Summer Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3431,
			name: "Retro Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Retro",
				tags: ["Retro", "Premium", "Pixel", "Green", "Wings", "JanM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_csg1_retro"]
		}, {
			id: 3432,
			name: "Pencil Free Ranger",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Pencil",
				tags: ["Pencil", "Sep23", "Yellow", "Paintbrush", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3433,
			name: "2022 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3434,
			name: "BWD Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Wizard",
				tags: ["Drops", "Blue", "Brown", "Crystal"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3435,
			name: "Cards Free Ranger",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3436,
			name: "Dino Free Ranger",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Dino",
				tags: ["Dino", "May23", "Green", "Orange", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3437,
			name: "Eggpire Free Ranger",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3438,
			name: "SPORTS Free Ranger",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Sports",
				tags: ["Sports", "JulyM23", "Brown", "White", "Baseball", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3439,
			name: "Rubber Chicken Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_RubberChicken",
				tags: ["Aug23", "Yellow", "MayM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_csg1_rubchick"]
		}, {
			id: 3440,
			name: "Breakfast Free Ranger",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Breakfast",
				tags: ["Breakfast", "Food", "Toast", "Brown", "Eggs", "Bread", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3441,
			name: "Valkyrie Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Valkyrie",
				tags: ["Valkyrie", "Premium", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_range_valk"]
		}, {
			id: 3442,
			name: "2023 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3443,
			name: "Fusion Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Fusion",
				tags: ["Premium", "JanM23", "White", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_csg1_fusion"]
		}, {
			id: 3444,
			name: "Farm Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Farm",
				tags: ["Farm", "FebM23", "Food", "Yellow", "Green", "Corn", "May24", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3445,
			name: "Shellpreme Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Shellpreme",
				tags: ["MayM23", "Eggflation", "Premium", "Red", "Sep24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_csg1_shellpreme"]
		}, {
			id: 3446,
			name: "Equinox Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3447,
			name: "Kart Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Kart",
				tags: ["Aug23", "Kart", "Red", "Blue", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3448,
			name: "lifeofnurse Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Nurse",
				tags: ["AugM23", "Drops5", "Blue", "Purple", "Heart"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3449,
			name: "Bone Free Ranger",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Bones",
				tags: ["OctM23", "Halloween4", "Bone", "White", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3450,
			name: "Ancient Free Ranger",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3451,
			name: "Holideggs Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3452,
			name: "2024 Free Ranger",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2024",
				tags: ["DecM23", "2024", "NewYears", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3453,
			name: "Sleigh Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Christmas",
				tags: ["DecM23", "Newsletter", "Gold", "Green", "Red"]
			},
			is_available: !0,
			unlock: "manual"
		}, {
			id: 3454,
			name: "Racer Free Ranger",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3455,
			name: "Infernal Free Ranger",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Infernal",
				tags: ["JanM24", "Infernal", "Black", "Orange", "Red", "Grey", "Gray", "Burn"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_csg1_infernal"]
		}, {
			id: 3456,
			name: "Mecha-Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Steambot",
				tags: ["JanM24", "RotR", "Orange", "Apr24", "Premium"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3457,
			name: "Grasshopper Free Ranger",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Bugs",
				tags: ["Jun24", "Bugs", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3458,
			name: "Spore Free Ranger",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3459,
			name: "2025 Free Ranger",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_NewYear2025",
				tags: ["DecM24", "New Years", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3460,
			name: "Green Snake Free Ranger",
			price: 15e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_SnakePatrick",
				tags: ["Mar25", "StPatricksday", "Green", "White", "Yellow", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3461,
			name: "Golden Dragon Free Ranger",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Ranger Primary Weapons",
			exclusive_for_class: 2,
			item_data: {
				meshName: "gun_csg1_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3600,
			name: "The Scrambler",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge",
				tags: ["default", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 3601,
			name: "GOLD Scrambler",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3602,
			name: "Happy Bear Scrambler ",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3603,
			name: "Halloween Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3604,
			name: "Thanksgiving Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3605,
			name: "Christmas Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3606,
			name: "2019 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3607,
			name: "Groundhog Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3608,
			name: "Buck Rogers Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3609,
			name: "Valentines Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3610,
			name: "St Patricks Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3611,
			name: "Easter Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Easter",
				tags: ["Easter", "Yellow", "Green", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3612,
			name: "Flame Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3613,
			name: "Rainbow Scrambler",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3614,
			name: "Steampunk Scrambler",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3615,
			name: "Memphis Scrambler",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Memphis",
				tags: ["Memphis", "Yellow", "Green", "Black", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3616,
			name: "Eggwalker Scrambler",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3617,
			name: "Nuke Zone Scrambler",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NukeZone",
				tags: ["NukeZone", "Black", "Blue", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3618,
			name: "2020 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3619,
			name: "Country Singer Scrambler",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3620,
			name: "Albino Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3621,
			name: "Raid Land Scrambler",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_RaidLand",
				tags: ["RaidLand", "Brown", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3622,
			name: "Toxic Scrambler",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3623,
			name: "Music Scrambler",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Music",
				tags: ["Rockstar", "JanM23", "Red", "Gold", "Guitar", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3624,
			name: "Galeggsy Scrambler",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3625,
			name: "Killstreak Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Killstreak",
				tags: ["Killstreak", "Smile", "Yellow", "Brown", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3626,
			name: "Chicken Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3627,
			name: "Techno Scrambler",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Techno",
				tags: ["Techno", "premium", "SepM23", "Badoosh", "Red", "Purple", "Black"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["gun_gauge_techno"]
		}, {
			id: 3628,
			name: "2021 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3629,
			name: "Car Scrambler",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_car",
				tags: ["Cars", "Trains", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3630,
			name: "Merc Zone Scrambler",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Orange"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3631,
			name: "Summer Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3632,
			name: "Pencil Scrambler",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Pencil",
				tags: ["Pencil", "Sep23", "Highlighter", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3633,
			name: "BWD Fan-art Scrambler",
			price: 15e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_BWD",
				tags: ["Kids", "Wizard", "Blue", "Rainbow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3634,
			name: "Retro Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Retro",
				tags: ["Retro", "Premium", "Pixel", "Grey", "Gray", "Orange", "Wings", "Mar24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_crack_retro"]
		}, {
			id: 3635,
			name: "2022 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3636,
			name: "Thee_Owl Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_TheeOwl",
				tags: ["Relic", "Drops2", "Twitch", "Green", "Fingers"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3637,
			name: "Basket Bros Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Basketball",
				tags: ["BBros", "JulyM23", "Orange", "Hoops", "FebM24", "JunM24", "Jun25", "premFeatTwo"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_bros"]
		}, {
			id: 3638,
			name: "Cards Scrambler",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3639,
			name: "JWBerry3D Scrambler",
			price: 75e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_JWBerry",
				tags: ["Relic", "Black", "Red", "Glasses"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3640,
			name: "Dino Scrambler",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Dino",
				tags: ["Dino", "May23", "Blue", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3641,
			name: "Eggpire Scrambler",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3642,
			name: "Valkyrie Scrambler",
			price: 3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Valkyrie",
				tags: ["Eggwalker2", "Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_valk"]
		}, {
			id: 3643,
			name: "SPORTS Scrambler",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Sports",
				tags: ["Sports", "JulyM23", "Black", "White", "Green", "Soccer", "Football", "FebM24", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3644,
			name: "Breakfast Scrambler",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Breakfast",
				tags: ["Breakfast", "Food", "Red", "Ketchup", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3645,
			name: "Sharkbucks Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Sharkbucks",
				tags: ["Sep22", "Drops3", "Blue", "Smile"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3646,
			name: "Kilzomatic Scrambler",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Kilzomatic",
				tags: ["Sep22", "Blue", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3647,
			name: "Badegg Scrambler",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Badegg",
				tags: ["Badegg", "Red", "Yellow", "DecM23"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3648,
			name: "2023 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3649,
			name: "Sleigh Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Christmas",
				tags: ["Christmas2", "Newsletter", "Red", "White", "Gold", "Sleigh"]
			},
			is_available: !0,
			unlock: "manual"
		}, {
			id: 3650,
			name: "Octopus Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Octopus",
				tags: ["JanM23", "Oct23", "Blue", "Pink"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_octopus"]
		}, {
			id: 3651,
			name: "Farm Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Farm",
				tags: ["Farm", "FebM23", "Yellow", "Gold", "Wheat", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3652,
			name: "BWD Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Wizard",
				tags: ["Drops4", "Mar23", "Blue", "Brown", "Crystal"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3653,
			name: "Green Snake Scrambler",
			price: 15e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_SnakePatrick",
				tags: ["Mar23", "StPatricksDay", "Snek", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3654,
			name: "Beholder Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Fantasy",
				tags: ["Monsters", "Apr23", "Purple", "Yellow", "Eyes", "Apr24", "Apr25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_monster"]
		}, {
			id: 3655,
			name: "Fusion Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Fusion",
				tags: ["Premium", "MidM23", "Fusion", "White", "Blue", "Grey", "Gray", "bun_zorg"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_fusion"]
		}, {
			id: 3656,
			name: "Equinox Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3657,
			name: "Kart Scrambler",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Kart",
				tags: ["Aug23", "Kart", "Blue", "Green", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3658,
			name: "Ancient Scrambler",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3659,
			name: "Holideggs Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3660,
			name: "2024 Scrambler",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2024",
				tags: ["DecM23", "2024", "NewYears", "White", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3661,
			name: "Racer Scrambler",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3662,
			name: "Cloudkicker Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Clouds",
				tags: ["Feb24", "Clouds", "White", "Rainbow", "Feb25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_cloud"]
		}, {
			id: 3663,
			name: "Irish Scrambler",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Irish",
				tags: ["Mar24", "StPatricksDay", "Green", "Gold", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_irish"]
		}, {
			id: 3664,
			name: "Mecha-Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Steambot",
				tags: ["Apr24", "RotR", "Premium"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3665,
			name: "Infernal Scrambler",
			price: 4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Infernal",
				tags: ["JulyM24", "Infernal", "Premium", "Red", "Orange", "Black"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gauge_infernal"]
		}, {
			id: 3666,
			name: "Bone Scrambler",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Bones",
				tags: ["OctM24", "Halloween5"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3667,
			name: "Spore Scrambler",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3668,
			name: "2025 Scrambler",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3669,
			name: "Golden Dragon Scrambler",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Scrambler Primary Weapons",
			exclusive_for_class: 1,
			item_data: {
				meshName: "gun_dozenGauge_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3e3,
			name: "The Cluck 9mm",
			price: 0,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm",
				tags: ["Red", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 3001,
			name: "GOLD Cluck 9mm",
			price: 1500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3002,
			name: "Happy Bear Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3003,
			name: "Halloween Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3004,
			name: "Thanksgiving Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3005,
			name: "Christmas Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3006,
			name: "2019 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3007,
			name: "Groundhog Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3008,
			name: "Buck Rogers Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Buck",
				tags: ["Promotional", "Gray", "Grey", "Silver"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3009,
			name: "Valentines Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3010,
			name: "St Patricks Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3011,
			name: "Easter Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Easter",
				tags: ["Easter", "Pink", "Blue", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3012,
			name: "Flame Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3013,
			name: "Rainbow Cluck 9mm",
			price: 1e4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3014,
			name: "Steampunk Cluck 9mm",
			price: 1e4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3015,
			name: "Memphis Cluck 9mm",
			price: 7500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Memphis",
				tags: ["Memphis", "White", "Black", "Pink"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3016,
			name: "Eggwalker Cluck 9mm",
			price: 4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_9mm_space"]
		}, {
			id: 3017,
			name: "Nuke Zone Skin Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NukeZone",
				tags: ["NukeZone", "Yellow", "Black", "Neon"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3018,
			name: "2020 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3019,
			name: "Country Singer Cluck 9mm",
			price: 1e5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3020,
			name: "Albino Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_SnakeAlbino",
				tags: ["EggyCashAlbino", "Snek", "White", "Gray", "Grey", "Red", "ABHS"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3021,
			name: "Raid Land Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_RaidLand",
				tags: ["RaidLand", "Newsletter", "Rabbit", "Wabbit", "Heart", "Green", "Brown", "bun_badbunny"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3022,
			name: "Toxic Cluck 9mm",
			price: 7500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3023,
			name: "Music Cluck 9mm",
			price: 8e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Music",
				tags: ["Rockstar", "JanM23", "Grey", "Gray", "Harmonica", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3024,
			name: "Galeggsy Cluck 9mm",
			price: 7500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3025,
			name: "Techno Cluck 9mm",
			price: 10,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Techno",
				tags: ["AprM23", "Red", "Orange", "Yellow", "Pop", "Black", "SepM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_9mm_techno"]
		}, {
			id: 3026,
			name: "Cubic Castles Cluck 9mm",
			price: 4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_CubicCastles",
				tags: ["CubicCastles", "White", "Black", "Red", "Skull", "Perm"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_ccwand"]
		}, {
			id: 3027,
			name: "Chicken Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3028,
			name: "2021 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3029,
			name: "Retro Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Retro",
				tags: ["Retro", "Premium", "Pixel", "Red", "Gray", "Grey", "Silver", "Wings", "OctM23", "bun_gamer"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_retro_9mm"]
		}, {
			id: 3030,
			name: "Car Cluck 9mm",
			price: 7500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_car",
				tags: ["Cars", "Trains", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3031,
			name: "Merc Zone Cluck 9mm",
			price: 7e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Red"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3032,
			name: "Summer Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3033,
			name: "Lyerpald Cluck 9mm",
			price: 25e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_lyerpald",
				tags: ["Dog", "Grey", "Gray", "Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3034,
			name: "Pencil Cluck 9mm",
			price: 1500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Pencil",
				tags: ["Pencil", "Sep23", "Orange", "Yellow", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3035,
			name: "Devilish Cluck 9mm",
			price: 15e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Devilish",
				tags: ["Kids", "Red", "Black", "Purple", "Fork", "bun_demon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3036,
			name: "Bone Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Bones",
				tags: ["Halloween2", "Oct23", "Oct24", "bun_dove"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3037,
			name: "2022 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3038,
			name: "Sleigh Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Christmas",
				tags: ["Christmas2", "Newsletter", "Red", "Yellow", "Green", "Gold", "Sleigh"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3039,
			name: "Cards Cluck 9mm",
			price: 1520,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Cards",
				tags: ["EGGORG", "Apr23", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3040,
			name: "BWD Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Wizard",
				tags: ["Relic", "Drops2", "Blue", "Brown", "Crystal"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3041,
			name: "Dino Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Dino",
				tags: ["Dino", "May23", "Brown", "Yellow", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3042,
			name: "Eggpire Cluck 9mm",
			price: 12500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3043,
			name: "SPORTS Cluck 9mm",
			price: 2e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Sports",
				tags: ["Sports", "JulyM23", "White", "Bowling", "Pin", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3044,
			name: "Breakfast Cluck 9mm",
			price: 1500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Breakfast",
				tags: ["Breakfast", "Food", "Apple", "Juice", "Red", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3045,
			name: "Valkyrie Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Valkyrie",
				tags: ["Scavenger", "Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_9mm_valk"]
		}, {
			id: 3046,
			name: "Protractor Cluck 9mm",
			price: 1500,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Protractor",
				tags: ["Pencil2", "Sep23", "Grey", "Gray", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3047,
			name: "Badegg Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Badegg",
				tags: ["Badegg", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3048,
			name: "2023 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3049,
			name: "Aquarius Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Aquarius",
				tags: ["Groundhog", "Feb23", "Blue", "Stars", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3050,
			name: "Cloudkicker Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Clouds",
				tags: ["Premium", "Feb23", "Clouds", "Rainbow", "White", "Feb24", "Feb25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_cloud"]
		}, {
			id: 3051,
			name: "Farm Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Farm",
				tags: ["Farm", "FebM23", "Food", "Red", "Tomato", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3052,
			name: "Thee_Owl Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_TheeOwl",
				tags: ["Drops4", "Mar23", "Twitch", "Green", "Fingers"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3053,
			name: "Merc Zone Final Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_MercF",
				tags: ["Merc", "Suit", "Black", "Tie"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3054,
			name: "Fusion Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Fusion",
				tags: ["Premium", "AprM23", "White", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_fusion"]
		}, {
			id: 3055,
			name: "Caught in 4k Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Camera",
				tags: ["Jun23", "Photo", "Smile", "Meme", "FebM24", "DecM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_camera"]
		}, {
			id: 3056,
			name: "Equinox Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3057,
			name: "Kart Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Kart",
				tags: ["Aug23", "Kart", "Red", "Blue", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3058,
			name: "Infernal Cluck 9mm",
			price: 4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Infernal",
				tags: ["MarM24", "Infernal", "Black", "Orange", "Red", "Grey", "Gray", "Burn"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_infernal"]
		}, {
			id: 3059,
			name: "Megaphone Cluck 9mm",
			price: 5,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Megaphone",
				tags: ["Sep23", "Red", "White", "FebM24", "bun_tactic"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_mega"]
		}, {
			id: 3060,
			name: "Mouse Cluck 9mm",
			price: 1e4,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Mouse",
				tags: ["Sep23", "Grey", "Gray", "Yellow", "Cheese", "bun_cat"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3061,
			name: "Ancient Cluck 9mm",
			price: 2e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3062,
			name: "Holideggs Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3063,
			name: "2024 Cluck 9mm",
			price: 3e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2024",
				tags: ["DecM23", "2024", "NewYears", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3064,
			name: "Racer Cluck 9mm",
			price: 25e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3065,
			name: "Soccer Bros Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Soccer",
				tags: ["FebM24", "Sbros", "Sports", "Ball", "Black", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3066,
			name: "Mecha-Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Steambot",
				tags: ["Apr24", "RotR", "Robots", "Premium"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3067,
			name: "Stinkbug Cluck 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Bugs",
				tags: ["Jun24", "Bugs", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3068,
			name: "Spore Cluck 9mm",
			price: 2147483647,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3069,
			name: "2025 Cluck 9mm",
			price: 2e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3070,
			name: "Frostfall 9mm",
			price: 3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_Frostfall",
				tags: ["MarM25", "Permanent", "Blue", "White"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_9mm_frost"]
		}, {
			id: 3071,
			name: "Golden Dragon 9mm",
			price: 5e3,
			item_type_id: 4,
			item_type_name: "Secondary",
			category_name: "Shared Secondary Weapons",
			exclusive_for_class: null,
			item_data: {
				meshName: "gun_cluck9mm_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Yellow", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3800,
			name: "The RPEGG",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg",
				tags: ["default", "Yellow", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 3801,
			name: "GOLD RPEGG",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3802,
			name: "Happy Bear RPEGG",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3804,
			name: "Thanksgiving RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3805,
			name: "Christmas RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3806,
			name: "2019 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3807,
			name: "Groundhog RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3808,
			name: "Buck Rogers RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3809,
			name: "Valentines RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3810,
			name: "St Patricks RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3811,
			name: "Easter RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Easter",
				tags: ["Easter", "Orange", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3812,
			name: "Flame RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3813,
			name: "Rainbow RPEGG",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3814,
			name: "Steampunk RPEGG",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3815,
			name: "Memphis RPEGG",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Memphis",
				tags: ["Memphis", "Black", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3816,
			name: "Halloween Skin RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3817,
			name: "Eggwalker RPEGG",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3818,
			name: "Nuke Zone RPEGG",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NukeZone",
				tags: ["NukeZone", "Black", "Green", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3819,
			name: "2020 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3820,
			name: "Country Singer RPEGG",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3821,
			name: "Albino RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3822,
			name: "Raid Lands RPEGG",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_RaidLand",
				tags: ["RaidLand", "Silver", "Grey", "Gray", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3823,
			name: "Toxic RPEGG",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3824,
			name: "Music RPEGG",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Music",
				tags: ["Rockstar", "JanM23", "Yellow", "Gold", "Tuba", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3825,
			name: "Galeggsy RPEGG",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3826,
			name: "Chicken RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3827,
			name: "2021 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3828,
			name: "Techno RPEGG",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Techno",
				tags: ["Techno", "Premium", "JunM23", "Yeet", "Rainbow", "Red", "Yellow", "Green", "Blue", "Purple"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_rpeggTechno"]
		}, {
			id: 3829,
			name: "Car RPEGG",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_car",
				tags: ["Cars", "Trains", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3830,
			name: "Merc Zone RPEGG",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3831,
			name: "Summer RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3832,
			name: "Pencil RPEGG",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Pencil",
				tags: ["Pencil", "Sep23", "Yellow", "Tape", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3833,
			name: "Bone RPEGG",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Bones",
				tags: ["Halloween2", "Oct23", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3834,
			name: "2022 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3835,
			name: "Retro RPEGG",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Retro",
				tags: ["Retro", "Premium", "Pixel", "Mar23", "Green", "Wings", "July24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_rpegg_retro"]
		}, {
			id: 3836,
			name: "Cards RPEGG",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3837,
			name: "Dino RPEGG",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Dino",
				tags: ["Dino", "May23", "Orange", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3838,
			name: "Eggpire RPEGG",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3839,
			name: "SPORTS RPEGG",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Sports",
				tags: ["Sports", "JulyM23", "Brown", "Football", "JunM24", "Fbros", "SepM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3840,
			name: "Breakfast RPEGG",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Breakfast",
				tags: ["Breakfast", "Food", "Sausage", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3841,
			name: "Scavenger RPEGG",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Scavenger",
				tags: ["Scavenger", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3842,
			name: "Egg Carton RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Eggs",
				tags: ["Sep22", "Drops3", "Purple", "Grey", "Gray", "Food"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3843,
			name: "Valkyrie RPEGG",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Valkyrie",
				tags: ["Valkyrie", "Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_rpegg_valk"]
		}, {
			id: 3844,
			name: "Missile Toe RPEGG",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Christmas",
				tags: ["Christmas2", "Premium", "Red", "White", "Hohoho", "bun_mistle", "Dec24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_rpegg_christ"]
		}, {
			id: 3845,
			name: "2023 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3846,
			name: "Farm RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Farm",
				tags: ["Farm", "FebM23", "Barn", "Red", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3947,
			name: "Equinox RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3948,
			name: "MenoXD RPEGG",
			price: 75e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Meno",
				tags: ["JulyM23", "Red", "Black", "xd"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3949,
			name: "Kart RPEGG",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Kart",
				tags: ["Kart", "Aug23", "Blue", "Green", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3950,
			name: "Thee_Owl RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_TheeOwl",
				tags: ["Drops5", "AugM23", "Twitch", "Green", "Fingers"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3951,
			name: "Fusion RPEGG",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Fusion",
				tags: ["Oct23", "Premium", "Blue", "White", "Gray", "Grey", "bun_borg"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_rpegg_fusion"]
		}, {
			id: 3952,
			name: "Skellington RPEGG",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Skeleton",
				tags: ["OctM23", "Premium", "Black", "White", "Oct24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_rpegg_skele"]
		}, {
			id: 3953,
			name: "Ancient RPEGG",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3954,
			name: "Holideggs RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3955,
			name: "2024 RPEGG",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2024",
				tags: ["DecM23", "2024", "NewYears", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3956,
			name: "Racer RPEGG",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3687,
			name: "Broken item - do not use",
			price: 5e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Pickles",
				tags: ["JunM24", "Food", "Green", "Nobby"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3957,
			name: "Chubby Pickle RPEGG",
			price: 5e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Pickles",
				tags: ["JunM24", "Food", "Green", "Nobby"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 3958,
			name: "Infernal RPEGG",
			price: 3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Infernal",
				tags: ["AugM24", "Infernal", "Black", "Red", "Orange"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_rpegg_infernal"]
		}, {
			id: 3959,
			name: "Spore RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3960,
			name: "2025 RPEGG",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 3961,
			name: "The BFG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_BFG",
				tags: ["DecM24", "NewYears", "Premium", "Big Festive Gun"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3962,
			name: "BWD RPEGG",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Wizard",
				tags: ["FebM25", "Drops7", "D7W1"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 3963,
			name: "The Bouzouki",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_Bouzouki",
				tags: ["Mar25", "StPatrickDay", "Bundle"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 3964,
			name: "Golden Dragon RPEGG",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Eggsploder Primary Weapons",
			exclusive_for_class: 3,
			item_data: {
				meshName: "gun_rpegg_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4e3,
			name: "The Whipper",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg",
				tags: ["default", "Grey", "Gray", "Purple"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 4001,
			name: "GOLD Whipper",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4002,
			name: "Happy Bear Whipper",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4003,
			name: "Halloween Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4004,
			name: "Thanksgiving Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4005,
			name: "Christmas Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4006,
			name: "Timewarp 2019 Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4007,
			name: "Groundhog Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4008,
			name: "Buck Rogers Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4009,
			name: "Valentines Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4010,
			name: "St Patricks Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4011,
			name: "Easter Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Easter",
				tags: ["Easter", "Eggs", "Purple", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4012,
			name: "Flame Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4013,
			name: "Rainbow Whipper",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4014,
			name: "Steampunk Whipper",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4015,
			name: "Memphis Whipper",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Memphis",
				tags: ["Memphis", "White", "Black", "Pink"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4016,
			name: "Eggwalker Whipper",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4017,
			name: "Nuke Zone Whipper",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NukeZone",
				tags: ["NukeZone", "Red", "Black", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4018,
			name: "2020 Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4019,
			name: "Country Singer Whipper",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4020,
			name: "Albino Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4021,
			name: "Raid Land Whipper",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_RaidLand",
				tags: ["RaidLand", "Blue", "JulyM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4022,
			name: "Toxic Whipper",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4023,
			name: "Music Whipper",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Music",
				tags: ["Rockstar", "JanM23", "Red", "Orange", "Keytar", "Piano", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4024,
			name: "Galeggsy Whipper",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4025,
			name: "Chicken Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4026,
			name: "Techno Whipper",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Techno",
				tags: ["Techno", "AugM23", "Tuh", "Green", "Blue"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_smg_techno"]
		}, {
			id: 4027,
			name: "2021 Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4028,
			name: "Car Whipper",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_car",
				tags: ["Cars", "Trains", "Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4029,
			name: "Merc Zone Whipper",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Purple"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4030,
			name: "Summer Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4031,
			name: "Pencil Whipper",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Pencil",
				tags: ["Pencil", "Sep23", "Yellow", "Crayons", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4032,
			name: "Retro Whipper",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Retro",
				tags: ["Retro", "Nov23", "Pixel", "Purple", "Wings", "JanM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_smg_retro"]
		}, {
			id: 4033,
			name: "2022 Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4034,
			name: "Cards Whipper",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4035,
			name: "Dino Whipper",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Dino",
				tags: ["Dino", "May23", "Blue", "Yellow", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4036,
			name: "Eggpire Whipper",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4037,
			name: "SPORTS Whipper",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Sports",
				tags: ["Sports", "JulyM23", "Red", "Brown", "Badminton", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4038,
			name: "Breakfast Whipper",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Breakfast",
				tags: ["Breakfast", "Food", "Brown", "Red", "Eggs", "Bacon", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4039,
			name: "Teggtris Whipper",
			price: 1980,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Teggtris",
				tags: ["Sep22", "Mar23", "Red", "Orange", "Yellow", "Blue", "Grey", "Gray", "Tetris", "GameBoy", "AprM24", "bun_gamer", "FebM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4040,
			name: "Turkey-Supreme Whipper",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_SpecialTurkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Yellow", "NovM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_smg_turk"]
		}, {
			id: 4041,
			name: "2023 Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4042,
			name: "Valkyrie Whipper",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Valkyrie",
				tags: ["Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_smg_valk"]
		}, {
			id: 4043,
			name: "The Pea90",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Farm",
				tags: ["Farm", "FebM23", "Food", "Green", "Peas", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4044,
			name: "Fusion Whipper",
			price: 3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Fusion",
				tags: ["Premium", " Fusion", "White", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_smg_fusion"]
		}, {
			id: 4045,
			name: "Eggflation Whipper",
			price: 8e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Eggflation",
				tags: ["Eggflation", "MayM23", "Gold", "Yellow", "Eggs"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4046,
			name: "Equinox Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4047,
			name: "Kart Whipper",
			price: 3500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Kart",
				tags: ["Kart", "Aug23", "Pink", "Yellow", "Princess", "Peach", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4048,
			name: "KJDCitsme Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_KJ",
				tags: ["Drops5", "AugM23", "Pink", "Purple", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4049,
			name: "Wrestle Bros Whipper",
			price: 3500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Wrestlebros",
				tags: ["WBros", "SepM23", "Gold", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4050,
			name: "Ancient Whipper",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4051,
			name: "Holideggs Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4052,
			name: "2024 Whipper",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2024",
				tags: ["DecM23", "NewYears", "2024", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4053,
			name: "Racer Whipper",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4054,
			name: "Infernal Whipper",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Infernal",
				tags: ["MayM24", "Infernal", "Red", "Orange", "Black"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_smg_infernal"]
		}, {
			id: 4055,
			name: "Jack O' Lantern Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Pumpkin",
				tags: ["OctM24", "Halloween5", "Red", "Orange", "Black"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4056,
			name: "Spore Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4057,
			name: "2025 Whipper",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4058,
			name: "Irish Whipper",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_Irish",
				tags: ["Mar25", "StPatrickDay", "Green"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4059,
			name: "Golden Dragon Whipper",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Whipper Primary Weapons",
			exclusive_for_class: 4,
			item_data: {
				meshName: "gun_smg_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4200,
			name: "The Crackshot",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24",
				tags: ["default", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 4201,
			name: "GOLD Crackshot",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4202,
			name: "Happy Bear Crackshot",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4203,
			name: "Halloween Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4204,
			name: "Thanksgiving Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4205,
			name: "Christmas Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4206,
			name: "Timewarp 2019 Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear",
				tags: ["NewYears", "2019", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4207,
			name: "Groundhog Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4208,
			name: "Buck Rogers Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4209,
			name: "Valentines Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4210,
			name: "St Patricks Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Black", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4211,
			name: "Easter Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Easter",
				tags: ["Easter", "Eggs", "Green", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4212,
			name: "Flame Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Flames",
				tags: ["Promotional", "Red", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4213,
			name: "Rainbow Crackshot",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Rainbow",
				tags: ["Rainbow", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4214,
			name: "Steampunk Crackshot",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4215,
			name: "Memphis Crackshot",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Memphis",
				tags: ["Memphis", "Yellow", "Black", "White"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4216,
			name: "Eggwalker Crackshot",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_spaceEgg",
				tags: ["Eggwalker", "July23", "Black", "Red", "Grey", "Gray", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4217,
			name: "Nuke Zone Crackshot",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NukeZone",
				tags: ["NukeZone", "Black", "Purple", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4218,
			name: "2020 Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2020",
				tags: ["NewYears", "2020", "Purple", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4219,
			name: "Country Singer Crackshot",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4220,
			name: "Albino Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4221,
			name: "Raid Land Crackshot",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_RaidLand",
				tags: ["RaidLand", "May23", "Purple", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4222,
			name: "Toxic Crackshot",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4223,
			name: "Techno Crackshot",
			price: 10,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Techno",
				tags: ["Premium", "MayM23", "Untz", "Pink", "Blue", "Purple", "July24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_m24_techno"]
		}, {
			id: 4224,
			name: "Music Crackshot",
			price: 8e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Music",
				tags: ["Rockstar", "JanM23", "Red", "Guitar", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4225,
			name: "Galeggsy Crackshot",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4226,
			name: "Chicken Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4227,
			name: "2021 Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2021",
				tags: ["NewYears", "2021", "Pink", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4228,
			name: "Car Crackshot",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_car",
				tags: ["Cars", "Trains", "Blue", "White", "Limosine"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4229,
			name: "Retro Crackshot",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Retro",
				tags: ["Retro", "Premium", "Pixel", "Blue", "Wings", "Aug24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_m24_retro"]
		}, {
			id: 4230,
			name: "Merc Zone Crackshot",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Merc",
				tags: ["Merc", "Suit", "Black", "Tie", "Blue", "Teal"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4231,
			name: "Summer Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4232,
			name: "Pencil Crackshot",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Pencil",
				tags: ["Pencil", "Sep23", "Yellow", "Stapler", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4233,
			name: "2022 Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4234,
			name: "Graysocean Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Graysocean",
				tags: ["Drops", "Blue"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4235,
			name: "Cards Crackshot",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4236,
			name: "Dino Crackshot",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Dino",
				tags: ["Dino", "May23", "Brown", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4237,
			name: "Eggpire Crackshot",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4238,
			name: "SPORTS Crackshot",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Sports",
				tags: ["Sports", "JulyM23", "Silver", "Golf", "Clubs", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4239,
			name: "Breakfast Crackshot",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Breakfast",
				tags: ["Breakfast", "Food", "Fork", "Red", "Grey", "Gray", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4240,
			name: "Scavenger Crackshot",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Scavenger",
				tags: ["Scavenger", "Premium", "Black", "White", "OctM23", "bun_tactic", "Telescope", "FebM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_m24_scav"]
		}, {
			id: 4241,
			name: "BWD Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Wizard",
				tags: ["Sep22", "Drops3", "Blue", "Brown", "Crystal"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4242,
			name: "Valkyrie Crackshot",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Valkyrie",
				tags: ["Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_m24_valk"]
		}, {
			id: 4243,
			name: "2023 Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4244,
			name: "Farm Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Farm",
				tags: ["Farm", "FebM23", "Food", "Green", "Asparagus", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4245,
			name: "MenoXD Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Meno",
				tags: ["Drops4", "Mar23", "Red", "Black", "xd"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4246,
			name: "Equinox Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4247,
			name: "Kart Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Kart",
				tags: ["Kart", "Aug23", "Red", "Blue", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4248,
			name: "The Fusion Crackshot",
			price: 6,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Fusion",
				tags: ["Fusion", "SepM23", "Blue", "White", "Black"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_m24_fusion"]
		}, {
			id: 4249,
			name: "The Pablo Rifle",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Badegg",
				tags: ["Badegg", "Premium", "Yellow", "Brown", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4250,
			name: "Ancient Crackshot",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4251,
			name: "Holideggs Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4252,
			name: "2024 Crackshot",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2024",
				tags: ["DecM23", "NewYears", "2024", "White", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4253,
			name: "Infernal Crackshot",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Infernal",
				tags: ["DecM23", "Infernal", "Black", "Orange", "Red", "Grey", "Gray", "Burn"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_m24_infernal"]
		}, {
			id: 4254,
			name: "Racer Crackshot",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4255,
			name: "Wooden Grove Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Grove",
				tags: ["Feb24", "Newsletter", "Wood", "Brown"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4256,
			name: "Cyborg Crackshot",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Cyborg",
				tags: ["Apr24", "RotR", "Robot", "Grey", "EGGORG", "Apr25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_m24_cyborg"]
		}, {
			id: 4257,
			name: "K4hhny Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_K4nny",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4258,
			name: "The Quackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Quackshot",
				tags: ["May24", "Duck", "Crackshot"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4259,
			name: "Praying Mantis Crackshot",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Bugs",
				tags: ["Jun24", "Bugs", "Green"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4260,
			name: "The Checkmate Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Chess",
				tags: ["July24", "Chess", "Black", "White"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4261,
			name: "Bone Crackshot",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Bones",
				tags: ["Oct24", "Halloween5", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4262,
			name: "Spore Crackshot",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4263,
			name: "2025 Crackshot",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4264,
			name: "Golden Dragon Crackshot",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "Crackshot Primary Weapons",
			exclusive_for_class: 5,
			item_data: {
				meshName: "gun_m24_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16e3,
			name: "Grenade",
			price: 0,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade",
				tags: ["default", "green"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 16001,
			name: "GOLD Grenade",
			price: 2e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16002,
			name: "Happy Bear Grenade",
			price: 5e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16003,
			name: "Rainbow Grenade",
			price: 1e4,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Rainbow",
				tags: ["boom", "White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16004,
			name: "Steampunk Grenade",
			price: 1e4,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Steampunk",
				tags: ["Steampunk", "Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16005,
			name: "Memphis Grenade",
			price: 7500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Memphis",
				tags: ["Memphis", "pink", "blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16006,
			name: "Nuke Zone Grenade",
			price: 7500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_NukeZone",
				tags: ["NukeZone", "Green", "Black", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16007,
			name: "Country Singer Grenade",
			price: 1e5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16008,
			name: "Raid Land Grenade",
			price: 6500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_RaidLand",
				tags: ["SepM23", "brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16009,
			name: "Toxic Grenade",
			price: 7500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16010,
			name: "Albino Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_SnakeAlbino",
				tags: ["countrysinger", "EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16011,
			name: "Holy Hand Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Holy",
				tags: ["Premium", "vipItem", "Blue", "Yellow"],
				sound: "grenade_holy",
				cell: 3,
				smokeColors: "white",
				fireColors: "gold"
			},
			is_available: !1,
			unlock: "vip"
		}, {
			id: 16012,
			name: "Groundhog Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Smile", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16013,
			name: "Corrupted Grenade",
			price: 75e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Corrupted",
				tags: ["Brown", "Eye"],
				sound: "grenade_corrupt",
				cell: 4,
				smokeColors: "corrupt",
				fireColors: "corrupt"
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16014,
			name: "Skullnado Grenade",
			price: 7,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Skull",
				tags: ["SepM23", "OctM23", "White", "Halloween", "Oct24"],
				sound: "grenade_skullnado",
				cell: 2,
				smokeColors: "white"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_skullnado"]
		}, {
			id: 16015,
			name: "St Patricks Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16016,
			name: "Easter Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Easter",
				tags: ["Easter", "Blue", "Pink", "Eggs", "MarM24", "bun_badbunny", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16017,
			name: "Pablo Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Pablo",
				tags: ["Brown", "Yellow", "Hat", "Smile"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16018,
			name: "Diablo Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Diablo",
				tags: ["EGGORG", "Apr23", "Brown", "Frown", "Apr25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16019,
			name: "Unicorn Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Unicorn",
				tags: ["FebM23", "Sep23", "Pink", "Nov24"],
				sound: "grenade_unicorn",
				cell: 1,
				smokeColors: "white",
				fireColors: "rainbow"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_unicorn"]
		}, {
			id: 16020,
			name: "Phone Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Phone",
				tags: ["Mobile", "Fire", "Red"],
				sound: "grenade_cellphone",
				cell: 5,
				smokeColors: "white"
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16021,
			name: "Merc Zone Grenade",
			price: 7e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Merc",
				tags: ["Merc", "Suit", "Black", "Tie"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16022,
			name: "The Coconut Punch",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Coconut",
				tags: ["Summer", "JunM23", "Food", "Brown", "Drink", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16023,
			name: "Toilet Paper Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_ToiletPaper",
				tags: ["Premium", "AugM23", "Poop", "White", "bun_toilet"],
				sound: "grenade_tp",
				cell: 6,
				smokeColors: "white"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_toilet_papr"]
		}, {
			id: 16024,
			name: "Buck Rogers Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16025,
			name: "Galeggsy Grenade",
			price: 7500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16026,
			name: "ChantiGG Booth Grenade",
			price: 1e4,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Booth",
				tags: ["Chantigg", "Red", "Phone"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16027,
			name: "Glitterbomb Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Glitterbomb",
				tags: ["Pencil", "Premium", "Pink", "Disco", "JanM25"],
				sound: "grenade_glitterbomb",
				smokeColors: "white",
				fireColors: "gold",
				cell: 7
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_glitterbomb"]
		}, {
			id: 16028,
			name: "Apple Grenade",
			price: 750,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Apple",
				tags: ["Pencil", "Sep23", "Red", "Food", "MayM24", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16029,
			name: "Chickaletta Grenade",
			price: 1250,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Wero",
				tags: ["Wero", "Chicken", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16030,
			name: "Halloween Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Halloween",
				tags: ["Halloween", "Oct23", "Pumpkin", "Jack", "Orange", "Smile", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16031,
			name: "Thanksgiving Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Turkey",
				tags: ["NovM23", "Thanksgiving", "Eye", "Yellow", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16032,
			name: "Thermal Detonator Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Thermal",
				tags: ["Premium", "JunM23", "Red", "Black"],
				sound: "grenade_thermal",
				cell: 8,
				smokeColors: "thermal",
				fireColors: "thermal"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_thermal"]
		}, {
			id: 16033,
			name: "Christmas Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Present",
				tags: ["Christmas2", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16034,
			name: "Eggs of Legends Grenade",
			price: 5e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Crystal",
				tags: ["Eggteam", "Blue", "Lol", "bun_zorg"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16035,
			name: "2022 Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16036,
			name: "Techno Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Supernova",
				tags: ["AprM23", "Rainbow", "White", "JanM24", "Aug24"],
				sound: "grenade_supernova",
				cell: 9,
				smokeColors: "supernova",
				fireColors: "thermal"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_supernova"]
		}, {
			id: 16037,
			name: "Valentines Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Valentines",
				tags: ["Valentines", "Heart", "Red", "bun_cupid", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16038,
			name: "Octopus Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Octopus",
				tags: ["May23", "Oct23", "White", "Cute", "Feb24"],
				sound: "grenade_octopus",
				cell: 10,
				smokeColors: "white",
				fireColors: "white"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_octopus"]
		}, {
			id: 16039,
			name: "Basket Bros Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_BBros",
				tags: ["Premium", "BBros", "Orange"],
				sound: "grenade_bbros",
				cell: 11,
				smokeColors: "white",
				fireColors: "white"
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16040,
			name: "Cards Grenade",
			price: 1520,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16041,
			name: "Diablo Cannonball",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_DiabloCannon",
				tags: ["Mar23", "EGGORG", "Blue", "Face", "Apr24", "Apr25"],
				sound: "grenade_diablocannon",
				cell: 12,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_diablo"]
		}, {
			id: 16042,
			name: "Yoyo Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Yoyo",
				tags: ["Relic", "Drops2", "Blue", "White"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16043,
			name: "Dino Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Dino",
				tags: ["Dino", "May23", "Orange", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16044,
			name: "Bumblebee Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Bee",
				tags: ["Premium", "Summer", "Mar23", "Yellow", "Black", "Cute", "Jun24", "bun_plant"],
				sound: "grenade_bees",
				cell: 13,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_bumble"]
		}, {
			id: 16045,
			name: "Soccer Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Soccer",
				tags: ["Sports", "JulyM23", "Black", "White", "FebM24", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16046,
			name: "Football Helmet Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Football",
				tags: ["Premium", "Sports", "JulyM23", "Red", "JunM24", "Fbros", "SepM24", "Jun25", "premFeatTwo"],
				sound: "grenade_football",
				cell: 14,
				smokeColors: "softblack",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_football"]
		}, {
			id: 16047,
			name: "Unhatched Chicken Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Chicken",
				tags: ["Chicken", "Eggs", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16048,
			name: "Valkyrie Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Valkyrie",
				tags: ["Premium", "Valkyrie", "Gold", "Yellow", "Blue"],
				sound: "grenade_valkyrie",
				cell: 15,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_valk"]
		}, {
			id: 16049,
			name: "Milk Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Milk",
				tags: ["Premium", "Breakfast", "MayM23", "Pink", "Food", "May24", "Sep24"],
				sound: "grenade_milk",
				cell: 16,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_milk"]
		}, {
			id: 16050,
			name: "Breakfast Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Breakfast",
				tags: ["Breakfast", "Food", "Eggs", "Bacon", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16051,
			name: "Eyeball Grenade",
			price: 5e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Eyeball",
				tags: ["Scavenger", "AugM23", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16052,
			name: "Padlock Grenade",
			price: 4200,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Padlock",
				tags: ["Pencil2", "Sep23", "Grey", "Gray", "Locker", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16053,
			name: "Barrel Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Barrel",
				tags: ["Sep22", "Mar23", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16054,
			name: "Bloodonade Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_premium_Blood",
				tags: ["Premium", "Halloween3", "Red", "DecM23", "bun_arach", "bun_demon", "OctM24"],
				sound: "grenade_bloodonade",
				cell: 17,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_blood"]
		}, {
			id: 16055,
			name: "Nutcracker Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Nutcracker",
				tags: ["Christmas2", "Red", "White", "Face", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16056,
			name: "2023 Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Blue", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16057,
			name: "Tambourine Grenade",
			price: 5e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Tambourine",
				tags: ["Rockstar", "JanM23", "Aug23", "Music", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16058,
			name: "Blue Shell Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Turtle",
				tags: ["Community", "BWD"],
				sound: "grenade_blueshell",
				cell: 20,
				smokeColors: "white",
				fireColors: "white"
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16059,
			name: "Slop Bucket Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Pail",
				tags: ["Premium", "farm", "FebM23", "Food", "May24"],
				sound: "grenade_milkbucket",
				cell: 16,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16060,
			name: "Green Shell Grenade",
			price: 3500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_TurtleGreen",
				tags: ["Kart", "AprM23", "Turtle", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16061,
			name: "Red Shell Grenade",
			price: 1e4,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_TurtleRed",
				tags: ["Kart", "AprM23", "Turtle", "JanM24", "AugM24", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16062,
			name: "Equinox Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "bun_mayan", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16063,
			name: "Kart Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Kart",
				tags: ["Kart", "Aug23", "Green", "Eggs", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16064,
			name: "Timebomb Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Timebomb",
				tags: ["Kart", "Aug23", "Blue", "Yellow", "AugM24"],
				sound: "grenade_Timebomb",
				cell: 18,
				smokeColors: "blue",
				fireColors: "blue"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_timebomb"]
		}, {
			id: 16065,
			name: "Luchador Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Luchador",
				tags: ["WBros", "SepM23", "Wrestle", "Face"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16066,
			name: "Smooth Brain Grenade",
			price: 2100,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Brain",
				tags: ["Oct23", "Halloween4", "Pink"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16067,
			name: "Ancient Grenade",
			price: 2e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16068,
			name: "Holideggs Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16069,
			name: "2024 Grenade",
			price: 3e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_NewYear2024",
				tags: ["DecM23", "2024", "NewYears", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16070,
			name: "Racer Frag Grenade",
			price: 25e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_RaceCarFrag",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16071,
			name: "Rogue Tire Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_RaceCarPremium",
				tags: ["JanM24", "Black", "Text", "Pireggi"],
				sound: "grenade_tire",
				cell: 21,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "premium"
		}, {
			id: 16074,
			name: "Fusion Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Fusion",
				tags: ["FebM23", "White"],
				sound: "grenade_fusion",
				cell: 22,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_fusion"]
		}, {
			id: 16078,
			name: "Mecha-Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Steambot",
				tags: ["Apr24", "RotR", "Robots", "White", "bun_borg"],
				sound: "grenade_Steambot",
				cell: 12,
				smokeColors: "black",
				fireColors: "red"
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16079,
			name: "Novosuper Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Novo",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16080,
			name: "The Fly Grenade",
			price: 2500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Fly",
				tags: ["Jun24", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16081,
			name: "Mort Face Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Mort",
				tags: ["Sep24", "EggyP"],
				sound: "grenade_mort",
				cell: 23,
				smokeColors: "default",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16082,
			name: "Infernal Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Infernal",
				tags: ["SepM24", "Red", "Orange", "Black"],
				sound: "grenade_infernal",
				cell: 22,
				smokeColors: "default",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_infernal"]
		}, {
			id: 16083,
			name: "Rest in Peaces Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Dove",
				tags: ["Oct24", "White", "Bird", "bun_dove"],
				sound: "grenade_Dove",
				cell: 24,
				smokeColors: "default",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16084,
			name: "Spore Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16085,
			name: "Cool Whip Grenade",
			price: 25e4,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Whip",
				tags: ["NovM24", "Gray", "Perm", "Premium", "eggyp"],
				sound: "grenade_Whip",
				cell: 25,
				smokeColors: "white",
				fireColors: "default"
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 16086,
			name: "Eggsmas Present",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_ChristmasGift",
				tags: ["Dec24", "Christmas4", "Red", "Gold", "Newsletter"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16087,
			name: "2025 Grenade",
			price: 2e3,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16088,
			name: "Kettlebell Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Kettlebell",
				tags: ["JanM25", "80KG", "Black", "Text", "80KG"],
				sound: "grenade_Kettlebell",
				smokeColors: "black",
				fireColors: "Red",
				cell: 8
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16089,
			name: "Can of Worms Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Worms",
				tags: ["Feb25", "Text", "Bait", "Pink", "Yellow", "Grey", "Gray", "Silver"],
				sound: "grenade_worms",
				smokeColors: "default",
				fireColors: "default",
				cell: 26
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 16090,
			name: "Thee_Owl Grenade",
			price: 2147483647,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_TheeOwl",
				tags: ["FebM25", "Drops7", "D7W1"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 16091,
			name: "Green Snack Grenade",
			price: 1500,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_greenSnack",
				tags: ["Apr25", "EGGORG", "Shadows", "Green", "Food", "Rice"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 16092,
			name: "Mayan Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_Mayan",
				tags: ["May25", "Mayan"],
				sound: "grenade_Mayan",
				cell: 27,
				smokeColors: "default",
				fireColors: "default"
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_mayan"]
		}, {
			id: 16093,
			name: "Banana Grenade",
			price: 5,
			item_type_id: 6,
			item_type_name: "Grenade",
			category_name: "Grenades",
			exclusive_for_class: null,
			item_data: {
				meshName: "grenade_KartBanana",
				tags: ["Jun25", "Yellow", "Kartbros"],
				sound: "grenade_KartBanana",
				cell: 28,
				smokeColors: "yellow",
				fireColors: "yellow"
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gre_banana"]
		}, {
			id: 4500,
			name: "The Tri-Hard",
			price: 0,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug",
				tags: ["Default", "Red"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 4501,
			name: "GOLD Tri-Hard",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Gold",
				tags: ["Brown", "Gold", "Grey", "Gray", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4502,
			name: "Happy Bear Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Bear",
				tags: ["White", "Pink", "Cute", "Heart"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4503,
			name: "Rainbow Tri-Hard",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Rainbow",
				tags: ["White", "Red", "Orange", "Yellow", "Green", "Blue", "Purple", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4504,
			name: "Steampunk Tri-Hard",
			price: 1e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Steampunk",
				tags: ["Brown", "Gears"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4505,
			name: "Memphis Tri-Hard",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Memphis",
				tags: ["Memphis", "Black", "Green"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4506,
			name: "Nuke Zone Tri-Hard",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_NukeZone",
				tags: ["Purple", "Blue", "Black", "Blurple", "Neon"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4507,
			name: "Country Singer Tri-Hard",
			price: 1e5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Snake",
				tags: ["EggyCash", "Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4508,
			name: "Raid Land Tri-Hard",
			price: 6500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_RaidLand",
				tags: ["RaidLand", "Yellow", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4509,
			name: "Toxic Tri-Hard",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Toxic",
				tags: ["Rotten", "Black", "Green", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4510,
			name: "Albino Snake Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_SnakeAlbino",
				tags: ["EggyCashAlbino", "White", "ABHS", "Snek", "Red", "Black", "Gray", "Grey"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4511,
			name: "St Patricks Day Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_SaintPaddy",
				tags: ["StPatricksDay", "MarM23", "Green", "Yellow", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4512,
			name: "Retro Tri-Hard",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Retro",
				tags: ["Retro", "Premium", "Sep23", "Red", "Green", "Pixel", "Wings"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_aug_retro"]
		}, {
			id: 4513,
			name: "Easter Tri-Hard",
			price: 1e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Easter",
				tags: ["Easter", "JunM23", "Green", "Eggs", "MarM24", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4514,
			name: "Car Tri-Hard",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_car",
				tags: ["Cars", "Trains", "Truck", "Green", "Red", "Yellow"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4515,
			name: "Merc Zone Tri-Hard",
			price: 7e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Merc",
				tags: ["Merc", "Suit", "Pink", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4516,
			name: "Summer Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Watergun",
				tags: ["Summer", "JunM23", "Blue", "Orange", "Yellow", "Blue", "Orange", "Yellow", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4517,
			name: "Buck Rogers Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Buck",
				tags: ["Promotional", "Black", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4518,
			name: "Galeggsy Tri-Hard",
			price: 7500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Galaxy",
				tags: ["Galeggsy", "AprM23", "Blue", "Purple", "Blurple", "Stars", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4519,
			name: "Pencil Tri-Hard",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Pencil",
				tags: ["Pencil", "Sep23", "Smile", "Yellow", "Blue", "Scissors", "Sep24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4520,
			name: "Halloween Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Halloween",
				tags: ["Halloween", "Oct23", "Purple", "Green", "Bat", "Wings", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4521,
			name: "Thanksgiving Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Turkey",
				tags: ["NovM23", "Thanksgiving", "Brown", "Red", "Purple", "Eye", "NovM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4522,
			name: "Christmas Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Present",
				tags: ["Christmas", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present", "Dec24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4523,
			name: "2022 Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_NewYear2022",
				tags: ["NewYears", "2022", "Blue", "Red", "Gold"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4524,
			name: "ChantiGG Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Chantigg",
				tags: ["Drops", "Red", "Phone", "Booth"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4525,
			name: "Valentines Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Valentines",
				tags: ["ValentinesDay", "Heart", "Brown", "Leopard", "Red", "Feb25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4526,
			name: "Kawaii Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Cutesy",
				tags: ["Kawaii", "Pink", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4527,
			name: "Cards Tri-Hard",
			price: 1520,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Cards",
				tags: ["EGGORG", "Apr23", "Blue", "Black", "Heart"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4528,
			name: "Valkyrie Tri-Hard",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Valkyrie",
				tags: ["Premium", "Valkyrie", "Gold", "Yellow", "Blue"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_gun_valk_aug"]
		}, {
			id: 4529,
			name: "Dino Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Dino",
				tags: ["Dino", "May23", "Orange", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4530,
			name: "Eggpire Tri-Hard",
			price: 12500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_spaceEggAlt",
				tags: ["Eggwalker2", "Black", "Grey", "Gray", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4531,
			name: "SPORTS Tri-Hard",
			price: 2500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Sports",
				tags: ["Sports", "JulyM23", "Green", "Blue", "Tennis", "JunM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4532,
			name: "Chicken Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Chicken",
				tags: ["Chicken", "Red", "White", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4533,
			name: "Breakfast Tri-Hard",
			price: 1500,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Breakfast",
				tags: ["Breakfast", "Food", "Spoon", "Red", "Grey", "Gray", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4534,
			name: "Bone Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Bones",
				tags: ["Halloween3", "OctM23", "Oct24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4535,
			name: "2023 Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_NewYear2023",
				tags: ["NewYears", "2023", "Red", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4536,
			name: "Music Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Music",
				tags: ["Rockstar", "JanM23", "Gold", "Yellow", "Saxaphone", "Saxamaphone", "SepM24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4537,
			name: "Groundhog Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Groundhog",
				tags: ["Groundhog", "Feb23", "Brown", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4538,
			name: "Farm Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Farm",
				tags: ["Farm", "FebM23", "Food", "Red", "Yellow", "Orange", "Peppers", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4539,
			name: "Equinox Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Equinox",
				tags: ["Equinox", "July23", "Blue", "Yellow", "Sun", "Moon", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4540,
			name: "Fusion Tri-Hard",
			price: 5,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Fusion",
				tags: ["Premium", "Fusion", "JulyM23", "White", "Blue", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_aug_fusion"]
		}, {
			id: 4541,
			name: "Kart Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Kart",
				tags: ["Kart", "Aug23", "Green", "Yellow", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4542,
			name: "Ancient Tri-Hard",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Ruins",
				tags: ["Nov23", "Mayan", "Gray", "Grey", "Green", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4543,
			name: "Holideggs Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_PresentRed",
				tags: ["Dec23", "Christmas3", "Gold", "Gray", "Grey", "Silver", "Black", "Yellow", "Bow", "Present"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4544,
			name: "2024 Tri-Hard",
			price: 3e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_NewYear2024",
				tags: ["DecM23", "NewYears", "2024", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4545,
			name: "Racer Tri-Hard",
			price: 25e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_RaceCar",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 4546,
			name: "Cupid Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Cupid",
				tags: ["Feb24", "White", "Orange", "Grey", "Gray", "bun_cupid"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4547,
			name: "Green Snake Tri-Hard",
			price: 15e4,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_SnakePatrick",
				tags: ["Mar24", "White", "StPatricksDay", "Green", "Grey", "Gray", "Albino", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4548,
			name: "Flame Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Flames",
				tags: ["Mar24", "Fire", "Brown", "Orange"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4549,
			name: "King Hayden Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Hayden",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4550,
			name: "Infernal Tri-hard",
			price: 3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Infernal",
				tags: ["AprM24", "Infernal", "Black", "Orange", "Red", "Grey", "Gray", "Burn"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_aug_infernal"]
		}, {
			id: 4551,
			name: "Spore Tri-hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 4552,
			name: "The Pumpkin Pie-hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Pumpkinpie",
				tags: ["NovM24", "Thanksgiving4"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4553,
			name: "2025 Tri-Hard",
			price: 2e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_NewYear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 4554,
			name: "Techno Tri-Hard",
			price: 2147483647,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_Techno",
				tags: ["FebM25"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 4555,
			name: "Golden Dragon Tri-Hard",
			price: 5e3,
			item_type_id: 3,
			item_type_name: "Primary",
			category_name: "TriHard Primary Weapons",
			exclusive_for_class: 6,
			item_data: {
				meshName: "gun_aug_dragongold",
				tags: ["Apr25", "EGGORG", "Shadows", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15e3,
			name: "The Whisk Melee",
			price: 0,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "whisk",
				tags: ["Silver"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 15001,
			name: "Corn Melee",
			price: 0,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_corn",
				tags: ["Yellow", "Green", "Food", "Meme"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 15002,
			name: "Club Melee",
			price: 0,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_stick",
				tags: ["Brown", "bun_plant", "Stick", "Wood"]
			},
			is_available: !0,
			unlock: "default"
		}, {
			id: 15003,
			name: "GOLD Melee",
			price: 2500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_gold",
				tags: ["Brown", "Gold", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15004,
			name: "Pink Bear Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_bear",
				tags: ["Pink", "Cute", "Heart", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15005,
			name: "Steampunk Melee",
			price: 7500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_steampunk",
				tags: ["Brown", "Gold", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15006,
			name: "Rainbow Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_rainbow",
				tags: ["Red", "Orange", "Yellow", "Green", "Blue", "Clouds", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15007,
			name: "Memphis Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_memphis",
				tags: ["Black", "White", "Rainbow", "Whisk"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15008,
			name: "Toxic Melee",
			price: 15e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_toxic",
				tags: ["Pipe", "Green", "Black", "bun_arach"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15009,
			name: "Car Melee",
			price: 2e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_shift",
				tags: ["Black", "Silver", "Gear"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15010,
			name: "Brown Snake Melee",
			price: 1e5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_snake",
				tags: ["Brown", "Snek"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15011,
			name: "Hoe Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_hoe",
				tags: ["FebM23", "farm", "Tools", "May24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15012,
			name: "Flame Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_flame",
				tags: ["Orange", "Yellow", "Fire"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15013,
			name: "Valkyrie Melee",
			price: 6,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_valkyrie",
				tags: ["Gold", "Blue", "Yellow", "Premium"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_valk"]
		}, {
			id: 15014,
			name: "BWD Wizard Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_wizard",
				tags: ["Drops4", "Mar23", "Blue", "Brown", "Staff"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15015,
			name: "Sneaker Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_sneaker",
				tags: ["BBros", "MarM23", "White", "Blue", "Shoe"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15016,
			name: "Fiddle Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fiddle",
				tags: ["StPatricksDay", "MarM23", "Music", "Brown", "Mar24", "Mar25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15017,
			name: "Medieval Key Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_mediKey",
				tags: ["Apr23", "Newsletter", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15018,
			name: "Galeggsy Whisk",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_galaxy",
				tags: ["AprM23", "Galeggsy", "Blue", "Purple", "Planets", "OctM23", "Aug24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15019,
			name: "Giant Spoon Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_spoon",
				tags: ["AprM23", "Silver", "Food", "MayM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15020,
			name: "Albino Snake Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_albino",
				tags: ["Giveaway", "White", "ABHS", "Snek"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15021,
			name: "Forkin' Fork! Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fork",
				tags: ["Silver", "Food"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15022,
			name: "Bone Bonker",
			price: 4500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_bone",
				tags: ["May23", "Dino2", "Caveman", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15023,
			name: "Stone Hammer Melee",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_rock",
				tags: ["May23", "Nov23", "Dino2", "Grey", "Gray", "AugM24", "May25", "premFeatOne"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_stone"]
		}, {
			id: 15024,
			name: "Eggflation Whisk",
			price: 8e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_eggflation",
				tags: ["MayM23", "Eggflation", "Gold", "Yellow", "80k"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15025,
			name: "Butterknife Melee",
			price: 6500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_butterknife",
				tags: ["MayM23", "Eggflation", "Silver", "Food"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15026,
			name: "Shellfie Stick Melee",
			price: 7500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_selfiestick",
				tags: ["Jun23", "Photo", "Cheese"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15027,
			name: "Spatula Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_spatula",
				tags: ["Jun23", "Silver"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15028,
			name: "Popsicle Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_popsicle",
				tags: ["JunM23", "Summer2", "Pink", "Food"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15029,
			name: "Wrench Melee",
			price: 4500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_wrench",
				tags: ["JunM23", "Summer2", "Blue", "Yellow", "Tools"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15030,
			name: "Fusion Melee",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fusion",
				tags: ["JunM23", "Blue", "White", "Gray", "Grey"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_fusion"]
		}, {
			id: 15031,
			name: "Equinox Melee",
			price: 3e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_equinox",
				tags: ["July23", "Equinox", "Blue", "Yellow", "Sun", "Moon", "Whisk", "JanM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15032,
			name: "Crowbar Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_crowbar",
				tags: ["July23", "Blue", "Yellow", "Red", "Tools"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15033,
			name: "Hockey Melee",
			price: 8e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_hockey",
				tags: ["JulyM23", "Sports2", "Stick"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15034,
			name: "Shovel Melee",
			price: 7500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_shovel",
				tags: ["JulyM23", "Pink", "Yellow", "Blue"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15035,
			name: "MenoXD Katana",
			price: 125e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_meno",
				tags: ["JulyM23", "Red", "Black"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15036,
			name: "Kart Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_kart",
				tags: ["Aug23", "Kart", "Red", "Blue", "Whisk", "Jun25"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15037,
			name: "Harrison Cat Melee",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_harrison",
				tags: ["AugM23", "Drops5", "Black", "White", "Cat", "FebM25"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_cat"]
		}, {
			id: 15039,
			name: "Ruler Melee",
			price: 6500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_ruler",
				tags: ["Sep23", "Pencil3", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15040,
			name: "Fighting Fish Slapper",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fish",
				tags: ["Sep23", "bun_cat", "Food", "eyes"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15041,
			name: "Folding Chair Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_chair",
				tags: ["SepM23", "WBros", "Wrestle", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15042,
			name: "Pitchfork Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_devil",
				tags: ["Oct23", "Halloween4", "Red", "Black"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15043,
			name: "Rolling Pin Whalloper",
			price: 8e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_rollingpin",
				tags: ["Oct23", "Brown"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15044,
			name: "Ancient Club",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_ruins",
				tags: ["Nov23", "Green", "Gray", "Grey", "May25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15045,
			name: "Mayan Macuahuitl",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_mayan",
				tags: ["Nov23", "Red", "Black", "Brown", "bun_mayan", "May25", "premFeatOne"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_mayan"]
		}, {
			id: 15046,
			name: "Turkey Drumstick",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_drumstick",
				tags: ["NovM23", "Red", "Black", "Brown"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15047,
			name: "The Turkey Carver",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_carver",
				tags: ["NovM23", "Blue", "Black", "Gas", "NovM24"]
			},
			is_available: !1,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_turkcar"]
		}, {
			id: 15048,
			name: "The Candy Cane-r",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_candycane",
				tags: ["Dec23", "Blue", "Black", "Gas"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15049,
			name: "Elf on a Shelf Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_elf",
				tags: ["Dec23", "Blue", "Black", "Gas", "bun_mistle"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15050,
			name: "2024 Whisk",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_newyear2024",
				tags: ["DecM23", "2024", "NewYears", "Blue", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15051,
			name: "Racer Lug Wrench",
			price: 5e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_lugwrench",
				tags: ["JanM24", "Racer", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15052,
			name: "Groundhog Melee",
			price: 7e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_groundhog",
				tags: ["Feb24", "Groundhog", "White", "Orange", "Grey", "Gray", "Feb24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15053,
			name: "Buck Rogers Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_buck",
				tags: ["Jan24", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15054,
			name: "Vuvuzela Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_vuvuzela",
				tags: ["FebM24", "White", "Orange", "Grey", "Gray"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15055,
			name: "World Cup Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_cup",
				tags: ["FebM24", "Gold", "Yellow"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15056,
			name: "Chocolate Bunny Melee",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_chocolatebun",
				tags: ["MarM24", "Rabbit", "Brown", "Easter", "Gold", "MarM25"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15057,
			name: "Mecha-Hammer",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_steambot",
				tags: ["Apr24", "Robot", "RotR"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15058,
			name: "Robo-Wrench",
			price: 7500,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_steamwrench",
				tags: ["Apr24", "Robot", "RotR"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15059,
			name: "Thee_Owl Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_theeowl",
				tags: ["AprM24", "Drops6"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15060,
			name: "Goldfish Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_gfish",
				tags: ["AprM24", "Orange"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15061,
			name: "Plunger Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_plunger",
				tags: ["May24", "Red", "Wood", "Toilet", "bun_toilet"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15062,
			name: "Army Ant  Melee",
			price: 15e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_ant",
				tags: ["Jun24", "Bugs"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15063,
			name: "Infernal Melee",
			price: 5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_infernal",
				tags: ["JunM24", "Red", "Orange"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_infernal"]
		}, {
			id: 15064,
			name: "Pickleball Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_pickleball",
				tags: ["JunM24"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15065,
			name: "Chess Board Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_chess",
				tags: ["July24", "Chess", "Checkerboard", "Black", "White"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15066,
			name: "Techno Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_techno",
				tags: ["JulyM24", "Techno", "Premium", "Purple", "White"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15067,
			name: "Jawbone Melee",
			price: 2e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_jawbone",
				tags: ["AugM24", "Dino", "AugM24"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15068,
			name: "The Elder Wand",
			price: 5e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_wand",
				tags: ["Sep24", "EggyP"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15069,
			name: "Broomstick Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_broom",
				tags: ["Sep24", "EggyP"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15070,
			name: "Keytar Melee",
			price: 3e5,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_keytar",
				tags: ["SepM24", "Perm", "Premium", "Music", "SepM24", "eggyp"]
			},
			is_available: !0,
			unlock: "purchase"
		}, {
			id: 15071,
			name: "Halloween Melee",
			price: 5e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_halloween",
				tags: ["OctM24", "Halloween5"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15072,
			name: "Frying Pan Melee",
			price: 1,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fryingpan",
				tags: ["OctM24", "Perm", "Permanent"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_pan"]
		}, {
			id: 15073,
			name: "Butcher Knife Melee",
			price: 125e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_butcher",
				tags: ["Nov24", "SC2"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15074,
			name: "Let Them Cook Melee",
			price: 2,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_eggpan",
				tags: ["Nov24", "Perm"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_panegg"]
		}, {
			id: 15075,
			name: "Monster Hand Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_zombiehand",
				tags: ["OctM24", "Bundle"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15077,
			name: "Big Kahuna Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_properfish",
				tags: ["NovM24", "Select", "Community", "BWD"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15078,
			name: "Spore Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_mushroom",
				tags: ["NovM24", "Giveaway", "Funghi", "Green"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15079,
			name: "mistake",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_frostfall",
				tags: ["null"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15080,
			name: "Eggsmas Bell Melee",
			price: 1e4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_christmasbell",
				tags: ["Dec24", "Christmas4", "Gold", "Yellow", "Brown", "Red"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15081,
			name: "Nutcracker Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_nutcracker",
				tags: ["Dec24", "Christmas4", "Bundle"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15082,
			name: "2025 Whisk",
			price: 5e3,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_newyear2025",
				tags: ["DecM24", "NewYears", "Green", "White", "Yellow"]
			},
			is_available: !1,
			unlock: "purchase"
		}, {
			id: 15083,
			name: "Frostfall Whisk",
			price: 4,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_frostfall",
				tags: ["DecM24", "NewYears", "perm", "Premium"]
			},
			is_available: !0,
			unlock: "premium",
			activeProduct: !0,
			sku: ["item_melee_frost"]
		}, {
			id: 15084,
			name: "Mj\xf6lnir",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_hammer",
				tags: ["JanM25", "Thor", "Silver"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15085,
			name: "Fishing Rod Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_frod",
				tags: ["Feb25", "Silver"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15086,
			name: "Harlequin Mallet",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_mallet",
				tags: ["Drops7", "D7W2", "FebM25"]
			},
			is_available: !1,
			unlock: "manual"
		}, {
			id: 15087,
			name: "Moai Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_moai",
				tags: ["Easter", "Gray", "Grey", "Premium", "MarM25"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15088,
			name: "Your Greatest Fan",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_fan",
				tags: ["Shadows", "Bundle", "Red", "Premium", "Apr25"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15089,
			name: "Adventurer's Whip",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_whip",
				tags: ["May25", "Mayan", "Indiana", "Jones"]
			},
			is_available: !1,
			unlock: "premium"
		}, {
			id: 15090,
			name: "F1 Racer Melee",
			price: 2147483647,
			item_type_id: 7,
			item_type_name: "Melee",
			category_name: "Melee",
			exclusive_for_class: null,
			item_data: {
				meshName: "melee_kartbros",
				tags: ["Jun25", "Kartbros", "Car"]
			},
			is_available: !1,
			unlock: "premium"
		}],
		Qw = [{
			id: 1,
			loc_ref: "chlg_kill_streak_five",
			type: 0,
			subType: 0,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: 0,
			value: "5",
			valueTwo: null,
			tier: 2
		}, {
			id: 2,
			loc_ref: "chlg_kill_streak_ten",
			type: 0,
			subType: 0,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 0,
			value: "10",
			valueTwo: null,
			tier: 2
		}, {
			id: 3,
			loc_ref: "chlg_kill_streak_fifteen",
			type: 0,
			subType: 0,
			period: 0,
			goal: 1,
			reward: 500,
			conditional: 0,
			value: "15",
			valueTwo: null,
			tier: 3
		}, {
			id: 4,
			loc_ref: "chlg_kill_streak_twenty",
			type: 0,
			subType: 0,
			period: 0,
			goal: 1,
			reward: 1e3,
			conditional: 0,
			value: "20",
			valueTwo: null,
			tier: 3
		}, {
			id: 5,
			loc_ref: "chlg_kill_streak_fifty",
			type: 0,
			subType: 0,
			period: 0,
			goal: 1,
			reward: 5e3,
			conditional: 0,
			value: "50",
			valueTwo: null,
			tier: 3
		}, {
			id: 6,
			loc_ref: "chlg_kill_kills_ten",
			type: 0,
			subType: 10,
			period: 0,
			goal: 10,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 0
		}, {
			id: 7,
			loc_ref: "chlg_kill_kills_twenty",
			type: 0,
			subType: 10,
			period: 0,
			goal: 20,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 8,
			loc_ref: "chlg_kill_kills_fifty",
			type: 0,
			subType: 10,
			period: 0,
			goal: 50,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 9,
			loc_ref: "chlg_kill_kills_hundred",
			type: 0,
			subType: 10,
			period: 0,
			goal: 100,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 10,
			loc_ref: "chlg_kill_kills_two_fifty",
			type: 0,
			subType: 10,
			period: 0,
			goal: 250,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 11,
			loc_ref: "chlg_kill_timePlayed_two",
			type: 0,
			subType: 6,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: null,
			value: "2",
			valueTwo: "60",
			tier: 0
		}, {
			id: 12,
			loc_ref: "chlg_kill_timePlayed_four",
			type: 0,
			subType: 6,
			period: 0,
			goal: 1,
			reward: 500,
			conditional: null,
			value: "4",
			valueTwo: "60",
			tier: 2
		}, {
			id: 13,
			loc_ref: "chlg_kill_timePlayed_seven",
			type: 0,
			subType: 6,
			period: 0,
			goal: 1,
			reward: 1e3,
			conditional: null,
			value: "7",
			valueTwo: "60",
			tier: 3
		}, {
			id: 14,
			loc_ref: "chlg_kill_timePlayed_ten",
			type: 0,
			subType: 6,
			period: 0,
			goal: 1,
			reward: 2500,
			conditional: null,
			value: "10",
			valueTwo: "60",
			tier: 3
		}, {
			id: 15,
			loc_ref: "chlg_kill_con_kill_one_shot",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: 11,
			value: "1",
			valueTwo: "1",
			tier: 1
		}, {
			id: 16,
			loc_ref: "chlg_kill_con_kill_hp_ten",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 500,
			conditional: 12,
			value: "1",
			valueTwo: "10",
			tier: 1
		}, {
			id: 17,
			loc_ref: "chlg_kill_con_kill_five_streak",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 1e3,
			conditional: 0,
			value: "0",
			valueTwo: "5",
			tier: 2
		}, {
			id: 18,
			loc_ref: "chlg_kill_con_kill_ten_streak",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 2500,
			conditional: 0,
			value: "0",
			valueTwo: "10",
			tier: 3
		}, {
			id: 19,
			loc_ref: "chlg_kill_con_kill_scoped",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 13,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 20,
			loc_ref: "chlg_kill_con_two_kills_one_shot",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 16,
			value: "2",
			valueTwo: null,
			tier: 2
		}, {
			id: 21,
			loc_ref: "chlg_kill_con_reloading",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: 17,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 22,
			loc_ref: "chlg_kill_con_kill_scoped_melee",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 13,
			value: null,
			valueTwo: "9",
			tier: 2
		}, {
			id: 23,
			loc_ref: "chlg_kill_con_kill_two_grenade",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 16,
			value: "2",
			valueTwo: "8",
			tier: 2
		}, {
			id: 24,
			loc_ref: "chlg_kill_con_kill_three_grenade",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 1e3,
			conditional: 16,
			value: "3",
			valueTwo: "8",
			tier: 3
		}, {
			id: 25,
			loc_ref: "chlg_kill_con_kill_two_rpegg",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 16,
			value: "2",
			valueTwo: "4",
			tier: 2
		}, {
			id: 26,
			loc_ref: "chlg_kill_con_kill_three_rpegg",
			type: 0,
			subType: 8,
			period: 0,
			goal: 1,
			reward: 1e3,
			conditional: 16,
			value: "3",
			valueTwo: "4",
			tier: 3
		}, {
			id: 27,
			loc_ref: "chlg_kill_weaponType_Cluck9mm_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "3",
			tier: 1
		}, {
			id: 28,
			loc_ref: "chlg_kill_weaponType_Cluck9mm_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "3",
			tier: 1
		}, {
			id: 29,
			loc_ref: "chlg_kill_weaponType_Cluck9mm_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "3",
			tier: 2
		}, {
			id: 30,
			loc_ref: "chlg_kill_weaponType_Cluck9mm_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: "3",
			tier: 3
		}, {
			id: 31,
			loc_ref: "chlg_kill_weaponType_Scrambler_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "1",
			tier: 1
		}, {
			id: 32,
			loc_ref: "chlg_kill_weaponType_Scrambler_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "1",
			tier: 1
		}, {
			id: 33,
			loc_ref: "chlg_kill_weaponType_Scrambler_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "1",
			tier: 2
		}, {
			id: 34,
			loc_ref: "chlg_kill_weaponType_Scrambler_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "1",
			tier: 3
		}, {
			id: 35,
			loc_ref: "chlg_kill_weaponType_Rpegg_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "4",
			tier: 2
		}, {
			id: 36,
			loc_ref: "chlg_kill_weaponType_Rpegg_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "4",
			tier: 2
		}, {
			id: 37,
			loc_ref: "chlg_kill_weaponType_Rpegg_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "4",
			tier: 2
		}, {
			id: 38,
			loc_ref: "chlg_kill_weaponType_Rpegg_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "4",
			tier: 3
		}, {
			id: 39,
			loc_ref: "chlg_kill_weaponType_Whipper_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "5",
			tier: 1
		}, {
			id: 40,
			loc_ref: "chlg_kill_weaponType_Whipper_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "5",
			tier: 1
		}, {
			id: 41,
			loc_ref: "chlg_kill_weaponType_Whipper_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "5",
			tier: 2
		}, {
			id: 42,
			loc_ref: "chlg_kill_weaponType_Whipper_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "5",
			tier: 3
		}, {
			id: 43,
			loc_ref: "chlg_kill_weaponType_Eggk47_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "0",
			tier: 0
		}, {
			id: 44,
			loc_ref: "chlg_kill_weaponType_Eggk47_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "0",
			tier: 1
		}, {
			id: 45,
			loc_ref: "chlg_kill_weaponType_Eggk47_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "0",
			tier: 2
		}, {
			id: 46,
			loc_ref: "chlg_kill_weaponType_Eggk47_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "0",
			tier: 3
		}, {
			id: 47,
			loc_ref: "chlg_kill_weaponType_FreeRanger_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "2",
			tier: 1
		}, {
			id: 48,
			loc_ref: "chlg_kill_weaponType_FreeRanger_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "2",
			tier: 1
		}, {
			id: 49,
			loc_ref: "chlg_kill_weaponType_FreeRanger_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "2",
			tier: 2
		}, {
			id: 50,
			loc_ref: "chlg_kill_weaponType_FreeRanger_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "2",
			tier: 3
		}, {
			id: 51,
			loc_ref: "chlg_kill_weaponType_Crackshot_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "6",
			tier: 1
		}, {
			id: 52,
			loc_ref: "chlg_kill_weaponType_Crackshot_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "6",
			tier: 1
		}, {
			id: 53,
			loc_ref: "chlg_kill_weaponType_Crackshot_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "6",
			tier: 2
		}, {
			id: 54,
			loc_ref: "chlg_kill_weaponType_Crackshot_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "6",
			tier: 3
		}, {
			id: 55,
			loc_ref: "chlg_kill_weaponType_TriHard_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: "7",
			tier: 1
		}, {
			id: 56,
			loc_ref: "chlg_kill_weaponType_TriHard_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "7",
			tier: 1
		}, {
			id: 57,
			loc_ref: "chlg_kill_weaponType_TriHard_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "7",
			tier: 2
		}, {
			id: 58,
			loc_ref: "chlg_kill_weaponType_TriHard_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "7",
			tier: 3
		}, {
			id: 59,
			loc_ref: "chlg_kill_weaponType_Melee_five",
			type: 0,
			subType: 1,
			period: 0,
			goal: 5,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: "9",
			tier: 2
		}, {
			id: 60,
			loc_ref: "chlg_kill_weaponType_Melee_ten",
			type: 0,
			subType: 1,
			period: 0,
			goal: 10,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: "9",
			tier: 2
		}, {
			id: 61,
			loc_ref: "chlg_kill_weaponType_Melee_twenty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 20,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: "9",
			tier: 3
		}, {
			id: 62,
			loc_ref: "chlg_kill_weaponType_Melee_fifty",
			type: 0,
			subType: 1,
			period: 0,
			goal: 50,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: "9",
			tier: 3
		}, {
			id: 63,
			loc_ref: "chlg_damage_five_hundred",
			type: 1,
			subType: null,
			period: 0,
			goal: 500,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 0
		}, {
			id: 64,
			loc_ref: "chlg_damage_one_thousand",
			type: 1,
			subType: null,
			period: 0,
			goal: 1e3,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 65,
			loc_ref: "chlg_damage_twenty_five_hundred",
			type: 1,
			subType: null,
			period: 0,
			goal: 2500,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 66,
			loc_ref: "chlg_damage_five_thousand",
			type: 1,
			subType: null,
			period: 0,
			goal: 5e3,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 67,
			loc_ref: "chlg_damage_ten_thousand",
			type: 1,
			subType: null,
			period: 0,
			goal: 1e4,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 68,
			loc_ref: "chlg_damage_twenty_five_thousand",
			type: 1,
			subType: null,
			period: 0,
			goal: 25e3,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 69,
			loc_ref: "chlg_deaths_ten",
			type: 2,
			subType: null,
			period: 0,
			goal: 10,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 70,
			loc_ref: "chlg_deaths_twenty",
			type: 2,
			subType: null,
			period: 0,
			goal: 20,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 71,
			loc_ref: "chlg_deaths_fifty",
			type: 2,
			subType: null,
			period: 0,
			goal: 50,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 72,
			loc_ref: "chlg_movement_distance_five_hunderd",
			type: 3,
			subType: 3,
			period: 0,
			goal: 500,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 0
		}, {
			id: 73,
			loc_ref: "chlg_movement_distance_one_thousand",
			type: 3,
			subType: 3,
			period: 0,
			goal: 1e3,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 74,
			loc_ref: "chlg_movement_distance_five_thousand",
			type: 3,
			subType: 3,
			period: 0,
			goal: 5e3,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 75,
			loc_ref: "chlg_movement_jump_one_hundred",
			type: 3,
			subType: 4,
			period: 0,
			goal: 100,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 76,
			loc_ref: "chlg_movement_jump_five_hundred",
			type: 3,
			subType: 4,
			period: 0,
			goal: 500,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 77,
			loc_ref: "chlg_kill_jump_one",
			type: 0,
			subType: 4,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 78,
			loc_ref: "chlg_kill_jump_five",
			type: 0,
			subType: 4,
			period: 0,
			goal: 5,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 79,
			loc_ref: "chlg_kill_jump_victim_jump",
			type: 0,
			subType: 4,
			period: 0,
			goal: 1,
			reward: 2500,
			conditional: 4,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 80,
			loc_ref: "chlg_movement_collect_ammo_ten",
			type: 4,
			subType: 18,
			period: 0,
			goal: 10,
			reward: 100,
			conditional: 16,
			value: "0",
			valueTwo: null,
			tier: 1
		}, {
			id: 81,
			loc_ref: "chlg_movement_collect_ammo_twenty_five",
			type: 4,
			subType: 18,
			period: 0,
			goal: 25,
			reward: 500,
			conditional: 16,
			value: "0",
			valueTwo: null,
			tier: 2
		}, {
			id: 82,
			loc_ref: "chlg_movement_collect_ammo_fifty",
			type: 4,
			subType: 18,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: 16,
			value: "0",
			valueTwo: null,
			tier: 3
		}, {
			id: 83,
			loc_ref: "chlg_movement_collect_grenade_ten",
			type: 4,
			subType: 18,
			period: 0,
			goal: 10,
			reward: 100,
			conditional: 17,
			value: "1",
			valueTwo: null,
			tier: 1
		}, {
			id: 84,
			loc_ref: "chlg_movement_collect_grenade_twenty_five",
			type: 4,
			subType: 18,
			period: 0,
			goal: 25,
			reward: 500,
			conditional: 17,
			value: "1",
			valueTwo: null,
			tier: 2
		}, {
			id: 85,
			loc_ref: "chlg_movement_collect_grenade_fifty",
			type: 4,
			subType: 18,
			period: 0,
			goal: 50,
			reward: 1e3,
			conditional: 17,
			value: "1",
			valueTwo: null,
			tier: 3
		}, {
			id: 86,
			loc_ref: "chlg_timed_timeAlive_thirty",
			type: 5,
			subType: 7,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: 7,
			value: "30",
			valueTwo: null,
			tier: 1
		}, {
			id: 87,
			loc_ref: "chlg_timed_timeAlive_sixty",
			type: 5,
			subType: 7,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 7,
			value: "60",
			valueTwo: null,
			tier: 2
		}, {
			id: 88,
			loc_ref: "chlg_timed_timeAlive_three_hundred",
			type: 5,
			subType: 7,
			period: 0,
			goal: 1,
			reward: 2500,
			conditional: 7,
			value: "300",
			valueTwo: null,
			tier: 3
		}, {
			id: 90,
			loc_ref: "chlg_timed_timePlayed_three_hundred",
			type: 5,
			subType: 6,
			period: 0,
			goal: 300,
			reward: 200,
			conditional: 6,
			value: "300",
			valueTwo: null,
			tier: 0
		}, {
			id: 91,
			loc_ref: "chlg_timed_timePlayed_nine_hundred",
			type: 5,
			subType: 6,
			period: 0,
			goal: 900,
			reward: 500,
			conditional: 6,
			value: "900",
			valueTwo: null,
			tier: 1
		}, {
			id: 92,
			loc_ref: "chlg_timed_timePlayed_eighteen_hundred",
			type: 5,
			subType: 6,
			period: 0,
			goal: 1800,
			reward: 1e3,
			conditional: 6,
			value: "1800",
			valueTwo: null,
			tier: 2
		}, {
			id: 93,
			loc_ref: "chlg_timed_timePlayed_thirty_six_hundred",
			type: 5,
			subType: 6,
			period: 0,
			goal: 3600,
			reward: 2500,
			conditional: 6,
			value: "3600",
			valueTwo: null,
			tier: 3
		}, {
			id: 94,
			loc_ref: "chlg_kotc_capturing_timeAlive_twenty",
			type: 6,
			subType: 20,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: 7,
			value: "10",
			valueTwo: null,
			tier: 1
		}, {
			id: 95,
			loc_ref: "chlg_kotc_capture",
			type: 6,
			subType: 21,
			period: 0,
			goal: 1,
			reward: 100,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 96,
			loc_ref: "chlg_kotc_win_one",
			type: 6,
			subType: 23,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 97,
			loc_ref: "chlg_kotc_win_three",
			type: 6,
			subType: 23,
			period: 0,
			goal: 3,
			reward: 500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 98,
			loc_ref: "chlg_kotc_win_five",
			type: 6,
			subType: 23,
			period: 0,
			goal: 5,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 99,
			loc_ref: "chlg_kotc_win_ten",
			type: 6,
			subType: 23,
			period: 0,
			goal: 10,
			reward: 2500,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 100,
			loc_ref: "chlg_kotc_coop_kill",
			type: 6,
			subType: 20,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 10,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 101,
			loc_ref: "chlg_kotc_coop_kill_victim_capturing",
			type: 6,
			subType: 20,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: 10,
			value: "18",
			valueTwo: null,
			tier: 1
		}, {
			id: 102,
			loc_ref: "chlg_cts_pick_up",
			type: 7,
			subType: 21,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 103,
			loc_ref: "chlg_cts_capture_timeAlive_thirty",
			type: 7,
			subType: 21,
			period: 0,
			goal: 1,
			reward: 500,
			conditional: 7,
			value: "30",
			valueTwo: null,
			tier: 2
		}, {
			id: 104,
			loc_ref: "chlg_cts_win_ten",
			type: 7,
			subType: 23,
			period: 0,
			goal: 20,
			reward: 1e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 1
		}, {
			id: 105,
			loc_ref: "chlg_cts_win_twenty_five",
			type: 7,
			subType: 23,
			period: 0,
			goal: 50,
			reward: 4e3,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 106,
			loc_ref: "chlg_cts_win_fifty",
			type: 7,
			subType: 23,
			period: 0,
			goal: 100,
			reward: 1e4,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 3
		}, {
			id: 107,
			loc_ref: "chlg_cts_kills_victim_spatula",
			type: 7,
			subType: 10,
			period: 0,
			goal: 1,
			reward: 200,
			conditional: null,
			value: null,
			valueTwo: null,
			tier: 2
		}, {
			id: 108,
			loc_ref: "chlg_cts_kills_killstreak_five",
			type: 7,
			subType: 10,
			period: 0,
			goal: 1,
			reward: 500,
			conditional: 0,
			value: "5",
			valueTwo: null,
			tier: 3
		}],
		Zw = [1340, 1206, 15024, 1050, 1013, 3066, 1415, 1024, 2521, 2305, 1393, 1230, 1350, 2250, 3014, 16006, 16028, 1504, 3155, 1410, 1097, 1216, 4244, 1158, 2526, 2262, 3413, 1252, 4028, 1151, 2527, 3456, 1274, 1264, 2067, 1187, 4519, 2292, 1305, 2273, 2522, 1046, 1246, 3633, 2368, 1038, 1039, 1360, 1052, 1398, 2524, 1327, 3664, 1141, 2161, 1370, 3838, 2149, 16061, 1047, 1476, 2319, 15057, 1048, 1040, 2373, 2146, 1134, 15017, 2096, 1199, 2090, 2529, 1287, 3653, 1173, 2523, 1067, 1201, 1474, 1049, 1041, 1343, 3021, 3008, 4012, 3608, 4517, 3120, 3112, 15053, 3812, 3412, 4510, 16024, 15020, 3808, 3408, 2525, 2528, 2008, 16007, 4255, 2231, 3448],
		eR = ["tip_001", "tip_ofthe_day_1", "tip_ofthe_day_4", "tip_ofthe_day_6", "tip_ofthe_day_9", "tip_ofthe_day_10", "tip_ofthe_day_11", "tip_ofthe_day_13", "tip_ofthe_day_15", "tip_ofthe_day_16", "tip_ofthe_day_17", "tip_ofthe_day_18", "tip_ofthe_day_19", "tip_ofthe_day_26", "tip_ofthe_day_27", "tip_ofthe_day_28", "tip_ofthe_day_30", "tip_ofthe_day_33", "tip_ofthe_day_34", "tip_ofthe_day_35", "tip_ofthe_day_37", "tip_ofthe_day_39", "tip_ofthe_day_40", "tip_ofthe_day_41", "tip_ofthe_day_42", "tip_ofthe_day_44", "tip_ofthe_day_45", "tip_ofthe_day_46", "tip_ofthe_day_47", "tip_ofthe_day_49", "tip_ofthe_day_51", "tip_ofthe_day_52", "tip_ofthe_day_53", "tip_ofthe_day_54", "tip_ofthe_day_56", "tip_ofthe_day_58", "tip_ofthe_day_59", "tip_ofthe_day_60", "tip_ofthe_day_62", "tip_ofthe_day_63", "tip_ofthe_day_64", "tip_ofthe_day_65", "tip_ofthe_day_66", "tip_ofthe_day_67", "tip_ofthe_day_68", "tip_ofthe_day_69", "tip_ofthe_day_70", "tip_ofthe_day_72", "tip_ofthe_day_73", "tip_ofthe_day_74", "tip_ofthe_day_75", "tip_ofthe_day_76", "tip_ofthe_day_77", "tip_ofthe_day_78", "tip_ofthe_day_79", "tip_ofthe_day_80", "tip_ofthe_day_81", "tip_ofthe_day_83", "tip_ofthe_day_84", "tip_ofthe_day_85", "tip_ofthe_day_86", "tip_ofthe_day_87", "tip_ofthe_day_88", "tip_ofthe_day_89", "tip_ofthe_day_90", "tip_ofthe_day_91", "tip_ofthe_day_92", "tip_ofthe_day_93", "tip_ofthe_day_94", "tip_ofthe_day_95", "tip_ofthe_day_96", "tip_ofthe_day_97", "tip_ofthe_day_98", "tip_ofthe_day_99", "tip_ofthe_day_100", "tip_ofthe_day_101", "tip_ofthe_day_102", "tip_ofthe_day_103", "tip_ofthe_day_104", "tip_ofthe_day_105", "tip_ofthe_day_106", "tip_ofthe_day_107", "tip_ofthe_day_108"],
		tR = ["tipNew_ofthe_day_2", "tipNew_ofthe_day_3", "tipNew_ofthe_day_7", "tipNew_ofthe_day_8", "tipNew_ofthe_day_14", "tipNew_ofthe_day_22", "tipNew_ofthe_day_23", "tipNew_ofthe_day_24", "tipNew_ofthe_day_25", "tipNew_ofthe_day_29", "tipNew_ofthe_day_31", "tipNew_ofthe_day_32", "tipNew_ofthe_day_38", "tipNew_ofthe_day_48", "tipNew_ofthe_day_50", "tipNew_ofthe_day_55", "tipNew_ofthe_day_57", "tipNew_ofthe_day_61", "tipNew_ofthe_day_71", "tipNew_ofthe_day_82", "tipNew_ofthe_day_109", "tipNew_ofthe_day_110"],
		iR = ["loading_msgs_1", "loading_msgs_2", "loading_msgs_3", "loading_msgs_4", "loading_msgs_5", "loading_msgs_6", "loading_msgs_7", "loading_msgs_8", "loading_msgs_9", "loading_msgs_10", "loading_msgs_11", "loading_msgs_12", "loading_msgs_13", "loading_msgs_14", "loading_msgs_15", "loading_msgs_16", "loading_msgs_17", "loading_msgs_18", "loading_msgs_19", "loading_msgs_20", "loading_msgs_21", "loading_msgs_22", "loading_msgs_23", "loading_msgs_24", "loading_msgs_25", "loading_msgs_26", "loading_msgs_27", "loading_msgs_28", "loading_msgs_29", "loading_msgs_30", "loading_msgs_31", "loading_msgs_32", "loading_msgs_33", "loading_msgs_34", "loading_msgs_35", "loading_msgs_36", "loading_msgs_37", "loading_msgs_38", "loading_msgs_39", "loading_msgs_40", "loading_msgs_41", "loading_msgs_42", "loading_msgs_43", "loading_msgs_44", "loading_msgs_45", "loading_msgs_46", "loading_msgs_47", "loading_msgs_48", "loading_msgs_49", "loading_msgs_50", "loading_msgs_51", "loading_msgs_52", "loading_msgs_53", "loading_msgs_54", "loading_msgs_55", "loading_msgs_56", "loading_msgs_57", "loading_msgs_58", "loading_msgs_59", "loading_msgs_60", "loading_msgs_61", "loading_msgs_62", "loading_msgs_63", "loading_msgs_64", "loading_msgs_65", "loading_msgs_66", "loading_msgs_67", "loading_msgs_68", "loading_msgs_69", "loading_msgs_70"];

	function sR(e) {
		let t = new bg(e);
		return t.useRightHandedSystem = !0, t.useGeometryIdsMap = !0, t.useMaterialMeshMap = !0, t.useClonedMeshMap = !0, t
	}

	function nR(e, t, i, s) {
		var n = Tk.getMeshByName(e);
		let a = new Vf(e, t, i, n);
		return a.setEnabled(!0), n ? n.skeleton && (a.skeleton = n.skeleton.clone(), a.skeleton._scene = t, a.animations = n.animations.map((e => {
			let i = e.clone("", (e => {
				let t = a.skeleton.getBoneIndexByName(e.name),
					i = a.skeleton.bones[t];
				return i.linkTransformNode(i), i
			}), !0);
			return i._scene = t, i
		})), a.skeleton.returnToRest()) : console.error("Cannot find mesh to clone:", e), s ? a.material = s : a.material && a.material._scene != t && (a.material = aR(a.material.name, t)), a
	}

	function aR(e, t) {
		let i = t.getMaterialByName(e);
		return i || (i = Tk.getMaterialByName(e).clone(e, t), t.addMaterial(i)), i
	}

	function rR(e, t, i = 1) {
		e.currentAnimation && e.currentAnimation.stop();
		let s = e.getAnimationByName(t);
		e.currentAnimation = s, s.speedRatio = i, s.play()
	}

	function oR(e, t, i) {
		let s = e.getAnimationByName(t);
		i && s.onAnimationGroupPauseObservable.addOnce(i), s.play(), s.goToFrame(0), s.pause()
	}

	function lR(e) {
		this.scene = e, this.x = 0, this.y = 0, this.z = 0, this.dx = 0, this.dy = 0, this.Sa = 0, this.active = !1, this.xa = null, this.damage = 20, this.range = 0, this.velocity = 0, this.hitsMap = !1, this.origin = new Lc, this.direction = new Lc, this.end = new Lc, this.meshName = "", this.weaponClassId = 0, this.pa = new pN(this)
	}
	gS.prototype.disableBlending = function() {
		this.bones.forEach((function(e) {
			e.animations.forEach((function(e) {
				e.enableBlending = !1
			}))
		}))
	}, hv.prototype.clearRect = function(e, t, i, s) {
		this._context.clearRect(e, t, i, s)
	}, jd.prototype.setLayerMask = function(e) {
		this.layerMask = e;
		for (var t = this.getChildMeshes(), i = 0; i < t.length; i++) t[i].setLayerMask(e)
	}, jd.prototype.setRenderingGroupId = function(e) {
		this.Lk = e;
		for (var t = this.getChildMeshes(), i = 0; i < t.length; i++) t[i].setRenderingGroupId(e)
	}, Jc.prototype.ra = function(e) {
		this.isVisible = e, this._isWorldMatrixFrozen = !e;
		for (var t = this.getChildTransformNodes(), i = 0; i < t.length; i++) t[i].ra(e)
	}, jd.prototype.setMaterial = function(e) {
		this.material = e;
		for (var t = this.getChildMeshes(), i = 0; i < t.length; i++) t[i].setMaterial(e)
	}, lR.damageExp = 4, lR.Ua = new Lc, lR.na = new Lc, lR.$a = new Lc, lR.position = new Lc, lR.fire = function(e, t, i, s) {
		cI.bulletPool.retrieve().fireThis(e, t, i, s)
	}, lR.prototype.fireThis = function(e, t, i, s) {
		this.xa = e, this.x = t.x, this.y = t.y, this.z = t.z, this.origin.set(this.x, this.y, this.z), this.direction.copyFrom(i).normalize().scaleInPlace(s.velocity), this.dx = this.direction.x, this.dy = this.direction.y, this.Sa = this.direction.z, this.weaponClass = s, this.damage = s.damage, this.active = !0, this.range = s.range, this.velocity = s.velocity, this.hitsMap = !1, this.powerful = !1, this.dmgTypeId = s.dmgTypeId;
		var n = uR.qa(t, i, uR.projectileCollidesWithCell);
		n && (this.end.copyFrom(n.pick.pickedPoint), this.range = Lc.Distance(t, n.pick.pickedPoint), this.hitsMap = !0), e.activeShellStreaks & ph.EggBreaker && (this.powerful = !0, this.damage *= 1.5), 0 == this.xa.Wa.tracer ? this.pa.fire(this.powerful) : this.pa.delayFrames = Number.MAX_SAFE_INTEGER
	}, lR.prototype.remove = function() {
		cI.bulletPool.recycle(this), this.pa.remove()
	}, lR.prototype.update = function() {
		if (lR.position.set(this.x, this.y, this.z), this.range < this.velocity && this.direction.scaleInPlace(this.range / this.velocity), !uR.fa(lR.position, this.direction, this))
			if (this.x += this.dx, this.y += this.dy, this.z += this.Sa, this.range -= this.velocity, this.range <= 0) {
				if (this.hitsMap) {
					var e = this.end,
						t = .1 * -this.dx,
						i = .1 * -this.dy,
						s = .1 * -this.Sa;
					! function(e, t, i, s, n, a) {
						var r = DN.getSprite(0);
						r.animLength = 20 * Math.random() + 30, r.easing = wR.outQuint, r.position.x = e, r.position.y = t, r.position.z = i, r.dx = .1 * s, r.dy = .1 * n, r.Sa = .1 * a, r.startSize = .1, r.endSize = .2 * Math.random() + .4, r.angle = Math.random() * Math.PI2, r.rotate = .08 * Math.random() - .04, r.animColors = BI
					}(e.x, e.y, e.z, t, i, s)
				}
				this.remove()
			} else;
	}, lR.prototype.collidesWithPlayer = function(e, t) {
		lR.Ua.x = this.dx, lR.Ua.y = this.dy, lR.Ua.z = this.Sa, lR.Ua.normalize();
		var i = .8 * -Lc.Dot(lR.Ua, t) + .2,
			s = this.damage * Math.pow(i, lR.damageExp + Math.pow(i, lR.damageExp));
		isNaN(s) && console.error("Bullet.collidesWithPlayer damage is NaN", this.weaponClass), dP(e, this, s, lR.Ua.x, lR.Ua.z), this.remove()
	};
	var hR = class {
		getObjects(e, t) {
			this.checkTick++, this.recurseObjects(e, this.bvh, t)
		}
		constructor() {
			var e = new Lc(0, 0, 0),
				t = new Lc(QN.width, QN.height, QN.depth);
			this.world = new du(e, t), this.bvh = this.createNode(this.world, 2), this.checkTick = 0
		}
		createNode(e, t) {
			var i = [],
				s = (e.maximumWorld.x - e.minimumWorld.x) / t,
				n = (e.maximumWorld.z - e.minimumWorld.z) / t;
			if (s > QN.height) var a = 0,
				r = QN.height,
				o = QN.height;
			else a = e.minimumWorld.y, o = ((r = e.maximumWorld.y) - a) / t;
			for (var l = e.minimumWorld.x; l < e.maximumWorld.x; l += s)
				for (var h = a; h < r; h += o)
					for (var c = e.minimumWorld.z; c < e.maximumWorld.z; c += n) {
						var u = new Lc(l, h, c),
							m = new Lc(l + s, h + o, c + n),
							d = new du(u, m);
						d.bvh = [], d.objects = [], i.push(d)
					}
			return i
		}
		add(e, t) {
			t = t || this.bvh;
			for (var i = 0; i < t.length; i++) {
				var s = t[i];
				du.Intersects(e.bb, s) && (s.maximumWorld.x - s.minimumWorld.x > .5 * (e.bb.maximumWorld.x - e.bb.minimumWorld.x) && s.maximumWorld.y - s.minimumWorld.y > .5 * (e.bb.maximumWorld.y - e.bb.minimumWorld.y) && s.maximumWorld.z - s.minimumWorld.z > .5 * (e.bb.maximumWorld.z - e.bb.minimumWorld.z) ? (0 == s.bvh.length && (s.bvh = this.createNode(s, 2)), e.checkTick = 0, this.add(e, s.bvh)) : s.objects.push(e))
			}
		}
		getObjectsWithRay(e, t, i) {
			this.checkTick++, this.recurseObjectsWithRay(e, t, this.bvh, i)
		}
		recurseObjectsWithRay(e, t, i, s) {
			for (var n = 0; n < i.length; n++) {
				var a = i[n];
				if (du.IntersectsRay(a, e, t)) {
					for (var r = 0; r < a.objects.length; r++) {
						var o = a.objects[r];
						o.checkTick != this.checkTick && du.IntersectsRay(o.bb, e, t) && (o.checkTick = this.checkTick, s(a.objects[r]))
					}
					this.recurseObjectsWithRay(e, t, a.bvh, s)
				}
			}
		}
		recurseObjects(e, t, i) {
			for (var s = 0; s < t.length; s++) {
				var n = t[s];
				if (du.Intersects(e, n)) {
					for (var a = 0; a < n.objects.length; a++) {
						var r = n.objects[a];
						r.checkTick != this.checkTick && du.Intersects(e, r.bb) && (r.checkTick = this.checkTick, i(n.objects[a]))
					}
					this.recurseObjects(e, n.bvh, i)
				}
			}
		}
	};

	function cR() {
		if (null == qw) throw "Items is undefined or null, cannot create Catalog";
		this.isSetup = !1, this.filterItems = function(e, t) {
			for (var i = [], s = 0; s < e.length; s++) t(e[s]) && i.push(e[s]);
			return i
		}, this.findItemInListById = function(e, t) {
			for (var i = 0; i < t.length; i++)
				if (t[i] && t[i].id === e) return t[i];
			return null
		}, this.findItemsByIds = function(e) {
			return qw.filter((t => e.includes(t.id)))
		}, this.findItemById = function(e) {
			return this.findItemInListById(e, qw)
		}, this.findItemBy8BitItemId = function(e, t, i) {
			if (!1 === this.isSetup && this.setupCatalog(), void 0 === t || t >= Ah.length) return null;
			var s = i;
			switch (e) {
				case Eh.Hat:
					return 0 === i ? null : this.findItemInListById(s, this.hats);
				case Eh.Stamp:
					return 0 === i ? null : this.findItemInListById(s, this.stamps);
				case Eh.Primary:
					return this.findItemInListById(s, this.forClass[t].forWeaponSlot[yh]);
				case Eh.Secondary:
					return this.findItemInListById(s, this.forClass[t].forWeaponSlot[Sh]);
				case Eh.Grenade:
					return this.findItemInListById(s, this.grenades);
				case Eh.Melee:
					return this.findItemInListById(s, this.melee)
			}
		}, this.addWeaponFunctions = function(e) {
			e.instantiateNew = function(e) {
				var t;
				return t = null === this.exclusive_for_class ? new ER(e, this.item_data.meshName) : new kh.classes[this.exclusive_for_class].Wa(e, this.item_data.meshName), e.pa && e.pa.setWeaponSkeleton(t.pa.skeleton), t
			}
		}, this.addGrenadeFunctions = function(e) {
			e.instantiateNew = function(e) {
				let t = nR(this.item_data.meshName, e.scene),
					i = {
						scene: e.scene,
						player: e,
						pa: {
							mesh: t,
							dispose: () => {
								t.dispose()
							}
						}
					};
				return t.position.y = .5, t.position.z = 1, i
			}
		}, this.addMeleeFunctions = function(e) {
			e.instantiateNew = function(e) {
				let t = nR(this.item_data.meshName, e.scene),
					i = {
						scene: e.scene,
						player: e,
						pa: {
							weaponMesh: t,
							skeleton: t.skeleton,
							dispose: () => {
								t.dispose()
							}
						}
					};
				return e.pa && e.pa.setWeaponSkeleton(i.pa.skeleton), i
			}
		}, this.getTaggedItems = function(e, t) {
			if (!e) return [];
			const i = (e = e.replace(/\s/g, "")).split(",");
			return this.filterItems(qw, (function(e) {
				if (void 0 !== e.item_data.tags && null !== e.item_data.tags && e.item_data.tags.length > 0) {
					if (void 0 !== t && e.item_type_name !== getKeyByValue(Eh, t)) return !1;
					let s = !1;
					return e.item_data.tags.forEach((e => {
						i.forEach((t => {
							t === e && (s = !0)
						}))
					})), s
				}
				return !1
			}))
		}, this.premiumSoundValid = function(e) {
			const t = "premium" === e.unlock,
				i = "manual" === e.unlock && "gun_cluck9mm_CubicCastles" === e.item_data.meshName,
				s = "purchase" === e.unlock && e.item_data.hasOwnProperty("tags") && e.item_data.tags.includes("Premium") && e.price > 15e4;
			return e.hasOwnProperty("unlock") && (t || i || s)
		}, this.getPremiumGunMeshNames = function() {
			Object.keys(Ah).forEach((e => {
				"Soldier" !== e && (Vw[e] = qw.filter((t => hasValue(t.exclusive_for_class) && t.exclusive_for_class === Ah[e] && this.premiumSoundValid(t))).map((e => e.item_data.meshName)))
			})), Object.keys(Eh).forEach((e => {
				"Primary" !== e ? Vw[e] = qw.filter((t => hasValue(t.item_type_id) && t.item_type_id === Eh[e] && this.premiumSoundValid(t))).map((e => e.item_data.meshName)) : "Primary" === e && (Vw.Soldier = qw.filter((e => hasValue(e.item_type_id) && e.item_type_id === Eh.Primary && !hasValue(e.exclusive_for_class) && this.premiumSoundValid(e))).map((e => e.item_data.meshName)))
			}))
		}, this.setupCatalog = function() {
			this.defaultItemIds = [], this.hats = [], this.stamps = [], this.primaryWeapons = [], this.secondaryWeapons = [], this.grenades = [], this.melee = [], this.forClass = [];
			for (var e = 0; e < qw.length; e++) switch ("default" === qw[e].unlock && this.defaultItemIds.push(qw[e].id), qw[e].item_type_id) {
				case Eh.Hat:
					this.hats.push(qw[e]);
					break;
				case Eh.Stamp:
					this.stamps.push(qw[e]);
					break;
				case Eh.Primary:
					this.primaryWeapons.push(qw[e]), this.addWeaponFunctions(qw[e]);
					break;
				case Eh.Secondary:
					this.secondaryWeapons.push(qw[e]), this.addWeaponFunctions(qw[e]);
					break;
				case Eh.Grenade:
					this.grenades.push(qw[e]), this.addGrenadeFunctions(qw[e]);
					break;
				case Eh.Melee:
					this.melee.push(qw[e]), this.addMeleeFunctions(qw[e])
			}
			for (var t = 0; t < Ah.length; t++) {
				var i = function(e) {
						return 0 === e.price && null === e.exclusive_for_class
					},
					s = function(e) {
						return 0 === e.price && e.exclusive_for_class === t
					},
					n = function(e) {
						return e.price > 0 && null === e.exclusive_for_class
					},
					a = function(e) {
						return e.price > 0 && e.exclusive_for_class === t
					},
					r = this,
					o = function(e) {
						return e = r.filterItems(e, i).concat(r.filterItems(e, s)).concat(r.filterItems(e, n)).concat(r.filterItems(e, a))
					},
					l = {
						primaryWeapons: o(this.primaryWeapons),
						secondaryWeapons: o(this.secondaryWeapons)
					};
				l.forWeaponSlot = [l.primaryWeapons, l.secondaryWeapons], this.forClass.push(l)
			}
			this.isSetup = !0
		}, this.isSetup || this.setupCatalog()
	}
	kh.catalog || (kh.catalog = new cR);
	var uR = {
			init: function(e) {
				uR.playerCollisionMesh = cS.dk("", {
					size: .5,
					height: .6
				}, e), uR.playerCollisionMesh.position.y = .3, uR.playerCollisionMesh.bakeCurrentTransformIntoVertices(), uR.playerCollisionMesh.setEnabled(!1), uR.wedgeCollisionMesh = cS.dk("", {
					size: 1.5
				}, e), uR.wedgeCollisionMesh.position.y = -.75, uR.wedgeCollisionMesh.bakeCurrentTransformIntoVertices(), uR.wedgeCollisionMesh.rotation.x = Math.PI / 4, uR.wedgeCollisionMesh.bakeTransformIntoVertices(uR.wedgeCollisionMesh.getWorldMatrix()), uR.wedgeCollisionMesh.setEnabled(!1), uR.wedgeCollisionMesh.flipFaces(), uR.iwedgeCollisionMesh = cS.dk("", {
					size: 1.5
				}, e), uR.iwedgeCollisionMesh.position.y = .75, uR.iwedgeCollisionMesh.bakeCurrentTransformIntoVertices(), uR.iwedgeCollisionMesh.rotation.x = Math.PI / 4, uR.iwedgeCollisionMesh.bakeTransformIntoVertices(uR.iwedgeCollisionMesh.getWorldMatrix()), uR.iwedgeCollisionMesh.setEnabled(!1), uR.iwedgeCollisionMesh.flipFaces(), uR.la = cS.dk("", {
					size: 1
				}, e), uR.la.setEnabled(!1), uR.la.flipFaces()
			},
			Ua: new Lc,
			na: new Lc,
			$a: new Lc,
			Da: new Lc,
			Fa: new Lc,
			ray: new Yv(Lc.Zero(), Lc.Zero(), 1),
			matrix: new Hc,
			meshCollidesWithMap: function(e, t) {
				var i = {};
				if (isNaN(t.x) || isNaN(t.y) || isNaN(t.z)) return !0;
				for (var s = e.getBoundingInfo().boundingBox, n = 0; n < s.vectors.length; n++) {
					var a = Math.floor(t.x + s.vectors[n].x),
						r = Math.floor(t.y + s.vectors[n].y),
						o = Math.floor(t.z + s.vectors[n].z);
					if (a < 0 || a >= qN.width || o < 0 || o >= qN.depth || r < 0) return !0;
					var l = a + 1e3 * r + 1e6 * o;
					if (r < qN.height && !i[l]) {
						var h = uR.meshCollidesWithCell(e, t, a, r, o);
						if (h) return h;
						i[l] = !0
					}
				}
				return !1
			},
			meshCollidesWithCell: function(e, t, i, s, n, a) {
				var r = qN.data[i][s][n];
				if (r.idx) {
					var o = kR[r.idx];
					if (a && o.softness) return !1;
					switch (o.colliderType) {
						case "full":
							return {
								x: i, y: s, z: n, cell: r, mesh: uR.la
							};
						case "ladder":
							if ("pc" != e.name) return !1;
							break;
						case "none":
							return !1
					}
					e.position.x = t.x - i - .5, e.position.y = t.y - s - .5, e.position.z = t.z - n - .5, uR.Ua.set(-e.position.x, -e.position.y, -e.position.z), e.setPivotPoint(uR.Ua), e.rotation.x = -r.rx, e.rotation.y = -r.ry, e.rotation.z = -r.rz, e.computeWorldMatrix();
					var l = r.colliderMesh.intersectsMesh(e, r.colliderPrecise, r.colliderChildren);
					if (l) return {
						x: i,
						y: s,
						z: n,
						cell: r,
						mesh: l
					}
				}
				return !1
			},
			qa: function(e, t, i) {
				if (isNaN(e.x) || isNaN(e.y) || isNaN(e.z)) return !1;
				if (e.x < 0 || e.x >= qN.width || e.z < 0 || e.z >= qN.depth || e.y < 0 || e.y >= qN.height) return !1;
				var s = t.length(),
					n = Math.floor(e.x),
					a = Math.floor(e.y),
					r = Math.floor(e.z),
					o = t.x,
					l = t.y,
					h = t.z,
					c = Math.sign(o),
					u = Math.sign(l),
					m = Math.sign(h),
					d = uR.intbound(e.x, o),
					f = uR.intbound(e.y, l),
					p = uR.intbound(e.z, h),
					_ = c / o,
					g = u / l,
					v = m / h;
				if (0 === o && 0 === l && 0 === h) return !1;
				for (s /= Math.sqrt(o * o + l * l + h * h);
					(c > 0 ? n < qN.width : n >= 0) && (u > 0 ? a < qN.height : a >= 0) && (m > 0 ? r < qN.depth : r >= 0);) {
					if (!(n < 0 || a < 0 || r < 0 || n >= qN.width || a >= qN.height || r >= qN.depth)) {
						var y = i(e, t, {
							x: n,
							y: a,
							z: r
						});
						if (y && "verysoft" != kR[y.cell.idx].softness) return y
					}
					if (d < f)
						if (d < p) {
							if (d > s) break;
							n += c, d += _
						} else {
							if (p > s) break;
							r += m, p += v
						}
					else if (f < p) {
						if (f > s) break;
						a += u, f += g
					} else {
						if (p > s) break;
						r += m, p += v
					}
				}
			},
			intbound: function(e, t) {
				return t < 0 ? uR.intbound(-e, -t) : (1 - (e = (e % 1 + 1) % 1)) / t
			},
			getCellForRay: function(e) {
				try {
					var t = qN.data[e.x][e.y][e.z]
				} catch (t) {
					console.log(e)
				}
				if (!t || !t.mesh) return !1;
				switch (t.mesh.colliderType) {
					case "none":
					case "ladder":
						return !1
				}
				return t
			},
			projectileCollidesWithCell: function(e, t, i) {
				var s = uR.getCellForRay(i);
				if (!s) return !1;
				if (s.mesh.softness) return !1;
				var n = s.colliderMesh;
				uR.matrix.copyFrom(s.colliderMatrix), uR.Da.set(i.x + .5, i.y + .5, i.z + .5), uR.Ua.set(e.x, e.y, e.z), uR.na.copyFrom(t), uR.Ua.subtractInPlace(uR.Da), uR.ray.origin.copyFrom(uR.Ua), uR.ray.direction.copyFrom(uR.na), uR.ray.length = 1, Yv.TransformToRef(uR.ray, uR.matrix, uR.ray);
				var a = uR.intersectsColliderMesh(n, !1);
				if (n = a.pickedMesh, a.hit) {
					var r = Lc.TransformCoordinates(a.pickedPoint, uR.matrix.invert());
					return r.addInPlace(uR.Da), a.pickedPoint = r, {
						cell: s,
						pick: a
					}
				}
				return !1
			},
			grenadeCollidesWithCell: function(e, t, i) {
				var s = uR.getCellForRay(i);
				if (!s) return !1;
				var n = s.colliderMesh;
				uR.matrix.copyFrom(s.colliderMatrix), uR.Da.set(i.x + .5, i.y + .5, i.z + .5), uR.Ua.set(e.x, e.y, e.z), uR.na.copyFrom(t);
				var a = t.length();
				uR.na.normalize().scaleInPlace(10), uR.Ua.subtractInPlace(uR.Da), uR.ray.origin.copyFrom(uR.Ua), uR.ray.direction.copyFrom(uR.na), uR.ray.length = 1, Yv.TransformToRef(uR.ray, uR.matrix, uR.ray);
				var r = uR.intersectsColliderMesh(n, !1);
				if ((n = r.pickedMesh, r.hit) && Lc.Distance(uR.ray.origin, r.pickedPoint) <= a) {
					uR.matrix.invert();
					var o = Lc.TransformCoordinates(r.pickedPoint, uR.matrix);
					o.addInPlace(uR.Da), r.pickedPoint = o;
					var l = Lc.TransformCoordinates(r.normal, uR.matrix);
					return {
						cell: s,
						pick: r,
						normal: l,
						dot: Lc.Dot(t, l)
					}
				}
				return !1
			},
			intersectsColliderMesh: function(e, t) {
				var i = uR.ray.intersectsMeshes([e, ...e.getChildMeshes()], t)[0];
				if (void 0 !== i && !0 === i.hit) {
					if (i.normal = i.getNormal(!0, !1), Lc.Dot(uR.ray.direction, i.normal) < 0) {
						if (!(i = uR.ray.intersectsMesh(uR.la, t)).hit) return {
							hit: !1
						};
						i.normal = i.getNormal(!0, !1)
					} else Math.abs(i.pickedPoint.x) > .5 || Math.abs(i.pickedPoint.y) > .5 || Math.abs(i.pickedPoint.z) > .5 ? (uR.ray.origin = i.pickedPoint, (i = uR.ray.intersectsMesh(uR.la, t)).normal = i.getNormal(!0, !1)) : i.normal.negateInPlace();
					return i
				}
				return {
					hit: !1
				}
			},
			fa: function(e, t, i, s) {
				for (var n = i ? i.xa.team : null, a = i ? i.xa.id : null, r = 0; r < Mk; r++) {
					var o = iI[r];
					if (o && (o.Ba || o.pauseTargetTime > 0) && o.id != a && (0 == o.team || o.team != n)) {
						uR.ray.origin.copyFrom(e), uR.ray.direction.copyFrom(t), uR.ray.length = 1;
						var l = uR.rayCollidesWithPlayerHelper(uR.ray, o, s);
						l && i && i.collidesWithPlayer(o, l)
					}
				}
				return !1
			},
			rayCollidesWithPlayerHelper: function(e, t, i) {
				var s = e.origin,
					n = i || .3;
				n *= t.scale;
				var a = uR.Ua;
				a.copyFrom(s).addInPlace(e.direction);
				var r = uR.Fa;
				r.set(t.Xa, t.ba + .3 * t.scale, t.va);
				var o = uR.na;
				o.copyFrom(e.origin), o.subtractInPlace(r);
				var l = Lc.Dot(e.direction, e.direction),
					h = 2 * Lc.Dot(e.direction, o),
					c = Lc.Dot(o, o) - n * n,
					u = Math.pow(h, 2) - 4 * l * c,
					m = uR.$a,
					d = uR.Da;
				if (u < 0) return !1;
				if (0 == u) return Lc.LerpToRef(s, a, u, m), m.subtractToRef(r, d), d.normalize(), d;
				var f = (-h - Math.sqrt(u)) / (2 * l);
				Math.sqrt(u);
				return f >= 0 && f <= 1 && (Lc.LerpToRef(s, a, f, m), m.subtractToRef(r, d), d.normalize(), d)
			}
		},
		mR = class e {
			static init() {
				e.bvh = new hR
			}
			static add(t) {
				e.bvh.add(t)
			}
			static pointCollidesWithBox(t, i) {
				var s = e.$a,
					n = e.mtx2;
				return s.copyFrom(t), s.subtractInPlace(i.position), i.matrix.invertToRef(n), Lc.TransformNormalToRef(s, n, s), s.x >= i.minimumWorld.x && s.x <= i.maximumWorld.x && s.y >= i.minimumWorld.y && s.y <= i.maximumWorld.y && s.z >= i.minimumWorld.z && s.z <= i.maximumWorld.z
			}
			static pointCollidesWithStructure(t) {
				var i = e.box;
				i.minimumWorld.copyFrom(t), i.maximumWorld.copyFrom(t);
				let s = !1;
				return e.bvh.getObjects(i, (i => {
					e.pointCollidesWithBox(t, i) && (s = !0)
				})), s
			}
			static sphereCollidesWithBox(t, i, s, n, a) {
				var r = e.$a,
					o = e.Da,
					l = e.mtx2;
				if (r.copyFrom(t), r.subtractInPlace(s.position), s.matrix.invertToRef(l), Lc.TransformNormalToRef(r, l, r), Lc.ClampToRef(r, s.minimumWorld, s.maximumWorld, o), (h = Lc.Distance(r, o)) < i) {
					o.subtractInPlace(r), Lc.TransformNormalToRef(o, s.matrix, o), o.addInPlace(t), o.subtractInPlace(s.position), Lc.ClampToRef(o, e.vmin, e.vmax, o), o.addInPlace(s.position);
					var h = Lc.Distance(t, o);
					if (o.subtractInPlace(t).normalize(), h < (i *= .16 * Math.abs(o.y) + .84)) return a.copyFrom(o), o.scaleInPlace(h - i - .001), n.copyFrom(o), !0
				}
				return !1
			}
			static sphereCollidesWithStructure(t, i, s, n) {
				var a = e.box,
					r = e.Ua,
					o = e.na;
				a.minimumWorld.copyFrom(t), a.minimumWorld.x -= i, a.minimumWorld.y -= i, a.minimumWorld.z -= i, a.maximumWorld.copyFrom(t), a.maximumWorld.x += i, a.maximumWorld.y += i, a.maximumWorld.z += i, s.copyFromFloats(0, 0, 0);
				var l = 0,
					h = !1;
				return e.bvh.getObjects(a, (a => {
					e.sphereCollidesWithBox(t, i, a, r, o) && (o.y < -.707 && (r.y = r.length(), r.x = 0, r.z = 0), r.length() > s.length() && (s.copyFrom(r), n.copyFrom(o), h = a), l++)
				})), l > 0 && h
			}
		};
	mR.Ua = new Lc, mR.na = new Lc, mR.$a = new Lc, mR.Da = new Lc, mR.Fa = new Lc, mR.Va = new Lc, mR.ea = new Lc, mR.mtx1 = new Hc, mR.mtx2 = new Hc, mR.vmin = new Lc(-.5, -.5, -.5), mR.vmax = new Lc(.5, .5, .5), mR.box = new du(Lc.Zero(), Lc.Zero()), mR.Type = {
		full: 1,
		wedge: 2,
		iwedge: 4,
		aabb: 8,
		obb: 16,
		ladder: 32
	}, mR.aabbMask = mR.Type.full | mR.Type.aabb | mR.Type.ladder;
	var dR = class {
			static setToDefaults() {
				this.value = this.getDefaults()
			}
			static isSelectedWeaponDisabled(e) {
				return !this.areAllWeaponsDisabled() && this.value.weaponDisabled[e]
			}
			static parse(e = !0) {
				let t = Nh.unPackInt8U(),
					i = Nh.unPackInt8U(),
					s = Nh.unPackInt8U(),
					n = Nh.unPackInt8U(),
					a = kh.classes.map((() => 1 === Nh.unPackInt8U()));
				return !!e && ((t < 1 || t > 4) && (t = 4), (i < 0 || i > 8) && (i = 4), s > 16 && (s = 4), this.value = {
					gravity: t / 4,
					damage: i / 4,
					healthRegen: s / 4,
					flags: n,
					weaponDisabled: a
				}, !0)
			}
			static init() {
				this.value = this.getDefaults()
			}
			static areAllWeaponsDisabled() {
				return !!this.value && !this.value.weaponDisabled.includes(!1)
			}
			static set(e) {
				this.value = e
			}
			static getDefaults() {
				let e = {
					gravity: 1,
					damage: 1,
					healthRegen: 1,
					flags: 0,
					weaponDisabled: new Array(kh.classes.length)
				};
				return e.weaponDisabled.fill(!1), e
			}
			static usingDefaults() {
				let e = this.getDefaults(),
					t = !0;
				return Object.keys(e).forEach((i => {
					let s = this.value[i];
					if ("flags" === i && (s ^= s & fR.locked), s instanceof Array) {
						for (let n = 0; n < s.length; n++)
							if (s[n] !== e[i][n]) return void(t = !1)
					} else if (s !== e[i]) return void(t = !1)
				})), t
			}
			static serialize() {
				var e = Rh.getBuffer();
				return e.BkKlQQwL(sh.K), e.BkKlQQwL(4 * this.value.gravity), e.BkKlQQwL(4 * this.value.damage), e.BkKlQQwL(4 * this.value.healthRegen), e.BkKlQQwL(this.value.flags), this.value.weaponDisabled.forEach((t => {
					e.BkKlQQwL(t ? 1 : 0)
				})), e
			}
		},
		fR = {
			locked: 1,
			noTeamChange: 2,
			noTeamShuffle: 4
		},
		pR = {
			reset: 1,
			pause: 2
		};

	function _R(e) {
		this.dmgTypeId = uh.findIndex((e => "Grenade" === e.name)), this.scene = e, this.x = 0, this.y = 0, this.z = 0, this.dx = 0, this.dy = 0, this.Sa = 0, this.ttl = 0, this.resting = !1, this.active = !1, this.xa = null, this.pa = new aO(this)
	}
	_R.Ua = new Lc, _R.na = new Lc, _R.$a = new Lc, _R.Da = new Lc, _R.matrix = new Hc, _R.prototype.update = function() {
		if (this.ttl <= 0) this.remove();
		else {
			if (!this.resting) {
				var e = this.dx,
					t = this.dy,
					i = this.Sa,
					s = .5 * (this.dx + e),
					n = .5 * (this.dy + t),
					a = .5 * (this.Sa + i);
				Math.length3(s, n, a);
				this.collidesWithMap() || (this.x += s, this.y += n, this.z += a, this.dy -= .012 * dR.value.gravity), this.dx *= .96, this.Sa *= .96
			}
			this.ttl -= 1
		}
	}, _R.prototype.remove = function() {
		cI.grenadePool.recycle(this), this.pa.remove()
	}, _R.prototype.collidesWithMap = function() {
		_R.Ua.set(this.x, this.y - .07, this.z), _R.na.set(this.dx, this.dy, this.Sa), _R.$a.set(this.dx, this.dy, this.Sa);
		var e = uR.qa(_R.Ua, _R.na, uR.grenadeCollidesWithCell);
		if (e) {
			if (!(1 == e.normal.y && _R.$a.length() < .05)) return _R.$a.subtractInPlace(e.normal.scale(1.6 * e.dot)), this.dx = .98 * _R.$a.x, this.dy = _R.$a.y, this.Sa = .98 * _R.$a.z, this.pa.bounce(), e;
			this.resting = !0
		}
		return !1
	}, _R.prototype.throw = function(e, t, i) {
		this.xa = e, this.x = t.x, this.y = t.y, this.z = t.z, this.dx = i.x, this.dy = i.y, this.Sa = i.z, this.ttl = 75, this.damage = 150, this.radius = 3, this.resting = !1, this.active = !0, this.pa.throw()
	};
	var gR = class {
		fire() {
			var e = Hc.Jk(this.xa.Oa + Math.PI, -this.xa.ca, 0),
				t = Hc.Translation(0, 0, this.constructor.range).multiply(e),
				i = t.getTranslation();
			this.shootingAccuracy = Math.min(this.shootingAccuracy + this.Ga, this.Qa), this.accuracyRecover = 8 * -this.constructor.accuracyRecover;
			let s = this.accuracy;
			if (isNaN(s) && (s = 0), this.constructor.burst && this.burstQueue <= 0 && (this.burstQueue = (this.constructor.burst - 1) * this.constructor.burstRof), this.constructor !== yR) {
				let e = s,
					i = Hc.Jk((this.xa.ya.getFloat() - .5) * e, (this.xa.ya.getFloat() - .5) * e, (this.xa.ya.getFloat() - .5) * e);
				t = t.multiply(i)
			}
			i = t.getTranslation();
			var n = Hc.Translation(0, .1, 0),
				a = (n = (n = n.multiply(e)).add(Hc.Translation(this.xa.Xa, this.xa.ba + .3 * this.xa.playerScale, this.xa.va))).getTranslation();
			a.x = Math.floor(256 * a.x) / 256, a.y = Math.floor(256 * a.y) / 256, a.z = Math.floor(256 * a.z) / 256, i.x = Math.floor(256 * i.x) / 256, i.y = Math.floor(256 * i.y) / 256, i.z = Math.floor(256 * i.z) / 256, this.ammo.Ca--, this.xa.id == xk && AP(), this.pa.fire(), this.fireMunitions(a, i), --this.tracer < 0 && (this.tracer = this.constructor.tracer)
		}
		constructor(e) {
			this.dmgTypeId = 0, this.xa = e, this.scene = this.xa.scene, this.highPrecision = !1, this.equipTime = 13, this.stowWeaponTime = 13, this.accuracy = this.constructor.ta, this.shootingAccuracy = this.constructor.ta, this.movementAccuracy = this.constructor.ta, this.ta = this.constructor.ta, this.Qa = this.constructor.Qa, this.Ga = this.constructor.Ga, this.accuracyRecover = this.constructor.accuracyRecover, this.tracer = 0, this.burstQueue = 0, this.adsMod = this.constructor.adsMod || .5, this.movementAccuracyMod = this.constructor.movementAccuracyMod || 1
		}
		update() {
			this.burstQueue > 0 && (this.burstQueue % this.constructor.burstRof == 0 && this.fire(), this.burstQueue--), this.xa.scope && 0 === this.xa.scopeDelay ? this.accuracyMod = this.adsMod : this.accuracyMod = 1;
			let e = 14.41 * Math.length2(this.xa.dx, this.xa.Sa),
				t = Math.min(1, 14.41 * Math.abs(this.xa.dy)),
				i = this.constructor.reloadBloom && this.xa.reloadCountdown > 0 || this.xa.swapWeaponCountdown > 0 || this.xa.ja > 0,
				s = this.xa.scope && 0 === this.xa.scopeDelay,
				n = (e + t + (i ? 1 : 0)) * this.constructor.Qa;
			this.movementAccuracy < n ? this.movementAccuracy = n : this.movementAccuracy = Math.max(this.movementAccuracy - this.constructor.accuracyRecover, n), s ? (this.ta = this.constructor.ta * this.adsMod, this.Qa = this.constructor.Qa * this.adsMod, this.Ga = this.constructor.Ga * this.adsMod) : (this.ta = this.constructor.ta, this.Qa = this.constructor.Qa, this.Ga = this.constructor.Ga), this.accuracyRecover = Math.min(this.accuracyRecover + this.constructor.accuracyRecover, this.constructor.accuracyRecover);
			let a = Math.max(this.accuracyRecover, 0);
			this.shootingAccuracy = Math.max(this.shootingAccuracy - a, this.ta), this.accuracy = this.movementAccuracy * this.movementAccuracyMod + this.shootingAccuracy, this.constructor.absoluteMinAccuracy && (this.accuracy = Math.min(this.accuracy, this.constructor.absoluteMinAccuracy))
		}
		equip(e) {
			this.xa.Ma = this.xa.equipWeaponIdx, this.xa.Wa = this.xa.weapons[this.xa.Ma], this.xa.Wa.pa.equip(e), this.xa.id == xk && AP(), this.xa.lastWeaponChange = 0
		}
		collectAmmo() {
			return this.ammo.store = Math.min(this.ammo.Ea, this.ammo.store + this.ammo.pickup), !0
		}
	};
	gR.reloadBloom = !0, gR.reloadTimeMod = 1;
	var vR = class e extends gR {
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 30,
				Yk: 30,
				reload: 30,
				store: 240,
				Ea: 240,
				pickup: 30
			}, this.longReloadTime = 205, this.shortReloadTime = 160, this.pa = new oO(this, t)
		}
	};
	vR.dmgTypeId = uh.findIndex((e => "Eggk47" === e.name)), vR.weaponName = "EggK-47", vR.za = "eggk47", vR.rof = 3, vR.recoil = 7, vR.automatic = !0, vR.damage = 20, vR.totalDamage = 20, vR.range = 20, vR.velocity = 1.5, vR.tracer = 1;
	var yR = class e extends gR {
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 2,
				Yk: 2,
				reload: 2,
				store: 24,
				Ea: 24,
				pickup: 8
			}, this.longReloadTime = 155, this.shortReloadTime = 155, this.Ua = new Lc, this.pa = new lO(this, t)
		}
		fireMunitions(t, i) {
			for (var s = this.accuracy, n = .6 * s, a = 0; a < 20; a++) this.Ua.set(i.x + this.xa.ya.getFloat(-s, s) * e.range, i.y + this.xa.ya.getFloat(-n, n) * e.range, i.z + this.xa.ya.getFloat(-s, s) * e.range), lR.fire(this.xa, t, this.Ua, e)
		}
	};
	yR.dmgTypeId = uh.findIndex((e => "Scrambler" === e.name)), yR.weaponName = "Dozen Gauge", yR.za = "dozenGauge", yR.rof = 8, yR.recoil = 10, yR.automatic = !1, yR.damage = 8, yR.totalDamage = 20 * yR.damage, yR.range = 8, yR.velocity = 1, yR.tracer = 0;
	var SR = class e extends gR {
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 15,
				Yk: 15,
				reload: 15,
				store: 60,
				Ea: 60,
				pickup: 15
			}, this.hasScope = !0, this.longReloadTime = 225, this.shortReloadTime = 165, this.highPrecision = !0, this.pa = new hO(this, t)
		}
	};
	SR.dmgTypeId = uh.findIndex((e => "FreeRanger" === e.name)), SR.weaponName = "CSG-1", SR.za = "csg1", SR.rof = 13, SR.recoil = 13, SR.automatic = !1, SR.damage = 110, SR.totalDamage = 110, SR.range = 50, SR.velocity = 1.75, SR.tracer = 0;
	var ER = class e extends gR {
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 15,
				Yk: 15,
				reload: 15,
				store: 60,
				Ea: 60,
				pickup: 15
			}, this.longReloadTime = 195, this.shortReloadTime = 160, this.pa = new cO(this, t)
		}
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
	};
	ER.dmgTypeId = uh.findIndex((e => "Cluck9mm" === e.name)), ER.weaponName = "Cluck 9mm", ER.za = "cluck9mm", ER.rof = 4, ER.recoil = 6, ER.automatic = !1, ER.damage = 25, ER.totalDamage = 25, ER.range = 15, ER.velocity = 1, ER.tracer = 0;
	var AR = class e extends gR {
		fireMunitions(t, i) {
			KR.fire(this.xa, t, i, e);
			for (var s = 0; s < 10; s++) {
				var n = .04 * Math.random() - .02,
					a = .04 * Math.random() - .02,
					r = .04 * Math.random() - .02;
				DI(DN, 10, t.x, t.y, t.z, n, a, r, .4, !1, 0)
			}
		}
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 1,
				Yk: 1,
				reload: 1,
				store: 3,
				Ea: 3,
				pickup: 1
			}, this.hasScope = !0, this.longReloadTime = 170, this.shortReloadTime = 170, this.pa = new uO(this, t)
		}
	};
	AR.dmgTypeId = uh.findIndex((e => "Rpegg" === e.name)), AR.weaponName = "RPEGG", AR.za = "rpegg", AR.rof = 40, AR.recoil = 60, AR.automatic = !1, AR.damage = 140, AR.radius = 2.75, AR.totalDamage = AR.damage * AR.radius * .5, AR.range = 45, AR.minRange = 3, AR.velocity = .4;
	var bR = class e extends gR {
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 40,
				Yk: 40,
				reload: 40,
				store: 200,
				Ea: 200,
				pickup: 40
			}, this.longReloadTime = 225, this.shortReloadTime = 190, this.pa = new mO(this, t)
		}
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
	};
	bR.dmgTypeId = uh.findIndex((e => "Whipper" === e.name)), bR.weaponName = "SMEGG", bR.za = "smg", bR.rof = 2, bR.recoil = 7, bR.automatic = !0, bR.damage = 15, bR.totalDamage = 15, bR.range = 20, bR.velocity = 1.25, bR.tracer = 2;
	var xR = class e extends gR {
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 1,
				Yk: 1,
				reload: 1,
				store: 12,
				Ea: 12,
				pickup: 4
			}, this.hasScope = !0, this.longReloadTime = 144, this.shortReloadTime = 144, this.pa = new dO(this, t)
		}
	};
	xR.dmgTypeId = uh.findIndex((e => "Crackshot" === e.name)), xR.weaponName = "M2DZ", xR.za = "m24", xR.rof = 15, xR.recoil = 20, xR.automatic = !1, xR.damage = 200, xR.totalDamage = 15, xR.range = 60, xR.velocity = 2, xR.tracer = 0;
	var MR = class e extends gR {
		constructor(e, t) {
			super(e), this.ammo = {
				Ca: 24,
				Yk: 24,
				reload: 24,
				store: 150,
				Ea: 150,
				pickup: 24
			}, this.longReloadTime = 205, this.shortReloadTime = 160, this.pa = new fO(this, t)
		}
		fireMunitions(t, i) {
			lR.fire(this.xa, t, i, e)
		}
	};
	MR.dmgTypeId = uh.findIndex((e => "TriHard" === e.name)), MR.weaponName = "TriHard", MR.za = "aug", MR.rof = 15, MR.recoil = 18, MR.automatic = !1, MR.movementInstability = 2, MR.damage = 20, MR.totalDamage = 20, MR.range = 20, MR.velocity = 1.5, MR.tracer = 0, MR.burst = 3, MR.burstRof = 3, vR.damage = 30, vR.ta = .03, vR.Qa = .15, vR.Ga = .05, vR.accuracyRecover = .025, vR.totalDamage = 30, yR.damage = 8.5, yR.ta = .13, yR.Qa = .16, yR.Ga = .17, yR.accuracyRecover = .02, yR.totalDamage = 170, yR.adsMod = .6, yR.movementAccuracyMod = .2, SR.damage = 105, SR.ta = .004, SR.Qa = .3, SR.Ga = .3, SR.accuracyRecover = .025, SR.totalDamage = 105, AR.ta = .015, AR.Qa = .3, AR.Ga = .3, AR.accuracyRecover = .02, AR.absoluteMinAccuracy = .3, bR.damage = 23, bR.ta = .06, bR.Qa = .19, bR.Ga = .045, bR.accuracyRecover = .05, bR.totalDamage = 23, bR.adsMod = .6, bR.movementAccuracyMod = .7, xR.damage = 170, xR.ta = 0, xR.Qa = .35, xR.Ga = .1, xR.accuracyRecover = .023, xR.totalDamage = 170, xR.movementAccuracyMod = 1.3, xR.reloadBloom = !1, xR.reloadTimeMod = .8, ER.damage = 26, ER.ta = .035, ER.Qa = .15, ER.Ga = .09, ER.accuracyRecover = .08, ER.totalDamage = 26, ER.adsMod = .8, ER.movementAccuracyMod = .6, MR.damage = 32, MR.ta = .03, MR.Qa = .15, MR.Ga = .037, MR.accuracyRecover = .03, MR.totalDamage = 34, MR.adsMod = .6, MR.movementAccuracyMod = .8;
	var CR = [{
		filename: "aqueduct",
		hash: "11dp765kifr",
		name: "Aqueduct",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "backstage",
		hash: "9dsromfqr1",
		name: "Backstage",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "bastion",
		hash: "uuwh7401no",
		name: "Bastion",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "bedrock",
		hash: "yqbkimntiu",
		name: "Bedrock",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "biohazard",
		hash: "kzarr9ebqx",
		name: "BioHazard",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "blender",
		hash: "1vvfxp9rt8u",
		name: "Blender",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "blue",
		hash: "2e7izzo70bk",
		name: "Blue",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "14"
	}, {
		filename: "bridge",
		hash: "20vcy8e1ev0",
		name: "Bridge",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "canyon",
		hash: "2avqtv9ygk1",
		name: "Canyon",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "cash",
		hash: "1427gfre8ma",
		name: "Cash",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "castle",
		hash: "2d2tcz2mw7e",
		name: "Castle",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "castleArena",
		hash: "9dhs3kms6l",
		name: "Castle Arena",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "8"
	}, {
		filename: "catacombs",
		hash: "2el91jtcun0",
		name: "Catacombs",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "chickenItza",
		hash: "hyjqbat0i3",
		name: "Chicken Itza",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "cluckgrounds",
		hash: "1h9z3hj51g5",
		name: "Cluckgrounds",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "16"
	}, {
		filename: "crossed",
		hash: "ead3tcf30r",
		name: "Crossed",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "crowsnest",
		hash: "1ze2s5zr9bm",
		name: "Crowsnest",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "8"
	}, {
		filename: "deathpit",
		hash: "1cc9cvjf607",
		name: "Death Pit",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "dirt",
		hash: "1u3k5nfvwuh",
		name: "Dirt",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "dirt2",
		hash: "494aka3mb4",
		name: "Dirt 2",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "dirtbase",
		hash: "6e9r2y7dxk",
		name: "Dirt Base",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "10"
	}, {
		filename: "downfall",
		hash: "26g5aj8aruc",
		name: "Downfall",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "duelPyramid",
		hash: "vmg0rj2e3b",
		name: "Duel Pyramid",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "eggcrates",
		hash: "j0i36e808n",
		name: "Eggcrates",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "enchanted",
		hash: "1igxtcyetaw",
		name: "Enchanted",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "16"
	}, {
		filename: "exposure",
		hash: "15hv3cme1fh",
		name: "Exposure",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "facility",
		hash: "18djbmo35ru",
		name: "Facility",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "feedlot",
		hash: "iuj8rc7kyh",
		name: "Feedlot",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "16"
	}, {
		filename: "field",
		hash: "e4aszuch87",
		name: "Field",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "10"
	}, {
		filename: "fortFlip",
		hash: "1w1b6dkalc2",
		name: "Fort Flip",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "foundation",
		hash: "11y636vc64b",
		name: "Foundation",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "fourQuarters",
		hash: "1a0w7vbz8is",
		name: "Four Quarters",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "10"
	}, {
		filename: "greenhouse",
		hash: "ffvpjhqou6",
		name: "Greenhouse",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "growler",
		hash: "1izyni7tb1e",
		name: "Growler",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "haunted",
		hash: "2dma8z1jdev",
		name: "Haunted",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "16"
	}, {
		filename: "helix",
		hash: "i2sl4vsg3h",
		name: "Helix",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "hydro",
		hash: "8znnxbxfss",
		name: "Hydro",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "indigo",
		hash: "1vrzzn6ym9q",
		name: "Indigo",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "jailbreak",
		hash: "2a3blmd9hf4",
		name: "Jail Break",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "jinx",
		hash: "24u6pohagnj",
		name: "Jinx",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "junction",
		hash: "bkca8j2ppd",
		name: "Junction",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "kingsCourt",
		hash: "aq1t2lsjza",
		name: "King's Court",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "lunarmodule",
		hash: "1448aqjdqvl",
		name: "Lunar Module",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "mansion",
		hash: "nqhtvwj3fo",
		name: "Mansion",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "mazerunner",
		hash: "j16i30k9dz",
		name: "Maze Runner",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "metamorph",
		hash: "l9o69l8e1b",
		name: "Metamorph",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "moonbase",
		hash: "1yzocf1mex3",
		name: "Moonbase",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "mudGulch",
		hash: "kto278skze",
		name: "Mud Gulch",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "14"
	}, {
		filename: "nextdoor",
		hash: "s2i5za1kx9",
		name: "Nextdoor",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "outer",
		hash: "w1biqokp89",
		name: "Outer Reach",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "overcooked",
		hash: "29ca98hgdeh",
		name: "Overcooked",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "palaceSiege",
		hash: "1enghs5hsxe",
		name: "Palace Siege",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "quarry",
		hash: "2crjk106pa",
		name: "Quarry",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "queenscourt",
		hash: "raudy4h9pv",
		name: "Queen's Court",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "raceway",
		hash: "1a3eo6xaoju",
		name: "Raceway",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "rameses",
		hash: "177jt4j8so9",
		name: "Rameses",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "16"
	}, {
		filename: "rats",
		hash: "13r2oqql8se",
		name: "Rats",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "relic",
		hash: "lxzknz53a2",
		name: "Relic",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "rivals",
		hash: "26fkvcef2h6",
		name: "Rivals",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "road",
		hash: "2h312vlocd",
		name: "Road",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "14"
	}, {
		filename: "ruins",
		hash: "3ycs8z9bcu",
		name: "Ruins",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "scales",
		hash: "101v5lpkv1s",
		name: "Scales",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "shadyglen",
		hash: "2d0d4bj7aq3",
		name: "Shady Glen",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "shellville",
		hash: "fdgmkbfe7n",
		name: "Shellville",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "16"
	}, {
		filename: "shipyard",
		hash: "1n1sptszksq",
		name: "Shipyard",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "skyScratcher",
		hash: "1th1c8epp95",
		name: "Sky Scratcher",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "spaceFactory",
		hash: "10802a2az0f",
		name: "Space Factory",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "10"
	}, {
		filename: "spacearena",
		hash: "k9zf5lqzze",
		name: "Space Arena",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "14"
	}, {
		filename: "sparta",
		hash: "274wwdyll9w",
		name: "Sparta",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "spellbound",
		hash: "1curtd0i4ls",
		name: "Spellbound",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "stage",
		hash: "1zn44r9jb3t",
		name: "Stage",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "starship",
		hash: "27xerc3smw5",
		name: "Starship",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}, {
		filename: "staxarena",
		hash: "1jid8ffda0z",
		name: "Stax Arena",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "teggtris",
		hash: "1y4rswkkv3l",
		name: "Teggtris",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "temple",
		hash: "bp6twwct9v",
		name: "Temple",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "timetwist",
		hash: "1ad75xyk2rv",
		name: "Timetwist",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "trainyard",
		hash: "2e1w70fjqet",
		name: "Trainyard",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "treefort",
		hash: "14a9akanqms",
		name: "Tree Fort",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "6"
	}, {
		filename: "twoTowers",
		hash: "2asidv5c0ff",
		name: "Two Towers",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "uncovered",
		hash: "bxrd0zdvtn",
		name: "Uncovered",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !1
		},
		availability: "private",
		numPlayers: "12"
	}, {
		filename: "vert",
		hash: "25a9ikled77",
		name: "Vert",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "12"
	}, {
		filename: "wimble",
		hash: "13smnxheae1",
		name: "Wimble",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "wonderland",
		hash: "5n6ixyepvy",
		name: "Wonderland",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "wreckage",
		hash: "nkiu4z6uj1",
		name: "Wreckage",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "yolkido",
		hash: "pttsmqw7xj",
		name: "Yolkido Garrison",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "private",
		numPlayers: "18"
	}, {
		filename: "zoomies",
		hash: "3vitx32ce8",
		name: "Zoomies",
		modes: {
			FFA: !0,
			Teams: !0,
			Spatula: !0,
			King: !0
		},
		availability: "both",
		numPlayers: "18"
	}];

	function TR() {
		this.seed = 100
	}
	Math.PI2 = 2 * Math.PI, Math.PI90 = Math.PI / 2, Math.mod = function(e, t) {
		var i = e % t;
		return i >= 0 ? i : i + t
	}, Math.length2 = function(e, t) {
		return Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2))
	}, Math.length3 = function(e, t, i) {
		return Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2) + Math.pow(i, 2))
	}, Math.capVector2 = function(e, t) {
		var i = Math.length2(e.x, e.y);
		return i > t && (e.x *= t / i, e.y *= t / i), e
	}, Math.capVector3 = function(e, t) {
		var i = Math.length3(e.x, e.y, e.z);
		return i > t && (e.x *= t / i, e.y *= t / i, e.z *= t / i), e
	}, Math.normalize2 = function(e, t) {
		t = t || 1;
		var i = Math.length2(e.x, e.y);
		return e.x *= t / i, e.y *= t / i, e
	}, Math.normalize3 = function(e, t) {
		t = t || 1;
		var i = Math.length3(e.x, e.y, e.z);
		return e.x *= t / i, e.y *= t / i, e.z *= t / i, e
	}, Math.clamp = function(e, t, i) {
		return Math.max(Math.min(e, i), t)
	}, Math.radAdd = function(e, t) {
		return Math.floor(8192 * Math.mod(e + t, Math.PI2)) / 8192
	}, Math.radSub = function(e, t) {
		return Math.floor(8192 * Math.mod(e - t, Math.PI2)) / 8192
	}, Math.radRange = function(e) {
		return Math.mod(e, Math.PI2)
	}, Math.radDifference = function(e, t) {
		var i = (e - t + Math.PI) % Math.PI2 - Math.PI;
		return i = i < -Math.PI ? i + Math.PI2 : i
	}, Math.cardVals = [0, Math.PI90, Math.PI, 3 * Math.PI90], Math.cardToRad = function(e) {
		return Math.cardVals[e]
	}, Math.randomInt = function(e, t) {
		return Math.floor(Math.random() * (t - e) + e)
	}, Math.diff = function(e, t, i) {
		return e < t ? i - e + t : e - t
	}, TR.prototype.setSeed = function(e) {
		this.seed = e
	}, TR.prototype.getFloat = function(e, t) {
		return e = e || 0, t = t || 1, this.seed = (9301 * this.seed + 49297) % 233280, e + this.seed / 233280 * (t - e)
	}, TR.prototype.getInt = function(e, t) {
		return Math.floor(this.getFloat(e, t))
	};
	var wR = {
			linear: function(e) {
				return e
			},
			inQuad: function(e) {
				return e * e
			},
			outQuad: function(e) {
				return e * (2 - e)
			},
			inOutQuad: function(e) {
				return e < .5 ? 2 * e * e : (4 - 2 * e) * e - 1
			},
			inCubic: function(e) {
				return e * e * e
			},
			outCubic: function(e) {
				return --e * e * e + 1
			},
			inOutCubic: function(e) {
				return e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
			},
			inQuart: function(e) {
				return e * e * e * e
			},
			outQuart: function(e) {
				return 1 - --e * e * e * e
			},
			inOutQuart: function(e) {
				return e < .5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e
			},
			inQuint: function(e) {
				return e * e * e * e * e
			},
			outQuint: function(e) {
				return 1 + --e * e * e * e * e
			},
			inOutQuint: function(e) {
				return e < .5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e
			}
		},
		RR = class e {
			attack() {
				this.collisionCountdown = 5
			}
			checkCollisions() {
				var t = Hc.Jk(this.xa.Oa, this.xa.ca, 0),
					i = Hc.Translation(0, 0, -.8).multiply(t);
				this.dir = i.getTranslation(), e.Ua.set(this.xa.Xa - .25 * this.dir.x, this.xa.ba - .25 * this.dir.y + .3, this.xa.va - .25 * this.dir.z), uR.fa(e.Ua, this.dir, this, .475)
			}
			update() {
				this.collisionCountdown > 0 && 0 == --this.collisionCountdown && this.checkCollisions()
			}
			constructor(e) {
				this.xa = e, this.scene = this.xa.scene, this.collisionCountdown = 0, this.dmgTypeId = uh.findIndex((e => "Melee" === e.name)), e.pa && (this.pa = new xO(this, this.xa.meleeItem.item_data.meshName)), this.dir = new Lc
			}
			collidesWithPlayer(e) {
				let t = 40;
				this.xa.activeShellStreaks & ph.EggBreaker && (t = 255), dP(e, this, t, this.dir.x, this.dir.z)
			}
		};

	function NR(e) {
		this.bulletPool = new Th((function() {
			return new lR(e)
		}), 200), this.rocketPool = new Th((function() {
			return new KR(e)
		}), 20), this.grenadePool = new Th((function() {
			return new _R(e)
		}), 10)
	}
	RR.Ua = new Lc, RR.na = new Lc, NR.prototype.updateLogic = function() {
		this.bulletPool.forEachActive((function(e) {
			e.update()
		})), this.rocketPool.forEachActive((function(e) {
			e.update()
		})), this.grenadePool.forEachActive((function(e) {
			e.update()
		}))
	}, NR.prototype.updateActors = function(e) {
		this.bulletPool.forEachActive((function(t) {
			t.pa.update(e)
		})), this.rocketPool.forEachActive((function(t) {
			t.pa.update(e)
		})), this.grenadePool.forEachActive((function(t) {
			t.pa.update(e)
		}))
	}, NR.prototype.removeAll = function() {
		this.bulletPool.forEachActive((function(e) {
			e.remove()
		})), this.rocketPool.forEachActive((function(e) {
			e.remove()
		})), this.grenadePool.forEachActive((function(e) {
			e.remove()
		}))
	}, NR.prototype.throwGrenade = function(e, t, i) {
		this.grenadePool.retrieve().throw(e, t, i)
	}, NR.prototype.getMapIntersectionPoint = function(e, t) {
		if (t && !kR[t.cell.idx].softness && t.cell && t.cell.idx) {
			var i = kR[t.cell.idx],
				s = new Yv(new Lc(e.x - e.dx - t.x - .5, e.y - e.dy - t.y - .5, e.z - e.Sa - t.z - .5), new Lc(2 * e.dx, 2 * e.dy, 2 * e.Sa), 1);
			i.rotation.x = t.cell.rx, i.rotation.y = t.cell.ry, i.rotation.z = t.cell.rz;
			var n = s.intersectsMesh(i, !1);
			if (n.hit) {
				var a = new Lc(-e.dx, -e.dy, -e.Sa).normalize().scale(.005);
				return {
					x: n.pickedPoint.x + t.x + .5 + a.x,
					y: n.pickedPoint.y + t.y + .5 + a.y,
					z: n.pickedPoint.z + t.z + .5 + a.z
				}
			}
		}
		return !1
	};
	var IR = {
		up: 1,
		down: 2,
		left: 4,
		right: 8,
		jump: 16,
		fire: 32,
		melee: 64,
		scope: 128,
		ascend: 256,
		descend: 512
	};
	kh.classes = [{
		name: "Soldier",
		Wa: vR
	}, {
		name: "Scrambler",
		Wa: yR
	}, {
		name: "Free Ranger",
		Wa: SR
	}, {
		name: "Eggsploder",
		Wa: AR
	}, {
		name: "Whipper",
		Wa: bR
	}, {
		name: "Crackshot",
		Wa: xR
	}, {
		name: "TriHard",
		Wa: MR
	}];
	var PR, kR, DR = ["streak", "kills", "killsCluck9mm", "killsGrenade", "killsRpegg", "killsEggk47", "killsScrambler", "killsFreeRanger", "killsWhipper", "killsCrackshot", "killsTriHard", "killsMelee", "killsPrivate", "killsPublic", "killsKing", "killsSpatula", "killsTeams", "killsFFA", "deaths", "deathsCluck9mm", "deathsGrenade", "deathsRpegg", "deathsEggk47", "deathsScrambler", "deathsFreeRanger", "deathsWhipper", "deathsCrackshot", "deathsTriHard", "deathsMelee", "deathsFall", "deathsPrivate", "deathsPublic", "deathsKing", "deathsSpatula", "deathsTeams", "deathsFFA", "kotcCaptured", "kotcWins"],
		OR = 256;

	function FR(e, t) {
		this.id = e.sa, this.ik = e.Ia, this.name = e.Ka, this.Ha = e.ua, this.safeName = e.Ja, this.charClass = e.ia, this.team = e.Ya, this.primaryWeaponItem = e.Na, this.secondaryWeaponItem = e.oa, this.shellColor = e.Pa, this.hatItem = e.ga, this.stampItem = e.Aa, this.stampPositionX = e.Ra, this.stampPositionY = e.da, this.grenadeItem = e.Za, this.meleeItem = e.ma, this.Xa = e.Xa, this.ba = e.ba, this.va = e.va, this.dx = e.Ta, this.dy = e.La, this.Sa = e.wa, this._a = e._a, this.Oa = e.Oa, this.ca = e.ca, this.kS = "AAAAAAAA", this.speed = 0, this.scope = !1, this.scopeDelay = 0, this.primaryWeaponDisabled = !1, this.reloading = !1, this.aS = e.SS, this.lifetimeDeaths = e.xS, this.totalKills = 0, this.pS = 0, this.rS = e.US, this.bestOverallStreak = e.nS, this.stats = {}, DR.forEach((t => {
			this.stats[t] = e.$S[t]
		})), this.gameData = e.qS, this.shield = e.WS, this.fS = e.fS, this.lS = 0, this.Ba = e.DS, this.Ma = e.FS, this.upgradeProductId = e.BS, this.mobileMultiplier = 1, this.isGameOwner = e.XS, this.capturing = !1, this.kotcCapturing = !1, this.activeShellStreaks = e.bS, this.vS = 0, this.eggBreakerValue = 0, this.ksEggMuliplierValue = 0, this.skMiniEggValue = 0, this.playerScale = 1, this.shellStreakIncrement = 450, this.adminRoles = e.VS, this.muted = e.eS, this.scene = t, this.corrected = {
			dx: 0,
			dy: 0,
			Sa: 0,
			ca: 0,
			Oa: 0
		}, this.corrections = 0, this.totalCorrections = 2, this.resetCountdowns(), this.equipWeaponIdx = this.Ma, this.OS = 1, this.cS = 3, this.lastWeaponChange = 0, this.jumpQueued = 0, this.GS = !1, this.onGround = 4, this.QS = !1, this.bobble = 0, this.stateIdx = 0, this.serverStateIdx = 0, this.respawnTargetTime = 0, this.pauseTargetTime = 0, this.ready = !1, this.chatLines = 0, this.respawnQueued = !1, this.canTakeTeamBonus = !0, this.changingCharacter = !1, this.lastDamageTakenType = 0, this.lastDamageGivenType = 0, this.lastDmgType = 0, this.lastPosition = {
			x: this.Xa,
			y: this.ba,
			z: this.va
		}, this.firstUpdate = !0, this.damageMod = e.yS, this.abBucket = e.hS, this.aBTestInventoryReady = !1, this.pa = new RO(this), this.changeWeaponLoadout(this.primaryWeaponItem, this.secondaryWeaponItem), this.CS = [], this.resetStateBuffer(), this.ya = new TR, this.social = e.tS, this.hideBadge = e.jS, this.challengesActive = [], this.challengeKills = [], this.challengeDeaths = [], this.challengeKotc = [], this.challengeFfa = [], this.challengeCts = [], this.challengeTimed = {
			alive: [],
			played: [],
			cts: [],
			kotc: [],
			kill: []
		}, this.challengesDelayedChecks = [], this.eggsEarned = 0, this.timers = {
			alive: 0,
			played: 0,
			cts: 0,
			kotc: 0,
			kill: 0
		}, this.distanceTime = Date.now(), this.dmgGiven = 0, this.distanceTraveled = 0, this.timesJumped = 0, this.jumps = 0, this.ammoCollected = [0, 0], this.cstCapturingTime = 0, this.ctsControlled = !1, this.streakCtsKills = 0, this.teamPoints = 0, this.challengesGet(e.challengesActive), this.shellStreakMsg = ""
	}
	FR.Ua = new Lc, FR.na = new Lc, FR.$a = new Lc, FR.Da = new Lc, FR.Fa = new Fc, FR.Va = new Fc, FR.ea = new Lc, FR.MS = new Lc, FR.ray = new Yv, FR.matrix = new Hc, FR.prototype.ctsCapture = function(e) {
		this.ctsControlled = e === this.ik
	}, FR.prototype.changeWeaponLoadout = function(e, t) {
		this.weapons && (this.weapons[0].pa.dispose(), this.weapons[1].pa.dispose(), this.meleeWeapon.pa.dispose()), this.meleeWeapon = new RR(this), this.primaryWeaponItem = e, this.secondaryWeaponItem = t, this.weapons = [e.instantiateNew(this), t.instantiateNew(this)], this.Wa = this.weapons[this.Ma], this.Wa.pa.equip()
	}, FR.prototype.ES = function(e) {
		var t = 0,
			i = 0,
			s = 0;
		if (e || this.id != xk || (this._a = zN), !this.pa || this.id != xk) {
			var n = this.stateIdx;
			n = Math.min(n, mh - 1), this._a = this.CS[n]._a, this.Oa = this.CS[n].Oa, this.ca = this.CS[n].ca, this.playerScale = this.CS[n].scale, this.CS[n]._a = 0
		}(m = this.CS[this.stateIdx])._a = this._a, m.Oa = this.Oa, m.ca = this.ca, m.kS = this.kS, m.scale = this.playerScale, this._a & IR.left && (t -= Math.cos(this.Oa), s += Math.sin(this.Oa)), this._a & IR.right && (t += Math.cos(this.Oa), s -= Math.sin(this.Oa)), this._a & IR.up && (this.QS ? i += 1 : (t -= Math.sin(this.Oa), s -= Math.cos(this.Oa))), this._a & IR.down && (this.QS ? i -= 1 : (t += Math.sin(this.Oa), s += Math.cos(this.Oa))), this._a & IR.jump && (this.jumpQueued = 10, this._a ^= this._a & IR.jump, this.id == xk && (zN ^= zN & IR.jump)), this._a & IR.scope ? this.scope || this.scopeIn() : this.scope && this.scopeOut(), this.jumpQueued > 0 && (this.jumpQueued--, this.jump());
		let a = this.scope && 0 === this.scopeDelay;
		if (this.QS) {
			this.setJumping(!1);
			var r = this.dy;
			this.corrections && (r += this.corrected.dy / this.totalCorrections, this.corrections--), this.dy += .028 * i;
			var o = .5 * (this.dy + r);
			this.ba += o, this.dy *= .5, Math.floor(this.ba) >= qN.height && (this.QS = !1), this.move(0, o, 0)
		} else {
			var l = new Lc(t, i, s).normalize();
			a && (l.x *= .5, l.z *= .5), this.dx += .025 * l.x, this.Sa += .025 * l.z, this.dy -= .012 * dR.value.gravity, this.dy = Math.max(-.29, this.dy);
			var h = FR.Da;
			if (h.copyFromFloats(this.Xa, this.ba, this.va), this.move(this.dx, this.dy, this.Sa), this.dx = this.Xa - h.x, this.dy = this.ba - h.y, this.Sa = this.va - h.z, this.onGround && this.dy > 0) {
				var c = 1 - .5 * FR.ea.copyFromFloats(this.dx, this.dy, this.Sa).normalize().y;
				this.dx *= c, this.Sa *= c
			}
			if (!e && this.corrections) {
				let e = 0,
					t = this.corrected.dx / this.totalCorrections;
				this.QS && (e = this.corrected.dy / this.totalCorrections);
				let i = this.corrected.Sa / this.totalCorrections;
				this.corrections--, this.move(t, e, i)
			}
		}
		if (!e) {
			this.shield > 0 && this.Ba && (this.shield -= 2, (0 != t || 0 != i || this.shield <= 0) && this.disableShield()), this.scopeDelay = Math.max(0, this.scopeDelay - 1), this.lastWeaponChange++;
			var u = Math.max(0, Math.length3(this.dx, this.dy, this.Sa) - .012);
			this.speed = u, (this.QS || this.GS) && (u *= 2), this.bobble = (this.bobble + 7 * (u + .01)) % Math.PI2, this.Wa && this.Wa.update(), this.meleeWeapon.update(), this.meleeCountdown > 0 && 0 == --this.meleeCountdown && (this.id == xk && this._a & IR.melee ? this.inspectMelee() : (this.swapWeaponCountdown = .5 * this.Wa.equipTime, this.pa.wieldGun(), this.id === bk && GN.show())), this.inspectMeleeCountdown > 0 && 0 == --this.inspectMeleeCountdown && (this.swapWeaponCountdown = .5 * this.Wa.equipTime, this.pa.wieldGun(), this.id === bk && GN.show()), this.updateHealth(), this.swapWeaponCountdown > 0 && (this.swapWeaponCountdown--, this.swapWeaponCountdown <= 0 && this.id == xk && GN.show()), this.timers.alive++, this.timers.played++, this.timers.played % 30 == 0 && this.challengeChecksDelay(), this.ctsControlled && this.challengeCts.length > 0 ? this.timers.cts++ : this.timers.cts = 0, this.kotcCapturing && this.challengeKotc.length > 0 ? this.timers.kotc++ : this.timers.kotc = 0, this.reloadCountdown > 0 && (this.lastWeaponChange = 0, this.reloadCountdown -= 2, this.reloadCountdown <= 0 && (this.reloadCountdown = 0, this.reloaded())), this.rofCountdown > 0 && (this.rofCountdown = Math.max(this.rofCountdown - 1, 0)), this.recoilCountdown > 0 && (this.recoilCountdown = Math.max(this.recoilCountdown - 2, 0)), this.ja > 0 && (this.ja -= 2), this.id == xk && (this.triggerPulled && this.fire(), this.shellStreakTimers()), this.stateIdx = Math.mod(this.stateIdx + 1, OR);
			var m = this.CS[this.stateIdx];
			this.saveState(m), mk && this.id == xk && bk.stateIdx % mh == 0 && mk.readyState == mk.OPEN && bk.Ba && !XT && function() {
				if (bk) {
					var e = Rh.getBuffer();
					e.BkKlQQwL(sh.jk), e.BkKlQQwL(bk.serverStateIdx), e.BkKlQQwL(Math.mod(bk.stateIdx - mh, OR));
					for (var t = Math.mod(bk.stateIdx - mh, OR), i = 0; i < mh; i++) {
						var s = Math.mod(t + i, OR);
						e.BkKlQQwL(bk.CS[s]._a), e.BkKlQQwL(bk.CS[s].shots), e.AABkKlQQwL(bk.CS[s].kS), e.BkKlQQwL(100 * bk.CS[s].scale), bk.CS[Math.mod(s - 128, OR)].shots = 0
					}
					e.send(mk)
				}
			}()
		}
		if (this.dx *= .64, this.Sa *= .64, this.QS && (this.dy *= .64), this.pa && this.id == xk || (this.reloadsQueued > 0 && this.reload(), this.weaponSwapsQueued > 0 && this.swapWeapon(this.equipWeaponIdx)), !this.pa && this.ba < -10) {
			let e = uh.findIndex((e => "Fall" === e.name));
			this.lastDmgType = e, this.die(), dk.scoreKill(this, this);
			var d = Rh.getBuffer();
			d.BkKlQQwL(sh.lk), d.BkKlQQwL(this.id), d.BkKlQQwL(this.id), d.BkKlQQwL(8), d.BkKlQQwL(e), d.BkKlQQwL(e), sendToAll(d)
		}
	}, FR.prototype.saveState = function(e) {
		e.Xa = this.Xa, e.ba = this.ba, e.va = this.va, e.dx = this.dx, e.dy = this.dy, e.Sa = this.Sa, e.GS = this.GS, e.QS = this.QS, e.Ma = this.Ma, e.Ca = this.Wa.ammo.Ca, e.store = this.Wa.ammo.store
	}, FR.prototype.move = function(e, t, i) {
		var s, n = FR.Ua,
			a = FR.MS,
			r = FR.na,
			o = FR.$a;
		if (this.onGround = Math.max(--this.onGround, 0), this.ba += .31, a.copyFromFloats(e, t, i), Math.capVector3(a, .29), n.copyFromFloats(this.Xa, this.ba, this.va), n.addInPlace(a), n.x = Math.clamp(n.x, .1, qN.width - .1), n.z = Math.clamp(n.z, .1, qN.depth - .1), this.firstUpdate) this.distanceTraveled = 0, this.firstUpdate = !1;
		else {
			let e = Math.sqrt((n.x - this.lastPosition.x) * (n.x - this.lastPosition.x) + (n.y - this.lastPosition.y) * (n.y - this.lastPosition.y) + (n.z - this.lastPosition.z) * (n.z - this.lastPosition.z));
			this.onGround > 0 && e > .01 && (this.distanceTraveled += e)
		}
		this.lastPosition.x = n.x, this.lastPosition.y = n.y, this.lastPosition.z = n.z;
		for (var l = 0; l < 8; l++) {
			var h = mR.sphereCollidesWithStructure(n, .31, r, o);
			if (!h) break;
			o.y < -.707 && (this.onGround = 4), this.QS || h.colliderType & mR.Type.ladder && this.tryToClimbLadder(h, o), n.addInPlace(r), this.onGround && (this.GS ? (this.setJumping(!1), this.dy = 0) : this._a & IR.down && (this.QS = !1))
		}
		if (8 == l && (a.scaleInPlace(.9), n.subtractInPlace(a)), this.Xa = n.x, this.ba = n.y, this.va = n.z, !this.QS || this.pa && this.id != xk) {
			u = Math.floor(this.Xa);
			var c = Math.floor(this.ba);
			m = Math.floor(this.va);
			if (this.Ba)
				if (s = jR(u, c, m)) s.zone || (this.capturing = !1, this.timers.kotc = 0);
			if (s = jR(u, Math.floor(this.ba - .5), m)) {
				let e = s.mesh;
				e && "jump-pad" == e.shortName && this.canJump() && Math.length2(u + .5 - this.Xa, m + .5 - this.va) < .3 && (this.ba += .26, this.setJumping(!0))
			}
		} else {
			var u = this.climbX,
				m = this.climbZ;
			this.QS = !1, this.capturing = !1, (s = jR(u, Math.floor(this.ba - .25), m)) && Math.floor(s.ry / Math.PI90) == this.climbRY && s.mesh && "ladder" == s.mesh.colliderType && (this.QS = !0), (s = jR(u, Math.floor(this.ba + .25), m)) && Math.floor(s.ry / Math.PI90) == this.climbRY && s.mesh && "ladder" == s.mesh.colliderType && (this.QS = !0)
		}
		this.ba -= .31
	}, FR.prototype.tryToClimbLadder = function(e, t) {
		if (this._a & IR.up && !(Math.abs(e.position.y - (this.ba + .18)) > .9)) {
			var i = Math.round(this.Oa / Math.PI90) % 4,
				s = e.cell.ry;
			if (i == s || (i + 2) % 4 == s) {
				var n = FR.Fa.set(t.x, t.z).normalize(),
					a = FR.Va.set(-Math.cos(this.Oa), Math.sin(this.Oa)),
					r = Fc.Dot(a, n);
				Math.abs(r) < .4 && (this.QS = !0, this.climbX = Math.clamp(Math.floor(e.position.x), 0, qN.width - 1), this.climbZ = Math.clamp(Math.floor(e.position.z), 0, qN.depth - 1), this.climbRY = e.cell.ry, this.dy = 0, this.setJumping(!1))
			}
		}
	}, FR.prototype.scopeIn = function() {
		this.isAtReady() && (this.Wa.pa && this.Wa.pa.restPose(), this.pa.wieldingMelee && this.pa.wieldGun(), this.scope = !0, this.scopeDelay = 7)
	}, FR.prototype.scopeOut = function() {
		this.scope = !1
	}, FR.prototype.disableShield = function() {
		this.shield = 0, this.pa.zS.renderOverlay = !1, this.pa.hands.renderOverlay = !1
	}, FR.prototype.sS = function() {
		this.shield = 120, this.pa.zS.overlayColor = FR.OverlayColor.green, this.pa.hands.overlayColor = FR.OverlayColor.green, this.pa.zS.renderOverlay = !0, this.pa.hands.renderOverlay = !0
	}, FR.prototype.resetStateBuffer = function() {
		for (var e = 0; e < OR; e++) this.CS[e] = {
			Oa: this.Oa,
			ca: this.ca,
			kS: this.kS,
			fire: !1,
			GS: this.GS,
			QS: this.QS,
			Xa: this.Xa,
			ba: this.ba,
			va: this.va,
			dx: this.dx,
			dy: this.dy,
			Sa: this.Sa,
			_a: this._a,
			shots: 0,
			Ca: [0, 0],
			store: [0, 0],
			scale: this.playerScale
		}
	}, FR.prototype.canJump = function() {
		return this.QS | this.onGround
	}, FR.prototype.jump = function() {
		this.QS && (this.dy = .065, this.QS = !1, this.setJumping(!0)), this.canJump() && (this.dy = .13, this.scope && 0 === this.scopeDelay && (this.dy *= .66), this.setJumping(!0))
	}, FR.prototype.setJumping = function(e) {
		this.jumpQueued = !1, this.onGround = 0, e && !this.GS && this.jumps++, this.GS = e, this.CS[this.stateIdx].GS = e
	}, FR.prototype.changeCharacter = function(e, t, i, s, n, a, r, o, l, h) {
		var c = function(e, t) {
			return e && !t || !e && t || null !== e && null !== t && e.id !== t.id
		};
		(e !== this.charClass || t.id !== this.primaryWeaponItem.id || i.id !== this.secondaryWeaponItem.id || s !== this.shellColor || c(this.hatItem, n) || c(this.stampItem, a) || this.grenadeItem !== l || this.meleeItem !== h || this.stampPositionX != r || this.stampPositionY != o) && (this.charClass = e, this.primaryWeaponItem = t, this.secondaryWeaponItem = i, this.shellColor = s, this.hatItem = n, this.stampItem = a, this.stampPositionX = r, this.stampPositionY = o, this.grenadeItem = l, this.meleeItem = h, this.pa.setShellColor(s), this.pa.setStampPosition(r, o), this.id !== xk && (this.pa.wearHat(this.hatItem), this.pa.applyStamp(this.stampItem), this.pa.setStampPosition(this.stampPositionX, this.stampPositionY)), this.changeWeaponLoadout(t, i))
	}, FR.prototype.swapWeapon = function(e) {
		if (this.primaryWeaponDisabled) return !1;
		if (this.pa && this.id != xk || this.canSwapOrReload() && e < 2) {
			if (this.equipWeaponIdx = e, this.releaseTrigger(), this.swapWeaponCountdown = this.Wa.stowWeaponTime + this.weapons[e].equipTime, this.id == xk && GN.hide(), this.pa.wieldingMelee = !1, this.Wa.pa.stow(), this.id == xk) {
				var t = Rh.getBuffer();
				t.BkKlQQwL(sh.k), t.BkKlQQwL(e), t.send(mk)
			}
			return !0
		}
		return !1
	}, FR.prototype.collectItem = function(e, t) {
		switch (e) {
			case EO.AMMO:
				return !!this.weapons[t].collectAmmo() && (this.ammoCollected[e]++, kN.play("pickup", this.pa.zS.absolutePosition, this.id == xk), AP(), !0);
			case EO.GRENADE:
				return this.OS < this.cS && (this.OS++, this.ammoCollected[e]++, kN.play("pickup", this.pa.zS.absolutePosition, this.id == xk), AP(), !0)
		}
	}, FR.prototype.isAtReady = function() {
		return !(!(this.Ba && this.Wa && this.reloadCountdown <= 0 && this.swapWeaponCountdown <= 0 && this.ja <= 0 && this.meleeCountdown <= 0) || this.pa && 0 != FN)
	}, FR.prototype.canMelee = function() {
		return !!(this.Ba && this.Wa && this.recoilCountdown <= 0 && this.reloadCountdown <= 0 && this.swapWeaponCountdown <= 0 && (this.pa || this.ja <= 0) && this.shotsQueued <= 0)
	}, FR.prototype.canSwapOrReload = function() {
		return !(!(this.Ba && this.Wa && this.recoilCountdown <= 0 && this.reloadCountdown <= 0 && this.swapWeaponCountdown <= 0 && this.ja <= 0 && this.shotsQueued <= 0 && this.meleeQueued <= 0) || this.pa && 0 != FN)
	}, FR.prototype.fire = function() {
		this.shield > 0 ? this.releaseTrigger() : this.isAtReady() && this.rofCountdown <= 0 && (this.Wa.ammo.Ca > 0 ? (this.recoilCountdown = this.Wa.constructor.recoil, this.rofCountdown = this.Wa.constructor.rof, this.pa.fire(), this.Wa.fire(), this.id == xk && (this.CS[this.stateIdx].shots++, this.lastWeaponChange = 0), 0 == this.Wa.constructor.automatic && this.releaseTrigger()) : (this.shotsQueued = 0, this.Wa.pa.dryFire(), this.releaseTrigger()))
	}, FR.prototype.pullTrigger = function() {
		if (1 == FN && bk.ja <= 0) this.IS();
		else if (this.isAtReady() && this.rofCountdown <= 0) return this.Wa.ammo.Ca > 0 ? (this.triggerPulled = !0, this.fire()) : this.Wa.ammo.store > 0 ? this.reload() : this.Wa.pa.dryFire(), !0;
		return !1
	}, FR.prototype.releaseTrigger = function() {
		this.triggerPulled = !1, this.Wa.tracer = 0
	}, FR.prototype.melee = function() {
		if (1 == FN && bk.ja <= 0 && this.IS(), this.shield > 0 || !this.canMelee()) return !1;
		this.meleeCountdown = 17, this.recoilCountdown = 40, this.id === xk && GN.hide(), this.pa.melee();
		var e = Rh.getBuffer();
		return e.BkKlQQwL(sh._), e.send(mk), this.meleeWeapon.attack(), !0
	}, FR.prototype.inspectMelee = function() {
		return this.inspectMeleeCountdown = 60, this.pa.inspectMelee(), this.id === xk && GN.hide(), !0
	}, FR.prototype.reload = function() {
		if (this.id == xk) {
			if (this.Wa.ammo.Ca == this.Wa.ammo.Yk || 0 == this.Wa.ammo.store || !this.canSwapOrReload()) return !1;
			var e = Math.min(Math.min(this.Wa.ammo.Yk, this.Wa.ammo.reload) - this.Wa.ammo.Ca, this.Wa.ammo.store);
			this.roundsToReload = e, this.scopeOut(), this.reloading = !0, this.id === xk && GN.hide(), this.Wa.pa.reload(), this.pa.wieldingMelee && this.pa.wieldGun(), this.releaseTrigger();
			var t = Rh.getBuffer();
			return t.BkKlQQwL(sh.vk), t.send(mk), 0 == this.Wa.ammo.Ca ? this.reloadCountdown = this.Wa.longReloadTime : this.reloadCountdown = this.Wa.shortReloadTime, !0
		}
		this.Wa.pa.reload()
	}, FR.prototype.reloaded = function() {
		var e = this.Wa.ammo;
		e.Ca += this.roundsToReload, e.store -= this.roundsToReload, this.reloading = !1, this.id == xk && (GN.show(), AP())
	}, FR.prototype.IS = function() {
		FN = !1, bk.ja = 30, this.id == xk && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), this.pa.gripBone._frozen = !1
	}, FR.prototype.throwGrenade = function() {
		this.shield > 0 && this.disableShield();
		var e = Rh.getBuffer();
		e.BkKlQQwL(sh.kk), e.ABkKlQQwL(Math.clamp(tI, 0, 1)), e.send(mk), bk.ja = 80, this.pa.reachForGrenade()
	}, FR.prototype.removeFromPlay = async function() {
		this.ksRemoveFromPlay(), this.Ba = !1, this._a = 0, this.GS = !1, this.jumpQueued = 0, this.scope = !1, this.QS = !1, this.vS = 0, this.playerScale = 1, this.activeShellStreaks = 0, this.pauseTargetTime = 0, this.lastDmgType = 0, this.dmgGiven = 0, this.distanceTraveled = 0, this.jumps = 0, this.ammoCollected = [0, 0], this.streakCtsKills = 0, this.meleeWeapon.collisionCountdown = 0, this.firstUpdate = !0, this.lS = 0, this.pa.removeFromPlay(), this.id == xk && nP()
	}, FR.prototype.setStats = function(e) {
		let t = this.gameData.private ? "Private" : "Public";
		this.stats[e + t]++;
		let i = e + ch[this.gameData.gameType].shortName;
		this.stats[i]++;
		let s = e + uh[this.lastDmgType].name;
		"deaths" !== e && (s = e + uh[this.lastDamageGivenType].name), this.stats[s]++
	}, FR.prototype.resetStats = function() {
		return Object.keys(this.stats).forEach((e => {
			if ("streak" != e) return this.stats[e] = 0
		}))
	}, FR.prototype.scoreKill = function() {
		this.stats.kills++, this.totalKills++, this.scoreKillStreak(), this.scoreKillCts(), this.setStats("kills"), this.lastDmgType = 0
	}, FR.prototype.scoreKillCts = function() {
		this.ctsControlled && this.streakCtsKills++
	}, FR.prototype.scoreKillStreak = function() {
		this.stats.streak++, this.rS = Math.max(this.rS, this.stats.streak), this.bestOverallStreak = Math.max(this.bestOverallStreak, this.stats.streak), this.aS = this.stats.streak, this.killStreakIncrementer()
	}, FR.prototype.killStreakIncrementer = function() {
		[{
			streak: ph.EggBreaker,
			value: "eggBreakerValue"
		}, {
			streak: ph.MiniEgg,
			value: "skMiniEggValue"
		}, {
			streak: ph.DoubleEggs,
			value: "ksEggMuliplierValue"
		}].forEach((e => {
			this.activeShellStreaks & e.streak && (this[e.value] = Math.min(this[e.value] + 90, this.shellStreakIncrement))
		}))
	}, FR.prototype.resetKsTypes = function(e) {
		var t = Rh.getBuffer();
		t.BkKlQQwL(sh.Fk), t.BkKlQQwL(this.id), t.BkKlQQwL(e), sendToAll(t)
	}, FR.prototype.ksRemoveFromPlay = function() {
		[
			["eggBreakerValue", ph.EggBreaker],
			["ksEggMuliplierValue", ph.DoubleEggs],
			["skMiniEggValue", ph.MiniEgg]
		].forEach((([e, t]) => {
			this[e] && (this[e] = 0)
		}))
	}, FR.prototype.checkAndEndShellStreak = function(e, t) {
		this[e] && --this[e] <= 0 && (this.endShellStreak(t), this.resetKsTypes(t))
	}, FR.prototype.updateShellStreaks = function() {
		this.checkAndEndShellStreak("eggBreakerValue", ph.EggBreaker), this.checkAndEndShellStreak("ksEggMuliplierValue", ph.DoubleEggs), this.checkAndEndShellStreak("skMiniEggValue", ph.MiniEgg)
	}, FR.prototype.kotcStatScoreCapture = function() {
		this.stats.kotcCaptured++, this.challengeKotcCheck({
			type: 1
		})
	}, FR.prototype.kotcStatScoreWin = function() {
		this.stats.kotcWins++, this.challengeKotcCheck({
			type: 2
		})
	}, FR.prototype.die = function() {
		this.aS = 0, this.stats.streak = 0, this.stats.deaths++, this.pS++, this.streakCtsKills = 0, this.reloading = !1, this.setStats("deaths"), this.lastDmgType = 0, this.fS = 0, this.removeFromPlay(), this.timers.alive = 0
	}, FR.prototype.aBTestInventoryCheck = function() {
		this.lifetimeDeaths++, this.abBucket && this.pS > 2 && this.lifetimeDeaths < 15 && (this.aBTestInventoryReady = !0)
	}, FR.prototype.beginShellStreak = function(e) {
		e !== ph.EggBreaker && e !== ph.HardBoiled && e !== ph.DoubleEggs && e !== ph.MiniEgg || (this.activeShellStreaks |= e);
		const t = {
			[ph.HardBoiled]: () => {
				this.shellStreakHardBoiled()
			},
			[ph.EggBreaker]: () => {
				this.shellStreakEggBreaker()
			},
			[ph.Restock]: () => {
				this.shellStreakRestock()
			},
			[ph.OverHeal]: () => {
				this.shellStreakOverHeal()
			},
			[ph.DoubleEggs]: () => {
				this.shellStreakEggMuliplier()
			},
			[ph.MiniEgg]: () => {
				this.shellStreakMiniEgg()
			}
		};
		t[e] && t[e](), this.pa.beginShellStreak(e)
	}, FR.prototype.endShellStreak = function(e) {
		e !== ph.EggBreaker && e !== ph.HardBoiled && e !== ph.DoubleEggs && e !== ph.MiniEgg || (this.activeShellStreaks &= ~e);
		let t = null;
		const i = {
			[ph.HardBoiled]: () => {
				this.vS = 0, t = "shellstreak_end"
			},
			[ph.EggBreaker]: () => {
				t = "shellstreak_end"
			},
			[ph.DoubleEggs]: () => {
				this.lS = 0, t = "ks_double_eggs_end"
			},
			[ph.MiniEgg]: () => {
				this.playerScale = 1, t = "sk_egg_grow"
			}
		};
		i[e] && (i[e](), t && kN.play(t, this.pa.mesh.position, !0)), this.pa.endShellStreak(e)
	}, FR.prototype.shellStreakEggBreaker = function() {
		this.shellStreakMsg = "EGG BREAKER", kN.play("shellstreak_start", this.pa.mesh.position, !0), this.eggBreakerValue = 450
	}, FR.prototype.shellStreakHardBoiled = function() {
		this.shellStreakMsg = "HARD BOILED", kN.play("shellstreak_start", this.pa.mesh.position, !0), this.vS = 100
	}, FR.prototype.shellStreakRestock = function() {
		this.resetAmmoGrenade(!0), this.shellStreakMsg = "RESTOCK", kN.play("ks_reload", this.pa.mesh.position, !0)
	}, FR.prototype.shellStreakOverHeal = function() {
		this.fS = Math.min(200, this.fS + 100), this.shellStreakMsg = "MORE HEALTH", kN.play("ks_overheal", this.pa.mesh.position, !0)
	}, FR.prototype.shellStreakEggMuliplier = function() {
		this.ksEggMuliplierValue = this.shellStreakIncrement, this.lS = 2, this.shellStreakMsg = "DOUBLE EGGS", kN.play("ks_double_eggs_start", this.pa.mesh.position, !0)
	}, FR.prototype.shellStreakMiniEgg = function() {
		this.skMiniEggValue = this.shellStreakIncrement, this.playerScale = .5, kN.play("ks_egg_shrink", this.pa.mesh.position, !0), this.shellStreakMsg = "SMALL EGG SPLATTER"
	}, FR.prototype.updateShellStreakTimer = function(e, t, i, s) {
		this.activeShellStreaks & i && (e[t] = Math.max(0, e[t] - 1));
		var n = Math.floor(e[t] / 30),
			a = document.getElementById(s);
		null !== a && n != parseInt(a.innerText) && (a.innerText = n)
	}, FR.prototype.shellStreakTimers = function() {
		this.updateShellStreakTimer(this, "eggBreakerValue", ph.EggBreaker, "shellStreak-egg-breaker-timer"), this.updateShellStreakTimer(this, "ksEggMuliplierValue", ph.DoubleEggs, "shellStreak-double-eggs-timer"), this.updateShellStreakTimer(this, "skMiniEggValue", ph.MiniEgg, "shellStreak-shrink-timer")
	}, FR.prototype.updateHealth = function() {
		const e = .1 * dR.value.healthRegen;
		this.fS > 0 && (this.fS > 100 ? this.fS = Math.max(100, this.fS - e) : this.fS = Math.min(100, this.fS + e))
	}, FR.prototype.respawn = function(e, t, i) {
		if (this.id == xk) {
			window.reset_yaw_pitch();
			let e = window.get_yaw_pitch();
			bk.Oa = e.yaw, bk.ca = e.pitch, bk.kS = e.coords
		}
		this.Xa = e, this.ba = t, this.va = i, this.dx = 0, this.dy = 0, this.Sa = 0, this.respawnQueued = !1, this.Ba = !0, this.onGround = 4, this.QS = !1, this.GS = !1, this._a = 0, this.capturing = !1, this.weapons[0].burstQueue = 0, this.fS <= 0 ? (this.fS = 100, this.resetWeaponState()) : this.resetWeaponState(!0), this.id == xk && (ST = xk), this.corrections = 0, this.pa.resetLerp(), this.pa.restoreToPlay(), this.Wa.equip(), this.id == ST && (CO = 0, GN.show(), GN.showDot(), AP()), this.sS(), this.resetStateBuffer()
	}, FR.prototype.resetWeaponState = function(e) {
		this.resetCountdowns(), this.releaseTrigger(), dR.areAllWeaponsDisabled() ? (this.primaryWeaponDisabled = !0, this.Ma = 1) : (this.primaryWeaponDisabled = !1, this.Ma = 0), this.equipWeaponIdx = this.Ma, this.Wa = this.weapons[this.Ma], this.weapons[0].pa.KS.setEnabled(!1), this.weapons[1].pa.KS.setEnabled(!1), this.resetAmmoGrenade(!1);
		var t = this.weapons[0];
		t.burstQueue = 0, t.constructor.burst && (t.ammo.Ca = Math.ceil(t.ammo.Ca / t.constructor.burst) * t.constructor.burst, t.ammo.store = Math.ceil(t.ammo.store / t.constructor.burst) * t.constructor.burst)
	}, FR.prototype.resetAmmoGrenade = function(e) {
		for (var t = 0; t < this.weapons.length; t++) this.weapons[t] && (this.weapons[t].ammo.Ca = this.weapons[t].ammo.Yk, this.weapons[t].ammo.store = this.weapons[t].ammo.Ea);
		this.updateGrenadeCount(e), AP()
	}, FR.prototype.updateGrenadeCount = function(e) {
		this.OS = e ? Math.min(3, Math.max(this.OS, 3)) : Math.max(this.OS, 1)
	}, FR.prototype.isDead = function() {
		return this.fS <= 0
	}, FR.prototype.resetCountdowns = function() {
		this.rofCountdown = 0, this.triggerPulled = !1, this.shotsQueued = 0, this.meleeQueued = 0, this.meleeCountdown = 0, this.inspectMeleeCountdown = 0, this.roundsToReload = 0, this.recoilCountdown = 0, this.reloadCountdown = 0, this.reloadsQueued = 0, this.swapWeaponCountdown = 0, this.weaponSwapsQueued = 0, this.ja = 0, this.grenadesQueued = 0
	}, FR.prototype.getChallengeData = function(e) {
		const t = this.challengesActive.filter((t => t.id === e));
		if (t.length > 0) return t.length > 0 ? t[0] : null
	}, FR.prototype.challengeCheckComplete = async function(e) {
		if (null != e && "function" == typeof e[Symbol.iterator])
			for (const t of e) {
				if (!t.didComplete) continue;
				const e = Rh.getBuffer();
				e.BkKlQQwL(sh.Kk), e.BkKlQQwL(this.id);
				const i = this.getChallengeData(t.data.challengeId);
				null !== i && i.isComplete() && (e.BkKlQQwL(i.id), sendToAll(e))
			}
	}, FR.prototype.challengeResetProps = function() {
		this.dmgGiven = 0, this.distanceTraveled = 0, this.timesJumped = 0, this.jumps = 0, this.ammoCollected = [0, 0], this.timers.played = 0, this.timers.timePlayed = 0, this.teamPoints = 0
	}, FR.prototype.challengeKill = async function(e) {
		const {
			player: t,
			playerHit: i
		} = e;
		Object.assign(t, {
			kills: this.stats.kills,
			streak: this.stats.streak,
			Wa: this.lastDamageGivenType,
			spatula: this.ctsControlled,
			streakCtsKills: this.streakCtsKills
		});
		const s = [this.challengeCheck([t, i, this.timers], this.challengeKills), this.challengeCtsCheck()],
			[n, a] = await Promise.all(s),
			r = [...n, ...a].filter((e => void 0 !== e));
		this.teamPoints = 0, await this.challengeCheckComplete(r)
	}, FR.prototype.challengeDeath = async function(e) {
		if (!e.player || !e.playerHit) return void console.error("Invalid player data provided.");
		const t = await this.challengeCheck([e.player, e.playerHit], this.challengeDeaths);
		this.challengeCheckComplete(t)
	}, FR.prototype.challengeKotcCheck = async function(e) {
		if (this.challengeKotc.length > 0) {
			const t = await this.challengeCheck(e, this.challengeKotc);
			this.challengeCheckComplete(t)
		}
	}, FR.prototype.challengeCtsCheck = async function() {
		return this.challengeCts.length > 0 ? this.challengeCheck({
			timer: this.timers.cts,
			teamPoints: this.teamPoints
		}, this.challengeCts) : []
	}, FR.prototype.challengeChecksDelay = async function() {
		if (this.challengesDelayedChecks.length > 0) {
			const e = await this.challengeCheck({
				streak: this.stats.streak,
				timers: this.timers,
				kills: this.stats.kills,
				dmgGiven: this.dmgGiven,
				distance: this.distanceTraveled,
				jumps: this.jumps,
				ammo: this.ammoCollected,
				cstTimer: this.timers.cts,
				teamPoints: this.teamPoints,
				ctsCon: this.ctsControlled
			}, this.challengesDelayedChecks);
			this.challengeResetProps(), await this.challengeCheckComplete(e)
		}
	}, FR.prototype.challengeCheck = async function(e, t) {
		if (this.pa) return void console.log("Challenge check aborted: actor is present");
		const i = t.map((async t => {
			const i = this.challengesActive.find((e => e.challenge.id === t.challengeId));
			return i ? i.updateData(e) : (console.log("Challenge not found:", t.challengeId), null)
		}));
		return (await Promise.all(i)).filter((e => void 0 !== e))
	}, FR.prototype.challengeCompleted = function(e) {
		! function(e) {
			const t = Qw.find((t => t.id === e));
			if (t) {
				const e = extern.playerChallenges.iconSrc(t.loc_ref),
					i = nD(`${t.loc_ref}_title`),
					s = nD(`${t.loc_ref}_desc`);
				vueApp.challengeMsg({
					icon: e,
					title: i,
					desc: s
				})
			} else console.warn("Challenge not found for ID:", e)
		}(e)
	}, FR.prototype.challengesReset = function() {
		this.challengesActive = [], this.challengeKills = [], this.challengeDeaths = [], this.challengeKotc = [], this.challengeFfa = [], this.challengeCts = [], this.challengesDelayedChecks = [], this.challengeTimed = {
			alive: [],
			played: [],
			cts: [],
			kotc: [],
			kill: []
		}
	}, FR.prototype.challengesReroll = async function(e) {
		if (!e.length) return;
		const t = [];
		try {
			for (let i = 0; i < e.length; i++) t.push(await parent.getPlayerChallenges({
				playerId: this.dbId,
				challengeId: e[i]
			}));
			setTimeout((() => {
				t.length && (this.challengesReset(), this.challengesGet(t))
			}), 100)
		} catch (e) {
			console.error("Error fetching challenges:", e)
		}
	}, FR.prototype.challengesGet = async function(e) {
		if (this.pa) return;
		const t = new Map(Qw.map((e => [e.id, e])));
		for (const i of e) {
			const e = t.get(i.challengeId) || null;
			if (!e) {
				console.log("Player challenge init failed, unknown challenge id:", i.challengeId);
				continue
			}
			const s = await playerChallengeSet(e, i);
			if (!s) {
				console.log("Player challenge empty:", i.challengeId);
				continue
			}
			s.init();
			const n = ChallengeType[s.challenge.type],
				a = ChallengeSubType[s.challenge.subType],
				r = ChallengeConditions[s.challenge.conditional];
			({
				kills: () => this.challengeKills.push(i),
				deaths: () => this.challengeDeaths.push(i),
				timed: () => {
					this.challengesDelayedChecks.push(i)
				},
				cts: () => {
					this.challengeCts.push(i), "kills" === a && this.challengeKills.push(i), this.challengesDelayedChecks.push(i)
				},
				ffa: () => {
					this.challengeFfa.push(i), this.challengesDelayedChecks.push(i)
				},
				kotc: () => {
					"kills" === r ? this.challengeKills.push(i) : this.challengeKotc.push(i), this.challengesDelayedChecks.push(i)
				},
				collect: () => {
					this.challengesDelayedChecks.push(i)
				}
			} [n] || (() => {
				this.challengesDelayedChecks.push(i)
			}))(), this.challengesActive.push(s)
		}
	}, FR.prototype.selectedWeaponAllowed = function() {
		return !!dR.areAllWeaponsDisabled() || !dR.value.weaponDisabled[this.charClass]
	};
	try {
		r("fs"), PR = void 0
	} catch (e) {
		PR = window.Loader
	}
	void 0 === PR && (PR = {
		addTask: () => {},
		progress: () => {},
		finish: () => {}
	});
	var LR, BR = !1;

	function GR(e, t, i) {
		var s = cS.dk(e, {
				size: 1
			}, t),
			n = new Wv("", t, !0);
		return n.diffuseColor = i, n.emissiveColor = i, n.specularColor = Tc.Black(), n.wireframe = !0, s.material = n, s.setEnabled(!1), s
	}

	function HR(e) {
		var t = k_.bullet("bullet", e);
		(t = new Ay("map", e, {
			vertexSource: "\nprecision highp float;\n\nattribute vec3 position;\nattribute vec4 color;\nattribute vec3 normal;\n\nuniform mat4 worldViewProjection;\nuniform mat4 shadowMat;\n\nvarying vec4 vPositionFromLight;\nvarying vec4 vColor;\nvarying float vNormalZ;\n\nvoid main() {\n    vec4 p = vec4(position, 1.);\n    vPositionFromLight = shadowMat * p;\n\tvColor = pow(color, vec4(vec3(0.5), 1.));\n\tvNormalZ = normal.y;\n    gl_Position = worldViewProjection * p;\n}\n\t\t",
			fragmentSource: "\nprecision highp float;\n\nuniform sampler2D shadowSampler;\n\nvarying vec4 vPositionFromLight;\nvarying vec4 vColor;\nvarying float vNormalZ;\n\nvoid main() {\n    vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n\tdepth = 0.5 * depth + vec3(0.5);\n\tvec2 uv = depth.xy;// + vec2(1. / 30.);\n    float s = texture2D(shadowSampler, uv).x;\n\n    if (depth.z < s) {\n        s = 1.;\n    } else {\n        s = clamp((depth.z - s) * 80., 0.5, 1.0);\n        s = min(1.0, max(s, length(vPositionFromLight.xy)));\n        s = mix(1., s, vNormalZ);\n    }\n\n    gl_FragColor = vColor * vec4(vec3(s), 1.);\n}\n\t\t"
		}, {
			attributes: ["position", "color", "normal"],
			uniforms: ["worldViewProjection", "shadowMat"],
			samplers: ["shadowSampler"]
		})).onBind = function(e) {
			var t = e.material.getEffect();
			t.setMatrix("shadowMat", tT.getTransformMatrix()), t.setTexture("shadowSampler", tT.getShadowMapForRendering())
		}, t = k_.standard("standard", e), t = k_.instanced("standardInstanced", e), (t = k_.shell("shell", e)).onBind = function(e) {
			var t = e.material.getEffect();
			t.setFloat("u_hp", e.hp), t.setColor3("u_customColor", e.shellColor), t.setDirectColor4("u_teamColor", e.teamColor), t.setFloat2("u_stampPosition", e.stampPositionX, e.stampPositionY), t.setVector2("u_stampOffset", e.stampOffset)
		}, (t = k_.standard("emissive", e)).onBind = function(e) {
			e.material.getEffect().setColor3("u_emissiveColor", e.emissiveColor)
		}, t = k_.colorized("colorized", e), (t = new Wv("wireframe", e, !0)).wireframe = !0, (t = new Wv("normalBackface", e, !0)).diffuseColor = new Tc(.5, .5, .5), t.ambientColor = new Tc(.5, .5, .5), t.specularColor = new Tc(0, 0, 0), t.backFaceCulling = !1, t.twoSidedLighting = !0, (t = new Wv("muzzleFlash", e, !0)).emissiveColor = Tc.White(), (t = new Wv("ui", e, !0)).disableLighting = !0, t.emissiveColor = Tc.White(), t.fogEnabled = !1
	}

	function UR(e, t, i, s, n) {
		var a = t.length,
			r = this,
			o = e.getMaterialByName("standard");
		e.useRightHandedSystem = !0;
		for (var l = 0, h = 0, c = 0; c < a; c++) {
			var u = n ? "models/full/" : "models/",
				m = t[c] + ".glb";
			m += "?" + Ch;
			let d = PR.addTask();
			! function(e, t, n) {
				qS.ImportMesh("", e, t, n, (function(e, n, c, u) {
					for (var m = 0; m < e.length; m++) {
						var f = e[m];
						if ("__root__" !== f.name) {
							if (f.animations = u, "egg" == f.name && l++, "hands" == f.name) {
								h++;
								for (let e of f.animations)
									if (e.name.startsWith("grenade"))
										for (let t = 0; t < e._targetedAnimations.length; t++) {
											let i = e._targetedAnimations[t];
											if ("gripHand" === i.target.name) {
												let e = i.animation;
												e.enableBlending = !0, e.blendingSpeed = 0
											}
										}
							}!BR && (l > 1 || h > 1) && (BR = !0, alert("Duplicate egg and/or hand models detected in " + t + ".\n\nOpen the weapon models in Blender and make sure egg/hands layers are turned off, then re-export.")), f.setMaterial && f.setMaterial(o), f.material = o, f.setEnabled(!1), f.isPickable = !1, f.rotationQuaternion && (f.rotation = f.rotationQuaternion.toEulerAngles(), f.rotationQuaternion = null), "__root__" === f.parent.name && (f.parent = void 0)
						}
						i && i(f)
					}
					0 == --a && s && s.call(r), PR.finish(d)
				}), (function(e) {
					d = PR.progress(d, e.loaded, e.total)
				}))
			}(u, m, e)
		}
	}
	var VR = [];

	function WR(e) {
		mR.init(), (qN = {
			width: QN.width,
			height: QN.height + 1,
			depth: QN.depth,
			surfaceArea: QN.surfaceArea
		}).data = function(e, t, i, s) {
			for (var n = Array(e), a = 0; a < e; a++) {
				n[a] = Array(t);
				for (var r = 0; r < t; r++) {
					n[a][r] = Array(i);
					for (var o = 0; o < i; o++) n[a][r][o] = s || {}
				}
			}
			return n
		}(qN.width, qN.height, qN.depth), LR = 0;
		for (var t = {}, i = 1; i < kR.length; i++) {
			var s = kR[i];
			t[s.name] = i
		}
		var n = {};
		"undefined" == typeof window && (spawnPoints = [
			[],
			[],
			[]
		]), Object.keys(QN.data).forEach((function(e) {
			var i = QN.data[e],
				s = t[e],
				a = kR[s];
			if (s) {
				var r, o, l, h = e.split(".");
				if (a.theme = h[0], a.shortName = h[1], a.colliderType = h[2], a.softness = h[3], "undefined" == typeof window && "SPECIAL" == a.theme) {
					if (a.shortName.startsWith("spawn")) {
						for (let e of i) spawnPoints[0].push({
							x: e.x,
							y: e.y,
							z: e.z
						}), "spawn-blue" == a.shortName ? spawnPoints[oh].push({
							x: e.x,
							y: e.y,
							z: e.z
						}) : spawnPoints[lh].push({
							x: e.x,
							y: e.y,
							z: e.z
						});
						return
					}
					if ("spatula" == a.shortName) {
						for (let e of i) spatulaSpawnPoints.push({
							x: e.x + .5,
							y: e.y + .1,
							z: e.z + .5
						});
						return
					}
				}
				switch (a.colliderType) {
					case "full":
						r = uR.la, o = !1, l = !1;
						break;
					case "wedge":
						r = uR.wedgeCollisionMesh, o = !0, l = !1;
						break;
					case "iwedge":
						r = uR.iwedgeCollisionMesh, o = !0, l = !1;
						break;
					case "ladder":
						r = a.colliderMesh, o = !1, l = !1;
						break;
					case "aabb":
						r = a.colliderMesh, o = !1, l = !0;
						break;
					case "obb":
						r = a.colliderMesh, o = !0, l = !0
				}
				for (let e of i) {
					void 0 === e.ry && (e.ry = 0);
					var c = e.rx * Math.PI90 || 0,
						u = e.ry * Math.PI90 || 0,
						m = e.rz * Math.PI90 || 0;
					qN.data[e.x][e.y][e.z] = {
						item: void 0,
						mesh: a,
						idx: s,
						colliderMesh: r,
						colliderPrecise: o,
						colliderChildren: l,
						colliderMatrix: Hc.Jk(-u, c, m),
						rx: c,
						ry: u,
						rz: m
					}, r && YR(r, mR.Type[a.colliderType], e)
				}
				if ("capture-zone" == a.shortName)
					for (let e of i)
						if (!qN.data[e.x][e.y][e.z].zone) {
							var d;
							e.zone = ++LR, qN.data[e.x][e.y][e.z].zone = e.zone, 0 == e.y && (console.log("INVALID ZONE", e), VR.push(e.zone));
							do {
								d = 0;
								let t = [{
									x: -1,
									z: 0
								}, {
									x: 1,
									z: 0
								}, {
									x: 0,
									z: -1
								}, {
									x: 0,
									z: 1
								}];
								for (let s of i)
									if (!qN.data[s.x][s.y][s.z].zone)
										for (let i of t) {
											let t = jR(s.x + i.x, s.y, s.z + i.z);
											if (t && t.zone == e.zone) {
												d++, s.zone = e.zone, qN.data[s.x][s.y][s.z].zone = e.zone;
												break
											}
										}
							} while (d > 0)
						}
			} else n[e] = !0
		}));
		var a = "";
		return Object.keys(n).forEach((function(e) {
			a += e + "\n"
		})), "" != a && (console.log("buildMapData error", a), e && e(a)), t
	}
	var zR = new Lc,
		XR = new Lc;

	function YR(e, t, i) {
		var s = i.rx * Math.PI90 || 0,
			n = i.ry * Math.PI90 || 0,
			a = i.rz * Math.PI90 || 0;
		XR.copyFrom(e.position), zR.copyFrom(e.rotation), e.unfreezeWorldMatrix(), e.rotation.copyFromFloats(0, 0, 0), e.computeWorldMatrix(!0);
		var r = e.getBoundingInfo().boundingBox.minimumWorld.clone(),
			o = e.getBoundingInfo().boundingBox.maximumWorld.clone(),
			l = new du(r, o);
		l.matrix = Hc.Jk(zR.y, zR.x, zR.z), Hc.RotationYawPitchRollToRef(n, s, a, uR.matrix), l.matrix.multiplyToRef(uR.matrix, l.matrix), l.position = new Lc(i.x + .5, i.y + .5, i.z + .5), l.colliderType = t, l.cell = i;
		var h = new du(new Lc(i.x, i.y, i.z), new Lc(i.x + 1, i.y + 1, i.z + 1));
		l.bb = h, l.name = e.name;
		for (var c = e.getChildMeshes(), u = 0; u < c.length; u++) c[u].rotationQuaternion = null;
		mR.add(l), e.position.copyFrom(XR), e.rotation.copyFrom(zR), e.freezeWorldMatrix();
		for (c = e.getChildMeshes(), u = 0; u < c.length; u++) YR(c[u], t, i)
	}

	function jR(e, t, i) {
		return e < 0 || e > qN.width - 1 || i < 0 || i > qN.depth - 1 || t < 0 || t > qN.height - 1 ? null : qN.data[e][t][i]
	}

	function KR(e) {
		this.scene = e, this.x = 0, this.y = 0, this.z = 0, this.dx = 0, this.dy = 0, this.Sa = 0, this.active = !1, this.xa = null, this.damage = 150, this.origin = new Lc, this.direction = new Lc, this.end = new Lc, this.dmgTypeId = "", this.pa = new GO(this)
	}

	function $R(e, t) {
		this.scene = e, this.init(t), this.lastControlTeam = 255, this.pa = new QO(this, e)
	}

	function JR(e) {
		var t = (e = " " + (e = e.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[\u2018\u2019\u201A\u201B]/g, "'").replace(/[\u201C\u201D\u201E\u201F]/g, '"').replace(/[\u2013\u2014]/g, "-").replace(/[\u2026]/g, "...").replace(/[\u00A0\u2007\u202F]/g, " ").replace(/[\u00B4]/g, "'").replace(/[\u02C6]/g, "^").replace(/[\u02DC]/g, "~").replace(/[\u00B5]/g, "u").replace(/[\u00D7]/g, "x").replace(/[\u00F7]/g, "/")) + " ").toLowerCase().replace(/[^a-zA-Z0-9|!\|@|$|;|\xa1]/g, "").replace(/6|g/g, "9").replace(/b/g, "6").replace(/\||l|i|1|;|\xa1/g, "!").replace(/e/g, "3").replace(/a|@/g, "4").replace(/o/g, "0").replace(/s|\$/g, "5").replace(/t/g, "7").replace(/z/g, "2").replace(/7h3|my|y0ur|7h3!r|h!5|h3r/g, ""),
			i = t.search(/( 94y | 455 )/),
			s = /(n421|5chu72574ff3!|n994|m457ur647|m4r!c4|n!qq4|fck|cn7|57urm4673!!un9|!uf7w4ff3|k!4n|66c|n993r|n!443r|n!99r|m4y473|64ch!ch4|64ch!ch3|c474!uf0|fr4nchu7|fr!j0!3r0|9464ch0|94chup!n|m0r0m!3rd4|54!74mur05|pu74|j0d3r|m0n90|c0n0|c4r4j0|m!3rd4|20rr4|chup4m3!|cu!0|p3nd3j0|c46r0n|0r70|pu70|p!r06|qu33f|455h47|ch04d|cum|k0ck|k0ch|pu74|n!94|n3993r|4fr!c4n|kn336r0|5ch00!5h007|n!qq3r|73rr0r!5t|qu33r|d!ck|w4nk|p!55|7357!c|735735|64!!5|nu75|nu72|j3w|k!k3|r374r|4u7!5|d0wn55|6006|8d|p0rn|5w4!!0w|347m3|347my|d!k|0r4!|5p0093|fuk|j!2|5u!c!d|m4573r6|5p0063|5p3rm|p3nu5|pu55y|6u7753x|fux|6u77h0!3|4n4!|4nu5|k!!!b!4ck5|murd3rb!4ck5|h!7!3r|w3764ck|49!n4|94y|455h0!3|5uck|j3w|5p!c|ch!nk|n!994|n!993|n!663|n!994|n!664|5h!7|6!7ch|fuck|cun7|kkk|wh0r3|f49|7w47|p3n!|r4p3w0m|r4p39!r|r4p!57|r4p3r|r4p3|r4p!n|n!93r|!d!07|c0ck|dum6|5!4v3|7!75|@|455|pu5y|ju!cy|nud3|fk|v!49r4|64n9|53x|h03|d473|h473|d47!n9|d473r|h4ck|h4ck3r|h4ck!n9|60yfr!3nd|9!r!fr!3nd|900k|gf|bf|m0nk3y|m0nk!35|d4ddy|5!u7|pr057!7u7|nud3|33m4!!|d!ckh34d|r374rd|n4993r|n0993r|4d0!f|kn339r0w|6umh0!3|c0kk|cuck|!3573r|!5r43!|p4!357!n3|ph!!3|n3994|f4ck|pr3d470r|pn!5|n!95|fr!ck|m0!3573r|n!94rd!y|m0!357|73rr0r!57|5h!4d|60!!0ck5|7r4n5|64!!649|n!9993r|ky5|60yfr!3nd|9!r!fr!3nd|d0uch3|pu55!35|57473f4rm|5fn37w0rk|n!gh4|5fc|n3g3r|53q|!u57|g3757473)/g,
			n = (t = t.replace(/ /g, "")).search(s),
			a = (t = t.replace(/(.)(?=\1)/g, "")).search(s);
		return i > -1 || n > -1 || a > -1
	}

	function qR() {
		var e, t = ["Captain", "Lord", "Supreme", "Master", "Pro", "Noob"],
			i = ["Egg", "Yolk", "Shell", "Cluck", "Chick", "Bird"];
		do {
			e = Math.randomInt(1, 99)
		} while (69 == e);
		return 0 == Math.randomInt(0, 2) ? t[Math.randomInt(0, t.length)] + i[Math.randomInt(0, i.length)] + e : i[Math.randomInt(0, i.length)] + t[Math.randomInt(0, t.length)] + e
	}
	KR.position = new Lc, KR.fire = function(e, t, i, s) {
		cI.rocketPool.retrieve().fireThis(e, t, i, s)
	}, KR.prototype.fireThis = function(e, t, i, s) {
		this.x = t.x, this.y = t.y, this.z = t.z, this.origin.set(this.x, this.y, this.z), this.direction.copyFrom(i).normalize().scaleInPlace(s.velocity), this.dx = this.direction.x, this.dy = this.direction.y, this.Sa = this.direction.z, this.radius = s.radius, this.xa = e, this.weaponClass = s, this.damage = s.damage, this.active = !0, this.range = s.range, this.minRange = s.minRange, this.velocity = s.velocity, this.dmgTypeId = s.dmgTypeId;
		var n = uR.qa(t, i, uR.projectileCollidesWithCell);
		n && (this.end.copyFrom(n.pick.pickedPoint), this.range = Lc.Distance(t, n.pick.pickedPoint)), this.pa.fire()
	}, KR.prototype.remove = function() {
		cI.rocketPool.recycle(this), this.pa.remove()
	}, KR.prototype.update = function() {
		if (KR.position.set(this.x, this.y, this.z), this.range < this.velocity && this.direction.scaleInPlace(this.range / this.velocity), !uR.fa(KR.position, this.direction, this)) {
			this.x += this.dx, this.y += this.dy, this.z += this.Sa;
			var e = this.velocity;
			return this.range -= e, this.minRange -= e, this.range <= 0 ? (this.x -= this.dx, this.y -= this.dy, this.z -= this.Sa, void(this.minRange <= 0 ? this.explode() : this.poof())) : void 0
		}
	}, KR.prototype.collidesWithPlayer = function(e) {
		this.minRange <= 0 ? this.explode() : this.poof()
	}, KR.prototype.explode = function() {
		this.remove()
	}, KR.prototype.poof = function() {
		KR.position.set(this.x, this.y, this.z), kN.play("gun_rpegg_rocket_poof", KR.position);
		for (var e = 0; e < 10; e++) {
			var t = .2 * Math.random() - .1,
				i = .2 * Math.random() - .1,
				s = .2 * Math.random() - .1;
			DI(DN, 10, this.x, this.y, this.z, t, i, s, .4, !1, 0)
		}
		this.remove()
	}, $R.prototype.init = function(e) {
		this.x = e.x, this.y = e.y, this.z = e.z, this.dx = 0, this.dy = 0, this.Sa = 0, this.HS = 255, this.controlledByTeam = 255
	}, $R.prototype.capture = function(e) {
		var t;
		bk.id == e.id && ((t = document.getElementById("spatulaPlayer")).classList.remove("drop"), t.classList.add("capture"));
		e.team != this.lastControlTeam && (dk.teamScore[e.team] = 0), this.HS = e.id, this.controlledByTeam = e.team, this.lastControlTeam = e.team, e.ctsCapture(e.ik), this.pa.capture(e), BAWK.play("capture_spatula"), (t = document.getElementById("teamScoreNum" + e.team)).innerText = dk.teamScore[e.team]
	}, $R.prototype.drop = function() {
		var e = iI[this.HS];
		e.ctsCapture(!1), this.HS = 255, this.controlledByTeam = 255, this.x = e.Xa, this.y = e.ba, this.z = e.va, this.dy = e.dy + .05;
		var t = document.getElementById("spatulaPlayer");
		t.classList.remove("capture"), t.classList.add("drop"), this.pa.drop()
	}, $R.prototype.respawn = function() {
		var e = spatulaSpawnPoints.length,
			t = spatulaSpawnPoints[Math.randomInt(0, e)];
		this.init(t);
		let i = Rh.getBuffer();
		dk.packState(i), sendToAll(i)
	}, $R.prototype.update = function() {
		this.dy -= .012 * dR.value.gravity, this.dy = Math.max(-.29, this.dy);
		var e = $R.Fa;
		e.copyFromFloats(this.x, this.y, this.z), this.move(this.dx, this.dy, this.Sa), this.dx = this.x - e.x, this.dy = this.y - e.y, this.Sa = this.z - e.z
	}, $R.prototype.move = function(e, t, i) {
		if (255 == this.HS) {
			let e = $R.Ua,
				t = $R.na,
				i = $R.$a,
				n = $R.Da;
			this.y += .31, n.copyFromFloats(0, this.dy, 0), Math.capVector3(n, .29), e.copyFromFloats(this.x, this.y, this.z), e.addInPlace(n), e.x = Math.clamp(e.x, .1, qN.width - .1), e.z = Math.clamp(e.z, .1, qN.depth - .1);
			for (var s = 0; s < 8; s++) {
				if (!mR.sphereCollidesWithStructure(e, .31, t, i)) break;
				i.y < -.707 && (this.dy = 0), t.x = 0, t.z = 0, e.addInPlace(t)
			}
			8 == s && (n.scaleInPlace(.9), e.subtractInPlace(n)), this.x = e.x, this.y = e.y, this.z = e.z
		} else {
			var n = iI[this.HS];
			n && (this.x = n.Xa + .3 * Math.sin(n.Oa), this.y = n.ba, this.z = n.va + .3 * Math.cos(n.Oa))
		}
		this.y -= .31
	}, $R.Ua = new Lc, $R.na = new Lc, $R.$a = new Lc, $R.Da = new Lc, $R.Fa = new Lc, $R.prototype.collidesWithMap = function() {
		return $R.Ua.set(this.x, this.y, this.z), uR.meshCollidesWithMap(uR.playerCollisionMesh, $R.Ua)
	};
	var QR, ZR = class {
			usePlayerId() {
				this.randID = kh.playerAccount.id, this.isNewrandID = !1
			}
			hashString(e) {
				let t = "number" == typeof e ? e.toString() : e,
					i = 0;
				for (let e = 0; e < t.length; e++) {
					i = (i << 5) - i + t.charCodeAt(e), i |= 0
				}
				return i
			}
			constructor(e = Mh, t = "shell_ab_variant", i = "shell_rand_id", s = 365) {
				this.groupPercentages = e, this.isNewRandID = !1, this.isNewVariant = !1, this.randID = null, this.assignedVariant = null, this.cookieName = t, this.randIDCookieName = i, this.expires = s;
				const n = Object.values(e).reduce(((e, t) => e + t), 0);
				if (n > 100) throw new Error("Group percentages exceed 100%. Adjust the distribution.");
				this.controlPercentage = 100 - n
			}
			setCookie(e, t, i) {
				const s = i ?? this.expires;
				let n = "";
				if (s) {
					const e = new Date;
					e.setTime(e.getTime() + 24 * s * 60 * 60 * 1e3), n = "; expires=" + e.toUTCString()
				}
				document.cookie = `${e}=${t||""}${n}; path=/`
			}
			getOrCreateRandID() {
				let e = this.getCookie(this.randIDCookieName);
				return e || (e = this.createUniqueID(), this.setCookie(this.randIDCookieName, e, this.expires), this.isNewRandID = !0), this.randID = e, this.randID
			}
			getCookie(e) {
				const t = `; ${document.cookie}`.split(`; ${e}=`);
				if (2 === t.length) return t.pop().split(";").shift()
			}
			deleteCookie(e) {
				document.cookie = e + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;"
			}
			getAssignedVariant() {
				return this.assignedVariant || (this.assignedVariant = this.getCookie(this.cookieName)), this.assignedVariant
			}
			createUniqueID() {
				return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
					const t = 16 * Math.random() | 0;
					return ("x" === e ? t : 3 & t | 8).toString(16)
				}))
			}
			getIsNewVariant() {
				return this.isNewVariant
			}
			assignABTestVariant() {
				const e = this.randID || this.getOrCreateRandID(),
					t = (this.hashString(e) % 100 + 100) % 100;
				let i = 0,
					s = "control";
				for (const [e, n] of Object.entries(this.groupPercentages))
					if (i += n, t < i) {
						s = e;
						break
					} let n = this.getCookie(this.cookieName);
				return n || (this.setCookie(this.cookieName, s, this.expires), this.isNewVariant = !0, n = s), this.assignedVariant = n, this.assignedVariant
			}
		},
		eN = (e, t) => {
			console.log("%c%s", "color: white; background: #006700; padding: 2px 6px; border-radius: 3px; margin-right: 5px;", "Chick'n Winner", e, t || "")
		};

	function tN(e) {
		eN("checkStartChicknWinner() success");
		const t = Math.trunc(Date.now() / 1e3),
			i = e;
		if (console.log("api_chicknWinnerPlayerRewardCheck data", i), i && Object.keys(i).length > 0) {
			const {
				reset: e,
				limit: s,
				span: n = 1,
				period: a
			} = i;
			iN(s <= _h ? t + n : t + a, s <= _h ? gh : vh, s, e)
		}
		vueApp.chicknWinnerError(!1)
	}

	function iN(e, t, i, s = 0) {
		vw && (vw.clearTimer(), vw = null), vw = new _N(e, t, i, s)
	}

	function sN(e) {
		var t, i;
		iN(Math.trunc(Date.now() / 1e3) + 1, gh, 0), eN("checkStartChicknWinner() start"), e ? tN(e) : (t = tN, i = e => aN("checkStartChicknWinner()", e.error), lN({
			cmd: "chicknWinnerReady",
			id: kh.playerAccount.id,
			sessionId: kh.playerAccount.sessionId
		}, t, i))
	}

	function nN() {
		Mw.isChwRequest ? uN((e => {
			Mw.isChwRequest = !1;
			const t = e.result;
			if (eN(`getIncetivizedReward() response ${t}`), "SUCCESS" !== t) return void("SESSION_EXPIRED" === t && aN("getIncetivizedReward", t));
			const i = vw.count ? vw.count : "free";
			if (e.reward.itemIds.length > 0) {
				const t = kh.catalog.findItemById(e.reward.itemIds[0]);
				kh.playerAccount.addToInventory(t, !0), t && (ga("send", "event", "Chickn Winner", "Reward", `${i} - item`), (e.reward_lvl || e.reward.rewardTier) && ga("send", "event", "Chickn Winner", "Reward item", `${t.name} - ${e.reward.rewardTier?e.reward.rewardTier:e.reward_lvl}`))
			}
			e.reward.eggsGiven && e.reward.eggsGiven > 0 && (ga("send", "event", "Chickn Winner", "Reward", `${i} - ${e.reward.eggsGiven}`), ga("send", "event", "Chickn Winner", "Reward amount", `${e.reward.eggsGiven}`)), vueApp.chw.reward.ownedItem = e.ownedItemId, vueApp.chw.reward.eggs = e.reward.eggsGiven, e.reward.itemIds.forEach((e => vueApp.chw.reward.itemIds.push(e))), vueApp.chicknWinnerError(!1), vueApp.showChicknWinnerPopup()
		}), (e => aN("getIncetivizedReward", e.error))) : eN("getIncetivizedReward() Request called directly. CHW not played")
	}

	function aN(e, t) {
		vueApp.chicknWinnerError(!0), vueApp.chwOnClick(!1), hasValue(t) && ("SESSION_EXPIRED" === t ? vueApp.showGenericPopup("session_expired", "session_expired_msg", "reload", !0) : vueApp.showGenericPopup("uh_oh", "purchase_disabled", "ok", !0), e && console.log(`${e} fail: `, t))
	}
	var rN = class e {
		static add(t) {
			e.inputs[t] = Date.now()
		}
		static update() {
			for (var t = 0; t < e.inputs.length; t++) {
				var i = e.inputs[t];
				if (Date.now() - i < 100) switch (t) {
					case e.jump:
						break;
					case e.fire:
						bk.pullTrigger() && e.remove(t);
						break;
					case e.swap:
						bk.swapWeapon(0 == bk.Ma ? 1 : 0) && e.remove(t);
						break;
					case e.reload:
						bk.reload() && e.remove(t);
						break;
					case e.melee:
						bk.melee() && (QR || (ga("send", "event", "weapon", "triggered", "Melee"), QR = !0), e.remove(t))
				}
			}!bk.triggerPulled || zN & IR.fire || bk.releaseTrigger()
		}
		static remove(t) {
			e.inputs[t] = 0
		}
		static init() {
			e.inputs = [0, 0, 0, 0, 0], QR = !1
		}
	};
	rN.jump = 0, rN.fire = 1, rN.swap = 2, rN.reload = 3, rN.melee = 4, parsedUrl.query.adTest && (nw = !0);
	var oN = class {
		showAdBlockerVideo() {
			vueApp.showAdBlockerVideo(), setTimeout((() => {
				vueApp.hideAdBlockerVideo(), vueApp.gameUiRemoveClassForNoScroll(), crazyGamesActive || testCrazy ? this.onVideoAdCompleted() : this.afterVideoAdComplete()
			}), 1e4)
		}
		adBlockerDetected() {
			vueApp.chwAdBlockerDetected(), this.adInPlayActive = !1
		}
		isAdBlocking() {
			return crazyGamesActive ? crazySdk.thirdPartyAdblocker : this.adBlocker
		}
		checkAdBlocker() {
			this.adBlocker = aipAPItag && aipAPItag.hasOwnProperty("sdkBlocked") && aipAPItag.sdkBlocked
		}
		init() {
			if (pokiActive || crazyGamesActive || kh.productBlockAds) return this.adInPlayActive = !1, void console.log("initAdInPlay Cancelled. Is portal?", pokiActive || crazyGamesActive);
			try {
				this.ADSLOG("F79520", "Shell Shockers AIP", "AIP init success!"), this.adInPlayActive = !testCrazy, aiptag.cmd.player.push((() => {
					this.initializeAipPlayer(), this.checkAdBlocker()
				}))
			} catch (e) {
				this.ADSLOG("F79520", "Shell Shockers AIP", `AIP error message: ${e}`), this.error(e)
			}
		}
		cgAdStarted(e) {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "started.", e), BT && vueApp.hideGameMenu(), vueApp.setDarkOverlay(!0, vueApp.ui.overlayClass.inGame), this.isPlayingVideoAd = !0, this.didVideoPlay = !0, KO(0)
		}
		setAdVideoLocalStorage() {
			localStore.setItem("lastPreRoll", Date.now())
		}
		ADSLOG(e, t, i) {
			console.log("%c%s", `color: white; background: #${e}; padding: 2px 6px; border-radius: 3px; margin-right: 5px;`, t, i)
		}
		afterVideoAdComplete(e) {
			this.ADSLOG("F79520", "Shell Shockers AIP", "afterVideoAdComplete"), this.isChwRequest || null !== this.challengeRerollRequest || vueApp.setDarkOverlay(!1), e && !["video-ad-skipped", "video-ad-completed"].includes(e) ? this.error(e) : this.didVideoPlay = !0, this.onVideoAdCompleted("F79520", "Shell Shockers AIP")
		}
		get adBlocker() {
			return this.adsBlocked
		}
		set adBlocker(e) {
			this.adsBlocked = e, this.adsBlocked && !kh.productBlockAds && this.adBlockerDetected()
		}
		cgAdError(e) {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "error.", e), this.cgErr = !0, this.didVideoPlay = !1, this.cgAdFinished()
		}
		cgRmListeners() {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "remove eventListeners"), vueApp.setDarkOverlay(!1)
		}
		completedPlayerChallengeReroll(e, t, i) {
			if (vueApp.setDarkOverlay(!1), this.didVideoPlay) {
				const s = e;
				this.ADSLOG(t, i, `Trying reroll for challenge id: ${s}`), dN(s, (e => {
					if (e.challengeId === s) console.log("Challenge slot already rerolled!!!");
					else {
						const t = ww.challengeGet(s);
						ga("send", "event", "dailyChallenge", "reroll", t.loc_ref), kh.playerAccount.challenges = e, ww.resetInGame()
					}
				}), (e => {
					console.log("playerChallengesReroll error: ", e.error), vueApp.showGenericPopup("uh_oh", "chlg_no_challenges", "ok")
				})), this.completedDefault()
			} else vueApp.showGenericPopup("ad_blocker_nugget_title", "ad_blocker_nugget_content", "ok")
		}
		preroll() {
			this.adBlocker ? (this.ADSLOG("F79520", "Shell Shockers AIP", "Ad blocker detected."), this.showAdBlockerVideo()) : void 0 !== dT ? aiptag.cmd.display.hasOwnProperty("push") && aiptag.cmd.player.hasOwnProperty("push") ? aiptag.cmd.player.push((() => {
				try {
					this.ADSLOG("F79520", "Shell Shockers AIP", `Play: ${this.adUnit}`), vueApp.gameUiAddClassForNoScroll(), BT && (vueApp.hideGameMenu(), vueApp.setDarkOverlay(!0, vueApp.ui.overlayClass.inGame)), dT.startPreRoll(this.adUnit)
				} catch (e) {
					this.error(e), vueApp.setDarkOverlay(!1), this.onVideoAdCompleted("F79520", "preroll error")
				}
			})) : (this.error("push method missing"), vueApp.setDarkOverlay(!1), this.onVideoAdCompleted("F79520", "preroll error")) : (this.error("aipPrerollPlayer undefined"), vueApp.setDarkOverlay(!1), this.onVideoAdCompleted("F79520", "preroll error"))
		}
		constructor() {
			this.rewardedAdPlayed = !1, this.didVideoPlay = !1, this.adsBlocked = !1, this.isPlayingVideoAd = !1, this.callback = null, this.adUnit = null, this.isChwRequest = !1, this.challengeRerollRequest = null, this.cgAdType = "midgame", this.cgErr = !1, this.cgErrTxt = "CG video ad", this.cgCallBacks = {
				adFinished: this.cgAdFinished.bind(this),
				adError: this.cgAdError.bind(this),
				adStarted: this.cgAdStarted.bind(this)
			}
		}
		completedDefault() {
			BT && (vueApp.disableRespawnButton(!1), vueApp.showGameMenu(), CI()), vueApp.gameUiRemoveClassForNoScroll()
		}
		completedChwReward() {
			this.didVideoPlay ? nN() : (this.isChwRequest = !1, vueApp.showGenericPopup("ad_blocker_nugget_title", "ad_blocker_nugget_content", "ok"))
		}
		cgListeners() {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "add eventListeners")
		}
		play(e, t) {
			if (this.adUnit = e, this.callback = t, nw && this.ADSLOG("F79520", "Shell Shockers AIP", "AD test active"), testCrazy && this.ADSLOG("3C1E6E", "CG video ad", "Crazy Games test ads"), this.ADSLOG("F79520", "Shell Shockers AIP", `Play video ads Ad unit: ${this.adUnit}`), this.isChwRequest || null !== this.challengeRerollRequest || this.setAdVideoLocalStorage(), crazyGamesActive) return this.ADSLOG("3C1E6E", this.cgErrTxt, "Crazy Game video ad request."), (this.isChwRequest || null !== this.challengeRerollRequest) && (this.cgAdType = "rewarded"), void this.cgAdRequested();
			vueApp.setDarkOverlay(!0, vueApp.ui.overlayClass.inGame), KO(0), this.isPlayingVideoAd = !0, this.preroll()
		}
		cgAdFinished(e) {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "ended.", e), vueApp.setDarkOverlay(!1), this.cgErr && (this.didVideoPlay = !1, this.rewardedAdPlayed = !1), this.onVideoAdCompleted("3C1E6E", this.cgErrTxt), this.cgRmListeners(), this.cgErr = !1, crazySdk.thirdPartyAdblocker && vueApp.hideAdBlockerVideo()
		}
		onVideoAdCompleted(e, t) {
			this.isChwRequest ? this.completedChwReward() : null !== this.challengeRerollRequest ? this.completedPlayerChallengeReroll(this.challengeRerollRequest, e, t) : this.completedDefault(), KO(), this.didVideoPlay = !1, this.challengeRerollRequest = null, this.rewardedAdPlayed = !1, this.callback && (this.callback(), this.callback = null), this.adUnit = null
		}
		cgRequestAd() {
			this.cgListeners(), crazySdk.requestAd(this.cgAdType, this.cgCallBacks), this.cgAdType = "midgame"
		}
		cgAdRequested() {
			this.ADSLOG("3C1E6E", this.cgErrTxt, "requested."), crazySdk.thirdPartyAdblocker ? (this.showAdBlockerVideo(), setTimeout((() => this.cgRequestAd()), 1e4)) : this.cgRequestAd()
		}
		error(e) {
			e && this.ADSLOG("F79520", "Shell Shockers AIP video error: ", e);
			const t = this.isChwRequest,
				i = this.isPlayingVideoAd;
			"user-has-adblock" === e && this.adBlockerDetected(), vueApp.chwOnClick(!1), this.didVideoPlay = !1, this.isChwRequest = !1, this.isPlayingVideoAd = !1, i && t && cN((() => {
				kh.playerAccount.isUpgraded() || t && (vueApp.showGenericPopup("chw_video_error_title", "chw_video_error_msg", "ok"), sN())
			}))
		}
		initializeAipPlayer() {
			dT = new aipPlayer({
				AD_WIDTH: 960,
				AD_HEIGHT: 540,
				AD_FULLSCREEN: !1,
				AD_CENTERPLAYER: !0,
				LOADING_TEXT: "loading advertisement",
				PREROLL_ELEM: () => document.getElementById("preroll"),
				AIP_COMPLETE: e => {
					this.ADSLOG("F79520", "Shell Shockers AIP_COMPLETE", e), this.afterVideoAdComplete(e), ga("send", "event", "aip-complete", "regular", e)
				},
				AIP_REMOVE: () => {},
				AIP_REWARDEDCOMPLETE: e => {
					this.ADSLOG("F79520", "Shell Shockers AIP Reward Complete", e), this.afterVideoAdComplete(e), ga("send", "event", "aip-complete", "reward", e)
				},
				AIP_REWARDEDGRANTED: e => {
					this.ADSLOG("F79520", "Shell Shockers AIP Reward Granted", e), this.rewardedAdPlayed = !0, ga("send", "event", "aip-complete", "reward-granted", e)
				}
			})
		}
	};

	function lN(e, t, i, s) {
		console.log("'{0}' api command".format(e.cmd));
		try {
			console.log("services server: " + kh.servicesServer);
			var n = new WebSocket(kh.servicesServer)
		} catch (e) {
			console.log(e)
		}
		e && !e.hasOwnProperty("sessionId") && kh.playerAccount.hasOwnProperty("sessionId") && (e.sessionId = kh.playerAccount.sessionId), n.onopen = function(t) {
			n.send(JSON.stringify(e)), console.log("servicesWs opened, and " + e.cmd + " request sent")
		}, n.onmessage = function(s) {
			var a = null;
			try {
				a = JSON.parse(s.data)
			} catch (e) {
				return console.log("Invalid data returned from services API", e.data), void i(e)
			}
			a.error ? (console.log(e.cmd + " error: " + JSON.stringify(a.error)), i(a)) : t(a), n.close()
		}, n.onclose = function(t) {
			console.log(e.cmd + " servicesWs closed, code: " + t.code, "reason: " + t.reason, "clean: " + t.wasClean), s && s(t.code)
		}, n.onerror = function(t) {
			console.log(e.cmd + " servicesWs error: " + JSON.stringify(t)), PR.hide(), i(t)
		}
	}

	function hN() {
		lN({
			cmd: "checkBalance",
			firebaseId: kh.playerAccount.firebaseId
		}, (function(e) {
			console.log("Check Balance response: " + JSON.stringify(e)), e.error ? console.log("Check Balance call failed: " + JSON.stringify(e.error)) : kh.playerAccount.setEggBalances(e.currentBalance)
		}), (function() {
			console.log("Error running check balance call")
		}))
	}

	function cN(e, t) {
		! function(e, t) {
			lN({
				cmd: "checkUpgrade",
				firebase_id: kh.playerAccount.firebaseId,
				session: kh.playerAccount.session,
				sessionId: kh.playerAccount.sessionId
			}, e, t)
		}((function(t) {
			kh.playerAccount.setUpgrade(t), !kh.playerAccount.isUpgraded() && BT && (document.getElementById("chickenBadge").style.display = "none"), kh.productBlockAds = kh.playerAccount.isUpgraded(), kh.productBlockAds && vueApp.runProductCheck(), e && e(t)
		}), (function(e) {
			t && t(e), console.log("Error checking account upgrade status")
		}))
	}

	function uN(e, t) {
		if (!Mw.isChwRequest) return void console.log("api_incentivizedVideoRewardRequest() API called directly. chw not played");
		lN({
			cmd: "incentivizedVideoReward",
			token: null,
			id: kh.playerAccount.id,
			firebaseId: kh.playerAccount.firebaseId,
			sessionId: kh.playerAccount.sessionId
		}, e, t)
	}
	dw && console.log("adTagDebug debug is on"), kh.api_saveLoadout = function(e, t) {
		var i, s = {
			cmd: "saveLoadout",
			firebaseId: kh.playerAccount.firebaseId,
			save: "undefined" == typeof checkStatus || checkStatus(),
			loadout: e
		};
		t && (i = setTimeout((() => {
			t()
		}), 5e3)), lN(s, (function(e) {
			console.log("Save Loadout response: " + JSON.stringify(e)), e.error ? console.log("Save Loadout call failed: " + JSON.stringify(e.error)) : console.log("Successfully saved player loadout"), t && (clearTimeout(i), t())
		}), (function() {
			console.log("Error running save loadout call")
		}))
	}, kh.checkUpgrade = cN;
	var mN = (e, t, i) => lN({
		cmd: "urlRewardParams",
		reward: e,
		firebaseId: kh.playerAccount.firebaseId,
		sessionId: kh.playerAccount.sessionId
	}, t, i);

	function dN(e, t, i) {
		lN({
			cmd: "challengeRerollSlot",
			slotId: e,
			sessionId: kh.playerAccount.sessionId
		}, t, i)
	}
	var fN = (e, t) => {
		lN({
			cmd: "challengeGetDaily",
			playerId: kh.playerAccount.id,
			sessionId: kh.playerAccount.sessionId
		}, e, t)
	};

	function pN(e) {
		this.scene = e.scene, this.bullet = e, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("bullet").createInstance(""), this.mesh.setEnabled(!1)
	}
	pN.prototype.fire = function(e) {
		this.delayFrames = 3, e ? (this.mesh.scaling.x = 2, this.mesh.scaling.y = 2) : (this.mesh.scaling.x = 1, this.mesh.scaling.y = 1), this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.mesh.lookAt(new Lc(this.bullet.x + this.bullet.dx, this.bullet.y + this.bullet.dy, this.bullet.z + this.bullet.Sa)), this.mesh.scaling.z = .5
	}, pN.prototype.update = function(e) {
		this.delayFrames > 0 ? this.delayFrames-- : this.mesh.setEnabled(!0), this.mesh.position.x += .5 * (this.bullet.x - this.mesh.position.x), this.mesh.position.y += .5 * (this.bullet.y - this.mesh.position.y), this.mesh.position.z += .5 * (this.bullet.z - this.mesh.position.z), this.bullet.xa.id != xk && (this.mesh.scaling.z = Math.min(this.mesh.scaling.z + .03, 3))
	}, pN.prototype.remove = function() {
		this.mesh.setEnabled(!1)
	};
	var _N = class e {
		updateTimerData() {
			const e = Math.trunc(Date.now() / 1e3);
			this.gap = Math.max(this.end - e, 0), this.progress = Math.floor((this.span - this.gap) / this.span * 100), this.progress < 100 ? this.calculateTimeRemaining() : (this.ready = !0, this.clearTimer(), vueApp.chwUiTimerUpdate(0, 0, 0, 0, !0, this.limitReached, this.count, this.reset))
		}
		init() {
			this.limitReached = this.count > _h, this.startTimer()
		}
		clearTimer() {
			this.timer && (clearInterval(this.timer), this.timer = null)
		}
		constructor(e, t, i, s) {
			this.watchedCount = 0, this.days = 0, this.hours = 0, this.minutes = 0, this.seconds = 0, this.progress = 1, this.timer = null, this.reset = s || 0, this.gap = 0, this.end = e, this.span = t, this.limitReached = !1, this.ready = !1, this.count = i || 0, this.init()
		}
		startTimer() {
			this.timer || (this.timer = setInterval((() => this.updateTimerData()), 1e3))
		}
		calculateTimeRemaining() {
			this.days = Math.floor(this.gap / e.SECONDS_IN_A_DAY);
			let t = this.gap - this.days * e.SECONDS_IN_A_DAY;
			this.hours = Math.floor(t / e.SECONDS_IN_AN_HOUR), t -= this.hours * e.SECONDS_IN_AN_HOUR, this.minutes = Math.floor(t / e.SECONDS_IN_A_MINUTE), this.seconds = t % e.SECONDS_IN_A_MINUTE, vueApp.chwUiTimerUpdate(this.hours, this.minutes, this.seconds, this.progress, this.ready, this.limitReached, this.count, this.reset)
		}
	};
	_N.SECONDS_IN_A_DAY = 86400, _N.SECONDS_IN_AN_HOUR = 3600, _N.SECONDS_IN_A_MINUTE = 60;
	var gN, vN, yN, SN, EN, AN, bN, xN, MN, CN, TN, wN, RN, NN, IN, PN, kN, DN, ON, FN, LN, BN, GN, HN, UN, VN, WN, zN, XN, YN, jN, KN, $N, JN, qN, QN, ZN, eI, tI, iI, sI, nI, aI, rI, oI, lI, hI, cI, uI, mI = new Lc,
		dI = new Lc,
		fI = 0,
		pI = !1,
		_I = new Lc,
		gI = !1,
		vI = [0, 0, 0];

	function yI() {
		console.log("startGame()");
		var e = document.getElementById("onesignal-bell-container");
		NN = Date.now(), e && (e.style.display = "none"), wN = !1, iI = [], IN = [], gN = -1, vueApp.game.respawnTime = 0, bk = null, eI = null, FN = !1, oI = null, zN = 0, uw = !0, gI = !1, VN = !1, bN = new ZO, MN = performance.now(), lI = 0, tw = 0, hT = 0, cT = 0, uT = -1, mT = 0, CN = 0, XN = 0, YN = 0, jN = 0, sT = Date.now(), Date.now() + 1e3, JN = sR(kh.engine), FT.autoDetail || (JN.shadowsEnabled = FT.shadowsEnabled), JN.autoClear = !0, JN.autoClearDepthAndStencil = !0, iT = new Ng("camera", Lc.Zero(), JN), JN.activeCameras.push(iT), iT.maxZ = 1e3, iT.mk = 1.25, iT.minZ = .05, BAWK.attach(iT.globalPosition, _I), (vN = new lv("uiCamera", new Lc(0, 0, -1), JN)).mode = Sd.ORTHOGRAPHIC_CAMERA, vN.layerMask = 536870912, vN.autoClear = !1, JN.activeCameras.push(vN), sI = new hv("", 2048, JN, !0, 2), Ck = Nk((() => sI.update()), 100);
		let t = sI.getContext(),
			i = Rk["particles.webp"];
		t.save(), t.scale(1, -1), t.drawImage(i, 0, -i.height), t.restore(), sI.update(), (nI = new $v("", "", 18, {
			width: 256,
			height: 128
		}, JN)).fogEnabled = !1, nI.texture = sI, wk = aT == hh.teams || aT == hh.ctf || aT == hh.king, (aI = new $v("", "", 18, 128, JN)).texture = sI, aI.fogEnabled = !0, HR(JN), window.onfocus = function() {
			MN = performance.now(), bk && function() {
				if (!BT) return;
				dk.suppressSound = !0;
				var e = Rh.getBuffer();
				e.BkKlQQwL(sh.U), e.send(mk)
			}()
		}, window.onblur = function() {}, document.onpointerlockchange = function() {
			!document.pointerLockElement && bk && SI()
		}, document.body.style.overflow = "hidden", rN.init(), async function(e, t) {
			if (console.log("loadMap()"), uR.init(JN), HT) QN = JSON.parse(localStore.getItem("mapBackup"));
			else {
				var i = CR[e].filename,
					s = await fetch("maps/" + i + ".json?" + CR[e].hash);
				QN = await s.json(), console.log("MAP: " + i), vueApp.setGameDataUi(QN.name)
			}
			QN.sun ? JN.sunLight = {
				direction: new Lc(QN.sun.direction.x, QN.sun.direction.y, QN.sun.direction.z),
				diffuse: Tc.FromHexString(QN.sun.color)
			} : JN.sunLight = {
				direction: new Lc(.2, 1, .1),
				diffuse: Tc.White()
			};
			QN.ambient ? JN.ambientColor = Tc.FromHexString(QN.ambient) : JN.ambientColor = new Tc(.2, .2, .2);
			QN.fog ? (console.log("FOG:", QN.fog), QN.fog.density > 0 ? (JN.fogMode = bg.FOGMODE_EXP2, JN.fogColor = Tc.FromHexString(QN.fog.color), JN.fogDensity = QN.fog.density, JN.fogEnabled = !0) : (JN.fogEnabled = !1, JN.fogDensity = 0)) : (JN.fogMode = bg.FOGMODE_EXP2, JN.fogColor = new wc(.5, .55, .6, 1), JN.fogDensity = .01);
			QN.extents.x.min = 0, QN.extents.y.min = 0, QN.extents.z.min = 0, await new Promise((e => {
				var t = setInterval((() => {
					kT && (clearInterval(t), vueApp.assetLoaded(), e())
				}), 100)
			}));
			var n = WR((function(e) {
				alert("The following map meshes were not found:\n\n" + e + "\nTry clearing your cache and reload the page!")
			}));
			if (lF.uS(JN, n, QN, null, null, ((e, t) => {
					vueApp.assetLoaded(), (rI = lF.stripTris(qN.data, kR, e, t)).position.set(.5, .5, .5), rI.bakeCurrentTransformIntoVertices(), rI.receiveShadows = !0, r()
				})), PN = [], aT == hh.king)
				for (var a = 1; a <= LR; a++) lF.uS(JN, n, QN, "DYNAMIC.capture-zone.none", a, ((e, t) => {
					if (e) {
						let i = new Lc;
						for (let e of t) i.x += e.x, i.y += e.y, i.z += e.z;
						i.scaleInPlace(1 / t.length), i.x += .5, i.y += .6, i.z += .5, e.capIconPosition = i, e.position.set(.5, .5, .5), e.material = JN.getMaterialByName("colorized"), e.material.colorNode = e.material.getBlockByName("color"), e.sideOrientation = Pf.BACKSIDE, PN.push(e)
					}
				}));
			async function r() {
				var t;
				if (function() {
						JN.clearColor = Tc.Black(), (ZN = new Tg("", new Lc(0, -1, 0), JN)).lightmapMode = xg.LIGHTMAP_SHADOWSONLY, ZN.intensity = 1.2, ZN.autoUpdateExtends = !1, ZN.shadowMinZ = .1, ZN.shadowMaxZ = 100, ZN.shadowFrustumSize = 15, ZN.diffuse = Tc.Black(), ZN.specular = Tc.Black(), (tT = new Rg(1024, ZN)).forceBackFacesOnly = !0, tT.depthScale = 100, tT.frustumEdgeFalloff = 3, tT.onBeforeShadowMapRenderObservable.add((() => {
							kh.engine.setAlphaMode(Fd.ALPHA_COMBINE)
						})), tT.onAfterShadowMapRenderObservable.add((() => {
							kh.engine.setAlphaMode(Fd.ALPHA_DISABLE)
						}));
						var e = new Mg("", new Lc(0, -1, 0), JN);
						e.intensity = .6, e.groundColor = new Tc(.3, .3, .3);
						let t = new Tg("", JN.sunLight.direction.negate(), JN);
						t.intensity = 1.2, t.diffuse = JN.sunLight.diffuse
					}(), HT ? (t = localStorage.getItem("lightmap"), t = JSON.parse(t)) : t = await async function(e, t) {
						var i = await fetch(e),
							s = i.body.getReader(),
							n = +i.headers.get("Content-Length"),
							a = 0,
							r = [];
						for (;;) {
							var {
								done: o,
								value: l
							} = await s.read();
							if (o) break;
							r.push(l), a += l.length, t && t(a, n)
						}
						var h = new Uint8Array(a),
							c = 0;
						for (var u of r) h.set(u, c), c += u.length;
						var m = new Uint8Array(h);
						return m
					}("maps/" + i + ".lightmap?" + CR[e].hash, ((e, t) => {})), t) {
					var s = rI.getVerticesData(eu.ColorKind);
					vueApp.assetLoaded();
					for (var n = 0, a = 0; n < t.length; n += 3, a += 4) s[a] = t[n] / 255, s[a + 1] = t[n + 1] / 255, s[a + 2] = t[n + 2] / 255;
					rI.updateVerticesData(eu.ColorKind, s)
				}
				if (rI.material = JN.getMaterialByName("map"), rI.material.sideOrientation = Pf.CounterClockWiseSideOrientation, rI.freezeWorldMatrix(), !YT) {
					var r = QN.skybox || "default",
						l = cS.dk("skyBox", {
							size: 200
						}, JN);
					l.infiniteDistance = !0;
					var h = new Wv("skyBox", JN);
					h.backFaceCulling = !1, h.fogEnabled = !1, h.reflectionTexture = new Iv("img/skyboxes/" + r + "/skybox", JN), h.reflectionTexture.coordinatesMode = Np.SKYBOX_MODE, h.diffuseColor = new Tc(0, 0, 0), h.specularColor = new Tc(0, 0, 0), l.material = h, l.rotation.y = Math.PI
				}
				let c = Date.now() - NN;
				c > 3e3 ? o() : setTimeout((() => o()), 3e3 - c)
			}

			function o() {
				console.log("Now complete"), vueApp.assetLoaded(), setTimeout((() => {
					HT && PR.hide(), setTimeout((() => {
						vueApp.hideSpinner()
					}), 600), vueApp.progressBarReset(), crazySdk.showInviteButton({
						crazyShare: rT
					}), ga("send", "timing", "load", "mapLoaded", Math.round(performance.now()) - Math.round(OT), QN.name), t()
				}), 100)
			}
		}(oT, YI), bw && (bw = !1), async function() {
			Pw = !0
		}()
	}

	function SI() {
		xP = null, zN = 0, bk._a = 0, bk.releaseTrigger(), setTimeout((() => {
			var e = Rh.getBuffer();
			e.BkKlQQwL(sh.I), e.send(mk), bk.resetCountdowns(), MI(!LT || kh.productBlockAds || pokiActive ? 5 : 10)
		}), 100), uw = !0, vueApp.statsLoading(), MD.set((function() {
			bk.removeFromPlay(), GD()
		}), 3e3), console.log("pausing game via pointerlock exit"), bI(), crazySdk.gameplayStop()
	}

	function EI(e) {
		AN || BT && !uw && document.pointerLockElement && (document.exitPointerLock(), console.log("pausing game on key: ", e))
	}

	function AI() {
		document.pointerLockElement ? (console.log("pausing game and breaking pointerlock"), document.exitPointerLock()) : (console.log("pausing game via esc key"), bI())
	}

	function bI() {
		if (vueApp.showScreen === vueApp.screens.equip) return;
		fN((e => {
			kh.playerAccount.challenges = e
		}), (e => console.log("playerChallengesData error", e.error))), uw = !0, VN = !1, xD.clear(xN), lP(), qP(), vueApp.setPause(uw), vueApp.showGameMenu(), vueApp.showWelcomeBundleCtaInGame(), rP(), document.getElementById("grenadeThrowContainer").style.visibility = "hidden";
		["weaponBox", "healthContainer", "killTicker", "spectate", "captureIconContainer"].forEach((e => document.getElementById(e).style.display = "none")), document.getElementById("serverAndMapInfo").style.display = "block", document.getElementById("chw-game-screen").style.display = "block", document.getElementById("playerList").style.pointerEvents = "auto";
		const e = document.getElementById("gameAdContainer");
		e && (e.style.display = "block"), GN.hide(), GN.hideDot(), AN && fT.focus(), TN || (TN = document.querySelector(".chat-container")), setTimeout((() => {
			TN.scrollTop = TN.scrollHeight, rD()
		}), 300)
	}

	function xI() {
		if (console.log("resumeGame called"), bk) {
			uw = !1, vueApp.hideGameMenu(), document.getElementById("killTicker").style.display = "block", ["serverAndMapInfo", "chw-game-screen", "welcome-bundle-ui"].forEach((e => document.getElementById(e).style.display = "none")), aT == hh.king && (document.getElementById("captureIconContainer").style.display = "block"), document.getElementById("playerList").style.pointerEvents = "none", VN ? document.getElementById("spectate").style.display = "block" : (document.getElementById("weaponBox").style.display = "block", document.getElementById("healthContainer").style.display = "block", fP());
			const e = document.getElementById("gameAdContainer");
			e && (e.style.display = "block"), window.focus(), setTimeout((() => {
				! function() {
					console.log("Adding canvas event listeners"), canvas.hasAttribute("tabindex") || canvas.setAttribute("tabindex", "0");
					canvas.focus(), canvas.style.pointerEvents = "all",
						function() {
							const e = kh.engine.scenes[0];
							if (!e) return void console.error("Scene not found.");
							$P = e.onPointerObservable.add((e => {
								const t = e.event;
								switch (e.type) {
									case H_.POINTERDOWN:
										NI(t);
										break;
									case H_.POINTERUP:
										II(t)
								}
							}))
						}(), JP.forEach((e => canvas.addEventListener(e.type, e.listener, e.options))), addEventListener("gamepadbuttondown", QP)
				}(), AN ? fT.focus() : MP()
			}), 0), setTimeout((() => {
				rD()
			}), 300), fD()
		}
	}

	function MI(e) {
		gN = Math.max(e, gN), vueApp.game.respawnTime = gN, RN && xD.clear(RN), RN = xD.set((function() {
			gN--, vueApp.game.respawnTime = Math.min(gN, e), gN <= 0 && BT && (gN = -1, xD.clear(RN), CI(), KI())
		}), 1200)
	}

	function CI() {
		if (wI()) return void console.log("prepRespawnButton", "ad first");
		console.log("prepRespawnButton");
		document.querySelector(".btn-respawn").addEventListener("click", TI, {
			once: !0
		})
	}
	async function TI() {
		try {
			await canvas.requestPointerLock({
				unadjustedMovement: FT.fastPollMouse
			}), console.log("Pointer lock with unadjusted movement acquired.")
		} catch (e) {
			if ("NotSupportedError" === e.name) {
				console.warn("Unadjusted movement not supported; falling back.");
				try {
					await canvas.requestPointerLock(), console.log("Pointer lock acquired without unadjusted movement.")
				} catch (e) {
					console.error("Pointer lock failed:", e)
				}
			} else console.error("Pointer lock failed:", e)
		}
	}

	function wI() {
		if (kh.productBlockAds || wN) return !1;
		let e = nw ? 3e4 : 24e4;
		pokiActive && (e = 0);
		const t = Cw || lT > 1,
			i = getStoredNumber("lastPreRoll", Date.now()) + e,
			s = t && YN > 1 && Date.now() > i,
			n = fk.timeToPlayVideoAd();
		if (null !== n) return n;
		if (s) {
			console.log("video ad cancels respawnBtn click");
			document.querySelector(".btn-respawn").removeEventListener("click", TI, {
				once: !0
			})
		}
		return s
	}
	var RI = !1;

	function NI(e) {
		document.pointerLockElement || (e.preventDefault(), TI()), wP("keyboard", "MOUSE " + e.button), e.preventDefault(), e.stopPropagation(), console.log(`Mouse button ${e.button} down, Pointer Lock: ${!!document.pointerLockElement}`)
	}

	function II(e) {
		console.log(`Mouse button ${e.button} up, Pointer Lock: ${!!document.pointerLockElement}`), NP("keyboard", "MOUSE " + e.button), e.preventDefault(), e.stopPropagation()
	}
	var PI = new wc(1, 1, 1, 1);

	function kI(e, t, i, s) {
		t += 128, i += 128;
		var n = new $v("", "", e, 128, s);
		n.texture = sI, n.oldRender = n.render, n.render = function() {
			kh.engine.setDepthFunctionToLessOrEqual(), kh.engine.setAlphaMode(Fd.ALPHA_COMBINE), this.oldRender(), kh.engine.setAlphaMode(Fd.ALPHA_DISABLE), kh.engine.setDepthFunctionToLess()
		};
		for (var a = 0; a < e; a++) {
			new Xv("", n).isVisible = !1
		}
		return n.nextIdx = 0, n.getSprite = function(e) {
			var s = this.sprites[this.nextIdx];
			return s.cellIndex = void 0 !== e ? t + e : Math.randomInt(t, i), s.isVisible = !0, s.easing = wR.linear, s.startSize = -1, s.endSize = -1, s.gravity = 0, s.dx = 0, s.dy = 0, s.Sa = 0, s.float = 0, s.anim = 0, s.slow = 0, s.angle = 0, s.rotate = 0, s.stopped = !1, s.animColors = null, s.collide = !1, s.color.copyFrom(PI), this.nextIdx = ++this.nextIdx % this.sprites.length, s
		}, n
	}

	function DI(e, t, i, s, n, a, r, o, l, h, c) {
		let u = 0,
			m = 0,
			d = "default",
			f = "default";
		c && (u = c.item_data.cell || 0, e == DN && u && (m = c.item_data.smokeCell, isNaN(m) && (m = u)), d = c.item_data.fireColors || "default", f = c.item_data.smokeColors || "default");
		var p = e.getSprite(u);
		return p.animLength = t, p.easing = wR.inOutQuad, p.position.x = i, p.position.y = s, p.position.z = n, p.size = l, p.dx = a, p.dy = r, p.Sa = o, p.slow = .7, p.angle = Math.random() * Math.PI2, p.rotate = .04 * Math.random() - .02, p.animColors = e == ON ? FI[d] : LI[f], p
	}

	function OI(e, t, i, s, n, a) {
		for (var r = 0; r < Math.floor(s / 4); r++) {
			var o = 80 * Math.random() + 80,
				l = 1 * Math.random() + .5,
				h = .5 * (.9 - l),
				c = (2 * Math.random() - 1) * h,
				u = (2 * Math.random() - 1) * h + .1,
				m = (2 * Math.random() - 1) * h,
				d = DI(DN, o, e, t, i, c, u, m, l, 0, a);
			d.float = .015 * Math.random() + .001, d.collide = !0, (d = DI(ON, .075 * o, e, t, i, 1.5 * c, 1.5 * u, 1.5 * m, l, 0, a)).collide = !0
		}
		if (bk) {
			var f = Math.length3(bk.Xa - e, bk.ba - t, bk.va - i);
			if (f < (n *= 1.5)) {
				var p = Math.max(0, (n - f) / n);
				CO = Math.min(7, CO + 6 * p)
			}
		}
	}
	var FI = {
			default: [{
				pos: 0,
				color: new wc(1, .9, .8, 1)
			}, {
				pos: .2,
				color: new wc(1, .5, .1, 1)
			}, {
				pos: .4,
				color: new wc(.6, .2, .1, 1)
			}, {
				pos: .7,
				color: new wc(0, 0, 0, 0)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			rainbow: [{
				pos: 0,
				color: new wc(1, .1, .1, 1)
			}, {
				pos: .2,
				color: new wc(1, 1, .1, 1)
			}, {
				pos: .4,
				color: new wc(.1, 1, .1, 1)
			}, {
				pos: .7,
				color: new wc(.1, .1, 1, .5)
			}, {
				pos: 1,
				color: new wc(1, .1, 1, 0)
			}],
			gold: [{
				pos: 0,
				color: new wc(1, 1, .3, 1)
			}, {
				pos: .4,
				color: new wc(1, .8, .2, 1)
			}, {
				pos: 1,
				color: new wc(1, .6, .1, 0)
			}],
			corrupt: [{
				pos: 0,
				color: new wc(1, .1, .1, 1)
			}, {
				pos: .3,
				color: new wc(1, 1, 1, 1)
			}, {
				pos: .6,
				color: new wc(1, .1, .1, 1)
			}, {
				pos: 1,
				color: new wc(1, 1, 1, 0)
			}],
			thermal: [{
				pos: 0,
				color: new wc(1, .9, .8, 1)
			}, {
				pos: .2,
				color: new wc(1, .5, .1, 1)
			}, {
				pos: .4,
				color: new wc(.6, .2, .1, 1)
			}, {
				pos: .5,
				color: new wc(1, 1, 1, 1)
			}, {
				pos: .6,
				color: new wc(1, 1, 1, 0)
			}, {
				pos: .7,
				color: new wc(1, 1, 1, 1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			black: [{
				pos: 0,
				color: new wc(0, 0, 0, 1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			red: [{
				pos: 0,
				color: new wc(1, .7, .3, 1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			blue: [{
				pos: 0,
				color: new wc(.3, .7, 1, 1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}]
		},
		LI = {
			default: [{
				pos: 0,
				color: new wc(.3, .3, .3, 1)
			}, {
				pos: 1,
				color: new wc(.7, .7, .7, 0)
			}],
			white: [{
				pos: 0,
				color: new wc(1, 1, 1, .5)
			}, {
				pos: 1,
				color: new wc(1, 1, 1, 0)
			}],
			corrupt: [{
				pos: 0,
				color: new wc(1, 1, 1, .6)
			}, {
				pos: .5,
				color: new wc(1, .1, .1, .4)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			thermal: [{
				pos: 0,
				color: new wc(.5, .1, .01, .3)
			}, {
				pos: .3,
				color: new wc(.7, .4, 0, .1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			supernova: [{
				pos: 0,
				color: new wc(1, 1, 1, .5)
			}, {
				pos: 1,
				color: new wc(1, 0, 1, 0)
			}],
			black: [{
				pos: 0,
				color: new wc(0, 0, 0, 1)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			softblack: [{
				pos: 0,
				color: new wc(0, 0, 0, .5)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			red: [{
				pos: 0,
				color: new wc(1, .7, .3, 1)
			}, {
				pos: .5,
				color: new wc(1, .3, 0, .6)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}],
			blue: [{
				pos: 0,
				color: new wc(.3, .7, 1, 1)
			}, {
				pos: .5,
				color: new wc(0, .3, 1, .6)
			}, {
				pos: 1,
				color: new wc(0, 0, 0, 0)
			}]
		},
		BI = [{
			pos: 0,
			color: new wc(1, 1, 1, 1)
		}, {
			pos: .2,
			color: new wc(.7, .7, .7, .7)
		}, {
			pos: 1,
			color: new wc(.7, .7, .7, 0)
		}],
		GI = [{
			pos: 0,
			color: new wc(1, 1, 1, 1)
		}, {
			pos: .8,
			color: new wc(1, 1, 1, 1)
		}, {
			pos: 1,
			color: new wc(1, 1, 1, 0)
		}];

	function HI(e, t, i) {
		for (var s = e.length - 2; s >= 0; s--)
			if (t >= e[s].pos) return void wc.LerpToRef(e[s].color, e[s + 1].color, (t - e[s].pos) * (1 / (e[s + 1].pos - e[s].pos)), i)
	}

	function UI(e, t, i, s) {
		for (var n = 0; n < t; n++) {
			var a = Math.random() * s + .5 * s,
				r = n / (.5 * t) * i + .5 * i,
				o = .08 / (r + 1),
				l = (2 * Math.random() - 1) * o,
				h = (2 * Math.random() - .5) * o,
				c = (2 * Math.random() - 1) * o,
				u = SN.getSprite();
			u.animLength = a, u.easing = wR.inQuad, u.position.x = e.pa.mesh.position.x, u.position.y = e.pa.mesh.position.y + .3, u.position.z = e.pa.mesh.position.z, u.startSize = r, u.endSize = 0, u.gravity = .003, u.dx = l, u.dy = h, u.Sa = c, u.angle = Math.random() * Math.PI2, u.rotate = .2 * Math.random() - .1, u.collide = !0;
			let m = e.pa.zS.shellColor;
			u.color.copyFromFloats(m.r, m.g, m.b, 1)
		}
	}

	function VI(e) {
		for (var t = 0; t < 10; t++) {
			var i = 80 * Math.random() + 80,
				s = t / 5 * .2 + .2,
				n = .05 / (s + 1),
				a = (2 * Math.random() - 1) * n,
				r = (2 * Math.random() - .25) * n * 1.5,
				o = (2 * Math.random() - 1) * n,
				l = hI.getSprite();
			l.animLength = i, l.easing = wR.inQuad, l.position.x = e.pa.mesh.position.x, l.position.y = e.pa.mesh.position.y + .3, l.position.z = e.pa.mesh.position.z, l.startSize = s, l.endSize = 0, l.gravity = .005, l.dx = a, l.dy = r, l.Sa = o, l.slow = .9, l.angle = Math.random() * Math.PI2, l.rotate = .2 * Math.random() - .1, l.collide = !0
		}
	}

	function WI(e, t) {
		for (var i = Math.floor(t / 33) + 1, s = 0; s < i; s++) {
			var n = 9 * Math.random() + 9,
				a = .03 / 1.8,
				r = (2 * Math.random() - 1) * a,
				o = (2 * Math.random() - .25) * a * 1.5,
				l = (2 * Math.random() - 1) * a;
			mI.set(bk.Xa, bk.ba, bk.va), dI.set(e.Xa, e.ba, e.va), mI.subtractInPlace(dI).normalize().scaleInPlace(.26);
			var h = EN.getSprite();
			h.animLength = n, h.easing = wR.linear, h.position.x = e.pa.mesh.position.x, h.position.y = e.pa.mesh.position.y + .3, h.position.z = e.pa.mesh.position.z, h.startSize = .8 * .2, h.endSize = .8, h.gravity = .003, h.dx = r + e.dx, h.dy = o, h.Sa = l + e.Sa, h.slow = .95, h.angle = Math.random() * Math.PI2, h.rotate = .02 * Math.random() - .001, h.collide = !1, h.animColors = GI
		}
	}

	function zI(e, t) {
		for (var i = Math.floor(t / 33) + 1, s = 0; s < i; s++) {
			var n = 9 * Math.random() + 9,
				a = .8,
				r = .03 / ((a *= e.playerScale) + 1),
				o = (2 * Math.random() - 1) * r,
				l = (2 * Math.random() - .25) * r * 1.5,
				h = (2 * Math.random() - 1) * r;
			mI.set(bk.Xa, bk.ba, bk.va), dI.set(e.Xa, e.ba, e.va), mI.subtractInPlace(dI).normalize().scaleInPlace(.26);
			var c = yN.getSprite();
			c.animLength = n, c.easing = wR.linear, c.position.x = e.pa.mesh.position.x, c.position.y = e.pa.mesh.position.y + .3, c.position.z = e.pa.mesh.position.z, c.startSize = .2 * a, c.endSize = a, c.gravity = .003, c.dx = o + e.dx, c.dy = l, c.Sa = h + e.Sa, c.slow = .95, c.angle = Math.random() * Math.PI2, c.rotate = .02 * Math.random() - .001, c.collide = !1, c.animColors = GI
		}
	}

	function XI(e, t) {
		for (var i = 0; i < e.sprites.length; i++) {
			var s = e.sprites[i];
			if (s.isVisible) {
				var n = s.easing(s.anim);
				if (s.endSize >= 0 && (s.size = s.startSize + n * (s.endSize - s.startSize)), s.animColors && HI(s.animColors, n, s.color), !s.stopped) {
					s.position.x += s.dx * t, s.position.y += s.dy * t + s.float, s.position.z += s.Sa * t, s.rotate && (s.angle += s.rotate * t);
					var a = !1;
					s.collide && (mI.set(s.position.x, s.position.y, s.position.z), a = mR.pointCollidesWithStructure(mI, !0)), a ? (s.stopped = !0, s.position.x -= s.dx * t, s.position.y -= s.dy * t, s.position.z -= s.Sa * t) : s.gravity && (s.dy -= s.gravity * t), s.slow && (s.dx *= Math.pow(s.slow, t), s.dy *= Math.pow(s.slow, t), s.Sa *= Math.pow(s.slow, t))
				}
				s.anim += t / s.animLength, s.anim >= 1 && (s.isVisible = !1)
			}
		}
	}

	function YI() {
		console.log("onLoadingComplete"), kN = new Ph({
			numChannels: 24
		}, {
			distanceModel: "exponential"
		});
		try {
			BN = new UP, HN = new VP, UN = new Kf(JN), FT.hitMarkers ? UN.show() : UN.hide(), (GN = new WP).hide(), GN.hideDot(), nR("muzzleFlash", JN, null, JN.getMaterialByName("muzzleFlash")).setEnabled(!1), nR("bullet", JN, null, JN.getMaterialByName("bullet")).setEnabled(!1), nR("rocket", JN, null, JN.getMaterialByName("standardInstanced")).setEnabled(!1), nR("ammo", JN, null, JN.getMaterialByName("standardInstanced")).setEnabled(!1), nR("grenadeItem", JN, null, JN.getMaterialByName("standardInstanced")).setEnabled(!1), nR("spatula", JN, null, JN.getMaterialByName("emissive")).setEnabled(!1);
			for (let e = 0; e < kh.catalog.grenades.length; e++) {
				nR(kh.catalog.grenades[e].item_data.meshName, JN, null, JN.getMaterialByName("emissive")).setEnabled(!1)
			}
			if (cI = new NR(JN), uI = new EO, (DN = kI(300, 16, 23, JN)).fogEnabled = !0, (ON = kI(300, 16, 23, JN)).fogEnabled = !0, ON.blendMode = Fd.ALPHA_ADD, (SN = kI(400, 3, 6, JN)).fogEnabled = !0, window.P = SN, (hI = kI(100, 2, 2, JN)).fogEnabled = !0, kh.engine.clear(Tc.Black()), kh.engine.stopRenderLoop(), vueApp.switchToGameUi(), kh.playerAccount.isUpgraded() && (document.getElementById("chickenBadge").style.display = "block"), (yN = kI(20, 0, 0, JN)).fogEnabled = !0, (EN = kI(20, 7, 7, JN)).fogEnabled = !0, HT) {
				xk = 0, fk = {
					update: () => {},
					render: () => {}
				}, dk = {
					update: () => {}
				};
				var e = {
					sa: 0,
					Ia: 0,
					Ka: "Test",
					ia: 0,
					Ya: 0,
					Na: kh.playerAccount.getPrimaryWeapon(),
					oa: kh.playerAccount.getSecondaryWeapon(),
					Pa: 0,
					ga: null,
					Aa: null,
					Ra: 0,
					da: 0,
					SS: 0,
					JS: 0,
					iS: 0,
					YS: 0,
					NS: 0,
					oS: 0,
					US: 0,
					nS: 0,
					Xa: zT.x + .5,
					ba: zT.y - .32,
					va: zT.z + .5,
					Ta: 0,
					La: 0,
					wa: 0,
					PS: 0,
					ca: zT.pitch,
					Oa: zT.yaw,
					WS: 0,
					fS: 0,
					DS: !1,
					FS: 0,
					_a: 0,
					gS: 0,
					BS: void 0 !== kh.playerAccount.upgradeProductId && null !== kh.playerAccount.upgradeProductId ? kh.playerAccount.upgradeProductId : 0,
					bS: 0,
					tS: [],
					jS: 0,
					yS: 1,
					$S: {}
				};
				bh.forEach((t => e.$S[t] = 0)), pP(e), iI[xk].fS = 100, $I(), qI(), QI(), AI(), GN.show(), GN.showDot(), gN = -1, uT = 0, vueApp.delayTheCracking = !0
			} else {
				LN = !0, mk.onmessage = function(e) {
					for (Nh.init(e.data); Nh.isMoreDataAvailable();) {
						var t = Nh.unPackInt8U();
						switch (t) {
							case sh.Ik:
								var i = Nh.unPackInt8U(),
									s = Nh.unPackString(128),
									n = Nh.unPackString(32);
								if (Pe = iI[i]) {
									Pe.dbId = s, Pe.ip = n;
									for (var a = 0; a < IN.length; a++)
										if (IN[a].id === i) {
											IN[a].dbId = s, IN[a].ip = n;
											break
										}
								}
								break;
							case sh.zk:
								var r = Nh.unPackLongString();
								sP(r);
								break;
							case sh.I:
								i = Nh.unPackInt8U(), (Pe = iI[i]) && Pe.removeFromPlay();
								break;
							case sh.Sk:
								console.log("eventModifier"), (o = Rh.getBuffer()).BkKlQQwL(sh.Sk), o.send(mk);
								break;
							case sh.ck:
								ZP(), gN = -1, uT = 0, qI(), QI(), vueApp.delayInGamePlayButtons();
								let e = zP();
								var o;
								vueData.game.shareLinkPopup.code = rT, vueData.game.shareLinkPopup.url = e, cw ? (vueApp.hideHeaderAd(!0), setTimeout((() => {
									vueApp.onGamePauseUi(), vueApp.onGameOptionsClick()
								}), 200)) : AI(), FT.autoDetail ? oD() : (hD(FT.highRes), cD(FT.shadowsEnabled)), (o = Rh.getBuffer()).BkKlQQwL(sh.D), o.send(mk);
								break;
							case sh.N:
								var l = Nh.unPackInt8U(),
									h = Nh.unPackString(),
									c = Nh.unPackString(),
									u = Nh.unPackString(),
									m = Nh.unPackInt8U(),
									d = {
										sa: l,
										Ia: h,
										Ka: c = RD(c, 80),
										Ja: u,
										ia: m,
										Ya: Nh.unPackInt8U(),
										Na: kh.catalog.findItemById(Nh.unPackInt16U()),
										oa: kh.catalog.findItemById(Nh.unPackInt16U()),
										Pa: Nh.unPackInt8U(),
										ga: kh.catalog.findItemById(Nh.unPackInt16U()),
										Aa: kh.catalog.findItemById(Nh.unPackInt16U()),
										Ra: Nh.unPackInt8(),
										da: Nh.unPackInt8(),
										Za: kh.catalog.findItemById(Nh.unPackInt16U()),
										ma: kh.catalog.findItemById(Nh.unPackInt16U()),
										Xa: Nh.unPackFloat(),
										ba: Nh.unPackFloat(),
										va: Nh.unPackFloat(),
										Ta: Nh.unPackFloat(),
										La: Nh.unPackFloat(),
										wa: Nh.unPackFloat(),
										Oa: Nh.unPackRadU(),
										ca: Nh.unPackRad(),
										SS: Nh.unPackInt32U(),
										JS: Nh.unPackInt16U(),
										iS: Nh.unPackInt16U(),
										YS: Nh.unPackInt16U(),
										NS: Nh.unPackInt32U(),
										oS: Nh.unPackInt32U(),
										US: Nh.unPackInt16U(),
										nS: Nh.unPackInt16U(),
										WS: Nh.unPackInt8U(),
										fS: Nh.unPackInt8U(),
										DS: Nh.unPackInt8U(),
										FS: Nh.unPackInt8U(),
										_a: Nh.unPackInt8U(),
										BS: Nh.unPackInt8U(),
										bS: Nh.unPackInt8U(),
										tS: Nh.unPackLongString(),
										jS: Nh.unPackInt8U(),
										qS: {}
									};
								if (d.qS.mapIdx = Nh.unPackInt8U(), d.qS.private = Nh.unPackInt8U(), d.qS.gameType = Nh.unPackInt8U(), d.$S = {}, bh.forEach((e => d.$S[e] = 0)), d.$S.kills = d.JS, d.$S.deaths = d.iS, d.$S.streak = d.YS, d.Ka = ID(d.Ka), !iI[d.sa]) {
									xk == d.sa || VT ? (d.ua = d.Ka, d.Ja = d.Ka) : (d.ua = d.Ka.replace(/<|>/g, ""), (0 == d.ua.length || JR(d.ua)) && (d.ua = d.Ja), FT.safeNames ? d.Ka = d.Ja : d.Ka = d.ua);
									let e = yP(h);
									e ? (d.eS = e.muted, d.eS && !FT.safeNames && (d.Ka = d.Ja)) : d.eS = !1, pP(d)
								}
								break;
							case sh.P:
								_P(i = Nh.unPackInt8U());
								break;
							case sh.$:
								l = Nh.unPackInt16U();
								var f = Nh.unPackInt8U(),
									p = Nh.unPackFloat(),
									_ = Nh.unPackFloat(),
									g = Nh.unPackFloat();
								uI.spawnItem(l, f, p, _, g);
								break;
							case sh.rk:
								i = Nh.unPackInt8U(), f = Nh.unPackInt8U();
								var v = Nh.unPackInt8U();
								l = Nh.unPackInt16U(), uI.collectItem(f, l), i == xk && bk.collectItem(f, v);
								break;
							case sh.lk:
								var y, S, E = Nh.unPackInt8U(),
									A = Nh.unPackInt8U(),
									b = Nh.unPackInt8U(),
									x = iI[E],
									M = iI[A],
									C = Nh.unPackInt8U(),
									T = Nh.unPackInt8U();
								if (M.lastDmgType = C, x.lastDmgType = T, E == xk && A != xk ? MT.updateTerminus(getKeyByValue(Ah, x.charClass), uh[T].name, "deaths") : A == xk && E == xk && (MT.updateTerminus(getKeyByValue(Ah, x.charClass), "Grenade", "deaths", !0), ga("send", "event", "weapon", "deathBy", "Suicide")), x) {
									dk.scoreKill(M, x) && KP(), y = x.name;
									var w = new Lc(x.Xa, x.ba + .32, x.va);
									kN.play("shell_burst", w);
									var R = Math.randomInt(0, 10) + 1;
									kN.play("death_scream" + R, w), zI(x, 100), WI(x, 100), UI(x, 80, .2, 40), VI(x), x.die(), x.pa.mesh.position.x = x.Xa, x.pa.mesh.position.y = x.ba, x.pa.mesh.position.z = x.va
								} else y = "N/A";
								M ? (A === xk && E !== A && (MT.streak = M.rS, MT.updateTerminus(getKeyByValue(Ah, M.charClass), uh[T].name, "kills"), "Grenade" !== uh[T].name && "Melee" !== uh[T].name || ga("send", "event", "weapon", "killedWith", uh[T].name)), S = M.name, M.isDead() || (M.scoreKill(), A == xk && vueApp.bestStreakUpdate(M.bestOverallStreak), A == xk && (XN++, jN = Math.max(jN, M.stats.streak)))) : S = "N/A", E != xk ? A == xk && (vueApp.killedName = y, vueApp.shellIngameNotification({
									msg: y,
									type: 0,
									streak: bk.stats.streak > 1 ? bk.stats.streak : ""
								})) : (uw = !0, iT.parent = null, iT.position = new Lc(eI.pa.mesh.position.x, eI.pa.mesh.position.y + .2, eI.pa.mesh.position.z), M && (iT.lockedTarget = M.pa.head), vueApp.shellIngameNotification({
									msg: S,
									type: 1,
									streak: 0
								}), YN++, MI(!LT || kh.productBlockAds || pokiActive ? b - 1 : 12), qP(), MD.set((function() {
									BT && ST == xk && AI()
								}), 3e3)), M && x && PP(M, x), EP();
								break;
							case sh.qk:
								i = Nh.unPackInt8U();
								var N = Nh.unPackInt8U();
								OP(Nh.unPackString().valueOf(), N, i);
								break;
							case sh.tk:
								dk._unPackState(Nh);
								break;
							case sh.jk:
								l = Nh.unPackInt8U();
								var I = Nh.unPackInt8U(),
									P = Nh.unPackInt8U(),
									k = (p = Nh.unPackFloat(), _ = Nh.unPackFloat(), g = Nh.unPackFloat(), Nh.unPackInt8U()),
									D = Nh.unPackInt8U(),
									O = Nh.unPackInt8U();
								(Pe = iI[l]).serverStateIdx = P;
								var F = Pe.Xa,
									L = Pe.ba,
									B = Pe.va,
									G = Pe.dx,
									H = Pe.dy,
									U = Pe.Sa,
									V = Pe.Oa,
									W = Pe.ca,
									z = (a = I, Pe.CS[a]),
									X = Math.mod(Pe.stateIdx - I, OR) + 8 * mh;
								if (Pe.lastWeaponChange > X && (D !== z.Ca || O !== z.store)) {
									for (var Y = I; Y != Pe.stateIdx; Y = Math.mod(Y + 1, OR)) {
										var j = Pe.CS[Y];
										D -= j.shots, j.Ca = D
									}
									Pe.Wa.ammo.Ca = D, Pe.Wa.ammo.store = O, AP()
								}
								if (k) var K = Math.length3(z.Xa - p, z.ba - _, z.va - g);
								else K = Math.length2(z.Xa - p, z.va - g);
								if (0 != zN) {
									if (K < .1) {
										var $ = 2 * mh;
										Pe.totalCorrections = $, Pe.corrections = $, Pe.corrected.dx = p - z.Xa, Pe.corrected.dy = _ - z.ba, Pe.corrected.Sa = g - z.va;
										break
									}
									$ = 2 * mh
								} else {
									if (K < .02) break;
									$ = 2 * mh
								}
								Pe.totalCorrections = $, Pe.Xa = p, Pe.ba = _, Pe.va = g, Pe.dx = z.dx, Pe.dy = z.dy, Pe.Sa = z.Sa, Pe.QS = z.QS, Pe.GS = z.GS, Pe.playerScale = z.scale;
								for (var J = bk._a; a != Pe.stateIdx; a = Math.mod(a + 1, OR)) z = Pe.CS[a], Pe._a = z._a, Pe.Oa = z.Oa, Pe.ES(!0);
								(K = Pe.QS ? Math.length3(Pe.Xa - F, Pe.ba - L, Pe.va - B) : Math.length2(Pe.Xa - F, Pe.va - B)) < .2 ? (Pe.corrections = $, Pe.corrected.dx = Pe.Xa - F, Pe.corrected.dy = Pe.ba - L, Pe.corrected.Sa = Pe.va - B, Pe.Xa = F, Pe.ba = L, Pe.va = B, Pe.dx = G, Pe.dy = H, Pe.Sa = U) : Pe.corrections = 0, Pe.Oa = V, Pe.ca = W, Pe._a = J;
								break;
							case sh.Wk:
								if (l = Nh.unPackInt8U(), p = Nh.unPackFloat(), _ = Nh.unPackFloat(), g = Nh.unPackFloat(), k = Nh.unPackInt8U(), !(Pe = iI[l]) || Pe.id == xk) {
									for (a = 0; a < mh; a++) Nh.unPackInt8U(), Nh.unPackRadU(), Nh.unPackRad(), Nh.unPackInt8U();
									break
								}
								for (Pe.stateIdx = 0, a = 0; a < mh; a++) Pe.CS[a]._a = Nh.unPackInt8U(), Pe.CS[a].Oa = Nh.unPackRadU(), Pe.CS[a].ca = Nh.unPackRad(), Pe.CS[a].scale = Nh.unPackInt8U() / 100;
								Pe.Xa = p, (!Pe.GS || Math.abs(Pe.ba - _) > .5) && (Pe.ba = _), Pe.va = g, Pe.CS[0].Xa = p, Pe.CS[0].ba = _, Pe.CS[0].va = g, Pe.QS = k;
								break;
							case sh.T:
								if (l = Nh.unPackInt8U(), mI.x = Nh.unPackFloat(), mI.y = Nh.unPackFloat(), mI.z = Nh.unPackFloat(), dI.x = Nh.unPackFloat(), dI.y = Nh.unPackFloat(), dI.z = Nh.unPackFloat(), !(Pe = iI[l])) break;
								l != xk && (Pe.Wa.pa.fire(), Pe.Wa.fireMunitions(mI, dI), --Pe.Wa.tracer < 0 && (Pe.Wa.tracer = Pe.Wa.constructor.tracer));
								break;
							case sh._:
								l = Nh.unPackInt8U(), iI[l] && (iI[l].meleeCountdown = 17, iI[l].pa.melee());
								break;
							case sh.kk:
								l = Nh.unPackInt8U(), p = Nh.unPackFloat(), _ = Nh.unPackFloat(), g = Nh.unPackFloat();
								var q = Nh.unPackFloat(),
									Q = Nh.unPackFloat(),
									Z = Nh.unPackFloat();
								if (!(Pe = iI[l])) break;
								Pe.OS--, l != xk ? (Pe.pa.head.rotation.x = Pe.ca, Pe.pa.mesh.rotation.y = Pe.Oa) : AP(), Pe.pa.throwGrenade(), cI.throwGrenade(Pe, {
									x: p,
									y: _,
									z: g
								}, {
									x: q,
									y: Q,
									z: Z
								});
								break;
							case sh.Mk:
								var ee = Nh.unPackInt8U(),
									te = Nh.unPackInt16U(),
									ie = (p = Nh.unPackFloat(), _ = Nh.unPackFloat(), g = Nh.unPackFloat(), Nh.unPackInt8U()),
									se = Nh.unPackFloat();
								let t = null;
								ee > 0 && (t = kh.catalog.findItemById(te)), OI(p, _, g, ie, se, t), mI.set(p, _, g), ee == Eh.Grenade ? kN.play(t.item_data.sound || "grenade", mI) : kN.play("gun_rpegg_rocket_hit", mI);
								break;
							case sh.vk:
								l = Nh.unPackInt8U(), iI[l] && iI[l].reload();
								break;
							case sh.k:
								l = Nh.unPackInt8U();
								var ne = Nh.unPackInt8U();
								iI[l] && iI[l].swapWeapon(ne);
								break;
							case sh.pk:
								var ae = Nh.unPackInt8U();
								q = Nh.unPackFloat(), Z = Nh.unPackFloat(), bk.fS = ae, bk.pa.hit(), HN.hit(q, Z), UN.hit(q, Z);
								break;
							case sh.sk:
								var re = Nh.unPackInt8U();
								ae = Nh.unPackInt8U(), q = Nh.unPackFloat(), Z = Nh.unPackFloat(), bk.fS = ae, bk.vS = re, bk.pa.hit(), HN.hit(q, Z), UN.hit(q, Z), fP();
								break;
							case sh.xk:
								if (l = Nh.unPackInt8U(), ae = Nh.unPackInt8U(), !(Pe = iI[l])) break;
								Pe.fS = ae, Pe.lastDmgType = Pe.Wa.constructor.id, Pe.pa.hit(), ae > 0 && WI(Pe, Math.clamp(Pe.fS - ae, 0, 100));
								break;
							case sh.Vk:
								wN = !1, l = Nh.unPackInt8U();
								var oe = Nh.unPackInt16U(),
									le = (p = Nh.unPackFloat(), _ = Nh.unPackFloat(), g = Nh.unPackFloat(), Nh.unPackInt8U()),
									he = Nh.unPackInt8U(),
									ce = Nh.unPackInt8U(),
									ue = Nh.unPackInt8U(),
									me = Nh.unPackInt8U();
								(Pe = iI[l]) && (Pe.pa.removeFromPlay(), Pe.ya.setSeed(oe), Pe.weapons[0].ammo.Ca = le, Pe.weapons[0].ammo.store = he, Pe.weapons[1].ammo.Ca = ce, Pe.weapons[1].ammo.store = ue, Pe.grenades = me, Pe.respawn(p, _, g), l == xk ? (xI(), nP(), rN.init(), $I(), GN.show(), GN.showDot(), AN && fT.focus()) : EP());
								break;
							case sh.ek:
								AI();
								break;
							case sh.M:
								l = Nh.unPackInt8U();
								var de = Nh.unPackInt8U(),
									fe = Nh.unPackInt16U(),
									pe = Nh.unPackInt16U(),
									_e = Nh.unPackInt8U(),
									ge = Nh.unPackInt16U(),
									ve = Nh.unPackInt16U(),
									ye = Nh.unPackInt16U(),
									Se = Nh.unPackInt16U(),
									Ee = Nh.unPackInt8(),
									Ae = Nh.unPackInt8(),
									be = kh.catalog.findItemById(fe),
									xe = kh.catalog.findItemById(pe),
									Me = kh.catalog.findItemById(ge),
									Ce = kh.catalog.findItemById(ve),
									Te = kh.catalog.findItemById(ye),
									we = kh.catalog.findItemById(Se);
								(Pe = iI[l]) && Pe.changeCharacter(de, be, xe, _e, Me, Ce, Ee, Ae, Te, we);
								break;
							case sh.j:
								l = Nh.unPackInt8U();
								var Re = Nh.unPackInt8U();
								(Pe = iI[l]) && (l == xk && (ET = Re, vueApp.setTeam(ET), dk.teamScore[Re] >= dk.teamScore[Pe.team] && dk.teamScore[Re] > 0 && (Pe.canTakeTeamBonus = !1)), Pe.team = Re, Pe.aS = 0, Pe.stats.kills = 0, Pe.stats.streak = 0, Pe.rS = 0, Nh.isMoreDataAvailable() && Nh.peekInt8U() === sh.j || (lP(), EP()));
								break;
							case sh.hk:
								vueApp.showGenericPopup("ui_game_fairteams_header", "ui_game_fairteams_text", "ok");
								break;
							case sh.D:
								lI = Date.now() - uP, hT += lI, cT++, (De = document.getElementById("ping")).style.color = lI < 100 ? "#0f0" : lI < 150 ? "#ff0" : lI < 200 ? "#f90" : "#f00", De.innerText = lI + "ms", setTimeout((function() {
									if (mk) {
										var e = Rh.getBuffer();
										e.BkKlQQwL(sh.D), e.send(mk), uP = Date.now()
									}
								}), 1e3);
								break;
							case sh.O:
								notify(vueApp.loc.ui_game_locked, 1e4);
								break;
							case sh.bk:
								var Ne = Nh.unPackInt32U();
								console.log("updating balance from server: " + Ne), kh.playerAccount.currentBalance = Ne;
								break;
							case sh.Ck:
								console.log("upgrade has expired"), cN();
								break;
							case sh.Dk:
								l = Nh.unPackInt8U();
								var Ie = Nh.unPackInt8U();
								(Pe = iI[l]).beginShellStreak(Ie);
								break;
							case sh.Fk:
								l = Nh.unPackInt8U(), Ie = Nh.unPackInt8U(), (Pe = iI[l]).endShellStreak(Ie);
								break;
							case sh.Kk:
								l = Nh.unPackInt8U();
								var Pe, ke = Nh.unPackInt8U();
								(Pe = iI[l]).id === xk && Pe.challengeCompleted(ke);
								break;
							case sh.K:
								dR.parse(), vueData.selectedWeaponDisabled = dR.isSelectedWeaponDisabled(kh.playerAccount.classIdx), vueApp.$refs.gameScreen.$forceUpdate(), vueApp.$refs.gameScreen.$refs.weaponSelect.$forceUpdate();
								break;
							case sh.H:
								switch (Nh.unPackInt8U()) {
									case pR.reset:
										var De;
										dk.reset(), (De = document.getElementById("gameMessage")).innerHTML = nD("ingame_reset"), De.className = "show", setTimeout((() => {
											De.className = "hide"
										}), 3e3);
										break;
									case pR.pause:
										bk.Ba && AI()
								}
								break;
							case sh.$k:
								l = Nh.unPackInt8U(), te = Nh.unPackInt16U(), Nh.unPackInt24U()
						}
						eP.push(t), eP.length > 4 && eP.shift()
					}
				}, mk.onclose = e => {
					bD(e.code)
				};
				var t = Rh.getBuffer();
				t.BkKlQQwL(sh.ck), t.send(mk), uP = Date.now(), DO();
				OP(nD("ingame_chat_msg_2"), nh, null, jI, "<i class='fas fa-user-friends'></i>"),
					function() {
						if (!BT) return;
						setTimeout((() => {
							zk()
						}), 500)
					}()
			}
			pD(!1)
		} catch (e) {
			console.log(e)
		}
	}

	function jI() {
		ga("send", "event", "game", "click", "openShareLinkChat"), XP()
	}

	function KI() {
		iT.parent = null, iT.position.set(0, qN.height + 1, 0), iT.lockedTarget = null, iT.setTarget(new Lc(qN.width / 2, qN.height / 4, qN.depth / 2)), LN = !0, eI = bk, ST = xk, JN.autoClear = !0, JN.autoClearDepthAndStencil = !0
	}

	function $I(e) {
		iT.position.set(0, 0, 0), iT.rotation.set(0, Math.PI, 0), iT.parent = e ? e.pa.eye : bk.pa.eye, iT.lockedTarget = null, LN = !1, JN.autoClear = !1, JN.autoClearDepthAndStencil = !1
	}
	var JI = !1;

	function qI(e) {
		hasValue(e) || rD(), kh.engine.Zk((function() {
			! function() {
				if (iT.forwardRay && iT.forwardRay.direction && iT.forwardRay.origin) {
					window.set_mouse_params(FT.mouseSpeed, FT.mouseInvert, bk.Wa.pa.scopeFov, bk.scope, bk.ik), null !== XD.index && window.poll_gamepad(XD.index, FT.deadzone, FT.controllerSpeed, bk.scope, FT.controllerInvert, iI, iT, bk.id, bk.team);
					let e = window.get_yaw_pitch();
					isNaN(e.yaw) || isNaN(e.pitch) ? console.warn("Invalid yaw/pitch values:", e) : (bk.Oa = e.yaw, bk.ca = e.pitch, bk.kS = e.coords)
				}
				var e = performance.now(),
					t = Math.min((e - mP) / (1e3 / 60), 8);
				if (mP = e, uT >= 0) {
					var i = kh.engine.getFps();
					uT += i, mT++
				}
				if (mT % 10 == 0) {
					document.getElementById("FPS").innerText = Math.floor(i + .5), eI && fP()
				}
				cT > 10 && (tw = Math.max(tw, lI));
				if (XT) bk.pa.update(t);
				else {
					for (var s = 0; s < Mk; s++) {
						var n = iI[s];
						n && n.Ba && (n.pa.handsToWeaponSkeleton(), n.pa && n.pa.update(t))
					}
					oI && oI.pa.update(t)
				}
				bk && (HN.update(t), GN.update(t), UN.update(t, bk.Oa));
				XT || (cI.updateActors(t), uI.update(t), XI(DN, t), XI(ON, t), XI(yN, t), XI(SN, t), XI(hI, t), XI(EN, t));
				LN && (fI -= .002 * t, iT.position.x = Math.sin(fI) * qN.height + qN.width / 2, iT.position.z = Math.cos(fI) * qN.height + qN.depth / 2, iT.setTarget(new Lc(qN.width / 2, qN.height / 4, qN.depth / 2)));
				VN && bN.update(t)
			}(), eI && (ZN.position.x = eI.Xa, ZN.position.y = eI.ba + 2, ZN.position.z = eI.va), JN.render(), fk.render()
		}))
	}

	function QI() {
		MP(), LN && KI(), KN = setInterval(cP, 1e3 / 30)
	}
	var ZI = document.createElement("DIV"),
		eP = [],
		tP = "",
		iP = !1,
		sP = e => {
			if (!iP && e ? (iP = !0, vueApp.musicWidget(!0)) : iP && !e && (iP = !1, vueApp.musicWidget(!1)), tP !== e) {
				tP = e;
				var t = decodeURI(e);
				console.log("Music metadata", t), data = JSON.parse(t), vueApp.music.serverTracks = data, "localhost" == location.host || "localshelldev.bluewizard.com" == location.host ? vueApp.music.serverTracks.albumArt = "https://shellshock.io/data/img/albumArt/" + data.id + data.albumExt + "?" + data.query : vueApp.music.serverTracks.albumArt = dynamicContentPrefix + "data/img/albumArt/" + data.id + data.albumExt + "?" + data.query, vueApp.songChanged = !0
			}
		};

	function nP() {
		GN.hide(), GN.hideDot(), BN.hide(), GN.setPowerful(!1), iT.mk = 1.25, FN = !1, document.getElementById("grenadeThrowContainer").style.visibility = "hidden"
	}

	function aP(e) {
		if (void 0 !== bk && bk.shellStreakMsg) {
			var t = bk.stats && void 0 !== bk.stats.streak ? bk.stats.streak : null;
			vueApp.shellIngameNotification({
				type: 2,
				msg: bk.shellStreakMsg,
				streak: t,
				streakType: e
			}), bk.shellStreakMsg = ""
		}
	}

	function rP() {
		const e = {
			MiniEgg: "shellStreak-shrink",
			DoubleEggs: "shellStreak-double-eggs",
			EggBreaker: "shellStreak-egg-breaker",
			Restock: "shellStreak-restock"
		};
		for (const [t, i] of Object.entries(e)) Uw[t] = document.getElementById(i), Uw[t].style.display = "none"
	}

	function oP(e, t) {
		const i = t ? "grid" : "none";
		if (new Set([ph.EggBreaker, ph.DoubleEggs, ph.MiniEgg, ph.Restock]).has(e)) {
			const t = getKeyByValue(ph, e);
			[Uw[t]].forEach((t => {
				t && (t.style.display = i, e === ph.Restock && setTimeout((() => {
					t.style.display = "none"
				}), 2e3))
			}))
		}
	}

	function lP() {
		for (var e = 0; e < Mk; e++) {
			var t = iI[e];
			t && t.pa && t.pa.updateTeam()
		}
	}
	var hP = Math.PI / 2;

	function cP() {
		var e = performance.now();
		if ($N = e, !gI) {
			cT > 10 && (tw = Math.max(tw, lI));
			var t = 1e3 / 30;
			for (rN.update(); MN < e;) {
				if (MN += t, XT) bk.pa.AS(), bk.ES();
				else {
					for (var i = 0; i < Mk; i++) {
						var s = iI[i];
						s && (s.id === xk && (s.chatLines = Math.max(0, s.chatLines - 1 / 120), s.chatLines <= 2 && (fT.style.visibility = "visible"), s.Ba && (vueApp.player.challengeTimer.played = Math.floor(s.timers.played / 30))), s.Ba && (s.pa.AS(), s.ES()))
					}
					oI && oI.update()
				}
				bk && (bk.Wa && 0 == bk.Wa.ammo.Ca && (bk.stateIdx % 20 == 0 ? document.getElementById("ammo").style.color = "#f00" : bk.stateIdx % 20 == 10 && (document.getElementById("ammo").style.color = "#fff")), 1 == FN && (tI = Math.min(tI + .03, 1)) > 0 && (document.getElementById("grenadeThrowContainer").style.visibility = "visible", document.getElementById("grenadeThrow").style.height = 100 * tI + "%")), XT || cI.updateLogic(), dk.update()
			}
			var n = Hc.Invert(iT.getViewMatrix());
			_I.copyFrom(Lc.TransformNormal(new Lc(0, 0, -1), n)), _I.normalize(), BAWK.update(), fk.update()
		}
	}
	var uP, mP = performance.now();

	function dP(e, t, i, s, n) {
		(i *= dR.value.damage, t.xa.lastDamageGivenType = t.dmgTypeId, e.lastDamageTakenType = t.dmgTypeId, !e.Ba || e.shield > 0) || Math.max(0, Math.floor(e.fS - i)) > 0 && zI(e, Math.clamp(i, 0, 100))
	}

	function fP() {
		const {
			activeShellStreaks: e,
			vS: t,
			fS: i
		} = eI, s = document.getElementById("healthContainer"), n = document.getElementById("hardBoiled-bar"), a = document.getElementById("hardBoiled-stroke"), r = document.getElementById("healthBar"), o = document.getElementById("healthHp");
		if (e & ph.HardBoiled && t > 0) {
			s.classList.add("hard-boiled"), n.style.display = "block", a.style.display = "block";
			const e = 2.3 - t / 43.478;
			n.setAttribute("stroke-dashoffset", 6.2832 * e + "em")
		} else s.classList.remove("hard-boiled"), n.style.display = "none", a.style.display = "none";
		const l = i > 100 ? i - 100 : 0,
			h = 2.3 - Math.min(i, 100) / 43.478;
		if (r.setAttribute("stroke-dashoffset", 6.2832 * h + "em"), l > 0) {
			const e = 1 - l / 100,
				t = 23 + 232 * e,
				i = 146 + 109 * e,
				s = 0 + 255 * e;
			r.style.stroke = `rgb(${Math.round(t)}, ${Math.round(i)}, ${Math.round(s)})`
		} else r.style.stroke = "rgb(255, 255, 255)";
		o.innerText = Math.floor(i)
	}

	function pP(e) {
		e.sa == xk && (ST = e.sa);
		var t = new FR(e, JN);
		if (t.id == xk) eI = t, (bk = t).ws = mk, AP();
		else {
			let t = IN.findIndex((t => t.ik === e.Ia));
			t >= 0 && IN.splice(t, 1), IN.push({
				id: e.sa,
				ik: e.Ia,
				name: e.Ka,
				muted: e.eS,
				isGameOwner: e.XS
			}), IN.length > 50 && IN.shift()
		}
		t.Ba || t.pa.removeFromPlay(), iI[e.sa] = t, EP()
	}

	function _P(e) {
		var t = iI[e];
		e != xk ? t && (t.pa.remove(), ST === e && bN.unlock(), delete iI[e], EP()) : console.log("Tried to remove ME")
	}

	function gP(e) {
		if (e) {
			try {
				const t = JSON.parse(e);
				if (t.length > 0 && hasValue(t[0])) return t.find((e => e.active))
			} catch (e) {}
			return !1
		}
		return !1
	}

	function vP(e) {
		if (e.hideBadge) return !1;
		let t = null;
		e.social && (t = JSON.parse(e.social));
		const i = t && Array.isArray(t) && t.some((e => 1 == e.active));
		return e.upgradeProductId && e.upgradeProductId > 0 || i
	}

	function yP(e) {
		for (let t = 0; t < Mk; t++)
			if (iI[t] && iI[t].ik === e) return iI[t];
		return IN.find((t => t.ik === e))
	}

	function SP(e, t, i) {
		let s = yP(e);
		if (s) return function() {
			var n = {
				ik: e,
				isGameOwner: s.isGameOwner,
				muted: s.muted,
				playerName: s.name,
				muteFunc: function() {
					! function(e) {
						for (let i = 0; i < Mk; i++) {
							if ((t = iI[i]) && t.id !== xk && t.ik === e) {
								t.muted ? (t.muted = !1, FT.safeNames || (t.name = t.Ha)) : (t.muted = !0, FT.safeNames || (t.name = t.safeName)), t.pa.setupNameSprite(), EP();
								break
							}
						}
						var t = IN.find((t => t.id !== xk && t.ik === e));
						t && (t.muted = !t.muted)
					}(e)
				},
				bootFunc: function() {
					! function(e) {
						var t = Rh.getBuffer();
						t.BkKlQQwL(sh.F), t.AABkKlQQwL(e), t.send(mk)
					}(e)
				},
				banFunc: function(t, i) {
					! function(e, t, i) {
						var s = Rh.getBuffer();
						s.BkKlQQwL(sh.v), s.AABkKlQQwL(e), s.AABkKlQQwL(t), s.BkKlQQwL(i), s.send(mk)
					}(e, t, i)
				},
				infoFunc: function() {
					! function(e) {
						let t = yP(e);
						if (!t) return;
						let i = new BroadcastChannel("ShellShockersAdmin");
						i.postMessage({
							cmd: "getPlayer",
							id: t.dbId,
							ip: t.ip
						}), i.close()
					}(e)
				},
				reportFunc: function(t) {
					! function(e, t) {
						var i = Rh.getBuffer();
						i.BkKlQQwL(sh.G), i.AABkKlQQwL(e), i.BkKlQQwL(t), i.send(mk), vueApp.showGenericPopup("report_confirm_title", "report_confirm_message", "ok")
					}(e, t)
				},
				social: t,
				vipMember: i
			};
			vueApp.showPlayerActionsPopup(n)
		}
	}

	function EP() {
		vI[0] = 0, vI[1] = 0, vI[2] = 0;
		for (var e = [], t = 0; t < Mk; t++) iI[t] && (e.push(t), vI[iI[t].team]++);
		fk.sortPlayerList(e);
		var i = document.getElementById("playerList").children;
		for (t = 0; t < e.length; t++) {
			var s = iI[e[t]],
				n = i[t],
				a = n.children[0],
				r = a.children[0],
				o = a.children[1],
				l = n.children[1];
			r.classList.add("playerSlot--name"), o.classList.add("playerSlot--score"), l.classList.add("playerSlot--icons"), n.style.display = "block", n.style.opacity = 1, r.innerText = s.name;
			const h = gP(s.social);
			if (s.id != xk) {
				let e = !s.hideBadge && h;
				const t = s.upgradeProductId && s.upgradeProductId > 0 && !s.hideBadge;
				n.onclick = SP(s.ik, e, t), n.style.pointerEvents = "all", n.style.cursor = "pointer", s.Ba || (n.style.opacity = .3)
			}
			o.innerText = s.aS, a.classList.add("playerSlot--name-score");
			let c = "playerSlot--name-score",
				u = "playerSlot-player-is-me",
				m = "playerSlot-player-is-them",
				d = "";
			VN && WN === eF.firstPerson && s.id === bN.playerIdx && (d = "playerSlot-spectating"), s.id == xk ? a.className = `${c} ${u} ${Xw.meClass[s.team]}` : a.className = `${d} ${c} ${m} ${Xw.aa[s.team]}`, l.innerText = "";
			const f = document.createElement("i"),
				p = document.createElement("i"),
				_ = document.createElement("i");
			f.className = "fas fa-egg hidden text_gold vip-egg", h && (f.className = `fab ${SOCIALMEDIA[h.id]} hidden`), p.className = "fas fa-ban hidden";
			vP(s) && f.classList.remove("hidden"), s.muted && p.classList.remove("hidden"), _.className = "fas fa-exclamation-triangle red hidden", WT === s.ik && _.classList.remove("hidden"), l.appendChild(f), l.appendChild(p), l.appendChild(_)
		}
		for (; t < Mk;) i[t].style.display = "none", t++
	}

	function AP() {
		if (bk) {
			var e = document.getElementById("weaponName");
			e.innerHTML = bk.Wa.constructor.weaponName, (e = document.getElementById("ammo")).style.color = "#fff";
			var t = bk.Wa.ammo,
				i = Math.max(Math.min(t.Ca, t.Yk), 0),
				s = Math.max(Math.min(t.store, t.Ea), 0);
			e.innerHTML = i + "/" + s;
			for (var n = 1; n <= 3; n++) bk.OS >= n ? document.getElementById("grenade" + n).src = "img/ico_grenade.webp?v=1" : document.getElementById("grenade" + n).src = "img/ico_grenadeEmpty.webp?v=1"
		}
	}
	var bP, xP = null;

	function MP() {
		xP = null, document.addEventListener("keydown", GP), document.addEventListener("keyup", HP)
	}

	function CP() {
		document.removeEventListener("keydown", GP), document.removeEventListener("keyup", HP)
	}

	function TP(e, t) {
		if (VN)(i = UT[e].spectate[t]) || (i = UT[e].game[t]), WN === eF.firstPerson && ("ARROWUP" === t && (i = "up"), "ARROWDOWN" === t && (i = "down"));
		else var i = UT[e].game[t];
		return i
	}

	function wP(e, t) {
		(VN || document.pointerLockElement && bk.Ba) && RP(TP(e, t))
	}

	function RP(e) {
		switch (e) {
			case "up":
			case "down":
			case "left":
			case "right":
			case "jump":
			case "ascend":
			case "descend":
				zN |= t = IR[e];
				break;
			case "inspect":
				document.pointerLockElement && bk && bk.pa.inspect();
				break;
			case "melee":
				document.pointerLockElement && bk && rN.add(rN.melee), zN |= t = IR[e];
				break;
			case "fire":
				document.pointerLockElement && bk && rN.add(rN.fire), zN |= t = IR[e];
				break;
			case "grenade":
				document.pointerLockElement && bk && !FN && bk.canSwapOrReload() && bk.OS > 0 && (FN = !0, tI = -.15);
				break;
			case "scope":
				var t = IR[e];
				FT.holdToAim ? zN |= t : bk.scope ? zN ^= zN & t : zN |= t;
				break;
			case "reload":
				rN.add(rN.reload);
				break;
			case "swap_weapon":
				rN.add(rN.swap);
				break;
			case "toggle_freecam":
				VN && (WN === eF.freeCamera ? (WN = eF.firstPerson, bN.firstPerson()) : (WN = eF.freeCamera, bN.freeCamera()));
				break;
			case "despawn":
				crazyGamesActive && EI();
				break;
			case "slow":
				VN && WN === eF.freeCamera && bN.startSlow()
		}
	}

	function NP(e, t) {
		(VN || document.pointerLockElement && bk.Ba) && IP(TP(e, t))
	}

	function IP(e) {
		switch (e) {
			case "fire":
				zN ^= zN & IR[e];
				break;
			case "scope":
				if (FT.holdToAim) bk.scopeOut(), zN ^= zN & IR[e];
				break;
			case "grenade":
				document.pointerLockElement && FN && bk && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden", FN = !1, bk.throwGrenade(tI));
				break;
			case "slow":
				VN && WN === eF.freeCamera && bN.endSlow();
				break;
			case "up":
				if (VN && WN === eF.firstPerson) {
					bN.spectateNextPlayer(-1), zN = 0;
					break
				}
			case "down":
				if (VN && WN === eF.firstPerson) {
					bN.spectateNextPlayer(1), zN = 0;
					break
				}
			case "left":
			case "right":
			case "jump":
			case "melee":
			case "ascend":
			case "descend":
				zN ^= zN & IR[e]
		}
	}

	function PP(e, t) {
		var i = [` ${nD("ingame_kill_text_scrambled")} `, ` ${nD("ingame_kill_text_beat")} `, ` ${nD("ingame_kill_text_poached")} `, ` ${nD("ingame_kill_text_whipped")} `, ` ${nD("ingame_kill_text_fried")} `, ` ${nD("ingame_kill_text_cracked")} `],
			s = '<span style="color: ' + Xw.text[e.team] + '">' + e.name + "</span>" + i[Math.randomInt(0, i.length)] + '<span style="color: ' + Xw.text[t.team] + '">' + t.name + "</span>";
		(_T.innerHTML.match(/<br>/g) || []).length > 4 && (_T.innerHTML = _T.innerHTML.substr(_T.innerHTML.search("<br>") + 4)), _T.innerHTML += s + "<br>"
	}

	function kP() {
		return !!(gT || kh.playerAccount.isEmailVerified || new Date(kh.playerAccount.dateCreated).getTime() < 17145468e5)
	}

	function DP() {
		canvas.focus(), fT.style.display = "block", kP() ? (fT.value = nD("ingame_press_enter_to_chat"), fT.style.pointerEvents = "auto") : (fT.value = nD("ingame_sign_in_to_chat"), fT.style.pointerEvents = "all", fT.style.cursor = "pointer", fT.onclick = () => {
			vueApp.onShowloginPopupWarning()
		}), fT.style.background = "transparent", fT.blur(), AN = !1
	}

	function OP(e, t, i, s, n) {
		const a = pT.querySelectorAll(".chat-item");
		if (t & ah && !e) {
			for (let e of a) e.classList.contains("chat-pinned-item") && e.remove();
			return
		}
		const r = document.createElement("div"),
			o = document.createElement("span"),
			l = document.createElement("div"),
			h = document.createElement("span"),
			c = document.createElement("i");
		let u = !1,
			m = !1,
			d = !1;
		if (r.classList.add("chat-item"), l.style.display = "inline-block", i > 253) 255 === i ? (h.textContent = "SERVER: ", l.style.color = "#ff0") : 254 === i && (h.textContent = "MOD: ", l.style.color = "#0f0"), h.classList.add("chat-player-name", "ss_marginright_xs"), l.appendChild(h);
		else {
			let s = iI[i];
			if (ZI.innerHTML = e, e = ID(ZI.textContent.trim()), i === xk || null !== i && s && !s.muted && e.length > 0 && !JR(e) && e.indexOf("<") < 0) u = !!(s.upgradeProductId && s.upgradeProductId > 0), m = gP(s.social), m && !s.hideBadge ? (c.classList.add("fab", SOCIALMEDIA[m.id]), c.classList.add("ss_marginright_xs")) : u && !s.hideBadge && (c.classList.add("fas", "fa-egg", "hidden", "text_gold", "vip-egg"), c.classList.add("ss_marginright_xs")), d = s.ik, h.classList.add("chat-player-name", "ss_marginright_xs"), h.textContent = s.name + ": ", t & rh && (o.style.color = Xw.text[s.team], o.classList.add("chat-team")), l.style.color = Xw.text[s.team], l.appendChild(c), l.appendChild(h);
			else if (null !== i) return
		}
		a.length > 4 && (a[0].classList.contains("chat-pinned-item") ? t & ah ? a[0].remove() : a[1].remove() : a[0].remove()), n && (e = e.format(n)), o.innerHTML = e, t & ah && (o.classList.add("chat-pinned"), r.classList.add("chat-pinned-item")), r.appendChild(l), r.appendChild(o), r.classList.add("clickme"), r.onclick = () => {
			h.classList.add("clickme"), !d && s ? s() : d != bk.ik && (h.classList.add("clickme"), SP(d, m, u)())
		}, pT.appendChild(r), TN && (TN.scrollTop = TN.scrollHeight)
	}

	function FP(e) {
		var t = Rh.getBuffer();
		t.BkKlQQwL(sh.qk), t.AABkKlQQwL(e), t.send(mk)
	}

	function LP() {
		bk.chatLines <= 2 && kP() && (CP(), fT.style.background = "rgba(0, 0, 0, 0.5)", fT.value = "", fT.focus(), xP = null, AN = !0)
	}

	function BP() {
		DP(), MP()
	}

	function GP(e) {
		var t = (e = e || window.event).key;
		if (t != xP)
			if (xP = t, FN || 0 != zN || "Enter" != t || !FT.enableChat) {
				AN || "Tab" == t && (i = "ESCAPE", e.preventDefault(), EI("down"));
				var i = ("" + t).toLocaleUpperCase();
				if (" " == i && (i = "SPACE", e.preventDefault()), HO) {
					if ("`" == i) return void
					function() {
						if (bP) {
							for (var e = 0; e < Mk; e++) {
								var t = iI[e];
								if (t) {
									var i = {
										name: t.name,
										hp: t.fS,
										Ba: t.Ba,
										posX: t.Xa,
										posY: t.ba,
										posZ: t.va,
										actorX: t.pa.mesh.position.x,
										actorY: t.pa.mesh.position.y,
										actorZ: t.pa.mesh.position.z,
										transformEnabled: t.pa.mesh.isEnabled(),
										transformVisible: t.pa.mesh.isVisible,
										transformFrozen: t.pa.mesh.isWorldMatrixFrozen,
										shellEnabled: t.pa.zS.isEnabled(),
										shellVisible: t.pa.zS.isVisible,
										shellFrozen: t.pa.zS.isWorldMatrixFrozen,
										weaponEnabled: t.Wa.pa.KS.isEnabled(),
										weaponVisible: t.Wa.pa.KS.isVisible
									};
									bP.document.write(JSON.stringify(i) + "\n")
								}
							}
							bP.document.write("<hr>")
						} else(bP = window.open("", "", "name=Debug")).document.write("<pre>")
					}();
					if ("\\" == i) {
						XT = !0;
						for (var s = 0; s < JN.particleSystems.length; s++) JN.particlesPaused = !0;
						for (s = 0; s < Mk; s++) iI[s] && iI[s].pa && (iI[s].pa.mesh.ra(!0), iI[s].pa.showNameSprite(), iI[s].pa.positionNameSprite());
						mk.close()
					}
				}
				wP("keyboard", i)
			} else LP()
	}

	function HP(e) {
		var t = (e = e || window.event).key;
		t == xP && (xP = null);
		var i = ("" + t).toLocaleUpperCase();
		" " == i && (i = "SPACE", e.preventDefault()), NP("keyboard", i)
	}

	function UP() {
		var e = [
			[new Lc(-1, 0, 0), new Lc(1, 0, 0)],
			[new Lc(0, -1, 0), new Lc(0, 1, 0)]
		];
		this.dS = cS.CreateLineSystem("crosshairs", {
			lines: e
		}, JN), this.dS.setEnabled(!1), this.dS.position.z = 2, this.dS.applyFog = !1, this.dS.layerMask = 536870912, this.dS.color = Tc.Black()
	}

	function VP() {
		this.mesh = new Vf("hitIndicator", JN), this.mesh.updatable = !0, this.mesh.hasVertexAlpha = !0, this.positions = [0, 0, 0, 0, .5, 0, .5, .5, 0, .5, 0, 0, .5, -.5, 0, 0, -.5, 0, -.5, -.5, 0, -.5, 0, 0, -.5, .5, 0];
		this.colors = new Array(48).fill(0);
		for (var e = 0; e < 48; e += 4) this.colors[e] = 1, this.colors[e + 1] = .9, this.colors[e + 2] = 0, this.colors[e + 3] = -.5;
		var t = new Mu;
		t.positions = this.positions, t.indices = [0, 1, 8, 0, 2, 1, 0, 2, 1, 0, 3, 2, 0, 3, 2, 0, 4, 3, 0, 4, 3, 0, 5, 4, 0, 5, 4, 0, 6, 5, 0, 6, 5, 0, 7, 6, 0, 7, 6, 0, 8, 7, 0, 8, 7, 0, 1, 8], t.colors = this.colors, t.applyToMesh(this.mesh, !0), this.mesh.layerMask = 536870912, this.mesh.material = JN.getMaterialByName("ui"), this.resize()
	}

	function WP() {
		this.dS = [], this.shotBrackets = [];
		for (var e = 0; e < 4; e++) this.dS.push(document.getElementById("crosshair" + e)), this.shotBrackets.push(document.getElementById("shotBracket" + e));
		this.crosshairReticle = document.getElementById("crosshairContainer"), this.readyBrackets = document.getElementById("readyBrackets"), this.shotReticle = document.getElementById("shotReticleContainer"), this.redDotReticle = document.getElementById("redDotReticle"), this.reticleDot = document.getElementById("reticleDot")
	}

	function zP() {
		var e = ("" == dynamicContentPrefix ? parsedUrl.root : dynamicContentPrefix) + "#" + rT;
		const t = crazySdk.inviteLink({
			crazyShare: rT
		});
		return crazyGamesActive ? t : e
	}

	function XP() {
		vueApp.showShareLinkPopup(zP(), rT), cw = !1
	}

	function YP(e, t) {
		if (XT) return !0;
		for (var i = t || e.getBoundingInfo().boundingBox.center.z, s = e.position.x - iT.globalPosition.x, n = e.position.y + i - iT.globalPosition.y, a = e.position.z - iT.globalPosition.z, r = Math.length3(s, n, a), o = Math.normalize3({
				x: s,
				y: n,
				z: a
			}, .9), l = iT.globalPosition.x, h = iT.globalPosition.y, c = iT.globalPosition.z, u = 0, m = 0; m < r - .9 && (l += o.x, h += o.y, c += o.z, !(l < 0 || l >= qN.width || c < 0 || c >= qN.depth || h < 0 || h >= qN.height)); m += .9) {
			var d = qN.data[Math.floor(l)][Math.floor(h)][Math.floor(c)];
			if (d.idx) {
				var f = kR[d.idx];
				if ("full" == f.colliderType && !f.softness && "barrier" !== f.shortName && 2 == ++u) return !1
			}
		}
		return !0
	}

	function jP() {
		kh.engine.stopRenderLoop(), GT.startRendering()
	}

	function KP() {
		for (var e = 1; e <= 2; e++) {
			document.getElementById("teamScoreNum" + e).innerText = dk.teamScore[e];
			var t = document.getElementById("teamScore" + e);
			oI && (oI.controlledByTeam == e ? t.classList.replace("inactive", "active") : oI.lastControlTeam != e && t.classList.replace("active", "inactive"))
		}
	}
	UP.prototype.show = function() {
		var e = kh.engine.getRenderHeight();
		this.dS.scaling.x = e / 2, this.dS.scaling.y = e / 2, this.dS.setEnabled(!0), document.getElementById("scopeBorder").style.display = "flex", iT.viewport.width = e / kh.engine.getRenderWidth(), iT.viewport.x = .5 - .5 * iT.viewport.width
	}, UP.prototype.hide = function() {
		this.dS.setEnabled(!1), document.getElementById("scopeBorder").style.display = "none", iT.viewport.width = 1, iT.viewport.x = 0
	}, VP.prototype.resize = function() {
		this.mesh.scaling.x = kh.engine.getRenderWidth(), this.mesh.scaling.y = kh.engine.getRenderHeight()
	}, VP.prototype.update = function(e) {
		for (var t = 7; t < 48; t += 4) this.colors[t] -= (this.colors[t] + .5) / 10 * e;
		var i = Math.pow(.9, e);
		bk && bk.Ba && (iT.position.x *= i, iT.position.z *= i), this.mesh.updateVerticesData(eu.ColorKind, this.colors, !0)
	}, VP.prototype.hit = function(e, t) {
		var i = -Math.atan2(-e, t),
			s = Math.radRange(i - bk.Oa + .393);
		s = Math.floor(s / Math.PI2 * 8);
		var n = new Fc(-this.positions[3 * s + 3], -this.positions[3 * s + 4]).normalize();
		iT.position.x = .03 * n.x, iT.position.z = .03 * n.y, this.colors[4 * s + 7] = 2
	}, WP.prototype.show = function() {
		if (document.getElementById("reticleContainer").className = "", bk.Wa.constructor.readySpread) {
			this.readyBrackets.className = "notReady";
			var e = "62.5vw";
			this.readyBrackets.style.width = e, this.readyBrackets.style.height = e
		} else this.readyBrackets.className = "hideme";
		this.redDotReticle.className = "hideme", this.crosshairReticle.className = bk.Wa.constructor === yR ? "hideme" : "", this.shotReticle.className = bk.Wa.constructor === yR ? "" : "hideme"
	}, WP.prototype.hide = function() {
		document.getElementById("reticleContainer").className = "hideme"
	}, WP.prototype.hideDot = function() {
		this.reticleDot.className = "hideme"
	}, WP.prototype.showDot = function() {
		FT.centerDot && (this.reticleDot.className = "")
	}, WP.prototype.fireDenied = function() {
		this.readyBrackets.className = "";
		var e = this;
		setTimeout((function() {
			e.readyBrackets.className = "notReady"
		}), 10)
	}, WP.prototype.setPowerful = function(e) {
		for (var t = 0; t < 4; t++) {
			var i = this.dS[t],
				s = this.shotBrackets[t];
			e ? (i.classList.remove("normal"), i.classList.add("powerful"), s.classList.remove("normal"), s.classList.add("powerful")) : (i.classList.add("normal"), i.classList.remove("powerful"), s.classList.add("normal"), s.classList.remove("powerful"))
		}
	}, WP.prototype.update = function(e) {
		if (iT.forwardRay = iT.getForwardRay(), iT.forwardRay.origin = bk.pa.eye.getAbsolutePosition(), bk.Wa) {
			var t = bk.Wa.accuracy;
			if (bk.Wa.constructor === yR) {
				var i = t * (200 / iT.mk);
				this.shotReticle.style.width = i + "vh", this.shotReticle.style.height = i + "vh"
			} else {
				i = t * (50 / iT.mk);
				for (var s = 0; s < 4; s++) {
					this.dS[s].style.transform = "rotate(" + 90 * s + "deg) translateY(calc(" + i + "vh + 0.12em))"
				}
			}
			iT.forwardRay.direction.scaleInPlace(1e3);
			var n = uR.qa(iT.forwardRay.origin, iT.forwardRay.direction, uR.projectileCollidesWithCell);
			if (n) {
				var a = Lc.Distance(iT.forwardRay.origin, n.pick.pickedPoint);
				iT.forwardRay.range = a, bk.Wa.constructor.minRange && (a - .01 >= bk.Wa.constructor.minRange ? this.readyBrackets.className = "ready" : this.readyBrackets.className = "notReady")
			} else bk.Wa.constructor.minRange && (this.readyBrackets.className = "ready"), iT.forwardRay.range = 1e6;
			bk.Wa.constructor.burst && (iT.mk - bk.Wa.pa.scopeFov < .006 ? this.redDotReticle.className = "" : this.redDotReticle.className = "hideme")
		}
	}, WP.prototype.resize = function() {};
	var $P = null;
	var JP = [{
		type: "mousedown",
		listener: NI,
		options: {
			once: !1
		}
	}, {
		type: "mouseup",
		listener: II,
		options: {
			once: !1
		}
	}, {
		type: "pointermove",
		listener: function(e) {
			0
		},
		options: {
			once: !1
		}
	}, {
		type: "wheel",
		listener: function(e) {
			e.wheelDelta > 0 ? (wP("keyboard", "WHEEL UP"), NP("keyboard", "WHEEL UP")) : (wP("keyboard", "WHEEL DOWN"), NP("keyboard", "WHEEL DOWN"))
		},
		options: {
			once: !1
		}
	}];

	function qP() {
		console.log("Removing canvas event listeners"), canvas.style.pointerEvents = "none",
			function() {
				if ($P) {
					const e = kh.engine.scenes[0];
					e && e.onPointerObservable.remove($P), $P = null
				}
			}(), JP.forEach((e => canvas.removeEventListener(e.type, e.listener))), removeEventListener("gamepadbuttondown", QP)
	}

	function QP(e) {
		8 == e.detail && document.exitPointerLock()
	}

	function ZP() {
		const e = kh.playerAccount.accountAge < 864e5;
		Bw && e && (ga("send", "event", "play game", "join", "join_noob_lobby"), Bw = !1)
	}
	var ek = class {
			getTeamWithHighestScore() {
				let e = this.lastLeadingTeam;
				return this.teamScore[1] > this.teamScore[2] ? e = 1 : this.teamScore[2] > this.teamScore[1] && (e = 2), this.lastLeadingTeam = e, e
			}
			scoreKill(e, t) {}
			reset() {
				bk && (bk.canTakeTeamBonus = !0), dk.teamScore = [0, 0, 0];
				for (var e = 0; e < Mk; e++) {
					var t = iI[e];
					t && (t.aS = 0, t.stats.streak = 0)
				}
				EP()
			}
			update() {}
			getTeamWithMostKills() {
				let e = this.lastLeadingTeam,
					t = [0, 0, 0];
				for (let e = 0; e < Mk; e++) {
					let i = iI[e];
					i && (t[i.team] += i.aS)
				}
				return t[1] > t[2] ? e = 1 : t[2] > t[1] && (e = 2), this.lastLeadingTeam = e, e
			}
			playSound(e) {
				this.suppressSound || BAWK.play(e)
			}
			constructor() {
				this.teamScore = [0, 0, 0], this.suppressSound = !0, this.lastLeadingTeam = 1, this.zoneMesh = null
			}
			static otherTeam(e) {
				return 1 == e.team ? 2 : 1
			}
			_unPackState(e) {
				this.unPackState(e), this.suppressSound = !1
			}
		},
		tk = class {
			sortPlayerList() {}
			constructor() {}
			render() {}
			playSound(e) {
				dk.suppressSound || BAWK.play(e)
			}
			sortPlayerListByKills(e) {
				e.sort(((e, t) => iI[t].aS - iI[e].aS))
			}
			timeToPlayVideoAd() {
				return null
			}
			sortPlayerListByLeadingTeam(e, t) {
				e.sort(((e, i) => iI[i].team == t ? 1 : iI[e].team == t ? -1 : 0))
			}
			sortPlayerListByTeamKills(e) {
				this.sortPlayerListByKills(e);
				let t = dk.getTeamWithMostKills();
				this.sortPlayerListByLeadingTeam(e, t)
			}
			sortPlayerListByTeamScore(e) {
				this.sortPlayerListByKills(e);
				let t = dk.getTeamWithHighestScore();
				this.sortPlayerListByLeadingTeam(e, t)
			}
			update() {}
		},
		ik = class e extends ek {
			constructor() {
				super(), this.init()
			}
			init() {
				this.activeZone = null, this.teams = null, this.progress = null, this.numCapturing = null, this.teamsBalanced = !1, this.state = e.state.capturing
			}
			reset() {
				super.reset(), this.init()
			}
			update() {
				if (this.activeZone)
					if (this.state == e.state.takeover) this.progress > 0 && (this.progress -= e.takeOverSpeed);
					else if (this.state == e.state.capturing && (1 == this.teams || 2 == this.teams)) {
					let t = e.captureSpeeds[this.numCapturing - 1];
					this.progress += t
				}
			}
			unPackState(t) {
				let i = this.activeZone;
				switch (this.state = t.unPackInt8U(), this.activeZone = t.unPackInt8U(), this.teams = t.unPackInt8U(), this.progress = t.unPackInt16U(), this.numCapturing = t.unPackInt8U(), this.teamScore[1] = t.unPackInt8U(), this.teamScore[2] = t.unPackInt8U(), console.log("ACTIVE ZONE IS NOW", this.activeZone), this.state) {
					case e.state.win:
						cI.removeAll(), gI = !0, fk.win(), this.playSound("kotc_roundend");
						break;
					case e.state.start:
						if (gI && (gI = !1, this.reset(), vI[1] + vI[2] > 2)) {
							var s = document.getElementById("gameMessage");
							s.innerHTML = nD("ingame_coop_shuffle"), s.className = "show", setTimeout((() => {
								s.className = "hide"
							}), 3e3)
						}
						break;
					case e.state.aS:
						this.playSound("kotc_pointscore");
						break;
					case e.state.contested:
						this.playSound("kotc_contested")
				}
				this.activeZone && this.activeZone != i && this.playSound("kotc_zonespawn"), fk.setCaptureState(this.teams)
			}
		},
		sk = class e extends tk {
			render() {
				let e = this.captureIconContainer;
				if (!dk.activeZone) return void e.classList.remove("on");
				e.classList.add("on");
				let t = iT.getViewMatrix().multiply(iT.getProjectionMatrix()),
					i = PN[dk.activeZone - 1].capIconPosition,
					s = kh.engine.getHardwareScalingLevel(),
					n = kh.engine.getRenderWidth() * s,
					a = kh.engine.getRenderHeight() * s,
					r = Lc.TransformCoordinates(i, t);
				r.y *= -1;
				let o, l, h = iT.getDirection(Lc.Backward()),
					c = iT.globalPosition,
					u = i.x - c.x,
					m = i.y - c.y,
					d = i.z - c.z,
					f = Math.length3(u, m, d),
					p = (h.x * u + h.y * m + h.z * d) / f,
					_ = r.x,
					g = r.y;
				if (p < 0) {
					_ *= -1, g *= -1, o = Math.min(1, 1 / Math.abs(_)), l = Math.min(1, 1 / Math.abs(g)), _ *= l, g *= o, Math.abs(_) > Math.abs(g) ? _ = Math.sign(_) : g = Math.sign(g)
				} else o = Math.min(1, 1 / Math.abs(_)), l = Math.min(1, 1 / Math.abs(g)), _ *= l, g *= o;
				_ = _ * (n / 2) + n / 2, g = g * (a / 2) + a / 2, _ = Math.max(Math.min(_, .9 * n), .1 * n), g = Math.max(Math.min(g, .9 * a), .1 * a), e.style.transform = "translate(" + _ + "px," + g + "px)"
			}
			sortPlayerList(e) {
				this.sortPlayerListByTeamScore(e)
			}
			setZoneColor(e, t) {
				e && e.material.colorNode.value.set(t.r, t.g, t.b)
			}
			constructor() {
				super(), this.captureBarEl = document.getElementById("captureBar"), this.captureBarTextEl = document.getElementById("captureBarText"), this.captureIconContainer = document.getElementById("captureIconContainer"), this.captureIcon = document.getElementById("captureIcon"), this.captureRingContainer = document.getElementById("captureRingContainer"), this.captureRing = document.getElementById("captureRing"), this.captureIconCaption = document.getElementById("captureIconCaption"), this.previousCapturingTeam = 0, this.teamScoreEl = [null, document.getElementById("captureScoreBlue"), document.getElementById("captureScoreRed")]
			}
			setBarProgress(e) {
				this.captureBarEl.style.transform = "scaleX(" + e + ")";
				let t = 100 * (1 - e);
				this.captureRingContainer.style.transform = "translateY(" + t + "%)", this.captureRing.style.transform = "translateY(" + -t + "%)"
			}
			timeToPlayVideoAd() {
				return 4 !== dk.teamScore[1] && 4 !== dk.teamScore[2] && null
			}
			setCaptureState(t) {
				this.teamScoreEl[1].innerText = dk.teamScore[1] + " / " + ik.goalScore, this.teamScoreEl[2].innerText = dk.teamScore[2] + " / " + ik.goalScore;
				switch (dk.activeZone && (this.zoneMesh = PN[dk.activeZone - 1]), dk.state) {
					case ik.state.win:
						this.captureBarTextEl.innerText = nD("ingame_coop_nextround"), this.captureBarEl.className = "empty", this.captureRing.className = "empty", this.captureIcon.setAttribute("class", "empty"), this.previousCapturingTeam = 0;
						break;
					case ik.state.aS:
					case ik.state.start:
						this.captureBarTextEl.innerHTML = "&nbsp;", this.captureBarEl.className = "empty", this.captureRing.className = "empty", this.captureIcon.setAttribute("class", "empty"), this.previousCapturingTeam = 0;
						break;
					case ik.state.unclaimed:
						this.captureBarTextEl.innerText = nD("ingame_coop_find"), this.captureBarEl.className = "empty", this.captureRing.className = "empty", this.captureIcon.setAttribute("class", "empty"), this.setZoneColor(this.zoneMesh, e.zoneColor.unclaimed);
						break;
					case ik.state.capturing:
						var i = ["", "blue", "red"];
						this.captureBarTextEl.innerText = nD(rk[t].name).toUpperCase() + " " + nD("ingame_coop_capturing") + " (" + dk.numCapturing + "X)", this.captureBarEl.className = i[t], this.captureRing.className = i[t], this.captureIcon.setAttribute("class", i[t]), t > 0 && t != this.previousCapturingTeam && (this.previousCapturingTeam = t, bk.team == t ? this.playSound("kotc_capturing_player") : this.playSound("kotc_capturing_opponents")), this.setZoneColor(this.zoneMesh, rk[t].lightZone);
						break;
					case ik.state.abandoned:
						i = ["", "blueAbandoned", "redAbandoned"];
						this.captureBarTextEl.innerText = nD(rk[t].name).toUpperCase() + " " + nD("ingame_coop_capturing"), this.captureBarEl.className = i[t], this.captureRing.className = i[t], this.captureIcon.setAttribute("class", i[t]), this.setZoneColor(this.zoneMesh, rk[t].darkZone);
						break;
					case ik.state.contested:
						this.captureBarTextEl.innerText = nD("ingame_coop_contested"), this.captureBarEl.className = "contested", this.captureRing.className = "contested", this.captureIcon.setAttribute("class", "contested");
						break;
					case ik.state.takeover:
						this.captureBarTextEl.innerText = nD("ingame_coop_takeover"), this.captureBarEl.className = "takeover", this.captureRing.className = "takeover", this.captureIcon.setAttribute("class", "takeover")
				}
				for (let e = 0; e < PN.length; e++) {
					PN[e].visibility = dk.activeZone == e + 1
				}
			}
			win() {
				this.setCaptureState(0);
				let e = document.getElementById("bigMessageContainer");
				e.style.display = "block";
				let t = dk.teamScore[1] > dk.teamScore[2] ? 1 : 2;
				document.documentElement.style.setProperty("--ss-big-message-border-color", rk[t].lightColor), document.getElementById("bigMessage").innerHTML = '<span class="bigMessageText" style="color: var(--ss-big-message-border-color)">' + nD(rk[t].name).toUpperCase() + '</span><span class="bigMessageText">&nbsp;' + nD("ingame_coop_win") + "</span>", t == bk.team && bk.canTakeTeamBonus ? document.getElementById("bigMessageCaption").innerHTML = nD("ingame_coop_bonus") + ' +250 <img src="img/ico_goldenEgg.webp" style="height: 2em; vertical-align: text-top" />' : document.getElementById("bigMessageCaption").innerHTML = nD("ingame_coop_nextroundbig"), setTimeout((() => {
					e.style.display = "none"
				}), 5e3)
			}
			update() {
				if (0 != dk.activeZone) {
					if (dk.state == ik.state.takeover) {
						let t = Math.max(dk.progress, 0);
						this.setBarProgress(1 - t / ik.takeOverTime);
						let i = .5 * Math.cos($N / 100 % (2 * Math.PI)) + .5;
						Tc.LerpToRef(rk[1 == dk.teams ? 2 : 1].lightZone, e.zoneColor.takeover, i, e.color), this.setZoneColor(this.zoneMesh, e.color)
					} else if (1 == dk.teams || 2 == dk.teams) {
						let e = Math.min(dk.progress, 1200);
						this.setBarProgress(e / 1200)
					}
					if (dk.state == ik.state.contested) {
						let t = .5 * Math.cos($N / 100 % (2 * Math.PI)) + .5;
						Tc.LerpToRef(rk[1].lightZone, rk[2].lightZone, t, e.color), this.setZoneColor(this.zoneMesh, e.color)
					}
					if (bk && dk.activeZone) {
						let e = PN[dk.activeZone - 1].capIconPosition,
							t = Math.length3(bk.Xa - e.x, bk.ba - e.y, bk.va - e.z),
							i = Math.max(0, Math.min(.5 * t - 1 + .5 * Math.abs(bk.ba - e.y + .4), .6));
						this.captureIconContainer.style.opacity = i, this.captureIconCaption.innerText = Math.floor(2 * t) + "M"
					}
				} else "&nbsp;" != this.captureBarTextEl.innerHTML || 0 != vI[1] && 0 != vI[2] || (this.captureBarTextEl.innerText = nD("ingame_coop_waiting"))
			}
		};

	function nk(e) {
		return getComputedStyle(document.documentElement).getPropertyValue(e)
	}

	function ak(e) {
		let t = nk(e);
		return t = t.match(/^\s*rgba?\((\d+),\s*(\d+),\s*(\d+)(,\s*\d+\.*\d+)?\)\s*$/), Tc.FromInts(t[1], t[2], t[3])
	}
	sk.zoneColor = {
		unclaimed: new Tc(.3, .3, .3),
		takeover: new Tc(.8, .8, .8)
	}, sk.color = new Tc;
	var rk = [null, {
			name: "team_blue",
			lightColor: nk("--ss-team-blue-light"),
			darkColor: nk("--ss-team-blue-dark"),
			lightZone: ak("--ss-team-blue-light"),
			darkZone: ak("--ss-team-blue-dark")
		}, {
			name: "team_red",
			lightColor: nk("--ss-team-red-light"),
			darkColor: nk("--ss-team-red-dark"),
			lightZone: ak("--ss-team-red-light"),
			darkZone: ak("--ss-team-red-dark")
		}],
		ok = [{
			logic: class extends ek {
				constructor() {
					super()
				}
			},
			ui: class extends tk {
				sortPlayerList(e) {
					this.sortPlayerListByKills(e)
				}
				constructor() {
					super()
				}
			}
		}, {
			logic: class extends ek {
				unPackState(e) {
					this.teamScore[1] = e.unPackInt16U(), this.teamScore[2] = e.unPackInt16U()
				}
				constructor() {
					super()
				}
				scoreKill(e) {
					this.teamScore[e]++
				}
			},
			ui: class extends tk {
				constructor() {
					super()
				}
				sortPlayerList(e) {
					this.sortPlayerListByTeamKills(e)
				}
			}
		}, {
			logic: class extends ek {
				scoreKill(e, t) {
					oI.pa || oI.HS != t.id || oI.drop();
					var i = ek.otherTeam(t);
					oI.controlledByTeam == i && (this.teamScore[i]++, KP())
				}
				constructor() {
					super()
				}
				unPackState(e) {
					this.teamScore[1] = e.unPackInt16U(), this.teamScore[2] = e.unPackInt16U();
					let t = {
							x: e.unPackFloat(),
							y: e.unPackFloat(),
							z: e.unPackFloat()
						},
						i = e.unPackInt8U(),
						s = e.unPackInt8U();
					if (oI) {
						if (oI.x = t.x, oI.y = t.y, oI.z = t.z, oI.HS != i) {
							var n = ["", '<h1 class="blueTeam">' + vueApp.loc.team_blue + "</h1>", '<h1 class="redTeam">' + vueApp.loc.team_red + "</h1>"];
							if (255 == i) bk.Ba && vueApp.ctsCapturedMsg({
								team: n[s],
								msg: "ingame_dropped_the_spatula"
							}), oI.drop(t);
							else {
								bk.Ba && vueApp.ctsCapturedMsg({
									team: s,
									msg: "ingame_captured_the_spatula"
								});
								let e = iI[i];
								e && e.Ba && oI.capture(iI[i])
							}
						}
					} else(oI = new $R(JN, t)).HS = i, oI.controlledByTeam = s, 255 != i && oI.pa.capture(iI[i]);
					KP()
				}
				reset() {
					super.reset(), this.resetSpatula()
				}
				resetSpatula() {
					oI.pa.dispose(), oI = null;
					var e = document.getElementById("spatulaPlayer");
					e.classList.remove("capture"), e.classList.add("drop")
				}
			},
			ui: class extends tk {
				sortPlayerList(e) {
					this.sortPlayerListByTeamScore(e)
				}
				constructor() {
					super()
				}
			}
		}, {
			logic: ik,
			ui: sk
		}];

	function lk(e) {
		return kh.playerAccount.isItemOwned(e)
	}

	function hk() {
		if (!GT) return;
		gw && (GT = new MO);
		let e = kh.playerAccount.getEquippedItems();
		e[Eh.Grenade] = null, e[Eh.Melee] = null, GT.posingItems = {
			[Eh.Primary]: null,
			[Eh.Secondary]: null,
			[Eh.Grenade]: null,
			[Eh.Melee]: null,
			[Eh.Hat]: null,
			[Eh.Stamp]: null
		}, GT.poseWithItems(e, kh.playerAccount.stampPositionX, kh.playerAccount.stampPositionY), GT.poseWithColor(kh.playerAccount.colorIdx)
	}
	async function ck() {
		return new Promise(((e, t) => {
			try {
				const t = {
					apiKey: "AIzaSyDP4SIjKaw6A4c-zvfYxICpbEjn1rRnN50",
					authDomain: "shellshockio-181719.firebaseapp.com",
					databaseURL: "https://shellshockio-181719.firebaseio.com",
					projectId: "shellshockio-181719",
					storageBucket: "shellshockio-181719.appspot.com",
					messagingSenderId: "68327206324"
				};
				firebase.apps.length ? firebase.app() : firebase.initializeApp(t), kh.playerAccount = new Bh;
				const i = localStore.getItem("localLoadOut");
				if (i) {
					const e = JSON.parse(i);
					kh.playerAccount.applyLocalLoadout(e.items)
				} else kh.playerAccount.applyRandomLoadout();
				console.log("Start account search with Firebase..."), parsedUrl.query.sandbox && firebase.auth().setPersistence(firebase.auth.Auth.Persistence.SESSION);
				const s = setTimeout((() => {
					console.warn("Firebase auth timeout"), e(!1)
				}), 5e3);
				firebase.auth().onAuthStateChanged((t => {
					clearTimeout(s), QT && !hasValue(t) || (t && (pw = !0), e(!0), console.log("firebase resolved: has account", pw), t ? ((JT = t).isAnonymous ? (console.log("Firebase: anonymous user"), $T = JT, pw || !0) : (console.log("Firebase: auth provider: " + JT.providerData[0].providerId), JT.emailVerified || "password" !== JT.providerData[0].providerId || (console.log("Firebase: email not yet verified"), xw = !0)), uk()) : (console.log("Firebase: no account found"), console.log("No account created yet :("), qT = !1, IT = !0, pw = !1, iD(), Nw.aBParamCheck && (Nw.getOrCreateRandID(), Nw.assignABTestVariant(), "a" === Nw.getAssignedVariant() && zD())))
				}))
			} catch (e) {
				console.error("Error in signIn:", e), t(e)
			}
		}))
	}

	function uk() {
		if (!qT && (qT = !0, QT = !1, pw = !0, JT.getIdToken(!0).then((e => {
				! function(e, t, i, s) {
					lN({
						cmd: "auth",
						firebaseToken: e
					}, t, i, s)
				}(e, gk, vk, yk)
			})).catch((function(e) {
				console.log(e), qT = !1
			})), JT.providerData.length > 0 && JT.providerData[0].providerId, JT.photoURL && JT.providerData && JT.providerData.length > 0)) {
			var e = JT.photoURL;
			Lw = e
		}
	}
	kh.resetPaperDoll = hk;
	var mk, dk, fk, pk = null;

	function _k() {
		console.log("sending Firebase email verification"), JT.sendEmailVerification()
	}
	async function gk(e) {
		const {
			playerOutput: t,
			gameOutput: i
		} = e;
		if (Kw = i, Gk(), t.hasOwnProperty("dateModified") && t.hasOwnProperty("dateCreated")) {
			const e = Math.floor(Math.abs(new Date(t.dateModified) - new Date(t.dateCreated)) / 36e5);
			Cw = e > 1
		}
		if (t.hasOwnProperty("banRemaining")) {
			let e, i = t.banRemaining.split(":"),
				s = parseInt(i[0]),
				n = parseInt(i[1]);
			e = s > 24 ? `${Math.floor(s/24)} ${nD("time_days")}` : s > 0 ? `${s} ${nD("time_hours")}` : `${n} ${nD("time_minutes")}`, vueApp.showBannedPopup(e)
		} else if (e.error) console.log("accountDataResponse Error: " + JSON.stringify(accountDataResponse.error));
		else {
			if (await new Promise((e => {
					let t = setInterval((() => {
						kh.ready_meshes && (clearInterval(t), e())
					}))
				})), kh.playerAccount.signedIn(JT, t), vueApp.authCompleted(), IT = !0, setTimeout((() => kh.playerAccount.syncToServer()), 1e3), sN(t.chwReady), gw && (kh.showSigninBonus && (Vk(), kh.showSigninBonus = !1), iD(), vueApp.progressBarReset()), null !== $T) ga("set", "vip_status", "NoVIP");
			else {
				parsedUrl.query.signInPrompt && parsedUrl.query.closeAfterSign && window.close();
				const e = t.active_sub;
				ga("set", "vip_status", null === e ? "NoVIP" : e ? "IsVIP" : "WasVIP"), e && vueApp.hideHomeScreenAds(!0)
			}
			ww.dailyTimerStart(), console.log("Signed in"), pw || null === pk || (console.log("Nonaccount is now anon. Time for play"), vueApp.assetLoaded(), pw = !0, pD(!1), Hk(), _D(pk))
		}
		0
	}

	function vk() {
		console.log("authorization failed"), ga("send", "event", vueData.googleAnalytics.cat.playerStats, vueData.googleAnalytics.action.signIn, vueData.googleAnalytics.label.signInAuthFailed), PR.hide(), vueApp.authCompleted()
	}

	function yk(e) {
		console.log("auth ws closed, code: " + e), 1006 !== e ? qT = !1 : vueApp.showGenericPopup("signin_failed_title", "signin_failed", "ok")
	}

	function Sk() {
		KT || (KT = new firebaseui.auth.AuthUI(firebase.auth()));
		var e = {
			autoUpgradeAnonymousUsers: !0,
			callbacks: {
				signInSuccessWithAuthResult: Ek,
				signInFailure: Ak,
				uiShown: function(e) {
					console.log("UI: showed firebase UI");
					const t = document.querySelector(".firebaseui-idp-list"),
						i = document.querySelector('.firebaseui-idp-button[data-provider-id="password"]');
					if (i && (i.onclick = () => {
							document.getElementById("signin-msg-chat").style.display = "block"
						}), t) {
						const e = document.createElement("li"),
							i = document.createElement("button"),
							s = document.createElement("span"),
							n = document.createElement("img"),
							a = document.createElement("span");
						i.onclick = () => {
							vueApp.fbTransferAccountSignin()
						}, i.className = "firebaseui-idp-button mdl-button mdl-js-button mdl-button--raised firebaseui-idp-facebook firebaseui-id-idp-button", i.style.backgroundColor = "#3b5998", a.className = "firebaseui-idp-text firebaseui-idp-text-long", a.textContent = "Sign in with Facebook", s.className = "firebaseui-idp-icon-wrapper", n.className = "firebaseui-idp-icon", n.src = "https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/facebook.svg", e.className = "firebaseui-list-item", s.appendChild(n), i.appendChild(s), i.appendChild(a), e.appendChild(i), t.appendChild(e)
					}
				}
			},
			credentialHelper: firebaseui.auth.CredentialHelper.NONE,
			signInFlow: "popup",
			signInOptions: [{
				provider: firebase.auth.EmailAuthProvider.PROVIDER_ID,
				requireDisplayName: !1
			}, firebase.auth.GoogleAuthProvider.PROVIDER_ID],
			tosUrl: "http://www.bluewizard.com/terms"
		};
		KT.start("#firebaseui-auth-container", e), gw = !0, Ok()
	}

	function Ek(e, t) {
		var i = (JT = e.user).emailVerified,
			s = (e.credential, e.additionalUserInfo.isNewUser, e.additionalUserInfo.providerId);
		e.operationType;
		return vueApp.hideFirebaseSignIn(), "password" != s || i || _k(), console.log("Authing Firebase ID"), uk(), !1
	}

	function Ak(e) {
		if (vueApp.hideFirebaseSignIn(), console.log("Firebase: sign in failure, error code: " + e.code), "firebaseui/anonymous-upgrade-merge-conflict" !== e.code) return Promise.resolve();
		QT = !0, firebase.auth().signInWithCredential(e.credential), $T.delete(), setTimeout((() => {
			vueApp.$nextTick((() => {
				vueApp.urlParamSet = !!vueApp.urlParams || null, vueApp.shellShockUrlParamaterEvents()
			}))
		}), 2e3)
	}
	var bk, xk, Mk, Ck, Tk, wk = !1,
		Rk = {};

	function Nk(e, t) {
		let i = null;
		return (...s) => {
			clearTimeout(i), i = setTimeout((() => {
				e(...s)
			}), t)
		}
	}
	async function Ik(e) {
		try {
			if (!await async function() {
					return (TT = "1.0.8") ? (wT = getStoredString("lastVersionPlayed", Ch)) && wT !== Ch ? (uD(), !1) : (localStore.setItem("lastVersionPlayed", Ch), !0) : (console.error("Failed to retrieve version"), !1)
				}()) return;
			Fw = await ck().catch((e => (console.error("Firebase sign-in failed:", e), null))), parsedUrl.query.testMap && (HT = !0);
			const e = (AT = getStoredString("languageSelected", null), hasValue(AT) ? AT : Pk());
			Aw = function() {
				let e = "",
					t = document.createElement("canvas").getContext("webgl");
				e += t.getParameter(t.VERSION);
				let i = t.getExtension("WEBGL_debug_renderer_info");
				null != i && (e += t.getParameter(i.UNMASKED_RENDERER_WEBGL), e += t.getParameter(i.UNMASKED_VENDOR_WEBGL)), e += navigator.userAgent + navigator.language, Aw = 1;
				for (let t in e) Aw = Aw * e.charCodeAt(t) % Number.MAX_SAFE_INTEGER;
				Aw += (navigator.hardwareConcurrency + navigator.maxTouchPoints) % Number.MAX_SAFE_INTEGER
			}(), aT = getStoredNumber("gameType", ch.find((e => "Spatula" === e.shortName)).value), await async function() {
					const e = document.getElementById("canvas");
					if (!e) throw new Error("Canvas element not found");
					kh.engine = new Fd(e, !0, {
						preserveDrawingBuffer: !0,
						stencil: !0
					}, !1), kh.engineCaps = kh.engine.getCaps(), kh.engineCaps.parallelShaderCompile = void 0, kh.engine.disableManifestCheck = crazyGamesActive, kh.engine.enableOfflineSupport = !crazyGamesActive
				}(), (_w = new FO).init(), kh.catalog = new cR, kh.catalog.getPremiumGunMeshNames(), ww = new NO, rD(), bO.connect(), Bk(),
				function() {
					let e = getStoredString("selectedLanguage", null);
					if (!hasValue(e)) return;
					let t = Pk();
					"en" !== e && e === t && (console.log("Updating to new localStore for language setting"), localStore.setItem("languageSelected", t), ga("send", "event", {
						eventCategory: vueData.googleAnalytics.cat.playerStats,
						eventAction: vueData.googleAnalytics.action.langBeforeUpdate,
						eventLabel: e
					}));
					localStore.removeItem("selectedLanguage"), console.log("selectedLanguage item removed")
				}(), vueData.maps = CR;
			const t = await sD(e);
			CT = new BO(16029), startVue(e, t), console.log("ShellShockers startup complete")
		} catch (e) {
			console.error("Critical error during game startup:", e)
		}
	}

	function Pk() {
		let e = mw.includes("-") ? mw.split("-")[0].toLowerCase() : mw,
			t = vueData.languages,
			i = null;
		for (let s = 0; s < t.length; s++)
			if (t[s].code === e) {
				i = !0;
				break
			} return hasValue(i) ? e : "en"
	}

	function kk() {
		(Mw = new oN).init(), LT = Mw.isAdBlocking(),
			function e(t = 0) {
				"undefined" != typeof aiptag && aiptag.stack ? ga("send", "event", "user_property", "aip_stack", aiptag.stack) : t < 10 && setTimeout((() => {
					e(t + 1)
				}), 100)
			}()
	}

	function Dk() {
		if (console.log("afterResourcesLoaded"), kh.ready_meshes = !0, XD.init(), XO(), getRequest("data/housePromo.json?" + Date.now(), (function(e, t) {
				if (0 === Object.keys(HouseAds).length && HouseAds.constructor === Object) lw = {
					big: [],
					small: [],
					bigBanner: [],
					houseAdPercentChance: 100,
					smHouseAds: [],
					shellLogo: []
				};
				else {
					const e = {
						socialMedia: "",
						premFeat: ""
					};
					lw = HouseAds, pO(), console.log("special items tag: " + lw.specialItemsTag), hasValue(lw.specialItemsTag) && kh.catalog.getTaggedItems(lw.specialItemsTag).length > 0 ? vueApp.useSpecialItemsTag(lw.specialItemsTag) : vueApp.disableSpecialItems(), hasValue(lw.featuredSocialMedia) && (e.socialMedia = lw.featuredSocialMedia), hasValue(lw.premFeatured) && (e.premFeat = lw.premFeatured, zw[e.premFeat] = !0), lw.smHouseAds.length > 0 && vueApp.ui.houseAds.homeScreen.push(...lw.smHouseAds), vueApp.useTags(e)
				}
				0
			})), console.log("From EU: " + isFromEU), KO(), FT.autoDetail || hD(FT.highRes), HT) return zT.x = parsedUrl.query.x, zT.y = parsedUrl.query.y, zT.z = parsedUrl.query.z, zT.pitch = parsedUrl.query.pitch, zT.yaw = parsedUrl.query.yaw, Mk = 1, mk = {
			send: function() {}
		}, BT = !0, vueApp.setInGame(BT), kh.engine.stopRenderLoop(), void yI();
		GT = new MO, PT = !0, bT = new TO, IO(), parsedUrl.query.openSettings && vueApp.showSettingsPopup(), parsedUrl.query.test && (jT = !0), parsedUrl.query.noSkybox && (YT = !0), pokiActive && vueApp.isPlayingPoki(), NT = !0
	}
	async function Ok() {
		return Gw ? (vueApp.assetSetup(vueApp.ui.homeToGameProgressBar.accountTotal), !0) : (console.log("Loading all object meshes..."), Gw = !0, await new Promise((e => {
			UR(Tk, ["egg", "gun_eggk47", "gun_csg1", "gun_cluck9mm", "gun_dozenGauge", "gun_rpegg", "gun_smg", "gun_m24", "gun_aug", "melee", "munitions"], null, (() => {
				console.log("All object meshes loaded"), vueApp.assetLoaded(), e()
			}), Gw)
		})), vueApp.assetLoaded(), GT || (GT = new MO), GT.setStampTexture(), gO = new AO, vueApp.assetLoaded(), Tk.cleanCachedTextureBuffer(), console.log("All meshes and ItemRenderer loaded and initialized"), yw || jP(), !0)
	}

	function Fk() {
		return hasValue(vueApp) && vueApp.ready && NT && IT && PT && DT
	}
	var Lk = 0;

	function Bk() {
		if (Lk >= 100) return vueApp.showGenericPopup("uh_oh", "error", "reload", !0), void ga("send", "event", vueData.googleAnalytics.cat.playerStats, vueData.googleAnalytics.action.error, vueData.googleAnalytics.label.waitForGameReadyTimeout);
		Fk() ? function() {
			if (HT) return;
			var e = document.getElementById("onesignal-bell-container");
			e && (e.style.display = "none");
			(function() {
				const e = document.getElementById("changelog-link");
				e && e.addEventListener("click", (e => {
					e.preventDefault(), vueApp.hideChangelogPopup(), vueApp.showScavengerHuntPopup(), ga("send", "event", "changelog", "clicked", "showScavengerHuntPopup")
				}))
			})(), ga("send", "event", "ads", "ad blocker", LT.toString()), hk(), ZD(), t = getStoredString("lastUsername", qR()), vueApp.setPlayerName(t);
			var t;
			[Xk, Wk, eD, Uk, Qk, tD, jk, Kk, Zk, $k, qk, Yk].some((e => e())),
				function() {
					if (!pw) return !0;
					if (kh.playerAccount.isItemOwned({
							id: 16020
						})) return vueApp.hasMobileReward = !0, !0
				}(), vueApp.hideSpinner(), PR.hide(), e && (e.style.display = "none");
			console.log("After Game Ready"), vueApp.shellShockUrlParamaterEvents(), zk(), ga("send", "timing", "load", "homeLoaded", Math.round(performance.now()), "home"), kk(), kh.productBlockAds || vueApp.showTitleScreenAd();
			ww.resizeAllText(),
				function() {
					const e = kh.catalog.findItemById(Ow);
					kw = !!e && kh.playerAccount.isItemOwned(e)
				}(), Hk(), VD(),
				function() {
					if (pw || $T) return;
					vueApp.statsCurrent = new Dh, vueApp.statsLifetime = vueApp.statsCurrent
				}(), jw = !0, iF(!0)
		}() : setTimeout(Bk, 200)
	}

	function Gk(e) {
		if (!Kw.premiumSkuId) return;
		const t = e || Kw.premiumSkuId;
		_w.replaceItemProduct(t), vueApp.store.premiumItemId = t, vueApp.store.itemIdsToHide = _w.hideItemIdsInStore
	}

	function Hk() {
		vueApp.eggStoreItems = _w.getStoreItems(), vueApp.premiumShopItems = _w.getShopItems(), vueApp.subStoreItems = _w.getSubscriptions()
	}

	function Uk() {
		const e = kh.playerAccount.challengesHasAutoClaim;
		if (!e || 0 === e.length) return !1;
		const t = e.filter((e => "claimed" === e.status)).map((e => {
			const t = extern.playerChallenges.challengeGet(e.id);
			return t?.loc_ref && (e.loc_ref = t.loc_ref), t?.reward && (e.reward = t.reward), [e.id, e.loc_ref, e.reward]
		}));
		return vueApp.showPurchasesPopup([{
			type: "challenges",
			data: {
				items: t
			}
		}]), hN(), kh.playerAccount.challengesHasAutoClaim = [], !0
	}

	function Vk() {
		return !!kh.showSigninBonus && (vueApp.ui.bonus.showing = !0, vueApp.showPurchasesPopup([{
			type: "currency",
			data: {
				ids: [],
				items: [],
				eggs: vueApp.ui.bonus.amount
			}
		}]), !0)
	}

	function Wk() {
		if (xw) return xw = !1, void vueApp.showResendEmail();
		Vk()
	}

	function zk() {
		const {
			notification: e,
			factionActivated: t
		} = kh.playerAccount;
		if (!e || e.read) return void(t && (vueApp.showFactionActivatedPopup(), kh.playerAccount.factionActivated = !1));
		t && (vueApp.faction.showPopup = !0, kh.playerAccount.factionActivated = !1);
		const {
			type: i
		} = e, s = [];
		let n = 0;
		const a = () => {
				kh.playerAccount.notification.read = !0, setTimeout((() => {
					var e, t;
					e = () => console.log("Notifications: SUCCESS"), t = () => console.log("Notifications: ERROR"), lN({
						cmd: "notify_mark_as_complete",
						firebase_id: kh.playerAccount.firebaseId
					}, e, t)
				}), 500)
			},
			r = (e, t, i, n, a = null) => {
				s.push({
					type: e,
					data: {
						items: t,
						eggs: i,
						ids: n,
						product: a
					}
				})
			};
		Object.entries(i).forEach((([e, t]) => {
			const i = Array.isArray(t?.ids) ? [...new Set(t.ids)] : [],
				s = "number" == typeof t?.eggs ? t.eggs : 0;
			let a = null;
			if ("pass" === e || "bundle" === e) {
				const t = function(e, t) {
					return _w.getProductByItemIds(e, t)
				}(e, i);
				a = t && t.length ? t[0] : null
			}
			n += s;
			const o = i.length > 0 ? kh.catalog.findItemsByIds(i) : [];
			(o.length > 0 || s > 0) && (console.log(`Processing notification type: ${e}`), console.log("Product Data:", a), r(e, o, s, i, a))
		})), n > 0 && r("currency", [1], n, []), s.length > 0 && (console.log("Displaying Popup Data:", s), vueApp.showPurchasesPopup(s, a))
	}

	function Xk() {
		parsedUrl.hash && parsedUrl.query.observe ? (console.log("TRYING TO JOIN GAME AUTOMATICALLY", parsedUrl.hash), VT = !0, WT = parsedUrl.query.watchPlayer) : VT = !1;
		const e = "crazyShare" in parsedUrl.query;
		if (!parsedUrl.hash && !e) return !1;
		const t = e ? parsedUrl.query.crazyShare : parsedUrl.hash;
		return vueApp.showJoinPrivateGamePopup(t), !0
	}

	function Yk() {
		var e = new URLSearchParams(document.location.search);
		return !1 !== e.has("storeItem") && (vueApp.showPopupEggStoreSingle(e.get("storeItem")), !0)
	}

	function jk() {
		var e = new URLSearchParams(document.location.search);
		if (!1 === e.has("showItem")) return !1;
		var t = parseInt(e.get("showItem"));
		if (!1 === (Number.isInteger(t) && null !== kh.catalog.findItemById(t) && !0)) return !1;
		var i = kh.catalog.findItemById(t);
		return vueApp.showItemOnEquipScreen(i), !0
	}

	function Kk(e) {
		return null !== (iw = e || iw) && (vueApp.showTaggedItemsOnEquipScreen(iw), !0)
	}

	function $k() {
		if (null === sw || kh.playerAccount.isUpgraded()) return !1;
		vueApp.showChicknWinnerPopup(), sw = null
	}

	function Jk() {
		vueApp.onWelcomeBundlePopupShow()
	}

	function qk() {
		var e = new URLSearchParams(document.location.search);
		if (!e.has("purchase")) return !1;
		if (kh.playerAccount.isAnonymous) return vueApp.showGenericPopup("uh_oh", "anon_account", "ok"), !1;
		var t = e.get("purchase");
		return vueApp.showPopupEggStoreSingle(t), !0
	}

	function Qk() {
		return !1 !== new URLSearchParams(document.location.search).has("signInPrompt") && (Sk(), vueApp.$refs.firebaseSignInPopup.show(), !0)
	}

	function Zk() {
		const {
			vipSubEnded: e,
			passEnded: t
		} = kh;
		if (e || t) {
			const t = e ? 0 : 1;
			return vueApp.vipEndedPopup(t), !0
		}
		return !1
	}

	function eD() {
		var e, t, i, s = new URLSearchParams(document.location.search);
		if (!s.has("invoice_id") && !localStore.getItem("xsollaPurchase")) return !1;
		localStore.removeItem("xsollaPurchase"), window.history.replaceState(null, null, "/"), e = s.get("invoice_id"), t = e => {
			if ("SUCCESS" === e.result && (e.details.item_id || e.details.amount)) {
				let t = null;
				if (e.details.item_id) {
					const i = kh.catalog.findItemById(e.details.item_id);
					t = kh.playerAccount.isItemOwned(i) ? i : null
				}
				return t && vueApp.showItem(t), vueApp.showGiveStuffPopup("give_stuff_twitch_title", e.details.amount, hasValue(t) ? [t] : t), !0
			}
			return !1
		}, i = e => !1, lN({
			cmd: "checkAfterStorePurchase",
			playerId: kh.playerAccount.id,
			transactionId: e
		}, t, i)
	}

	function tD() {
		let e;
		const t = new URLSearchParams(document.location.search);
		if (Ww.forEach((i => {
				t.has(i) && (e = i)
			})), !hasValue(e)) return !1;
		console.log("tryUrlParam reward", e);
		let i = Date.now();
		const s = localStore.getItem(e);
		if (hasValue(s)) {
			const t = Number(s) + 432e6;
			if (i < t) return console.log(e + " reward already given!"), !1
		}
		var n, a;
		return n = function(t) {
			FD(t, {
				success() {
					localStore.setItem(e, i)
				},
				prevGiven() {
					this.success()
				},
				expired() {
					this.succces()
				},
				playerNotFound() {
					vueApp.showGenericPopup("player_not_found_title", "player_not_found_desc", "ok")
				},
				error() {
					this.playerNotFound()
				},
				default () {
					this.playerNotFound()
				}
			})
		}, a = function() {
			console.log(e, "error")
		}, lN({
			cmd: "urlRewardParams",
			reward: e,
			sessionId: kh.playerAccount.sessionId,
			firebaseId: kh.playerAccount.firebaseId
		}, n, a), !0
	}

	function iD() {
		const e = ["lastPreRoll", "localLoadOut", "showBigAd", "lastUsername"],
			t = vueApp?.ui?.socialMedia?.footer;
		t && Array.isArray(t) && t.forEach((t => e.push(t.reward + "Rewarded"))), e.push(...Ww), e.forEach((e => {
			localStore.getItem(e) && localStore.removeItem(e)
		}))
	}
	async function sD(e) {
		try {
			const t = await fetch(`language/${e}.json?${TT}`);
			if (!t.ok) throw new Error(`HTTP error! status: ${t.status}`);
			const i = await t.json();
			return ww.resizeAllText(), vueApp?.setLocData?.(e, i), i
		} catch (e) {
			throw console.error("Error loading language data:", e), e
		}
	}

	function nD(e) {
		return vueData.loc[e] || "[" + e + "]"
	}
	var aD = null;

	function rD() {
		clearTimeout(aD), aD = setTimeout((() => (aD = null, console.log("%cSTOP!", "color:red; font-size:60px; font-weight: bold; text-shadow: 0 0 2px black;"), void console.log("%cThis is a browser feature intended for developers. If someone told you to copy and paste something here, there is a good chance that they are attempting to gain access to your account and personal information!", "font-size: 18px;"))), 500), canvas && (canvas.style.width = "100%", canvas.style.height = "100%"), kh.engine && (kh.engine.resize(), FT && FT.highRes && kh.engine.setHardwareScalingLevel(FT.highRes)), BT && (HN && HN.resize(), UN && UN.resize(), GN && GN.resize())
	}

	function oD() {
		nT && xD.clear(nT), console.log("Auto detail enabled"), nT = xD.set((() => {
			uT / mT < 40 && kh.engine.getFps() < 40 && (JN.shadowsEnabled ? (cD(!1), FT.shadows = !1) : (hD(!1), FT.highRes = !1, lD()), YO())
		}), 4e3)
	}

	function lD() {
		nT && (xD.clear(nT), nT = null)
	}

	function hD(e) {
		console.log("setting high resolution: " + e), kh.engine.setHardwareScalingLevel(e ? 1 : 2),
			function() {
				GN && GN.resize();
				HN && HN.resize();
				UN && UN.resize();
				BN && BN.dS.isEnabled() && BN.show()
			}()
	}

	function cD(e) {
		console.log("setting shadows: " + e), JN.shadowsEnabled = e
	}

	function uD() {
		var e = window.indexedDB.deleteDatabase("babylonjs");
		e.onerror = function(e) {
			mD()
		}, e.onsuccess = function(e) {
			mD()
		}
	}

	function mD() {
		localStore.setItem("lastVersionPlayed", Ch), window.location.reload(!0)
	}

	function dD() {
		kh.engine.resize()
	}

	function fD(e) {
		kh.playerAccount.syncToServer(e)
	}

	function pD(e) {
		yw = e, vueApp.disablePlayButton(e)
	}

	function _D(e) {
		if (!yw) {
			if (aw && (clearInterval(aw), aw = null), pD(!0), GT.scale(), pw && (lT = getSetIncrementStoredNum("timesPlayed", 1)), !kh.productBlockAds) {
				var t = getStoredNumber("lastPreRoll", 0),
					i = !1;
				if (0 == t && (t = Date.now(), localStore.setItem("lastPreRoll", t)), (Cw || lT > 1) && (i = !0), nw || Date.now() > t + 24e4 && i) return console.log("play() calls PVA"), Mw.play("shellshock.io_preroll", (() => gD(e))), void vueApp.hideHomeScreenAds(!0)
			}
			gD(e)
		}
	}
	async function gD(e) {
		if (console.log("play(): " + JSON.stringify(e)), vueApp.setDarkOverlay(!1), !pw) return console.log("Create account now."), bw = !0, vueApp.onTutorialPopupClick(), ga("send", "event", "tutorial", "newUserPopup"), vueApp.assetSetup(vueApp.ui.homeToGameProgressBar.nonAccountTotal), void
		function(e) {
			firebase.auth().signInAnonymously().then((() => {
				firebase.auth().onAuthStateChanged((t => {
					pw = !0, null !== t && e && t.isAnonymous && (pw = !1, pk = e)
				}))
			})).catch((function(e) {
				console.debug("Failed Firebase anonymous signin, code: {0}, msg: {1}".format(e.code, e.message))
			}))
		}(e);
		await Ok() ? (hasValue(e.playerName) && 0 !== e.playerName.length && !/^ *$/.test(e.playerName) || (e.playerName = qR(), vueApp.setPlayerName(e.playerName)), localStore.setItem("lastUsername", e.playerName), e.playType === vueApp.playTypes.joinPrivate ? bO.joinPrivateGame(e).then((t => {
			gT = t.private, e.subdomain = t.subdomain, e.id = t.id, rT = t.id, e.uuid = t.uuid, vueApp.currentRegionId = t.region, Bw = t.noobLobby, vD(e)
		})).catch((e => bD(e))) : bO.findGame(e).then((t => {
			gT = t.private, Bw = t.noobLobby, e.subdomain = t.subdomain, e.id = t.id, rT = t.id, e.uuid = t.uuid, vueApp.currentRegionId = t.region, vD(e)
		})).catch((e => {
			bO.getRegions().then((() => wO())), bD(e)
		}))) : console.log("all mesh load error")
	}

	function vD(e) {
		console.log("prepareToJoinGame", e), document.body.scrollTop = document.documentElement.scrollTop = 0, OT = performance.now(),
			function(e) {
				vueApp.mediaTabsCancelRotate(), ED(1), SD = null, e.playerName = RD(e.playerName, 80), cw = !1, e.playType === vueApp.playTypes.createPrivate ? cw = !0 : (e.playType, vueApp.playTypes.joinPrivate);
				e.playType;
				let t = 0;

				function i() {
					let s = (isHttps() ? "wss" : "ws") + "://" + yD(e.subdomain) + "/game/" + e.id;
					console.log("Connecting to: " + s), (mk = new WebSocket(s)).binaryType = "arraybuffer", mk.onopen = function(e) {
						console.log("WebSocket opened")
					}, mk.onclose = function(e) {
						e.code === th.sessionNotFound ? (console.log(`Connect attempt #${t} - code: ${e.code}`), ++t > 10 ? bD(e.code) : setTimeout(i, 1e3)) : bD(e.code)
					}, mk.onmessage = function(t) {
						switch (Nh.init(t.data), Nh.unPackInt8U()) {
							case sh.i:
								ga("send", "event", "play game", "class", kh.classes[kh.playerAccount.classIdx].name);
								const t = getStoredBool("hideBadge", 0) ? 1 : 0;
								! function() {
									LD("primaryGun", kh.playerAccount.getPrimaryWeapon().name), LD("SecondaryGun", kh.playerAccount.getSecondaryWeapon().name), "undefined" != typeof EGGCOLOR && LD("eggColor", Object.keys(EGGCOLOR).find((e => EGGCOLOR[e] === kh.playerAccount.colorIdx)));
									null !== kh.playerAccount.hatItem && LD("hat", kh.playerAccount.hatItem.name);
									null !== kh.playerAccount.stampItem && LD("stamp", kh.playerAccount.stampItem.name);
									null !== kh.playerAccount.grenadeItem && kh.playerAccount.grenadeItem.hasOwnProperty("name") && LD("grenade", kh.playerAccount.grenadeItem.name)
								}();
								var i = Rh.getBuffer();
								VT ? i.BkKlQQwL(sh.W) : i.BkKlQQwL(sh.S), i.AABkKlQQwL(e.playerName), i.AABkKlQQwL(e.uuid), i.BkKlQQwL(t), i.BkKlQQwL(kh.playerAccount.classIdx), kh.playerAccount.firebaseId && (i.ABkKlQQwL(kh.playerAccount.session), i.AABkKlQQwL(kh.playerAccount.firebaseId), i.AABkKlQQwL(kh.playerAccount.sessionId)), i.send(mk);
								break;
							case sh.zk:
								var s = Nh.unPackLongString();
								sP(s);
								break;
							case sh.J:
								console.log("BkKlQQwL.gameJoined_ received"), xk = Nh.unPackInt8U(), ET = Nh.unPackInt8U(), aT = Nh.unPackInt8U(), oT = Nh.unPackInt8U(), Mk = Nh.unPackInt8U(), yT = 1 == Nh.unPackInt8U(), gT = 1 == Nh.unPackInt8U();
								Nh.unPackInt8U();
								let n = ok[aT];
								dk = new n.logic, fk = new n.ui,
									function() {
										fT = document.getElementById("chatIn"), pT = document.getElementById("chatOut"), _T = document.getElementById("killTicker");
										var e = document.getElementById("playerList");
										! function(e) {
											for (; e.firstChild;) e.removeChild(e.firstChild)
										}(e);
										for (var t = document.getElementById("playerSlot"), i = 0; i < 20; i++) {
											var s = t.cloneNode(!0);
											e.appendChild(s)
										}
										pT.innerHTML = "", 1 == FT.enableChat && (DP(), pT.style.display = "block", fT.style.display = "block"), _T.innerHTML = "", pT.value = "", document.getElementById("scopeBorder").style.display = "none", document.getElementById("spatulaPlayer").classList.replace("capture", "drop"), document.getElementById("spectate").style.display = "none", document.getElementById("teamScores").style.display = aT == hh.ctf ? "grid" : "none", document.getElementById("captureContainer").style.display = aT == hh.king ? "block" : "none", document.getElementById("captureIconContainer").style.display = "none", document.getElementById("playerList").style.pointerEvents = "auto", rP(), GN && GN.setPowerful(!1), console.log("resetGameUI")
									}(), KP(), wk = aT == hh.teams || aT == hh.ctf, console.log("game joined: game type:  " + aT), vueApp.gameJoined(aT, ET), console.log("is game owner: " + yT), BT = !0, vueApp.setInGame(BT);
								const a = vueData.gameTypes.find((({
									value: e
								}) => e === aT));
								vT = e.playType === vueApp.playTypes.createPrivate ? "createPrivate" : gT ? "joinPrivate" : "" !== e.joinCode ? "joinPublicByInvite" : "joinPublic", MT = new zO, CD = !1, ga("send", "event", vueData.googleAnalytics.cat.play, vT, `Map - ${CR[oT].name}`), ga("send", "event", vueData.googleAnalytics.cat.play, vT, `Game type - ${a.locKey}`), ga("send", "event", vueData.googleAnalytics.cat.play, vT, vueData.googleAnalytics.action.playerLimit, Mk), ga("send", "event", vueData.googleAnalytics.cat.play, vT, vueData.googleAnalytics.action.timesPlayed, lT), yI();
								break;
							case sh.u:
								AD()
						}
					}
				}
				i()
			}(e)
	}

	function yD(e) {
		let t = dynamicContentRoot || window.location.hostname;
		return t = t.split("."), t.length > 2 && (t = t.slice(-2)), t = t.join("."), `${e}.${t}`
	}
	document.onfullscreenchange = dD, document.onmsfullscreenchange = dD, document.onmozfullscreenchange = dD, document.onwebkitfullscreenchange = dD;
	var SD = null;

	function ED(e) {
		const t = document.getElementById("chw-home"),
			i = document.getElementById("chw-game-screen"),
			s = document.getElementById("chw-home-timer");
		1 === e ? i.appendChild(s) : t.appendChild(s)
	}

	function AD() {
		dR.serialize().send(mk)
	}

	function bD(e) {
		if (pD(!1), vueApp.mediaTabsStartRotate(), XT) return;
		let t = !1;
		switch (Object.keys(th).forEach((i => {
				th[i] === e && (console.log("Socket Closed: " + i), t = !0)
			})), t || console.log("Socket Closed: " + e), e) {
			case th.locked:
				console.log("Game locked"), ga("send", "event", "Websocket", "onclose", "Game locked"), vueApp.hideSpinner(), vueApp.showGenericPopup("game_locked", "game_locked_msg", "ok");
				break;
			case th.uuidNotFound:
				console.log("UUID invalid"), ga("send", "event", "Websocket", "onclose", "UUID not found"), vueApp.hideSpinner(), vueApp.showGenericPopup("cannot_connect", "session_expired_msg", "ok");
				break;
			case th.sessionNotFound:
				console.log("Session not found"), ga("send", "event", "Websocket", "onclose", "Session not found"), vueApp.hideSpinner(), vueApp.showGenericPopup("cannot_connect", "session_expired_msg", "reload", !0);
				break;
			case th.gameNotFound:
				console.log("Game not found"), ga("send", "event", "Websocket", "onclose", "Game not found"), vueApp.hideSpinner(), vueApp.showGenericPopup("game_not_found", "game_not_found_msg", "reload", !0);
				break;
			case th.gameFull:
			case th.gameMaxPlayersExceeded:
				console.log("Game full"), ga("send", "event", "Websocket", "onclose", "Game full"), vueApp.hideSpinner(), vueApp.showGenericPopup("game_full", "game_full_msg", "ok");
				break;
			case th.mainMenu:
				ga("send", "event", "Websocket", "onclose", "Return to main menu");
				break;
			case th.regionFull:
				ga("send", "event", "Websocket", "onclose", "Region full"), vueApp.hideSpinner(), vueApp.showGenericPopup("server_full", "server_full_msg", "ok");
				break;
			case th.clusterFullCpu:
				ga("send", "event", "Websocket", "onclose", "Game Cluster max CPU"), vueApp.hideSpinner(), vueApp.showGenericPopup("server_full", "server_full_msg", "ok");
				break;
			case th.clusterFullMem:
				ga("send", "event", "Websocket", "onclose", "Game Cluster max RAM"), vueApp.hideSpinner(), vueApp.showGenericPopup("server_full", "server_full_msg", "ok");
				break;
			case th.booted:
				BT ? vueApp.leaveGame() : vueApp.hideSpinner(), vueApp.showGenericPopup("connection_lost", "booted", "ok");
				break;
			case th.gameIdleExceeded:
				vueApp.leaveGame(), vueApp.showGenericPopup("connection_lost", "inactivity", "ok");
				break;
			default:
				if (BT) ga("send", "event", "Websocket", "onclose", "Connection Lost"), vueApp.leaveGame(), vueApp.showGenericPopup("connection_lost", "connection_lost_msg", "ok");
				else {
					var i = "";
					if (SD === sh.V) i = "login_required";
					else i = "generic_conn_failed";
					vueApp.hideSpinner(), vueApp.showGenericPopup("cannot_connect", i, "ok")
				}
		}
	}
	var xD = {
			intervals: {},
			set: function(e, t) {
				var i = setInterval.apply(window, [e, t].concat([].slice.call(arguments, 2)));
				return xD.intervals[i] = !0, i
			},
			clear: function(e) {
				return delete xD.intervals[e], clearInterval(e)
			},
			clearAll: function() {
				for (var e = Object.keys(xD.intervals), t = e.length; t-- > 0;) clearInterval(e.shift());
				xD.intervals = {}
			}
		},
		MD = {
			timeouts: {},
			set: function(e, t) {
				var i = setTimeout.apply(window, [e, t].concat([].slice.call(arguments, 2)));
				return MD.timeouts[i] = !0, i
			},
			clear: function(e) {
				return delete MD.timeouts[e], clearTimeout(e)
			},
			clearAll: function() {
				for (var e = Object.keys(MD.timeouts), t = e.length; t-- > 0;) clearTimeout(e.shift());
				MD.timeouts = {}
			}
		};
	var CD = !1;

	function TD(e) {
		if (bk && (MT.kills > 0 || MT.deaths > 0)) {
			const t = "player stats",
				i = kh.classes[bk.charClass].name;
			0 === MT.kills && MT.deaths > 0 ? ga("send", "event", t, "rageQuit", i, MT.deaths) : ga("send", "event", t, "best kill streak", i, jN), e && e()
		}
	}

	function wD() {
		cT > 10 && (ga("send", "timing", "game", "ping", Math.floor(hT / cT), vueData.currentRegionId), ga("send", "event", "game", "stats", "fps", Math.ceil(uT / mT)))
	}

	function RD(e, t) {
		t = t || 80;
		var i = hw.getContext("2d");
		for (i.font = "1em Nunito, sans-serif";;) {
			if (i.measureText(e).width < t) break;
			e = e.substr(0, e.length - 1)
		}
		return e
	}
	var ND = [{
		start: 688,
		end: 7679
	}, {
		start: 7936,
		end: 11359
	}, {
		start: 11392,
		end: 11903
	}, {
		start: 12032,
		end: 12255
	}, {
		start: 12272,
		end: 12287
	}, {
		start: 12352,
		end: 12735
	}, {
		start: 12784,
		end: 12799
	}, {
		start: 19904,
		end: 19967
	}, {
		start: 40960,
		end: 42783
	}, {
		start: 43008,
		end: 43823
	}, {
		start: 43888,
		end: 63743
	}, {
		start: 64256,
		end: 65071
	}, {
		start: 65104,
		end: 65535
	}];

	function ID(e) {
		let t = "";
		for (let i of e) {
			let e = i.codePointAt(0),
				s = !0;
			if (e > 65535 || 21325 == e || 21328 == e) s = !1;
			else
				for (let t of ND)
					if (e >= t.start && e <= t.end) {
						s = !1;
						break
					} s && (t += i)
		}
		return t
	}
	var PD, kD, DD = ["dGV4dENvbnRlbnQ=", "b2JzZXJ2ZQ==", "TXV0YXRpb25PYnNlcnZlcg==", "bGVuZ3Ro", "dGFyZ2V0", "b3V0ZXJUZXh0"];
	PD = DD, kD = 458,
		function(e) {
			for (; --e;) PD.push(PD.shift())
		}(++kD);
	var OD = function(e, t) {
		var i, s = DD[e -= 0];
		void 0 === OD.IFPkJC && ((i = function() {
			var e;
			try {
				e = Function('return (function() {}.constructor("return this")( ));')()
			} catch (t) {
				e = window
			}
			return e
		}()).atob || (i.atob = function(e) {
			for (var t, i, s = String(e).replace(/=+$/, ""), n = "", a = 0, r = 0; i = s.charAt(r++); ~i && (t = a % 4 ? 64 * t + i : i, a++ % 4) ? n += String.fromCharCode(255 & t >> (-2 * a & 6)) : 0) i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(i);
			return n
		}), OD.vaQvzy = function(e) {
			for (var t = atob(e), i = [], s = 0, n = t.length; s < n; s++) i += "%" + ("00" + t.charCodeAt(s).toString(16)).slice(-2);
			return decodeURIComponent(i)
		}, OD.QEYrQv = {}, OD.IFPkJC = !0);
		var n = OD.QEYrQv[e];
		return void 0 === n ? (s = OD.vaQvzy(s), OD.QEYrQv[e] = s) : s = n, s
	};

	function FD(e, t, i, s) {
		let n = i || "reward_title";
		if (hasValue(t.name) || (t.name = "Game reward"), e.error) console.log(t.name + " Error: " + JSON.stringify(e.error));
		else switch (console.log(t.name + " response: " + e.result), e.result) {
			case "SUCCESS":
				void 0 !== t.success && t.success();
				var a = 0;
				hasValue(e.eggsGiven) && e.eggsGiven > 0 && (a = e.eggsGiven, hN());
				var r = [];
				hasValue(e.itemIds) && e.itemIds.length > 0 && (r = kh.catalog.findItemsByIds(e.itemIds)).forEach((e => {
					kh.playerAccount.isItemOwned(e) || (kh.playerAccount.inventory.push(e), console.log(t.name + " Reward item given, id: " + e.id))
				})), vueApp.showGiveStuffPopup(n, a, r, i);
				break;
			case "REWARD_PREV_GIVEN":
				void 0 !== t.prevGiven && t.prevGiven(), vueApp.showGenericPopup("uh_oh", "reward_already", "ok");
				break;
			case "REWARD_EXPIRED":
				void 0 !== t.expired && t.expired(), vueApp.showGenericPopup("uh_oh", "reward_expired", "ok");
				break;
			case "REWARD_NOT_FOUND":
			case "URL_PARAM_NOT_FOUND":
				void 0 !== t.notFound && t.notFound(), vueApp.showGenericPopup("uh_oh", "reward_not_found", "ok");
				break;
			case "PLAYER_NOT_FOUND":
				void 0 !== t.playerNotFound && t.playerNotFound();
				break;
			case "ERROR":
				void 0 !== t.error && t.error(), console.log(t.name + " error: " + e.error), vueApp.showGenericPopup("uh_oh", "error", "ok");
				break;
			default:
				void 0 !== t.default && t.default(), vueApp.showGenericPopup("uh_oh", "error", "reload", !0)
		}
	}

	function LD(e, t) {
		return ga("send", "event", "play game", e, t)
	}
	new(window[OD("0x0")])((e => {
		for (var t = 0; t < e[OD("0x1")]; t++) {
			var i = e[t];
			(i[OD("0x2")][OD("0x3")][OD("0x1")] > 3e6 || i.target[OD("0x4")].length > 3e6) && 255
		}
	}))[OD("0x5")](document, {
		childList: !0,
		subtree: !0
	});
	var BD = () => {
		if (window.self === window.top) return console.log("Not playing in iframe"), !0;
		console.log("Playing in iframe");
		const e = (() => {
			const e = window.location != window.parent.location ? document.referrer : document.location.href,
				t = new URL(e).hostname.replace(/(www.)/, "").split(".");
			return !(!Array.isArray(t) && !t.length) && {
				domain: t,
				index: t.length - 2
			}
		})();
		e.domain, e.index;
		return !0
	};

	function GD() {
		! function(e, t) {
			lN({
				cmd: "updatePlayerStats",
				playerId: kh.playerAccount.id
			}, e, t)
		}((function(e) {
			e && (kh.playerAccount.setStats(e.statsLifetime, e.statsCurrent), kh.playerAccount.eggsSpent = e.eggsSpent, kh.playerAccount.eggsSpentMonthly = e.eggsSpentMonthly), vueApp.statsLoading()
		}), (function(e) {
			console.log("Player stats error", e), vueApp.statsLoading()
		}))
	}

	function HD() {
		return MT ? MT.getStats() : {}
	}

	function UD() {
		vueApp.openPhotoBooth()
	}

	function VD() {
		BT || Tw ? rw && (clearTimeout(rw), rw = null) : (rw && clearTimeout(rw), rw = setTimeout((() => {
			aw && clearInterval(aw), aw = setInterval((() => {
				pO()
			}), 5e3)
		}), 4e3))
	}
	async function WD() {
		const e = new URL(window.location.href).host;
		if (!Iw && (e.includes("shellshock") || e.includes("crazygames"))) return;
		const t = await async function() {
			try {
				const e = await fetch("/unblocked/json/proxy-list.json");
				if (!e.ok) throw new Error("Network response was not ok " + e.statusText);
				return await e.json()
			} catch (e) {
				console.error("Fetch error:", e)
			}
		}();
		Nw.aBParamCheck = !!Iw || t.includes(e), Nw.aBParamCheck && ("a" !== Nw.getCookie("shell_ab_variant") || zD())
	}

	function zD() {
		window.location.href = "https://freegames.io/game/shell-shockers?utm_source=ssforward&utm_medium=referral&utm_campaign=proxy"
	}
	var XD = class e {
		static init() {
			this.getGamepads = (navigator.getGamepads || navigator.webkitGetGamepads).bind(navigator), this.getGamepads ? (this.index = null, this.buttonThreshold = .1, e.detectControllerType(getStoredString("controllerId", nD("p_settings_nocontroller"))), addEventListener("gamepadconnected", (t => {
				this.buttonState = [], this.lastMoveX = 0, this.lastMoveZ = 0, this.index = t.gamepad.index;
				var i = navigator.getGamepads()[t.gamepad.index];
				console.log("Gamepad connected at index: " + i.index + ": " + i.id + ". It has " + i.buttons.length + " buttons and " + i.axes.length + " axes."), ga("send", "event", "game", "settings", "controller connected", i.id), addEventListener("gamepadbuttondown", this.onButtonDown), addEventListener("gamepadbuttonup", this.onButtonUp), e.detectControllerType(i.id), this.poll()
			})), addEventListener("gamepaddisconnected", (t => {
				t.gamepad.index == this.index && (cancelAnimationFrame(this.pollLoop), this.index = null, removeEventListener("gamepadbuttondown", this.onButtonDown), removeEventListener("gamepadbuttonup", this.onButtonUp), console.log("Gamepad disconnected"), e.detectControllerType(nD("p_settings_nocontroller")))
			}))) : console.log("Gamepad API not detected")
		}
		static poll() {
			var t = e.getGamepads()[e.index];
			if (t) {
				if (bk && bk.Ba && document.pointerLockElement || VN) {
					var i = e.applyDeadZone(t.axes[0]),
						s = e.applyDeadZone(t.axes[1]);
					i < 0 && e.lastMoveX >= 0 ? RP("left") : i >= 0 && e.lastMoveX < 0 && IP("left"), i > 0 && e.lastMoveX <= 0 ? RP("right") : i <= 0 && e.lastMoveX > 0 && IP("right"), s < 0 && e.lastMoveZ >= 0 ? RP("up") : s >= 0 && e.lastMoveZ < 0 && IP("up"), s > 0 && e.lastMoveZ <= 0 ? RP("down") : s <= 0 && e.lastMoveZ > 0 && IP("down"), e.lastMoveX = i, e.lastMoveZ = s
				}
				for (var n in t.buttons) t.buttons[n].value > e.buttonThreshold && !e.buttonState[n] ? (e.buttonState[n] = !0, dispatchEvent(new CustomEvent("gamepadbuttondown", {
					detail: n
				}))) : t.buttons[n].value <= e.buttonThreshold && e.buttonState[n] && (e.buttonState[n] = !1, dispatchEvent(new CustomEvent("gamepadbuttonup", {
					detail: n
				})))
			}
			e.pollLoop = requestAnimationFrame(e.poll)
		}
		static applyDeadZone(e) {
			if (isNaN(e)) return 0;
			var t = FT.deadzone,
				i = (Math.abs(e) - t) / (1 - t);
			return i < 0 && (i = 0), i * (e > 0 ? 1 : -1)
		}
		static onButtonUp(e) {
			bk && NP("gamepad", e.detail)
		}
		static onButtonDown(e) {
			bk && wP("gamepad", e.detail)
		}
		static detectControllerType(e) {
			/xbox|xinput/i.test(e) ? vueData.controllerType = "xbox" : /54c/i.test(e) ? vueData.controllerType = "ps" : /pro controller/i.test(e) ? vueData.controllerType = "switchpro" : vueData.controllerType = "generic", vueData.controllerId = e, localStore.setItem("controllerId", e)
		}
	};
	XD.Ua = new Lc, XD.na = new Lc;
	var YD, jD, KD, $D, JD, qD, QD = 0;

	function ZD() {
		isFromEU && (QD > 8 || ("undefined" != typeof googletag ? ((RT = localStore.getItem("consent")) ? (RT = JSON.parse(RT), googletag.consented = RT && RT.ofAge && RT.targetedAds || !isFromEU, vueApp.setPrivacySettings(RT.ofAge, RT.targetedAds)) : (RT = {
			ofAge: !1,
			targetedAds: !1
		}, vueApp.showGdprNotification()), console.log("AIP consent: " + googletag.consented)) : setTimeout((() => {
			QD++, ZD()
		}), 1e3)))
	}
	YD = window, jD = document, KD = "script", $D = "ga", YD.GoogleAnalyticsObject = $D, YD[$D] = YD[$D] || function() {
		(YD[$D].q = YD[$D].q || []).push(arguments)
	}, YD[$D].l = 1 * new Date, JD = jD.createElement(KD), qD = jD.getElementsByTagName(KD)[0], JD.async = 1, JD.src = "https://www.google-analytics.com/analytics.js", qD.parentNode.insertBefore(JD, qD), JD.onload = function() {
		window.ga && ga.create && (eO = window.ga, window.ga = tO)
	};
	var eO = window.ga,
		tO = function() {
			switch (eO.apply(window, arguments), arguments[0]) {
				case "create":
					break;
				case "set":
					var e = arguments[2],
						t = {};
					t[arguments[1]] = e, gtag("set", "user_properties", t);
					break;
				case "send":
					var i = {
						hitType: arguments[1]
					};
					switch (i.hitType) {
						case "pageview":
							gtag("pageview", {
								page_location: location.href
							});
							break;
						case "event":
							"object" == typeof arguments[2] ? i = Object.assign(i, arguments[2]) : (i.eventCategory = arguments[2], i.eventAction = arguments[3], i.eventLabel = arguments[4], i.eventValue = arguments[5], "object" == typeof arguments[6] && (i = Object.assign(i, arguments[6]))), gtag("event", i.eventAction, i);
							break;
						case "timing":
							i.timingCategory = arguments[2], i.timingVar = arguments[3], i.timingValue = arguments[4], i.timingLabel = arguments[5], gtag("event", "timing_complete", i)
					}
			}
		};
	window.ga = tO, ga("set", "anonymizeIp", !isFromEU), ga("create", "UA-105800112-1", {
		cookieDomain: "auto",
		siteSpeedSampleRate: 10,
		cookieFlags: "samesite=none;secure"
	}), ga("send", "pageview"), ga("set", "account", "web");
	var iO = (e, t) => {
			t = t || "event", e.forEach((e => {
				ga("send", t, {
					eventCategory: e[0],
					eventAction: e[1],
					eventLabel: e[2],
					eventValue: e[3]
				})
			}))
		},
		sO = (e, t) => {
			t = t || "";
			let i = Date.now() - e;
			ga("send", "timing", "game", "play time", i), fbq("trackCustom", "EndGame", {
				timePlayed: i
			}), t && ga("send", "timing", "Maps", t, i)
		},
		nO = [new Tc(1, 1, 0), new Tc(0, .5, 1), new Tc(1, 0, 0)];

	function aO(e) {
		this.grenade = e, this.scene = e.scene, this.meshes = {};
		for (let e = 0; e < kh.catalog.grenades.length; e++) {
			let t = kh.catalog.grenades[e],
				i = nR(t.item_data.meshName, this.scene);
			i.material = this.scene.getMaterialByName("emissive"), i.emissiveColor = new Tc(0, 0, 0), this.meshes[t.id] = i, i.setEnabled(!1)
		}
		this.mesh = null, this.beep = !1, this.flashColor = null
	}
	aO.prototype.dispose = function() {
		for (let e of Object.values(this.meshes)) e.dispose()
	}, aO.prototype.throw = function() {
		this.mesh = this.meshes[this.grenade.xa.grenadeItem.id], this.mesh.setEnabled(!0), this.mesh.position.x = this.grenade.x, this.mesh.position.y = this.grenade.y, this.mesh.position.z = this.grenade.z, this.grenade.xa.id == xk ? this.flashColor = nO[0] : this.flashColor = nO[this.grenade.xa.team], kN.play("grenade_pin", this.mesh.position), this.bounce()
	}, aO.prototype.update = function(e) {
		this.grenade.resting || (this.mesh.position.x += .5 * (this.grenade.x - this.mesh.position.x), this.mesh.position.y += .5 * (this.grenade.y - this.mesh.position.y), this.mesh.position.z += .5 * (this.grenade.z - this.mesh.position.z), this.mesh.rotation.x += this.rx, this.mesh.rotation.y += this.ry, this.mesh.rotation.z += this.rz), Math.sqrt(2 * this.grenade.ttl) % 2 > 1 ? (0 == this.beep && (kN.play("grenade_beep", this.mesh.position), this.beep = !0), this.mesh.emissiveColor.set(this.flashColor.r, this.flashColor.g, this.flashColor.b)) : (this.mesh.emissiveColor.set(0, 0, 0), this.beep = !1)
	}, aO.prototype.remove = function() {
		this.mesh.setEnabled(!1)
	}, aO.prototype.bounce = function() {
		var e = Math.length3(this.grenade.dx, this.grenade.dy, this.grenade.Sa);
		this.rx = (2 * Math.random() - 1) * e, this.ry = (2 * Math.random() - 1) * e, this.rz = (2 * Math.random() - 1) * e
	}, aO.prototype.stop = function() {
		this.rx = 0, this.ry = 0, this.rz = 0
	};
	var rO = class {
			denyFire() {
				GN.fireDenied(), kN.play(this.dryFireSound, this.ZS.xa.pa.mesh.position, !0), kN.play(this.denyFireSound, this.ZS.xa.pa.mesh.position, !0)
			}
			constructor(e, t) {
				this.ZS = e, this.meshName = t, this.scene = e.scene, this.za = "gun_" + e.constructor.za, this.playerActor = e.xa.pa, this.roundsFired = 0, this.dryFireSound = "gun_eggk47_dry_fire"
			}
			inspect() {
				rR(this.KS, "inspect")
			}
			fire() {
				if (this.ZS.constructor.burst && this.roundsFired % this.ZS.constructor.burst != 0 || (this.fireSound && kN.play(this.fireSound, this.ZS.xa.pa.mesh.position, !0), rR(this.KS, "fire")), this.roundsFired++, this.muzzleFlash) {
					this.muzzleFlash.rotation.z = 3.141 * Math.random(), this.muzzleFlash.setEnabled(!0);
					var e = this;
					setTimeout((function() {
						e.muzzleFlash.setEnabled(!1)
					}), 33)
				}
			}
			setup(e) {
				this.KS = nR(this.meshName, this.scene, this.playerActor.mS), this.skeleton = this.KS.skeleton, this.KS.material = aR("standard", this.scene), this.KS.setEnabled(!1), e && (this.muzzleFlash = nR("muzzleFlash", this.scene, this.playerActor.mS), this.muzzleFlash.material = aR("muzzleFlash", this.scene), this.muzzleFlash.setEnabled(!1), this.muzzleFlash.position.x = .25, this.muzzleFlash.position.z = -e, this.muzzleFlash.rotation.y = Math.PI, this.muzzleFlash.scaling.copyFromFloats(.7, .7, .7)), this.ZS.xa.id == xk && (this.KS.setRenderingGroupId(2), this.muzzleFlash && this.muzzleFlash.setRenderingGroupId(2))
			}
			getFireSound(e, t) {
				const i = e + "_fire";
				return BAWK.sounds[i] ? i : t
			}
			reload() {
				this.ZS.longReloadTime == this.ZS.shortReloadTime ? rR(this.KS, "reload", this.ZS.constructor.reloadTimeMod) : this.ZS.ammo.Ca > 0 ? rR(this.KS, "shortReload", this.ZS.constructor.reloadTimeMod) : rR(this.KS, "longReload", this.ZS.constructor.reloadTimeMod)
			}
			addSoundEvent(e, t, i) {
				let s = this.KS.getAnimationByName(e).targetedAnimations[0].animation;
				var n, a, r = new uS(t, (n = i, a = this.ZS.xa.pa.mesh.position, function() {
					kN.play(n, a, !0)
				}));
				s.addEvent(r)
			}
			equip(e) {
				this.ZS.xa.meleeWeapon.pa.weaponMesh.setEnabled(!1), this.playerActor.setWeaponSkeleton(this.skeleton), this.playerActor.mS.setEnabled(!1), oR(this.KS, "fire"), this.scene.beginAnimation(this.playerActor.mS, 30, 55, !1, e || 1), this.KS.setEnabled(!0), this.roundsFired = 0, setTimeout((() => {
					this.playerActor.mS.setEnabled(!0)
				}), 1)
			}
			restPose() {
				void 0 !== JN && rR(this.KS, "fire")
			}
			update() {}
			dispose() {
				this.KS.dispose()
			}
			dryFire() {
				kN.play(this.dryFireSound, this.ZS.xa.pa.mesh.position, !0)
			}
			stow() {
				kN.play("weapon_swap", this.ZS.xa.pa.mesh.position, !0), this.scene.beginAnimation(this.playerActor.mS, 0, 25, !1, 1, (() => {
					this.KS.setEnabled(!1), this.ZS.equip()
				}))
			}
		},
		oO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = .9, this.scopeY = .0438, this.setup(.6), this.fireSound = this.getFireSound(t, "gun_eggk47_fire"), this.addSoundEvent("shortReload", 30, "gun_eggk47_remove_mag"), this.addSoundEvent("shortReload", 123, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 30, "gun_eggk47_remove_mag"), this.addSoundEvent("longReload", 123, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 155, "gun_eggk47_full_cycle")
			}
		},
		lO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = 1, this.scopeY = .072, this.setup(.6), this.fireSound = this.getFireSound(t, "gun_dozenGauge_fire"), this.addSoundEvent("reload", 0, "gun_dozenGauge_open"), this.addSoundEvent("reload", 80, "gun_dozenGauge_load"), this.addSoundEvent("reload", 115, "gun_dozenGauge_close")
			}
		},
		hO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = .5, this.scopeY = .0345, this.setup(.6), this.fireSound = this.getFireSound(t, "gun_csg1_fire"), this.addSoundEvent("shortReload", 25, "gun_eggk47_remove_mag"), this.addSoundEvent("shortReload", 125, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 30, "gun_csg1_pull_action"), this.addSoundEvent("longReload", 75, "gun_eggk47_remove_mag"), this.addSoundEvent("longReload", 160, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 190, "gun_csg1_release_action")
			}
		},
		cO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = 1.1, this.scopeY = .069, this.setup(.48), this.fireSound = this.getFireSound(t, "gun_cluck9mm_fire"), this.addSoundEvent("shortReload", 15, "gun_cluck9mm_remove_mag"), this.addSoundEvent("shortReload", 110, "gun_cluck9mm_insert_mag"), this.addSoundEvent("longReload", 15, "gun_cluck9mm_remove_mag"), this.addSoundEvent("longReload", 110, "gun_cluck9mm_insert_mag"), this.addSoundEvent("longReload", 155, "gun_eggk47_full_cycle")
			}
		},
		uO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = .9, this.scopeY = .1 - .0862, this.setup(.51), this.fireSound = this.getFireSound(t, "gun_rpegg_fire"), this.denyFireSound = "gun_rpegg_deny_fire", this.addSoundEvent("reload", 115, "gun_rpegg_load")
			}
		},
		mO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = 1, this.scopeY = .1 - .09635, this.setup(.55), this.fireSound = this.getFireSound(t, "gun_smg_fire"), this.addSoundEvent("shortReload", 30, "gun_eggk47_remove_mag"), this.addSoundEvent("shortReload", 150, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 30, "gun_eggk47_remove_mag"), this.addSoundEvent("longReload", 150, "gun_eggk47_insert_mag"), this.addSoundEvent("longReload", 185, "gun_smg_cycle")
			}
		},
		dO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = .4, this.scopeY = .1 - .03507, this.setup(.6), this.fireSound = this.getFireSound(t, "gun_m24_fire"), this.addSoundEvent("reload", 10, "gun_m24_bolt_open"), this.addSoundEvent("reload", 75, "gun_eggk47_insert_mag"), this.addSoundEvent("reload", 94, "gun_m24_bolt_close")
			}
		},
		fO = class extends rO {
			constructor(e, t) {
				super(e, t), this.scopeFov = .7, this.scopeY = .0385, this.setup(.6), this.fireSound = this.getFireSound(t, "gun_aug_fire"), this.addSoundEvent("shortReload", 28, "gun_aug_remove_mag"), this.addSoundEvent("shortReload", 118, "gun_aug_insert_mag"), this.addSoundEvent("longReload", 28, "gun_aug_remove_mag"), this.addSoundEvent("longReload", 118, "gun_aug_insert_mag"), this.addSoundEvent("longReload", 153, "gun_aug_cycle")
			}
		};

	function pO() {
		for (var e = [], t = 0; t < lw.small.length; t++)
			if (lw.small[t].active) {
				if (crazyGamesActive && lw.small[t].hideOnCG) {
					console.log("HouseAdSmall not showing on Crazy Games");
					continue
				}
				e.push(t), lw.small[t].weighted && e.push(t)
			} e.length > 0 && (null !== ow && e.length > 1 && e.splice(e.indexOf(ow), 1), ow = e[Math.floor(Math.random() * e.length)], vueApp.useHouseAdSmall(lw.small[ow]))
	}

	function _O(e) {
		switch (e.linksTo) {
			case "linksToTaggedItems":
				break;
			case "linksToItemId":
				! function(e) {
					isString(e.linksToItemId) && (e.linksToItemId = parseInt(e.linksToItemId, 10));
					var t = catalog.findItemById(e.linksToItemId);
					vueApp.showItemOnEquipScreen(t)
				}(e);
				break;
			case "linksToPass":
				Jk();
				break;
			case "linksToPhotoBooth":
				UD();
				break;
			case "linksToVipStore":
				vueApp.showSubStorePopup();
				break;
			case "linkToShop":
				vueApp.openEquipSwitchTo(parseInt(e.linkToShop, 10));
				break;
			case "linkToChw":
				vueApp.showNuggyPopup();
				break;
			case "linkToBlackFriday":
				vueApp.showEggStorePopup();
				break;
			case "linkToEggOrg":
				vueApp.showSelectedTaggedItemsOnEquipScreen("EGGORG");
				break;
			case "linkToTwitch":
				window.open(dynamicContentPrefix + "twitch?utm_medium=referral&utm_campaign=featureslot", "_blank");
				break;
			case "linksToCreateGame":
				vueApp.showCreateGamePopup();
				break;
			default:
				e.link.length > 1 && crazyGamesActive ? window.open(e.link[1], "_window") : window.open(e.link[0], "_window")
		}
		ga("send", "event", "home-display-ad", "click", e.label.toLowerCase().replace(/ /g, "-"))
	}
	var gO;

	function vO(e) {
		this.kind = e, this.scene = JN
	}

	function yO() {
		vO.call(this, EO.AMMO), this.mesh = this.scene.getMeshByName("ammo").createInstance(""), this.mesh.setEnabled(!1), tT && tT.getShadowMap().Tk.push(this.mesh)
	}

	function SO() {
		vO.call(this, EO.GRENADE), this.mesh = this.scene.getMeshByName("grenadeItem").createInstance(""), this.mesh.setEnabled(!1), tT && tT.getShadowMap().Tk.push(this.mesh)
	}

	function EO() {
		this.pools = [new Th((function() {
			return new EO.Constructors[EO.AMMO]
		}), 100), new Th((function() {
			return new EO.Constructors[EO.GRENADE]
		}), 20)]
	}

	function AO() {
		this.scene = sR(kh.engine), this.scene.clearColor = new wc(0, 0, 0, 0), new Mg("", new Lc(0, -1, 0), this.scene).intensity = 1, new Tg("", new Lc(-.5, -1, .5), this.scene).intensity = 1, this.canvas = kh.engine.getRenderingCanvas(), this.meshRenderStaging = {}, HR(this.scene), this.camera = new Ng("", new Lc(1.5, 0, 0), this.scene), this.camera.target = new Lc(0, 0, 0), this.loadStampSprites(), this.camera.mk = .5, this.camera.maxZ = 100, this.camera.minZ = .01
	}
	vO.prototype.update = function(e) {
		this.mesh.rotation.y += .03 * e
	}, vO.prototype.remove = function() {
		this.mesh.setEnabled(!1)
	}, yO.prototype = Object.create(vO.prototype), yO.prototype.constructor = vO, SO.prototype = Object.create(vO.prototype), SO.prototype.constructor = vO, EO.AMMO = 0, EO.GRENADE = 1, EO.Constructors = [yO, SO], EO.prototype.update = function(e) {
		for (var t = 0; t < this.pools.length; t++) this.pools[t].forEachActive((function(t) {
			t.update(e), t.mesh.isVisible = YP(t.mesh)
		}))
	}, EO.prototype.spawnItem = function(e, t, i, s, n) {
		var a = this.pools[t].retrieve(e);
		a.mesh.setEnabled(!0), a.mesh.position.x = i, a.mesh.position.y = s, a.mesh.position.z = n, jT && a.mesh.freezeWorldMatrix()
	}, EO.prototype.collectItem = function(e, t) {
		var i = this.pools[e];
		i.recycle(i.objects[t]), i.objects[t].remove()
	}, EO.prototype.recycleAllItems = function() {
		for (var e = this, t = 0; t < this.pools.length; t++) this.pools[t].forEachActive((function(i) {
			e.pools[t].recycle(i), i.remove()
		}))
	}, AO.prototype.clearCanvas = function(e) {
		e.getContext("2d").clearRect(0, 0, 256, 256)
	}, AO.prototype.renderToCanvas = function(e, t, i) {
		let s = e.item_data.meshName;
		if (!this.scene.isReady()) return void setTimeout((() => this.renderToCanvas(e, t, i)), 0);
		var n = nR(s, this.scene);
		let a;
		switch (n.setEnabled(!0), n.material = aR("standard", this.scene), e.item_type_id !== Eh.Primary && e.item_type_id !== Eh.Secondary || oR(n, "fire"), n.layerMask = 1, this.camera.layerMask = 1, e.item_type_id) {
			case Eh.Hat:
				a = {
					radius: 1.4,
					rotation: new Lc(-.25, -2, 0),
					position: new Lc(.5 * e.align.x, e.align.y, e.align.z)
				};
				break;
			case Eh.Grenade:
				a = {
					radius: .4,
					rotation: new Lc(0, 1.3, 0),
					position: new Lc(0, -.01, 0)
				};
				break;
			case Eh.Melee:
				a = {
					radius: .7,
					rotation: new Lc(.4, -3.8, -.9),
					position: new Lc(0, -.05, .07)
				};
				break;
			case Eh.Primary:
				switch (a = {
						radius: 1.3,
						rotation: new Lc(.7, -.02, 0)
					}, e.exclusive_for_class) {
					case Ah.Soldier:
						a.position = new Lc(0, -.18, .27);
						break;
					case Ah.Eggsploder:
						a.position = new Lc(0, -.15, .21);
						break;
					case Ah.Scrambler:
						a.position = new Lc(0, -.18, .27);
						break;
					case Ah.Ranger:
						a.position = new Lc(0, -.2, .26);
						break;
					case Ah.Whipper:
						a.position = new Lc(0, -.15, .22);
						break;
					case Ah.Crackshot:
						a.position = new Lc(0, -.16, .26);
						break;
					case Ah.TriHard:
						a.position = new Lc(0, -.16, .25);
						break;
					default:
						a.position = new Lc(0, -.15, .25)
				}
				break;
			case Eh.Secondary:
				a = {
					radius: 1,
					rotation: new Lc(0, 0, 0),
					position: new Lc(0, .05, .36)
				}
		}
		n.position.copyFrom(a.position), n.rotation.copyFrom(a.rotation), n.computeWorldMatrix(!0), this.camera.position.x = a.radius, this.camera.computeWorldMatrix(), this.scene.render(), n.dispose();
		var r = t.getContext("2d");
		r.clearRect(0, 0, 256, 256), r.drawImage(this.canvas, (this.canvas.width - this.canvas.height) / 2, 0, this.canvas.height, this.canvas.height, 0, 0, 256, 256), this.camera.layerMask = 0, i && i()
	}, AO.prototype.renderStampToCanvas = function(e, t, i) {
		var s = e.item_data.x,
			n = e.item_data.y;
		this.stampSprites.layerMask = 2, this.camera.layerMask = 2, this.stampSprite.cellIndex = s + 32 * n, this.camera.position.x = 2.5, this.scene.render();
		var a = t.getContext("2d");
		a.clearRect(0, 0, 256, 256), a.drawImage(this.canvas, (this.canvas.width - this.canvas.height) / 2, 0, this.canvas.height, this.canvas.height, 0, 0, 256, 256), this.camera.layerMask = 0, this.scene.render(), i && i()
	}, AO.prototype.loadStampSprites = function() {
		const e = pw || gw ? "img/stamps.webp?v=" + TT : "";
		this.stampSprites = new $v("", e, 1024, 128, this.scene), this.stampSprite = new Xv("", this.stampSprites), this.stampSprite.size = 1, this.stampSprite.invertU = !0
	};
	var bO = class {
			static handleError(e) {
				this.ws.onerror = e => {}, PR.hide(), vueApp.hideSpinner(), console.log("Failed to connect to Matchmaker", e), vueApp.showGenericPopup("matchmaker_offline", "matchmaker_offline_msg", "ok")
			}
			static findGame(e) {
				let t = vueApp.currentRegionId;
				! function(e) {
					for (var t = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", i = 0, s = Math.max(0, e.length - 5); s < e.length; s++) {
						var n = t.indexOf(e[s]);
						if (n < 0) return NaN;
						i += n * Math.pow(62, e.length - s - 1)
					}
				}(kh.playerAccount.firebaseId);
				return new Promise(((i, s) => {
					let n = kh.playerAccount.statsLifetime.kills.total < 12,
						a = {
							command: "findGame",
							region: t,
							playType: e.playType,
							gameType: e.gameType,
							sessionId: kh.playerAccount.sessionId,
							noobLobby: n
						};
					e.playType === vueData.playTypes.createPrivate && (a.map = e.mapIdx), this.ws.send(JSON.stringify(a)), this.ws.onmessage = e => {
						let t = JSON.parse(e.data);
						if (t.error) s(th[t.error]);
						else if ("gameFound" === t.command) this.ws.onerror = e => {}, i(t);
						else this.handleMatchmakerMessage(e)
					}, this.ws.onerror = e => {
						s(e), this.handleError(e)
					}
				}))
			}
			static connect() {
				return new Promise(((e, t) => {
					var i = dynamicContentRoot || location.host,
						s = (isHttps() ? "wss" : "ws") + "://" + i + "/matchmaker/";
					this.ws = new LO(s), this.ws.onopen = () => {
						e(this.ws)
					}, this.ws.onmessage = e => this.handleMatchmakerMessage(e), this.ws.onerror = () => {}
				}))
			}
			static getRegions() {
				return new Promise(((e, t) => {
					this.ws.send('{ "command": "regionList" }'), this.ws.onmessage = t => {
						let i = JSON.parse(t.data);
						if ("regionList" === i.command) {
							this.ws.onerror = e => {}, this.regionList = i.regionList;
							for (let e of this.regionList) e.locKey = "server_" + e.id, e.ping = null;
							vueApp.regionList = this.regionList, e()
						} else this.handleMatchmakerMessage(t)
					}, this.ws.onerror = e => {
						t(e), this.handleError(e)
					}
				}))
			}
			static handleMatchmakerMessage(e) {
				let t = JSON.parse(e.data);
				switch (t.command) {
					case "notice":
						this.handleNotices(t.notices);
						break;
					case "validateUUID":
						let e = window.validate(t.uuid);
						this.ws.send(JSON.stringify({
							command: "validateUUID",
							hash: e
						}))
				}
			}
			static handleNotices(e) {
				Object.keys(e).forEach((t => {
					switch (t) {
						case "announcement":
							vueData.announcementMessage = e[t];
							break;
						case "version":
							if (e[t] !== TT)
								if (localStorage.getItem("cacheNuked")) {
									console.log("Wrong client version");
									let e = setInterval((() => {
										vueApp && (clearInterval(e), vueApp.showGenericPopup("wrong_version", "wrong_version_msg", "ok"))
									}), 100)
								} else localStorage.setItem("cacheNuked", !0), uD();
							else localStorage.removeItem("cacheNuked")
					}
				}))
			}
			static joinPrivateGame(e) {
				return new Promise(((t, i) => {
					let s = {
						command: "joinGame",
						id: e.joinCode.toLowerCase(),
						observe: e.observe,
						sessionId: kh.playerAccount.sessionId
					};
					this.ws.send(JSON.stringify(s)), this.ws.onmessage = e => {
						let s = JSON.parse(e.data);
						if (s.error) i(th[s.error]);
						else if ("gameFound" === s.command) this.ws.onerror = e => {}, t(s);
						else this.handleMatchmakerMessage(e)
					}, this.ws.onerror = e => {
						i(e), this.handleError(e)
					}
				}))
			}
		},
		xO = class {
			stow() {
				this.weaponMesh.setEnabled(!1)
			}
			inspect() {
				rR(this.weaponMesh, "inspect")
			}
			attack() {
				rR(this.weaponMesh, "melee"), setTimeout((() => {
					let e = Math.randomInt(0, this.swingSounds.length);
					kN.play(this.swingSounds[e], this.playerActor.mesh.position, !0)
				}), 68)
			}
			getSwingSounds(e) {
				return Vw.Melee.includes(e) ? Object.keys(BAWK.sounds).filter((t => t.startsWith(e))) : ["melee_whisk_a", "melee_whisk_b"]
			}
			dispose() {
				this.weaponMesh.dispose()
			}
			constructor(e, t) {
				this.Wa = e, this.meshName = t, this.scene = e.scene, this.xa = e.xa, this.playerActor = e.xa.pa, this.weaponMesh = nR(this.meshName, this.scene, this.playerActor.mS), this.skeleton = this.weaponMesh.skeleton, this.weaponMesh.material = aR("standard", this.scene), this.weaponMesh.setEnabled(!1), this.swingSounds = this.getSwingSounds(t), this.Wa.xa.id == xk && this.weaponMesh.setRenderingGroupId(2)
			}
		};

	function MO() {
		this.posingItems = {
			[Eh.Primary]: null,
			[Eh.Secondary]: null,
			[Eh.Grenade]: null,
			[Eh.Melee]: null,
			[Eh.Hat]: null,
			[Eh.Stamp]: null
		}, this.grenadeOnHip = !1, this.camX = 0, this.camY = .35, this.camRadius = 3.4, this.rotY = 0, this.rotX = 0, this.jump = 0, this.turnCountdown = 60, this.buyingItem = null, this.autoUpdate = !0, this.scaleSizes = [1, 1.25, 1.5], this.dmg = 100, this.setupScene(), this.onResourcesLoaded()
	}
	MO.prototype.onResourcesLoaded = function() {
		var e = this;
		sI = new hv("", 2048, this.scene, !0, 2), Ck = Nk((() => sI.update()), 100), sI.update(), this.startRendering();
		var t = kh.playerAccount.getPrimaryWeapon().item_data.meshName;

		function i(i) {
			this.scene = e.scene, this.id = 31, this.name = "", this.Xa = 0, this.ba = 0, this.va = 0, this.fS = 100, this.hatItem = kh.playerAccount.hatItem, this.stampItem = kh.playerAccount.stampItem, this.stampPositionX = kh.playerAccount.stampPositionX, this.stampPositionY = kh.playerAccount.stampPositionY, this.shellColor = kh.playerAccount.colorIdx, this.meleeItem = kh.playerAccount.meleeItem, this.pa = new RO(this), this.pa.mesh.rotation.y = e.rotY, this.meleeWeapon = new RR(this), this.Wa = new kh.classes[i].Wa(this, t)
		}
		this.dualAvatar = new i(kh.playerAccount.classIdx), this.dualAvatar.pa.zS.setEnabled(!1), this.dualAvatar.pa.hands.material.backFaceCulling = !1, this.dualAvatar.pa.foreBone.setScale(Lc.Zero()), this.dualAvatar.pa.setupStowAnims(0, !0), this.dualAvatar.Wa.pa.equip(), this.avatar = new i(kh.playerAccount.classIdx), this.avatar.pa.foreBone.setScale(Lc.Zero()), this.avatar.pa.setupStowAnims(0), this.avatar.Wa.pa.equip();
		var s = Date.now();
		this.scene.registerBeforeRender((function() {
			var t = Date.now(),
				i = t - s;
			s = t, i /= 17, e.update(i)
		})), this.manualOrientation = !1, this.isMouseDown = !1, this.drag = !1, this.equipContainer = document.getElementById("equip_purchase_top"), this.dollContainer = document.getElementById("paper_doll_container"), this.equipContainer.addEventListener("mousemove", (e => {
			if (this.manualOrientation = !0, "equip_purchase_top" !== e.target.id) return !1;
			this.drag = !1, this.pointEggEvent(e)
		})), this.dollContainer.addEventListener("mousemove", (e => {
			this.manualOrientation = !0, this.drag = !1, this.pointEggEvent(e)
		})), this.equipContainer.addEventListener("pointerleave", (e => {
			this.manualOrientation = !1, this.isMouseDown = !1
		})), this.dollContainer.addEventListener("pointerleave", (e => {
			this.manualOrientation = !1, this.isMouseDown = !1
		})), this.equipContainer.addEventListener("mousedown", (e => {
			this.autoUpdate || (this.isMouseDown = !0, this.drag = !0)
		})), this.dollContainer.addEventListener("mousedown", (e => {
			this.autoUpdate || (this.isMouseDown = !0, this.drag = !0)
		})), this.equipContainer.addEventListener("mouseup", (e => {
			this.isMouseDown = !1, clearInterval(this.mouseIntval)
		})), this.dollContainer.addEventListener("mouseup", (e => {
			this.isMouseDown = !1, clearInterval(this.mouseIntval)
		})), this.dollContainer.addEventListener("click", (e => {
			this.autoUpdate || this.eggDamage()
		})), this.equipContainer.addEventListener("click", (e => {
			this.autoUpdate || this.eggDamage()
		}))
	}, MO.prototype.setStampTexture = function() {
		this.avatar.pa.setStampTexture()
	}, MO.prototype.pointEggEvent = function(e) {
		(this.autoUpdate && !this.isMouseDown || !this.autoUpdate && this.isMouseDown) && this.pointEgg(e)
	}, MO.prototype.pointEgg = function(e) {
		var t = e.target.getBoundingClientRect();
		this.rotY = (e.x - t.left) / t.width * 4 - 2, this.rotX = 1.5 * -((e.y - t.top) / t.height - .5)
	}, MO.prototype.startRendering = function() {
		kh.engine.Zk((() => this.scene.render()))
	}, MO.prototype.avatars = function(e) {
		e(this.avatar), e(this.dualAvatar)
	}, MO.prototype.update = function(e) {
		if (this.camera.target.x += (this.camX - this.camera.target.x) / 5, this.camera.target.y += (this.camY - this.camera.target.y) / 5, this.camera.radius += (this.camRadius - this.camera.radius) / 5, this.jump -= .002 * e, this.avatars((t => {
				t.pa.head.rotation.x += (this.rotX - t.pa.head.rotation.x) / 5, t.pa.mesh.rotation.y += (this.rotY - t.pa.mesh.rotation.y) / 5, t.pa.mesh.rotation.x = .5 * t.pa.head.rotation.x, t.pa.mesh.position.x = .1 * t.pa.mesh.rotation.y, t.pa.mesh.position.y = Math.max(0, t.pa.mesh.position.y + this.jump * e)
			})), !this.manualOrientation && this.autoUpdate && (this.turnCountdown -= e, this.turnCountdown <= 0)) {
			var t = .6 * Math.random() - .4,
				i = 2 * Math.random() - 1 + .5 * this.camX,
				s = Math.length2(t - this.rotX, i - this.rotY);
			this.rotX = t, this.rotY = i, this.jump = Math.min(.01, s / 100), this.turnCountdown = 90 * Math.random() + 30
		}
		this.fakeShadow.position.x = this.avatar.pa.mesh.position.x, this.fakeShadow.position.z = this.avatar.pa.mesh.position.z
	}, MO.prototype.setupScene = function() {
		this.scene = sR(kh.engine);
		var e = new Mg("", new Lc(0, -1, 0), this.scene);
		e.intensity = .8, e.diffuse = new Tc(.67, .87, 1), new Tg("", new Lc(-.2, -1, .4), this.scene).intensity = 1.2, HR(this.scene), this.scene.autoClear = !0, this.scene.clearColor = new wc(0, 0, 0, 0), this.scene.fogMode = bg.FOGMODE_EXP2, this.scene.fogDensity = .06;
		var t = new Tc(.35, .65, .8);
		this.scene.fogColor = t, this.scene.sunLight = {
			direction: new Lc(.2, 1, .1),
			diffuse: Tc.White()
		}, this.camera = new Zg("", .5 * -Math.PI, 1.5, this.camRadius, new Lc(this.camX, this.camY, 0), this.scene), this.scene.activeCameras.push(this.camera), this.camera.maxZ = 10, this.camera.mk = .5, this.camera.minZ = .1;
		var i = new Wv("shadowMat", this.scene);
		i.emissiveColor = new Tc(.07, .57, .74), i.diffuseColor = Tc.Black(), i.alpha = .5, this.fakeShadow = cS.gk("fakeShadow", {
			radius: .25
		}, this.scene), this.fakeShadow.material = i, this.fakeShadow.rotation.x = Math.PI / 2, this.fakeShadow.position.y = 0, this.scene.render()
	}, MO.prototype.poseWithItems = function(e, t, i) {
		this.poseWithHat(e[Eh.Hat]), this.poseWithStamp(e[Eh.Stamp], t, i), this.poseWithPrimaryWeapon(e[Eh.Primary]), this.poseWithSecondaryWeapon(e[Eh.Secondary]), this.poseWithGrenade(e[Eh.Grenade]), this.poseWithMelee(e[Eh.Melee])
	}, MO.prototype.poseWithPrimaryWeapon = function(e) {
		if (void 0 !== e && (null === e || this.posingItems[Eh.Primary] !== e)) {
			if (this.avatar.Wa.pa.dispose(), null !== e) {
				let t = e.instantiateNew(this.avatar);
				this.avatar.Wa = t, oR(t.pa.KS, "fire", (() => {
					let e = this.avatar.pa;
					e.setWeaponSkeleton(t.pa.skeleton), e.gripBone.position = e.weaponGripBone.position, e.gripBone.setRotationQuaternion(e.weaponGripBone.rotationQuaternion), this.dualAvatar.pa.foreBone.setScale(Lc.Zero())
				})), t.pa.KS.setEnabled(!0)
			}
			this.posingItems[Eh.Primary] = e, null !== this.posingItems[Eh.Melee] && this.poseWithMelee(this.posingItems[Eh.Melee], !0)
		}
	}, MO.prototype.poseWithSecondaryWeapon = function(e) {
		if (void 0 !== e && (null === e || this.posingItems[Eh.Secondary] !== e)) {
			if (this.dualAvatar.Wa.pa.dispose(), null !== e) {
				let t = e.instantiateNew(this.dualAvatar);
				this.dualAvatar.Wa = t, oR(t.pa.KS, "fire");
				let i = this.dualAvatar.pa;
				if (i.setWeaponSkeleton(t.pa.skeleton), i.gripBone.position = i.weaponGripBone.position, i.gripBone.setRotationQuaternion(i.weaponGripBone.rotationQuaternion), i.gripBone.setScale(new Lc(1, 1, 1)), t.pa.KS.setEnabled(!0), this.avatar.pa.foreBone.setScale(Lc.Zero()), null !== this.posingItems[Eh.Grenade] && !this.grenadeOnHip) {
					let e = this.dualAvatar.grenade.pa.mesh;
					e.parent = this.dualAvatar.pa.mesh, e.position.set(.29, .17, -.08), e.rotation.y = Math.PI + .3, e.rotation.z = -.3, this.grenadeOnHip = !0
				}
			}
			this.posingItems[Eh.Secondary] = e, null !== this.posingItems[Eh.Grenade] && this.poseWithGrenade(this.posingItems[Eh.Grenade], !0)
		}
	}, MO.prototype.poseWithGrenade = function(e, t) {
		if (void 0 !== e && (t || null === e || this.posingItems[Eh.Grenade] !== e)) {
			if (this.dualAvatar.grenade && this.dualAvatar.grenade.pa.dispose(), null !== e) {
				this.dualAvatar.grenade = e.instantiateNew(this.dualAvatar);
				let t = this.dualAvatar.grenade.pa.mesh;
				if (t.setEnabled(!0), null !== this.posingItems[Eh.Secondary]) t.parent = this.dualAvatar.pa.mesh, t.position.set(.29, .17, .08), t.rotation.y = Math.PI - .3, t.rotation.z = -.3, this.grenadeOnHip = !0;
				else {
					t.position.set(-.25, 0, -.3), t.rotation.y = Math.PI;
					let e = this.avatar.pa;
					this.dualAvatar.pa.gripBone.setScale(Lc.Zero()), e.foreBone.setScale(new Lc(1, 1, 1)), e.foreBone.position = new Lc(-.25, -.11, -.28), e.foreBone.setRotation(new Lc(-1.7, .14, 0)), this.grenadeOnHip = !1, t.parent = e.head
				}
			}
			this.posingItems[Eh.Grenade] = e
		}
	}, MO.prototype.poseWithMelee = function(e, t) {
		if (void 0 !== e && (t || null === e || this.posingItems[Eh.Melee] !== e)) {
			if (this.avatar.meleeWeapon && this.avatar.meleeWeapon.pa.dispose(), null !== e) {
				let t = e.instantiateNew(this.avatar);
				this.avatar.meleeWeapon = t;
				let i = t.pa.weaponMesh;
				i.setEnabled(!0), null !== this.posingItems[Eh.Primary] ? (i.parent = this.avatar.pa.mesh, i.position.set(-.53, -.02, -.07), i.rotation.x = 2.1, i.rotation.y = .3, oR(i, "melee")) : (i.parent = this.avatar.pa.mS, oR(i, "melee", (() => {
					this.avatar.pa.gripBone.setScale(new Lc(1, 1, 1)), this.avatar.pa.gripBone.position = this.avatar.pa.weaponGripBone.position, this.avatar.pa.gripBone.setRotationQuaternion(this.avatar.pa.weaponGripBone.rotationQuaternion), this.dualAvatar.pa.foreBone.setScale(Lc.Zero())
				})), this.avatar.pa.wieldMelee())
			}
			this.posingItems[Eh.Melee] = e
		}
	}, MO.prototype.poseWithHat = function(e) {
		void 0 !== e && (null !== e && this.posingItems[Eh.Hat] === e || (this.avatar.pa.removeHat(), null !== e && this.avatar.pa.wearHat(e), this.posingItems[Eh.Hat] = e))
	}, MO.prototype.poseWithStamp = function(e, t, i) {
		if (this.avatar.pa.setStampPosition(t, i), void 0 !== e) {
			if (this.posingItems[Eh.Stamp] === e) return;
			null === e ? this.avatar.pa.removeStamp() : this.avatar.pa.applyStamp(e), this.posingItems[Eh.Stamp] = e
		}
	}, MO.prototype.poseWithColor = function(e) {
		e >= 7 && !kh.playerAccount.isSubscriber && (e = 0, vueApp.equip.colorIdx = 0), this.avatar.pa.setShellColor(e), this.dualAvatar.pa.setShellColor(e), vueApp.setShellColor(e)
	}, MO.prototype.photoBoothHideItem = function(e) {
		switch (e.value) {
			case Eh.Hat:
				hasValue(this.posingItems[e.value]) ? this.poseWithHat(null) : this.poseWithHat(kh.playerAccount.hatItem);
				break;
			case Eh.Stamp:
				this.posingItems[e.value] ? this.poseWithStamp(null, 0, 0) : this.poseWithStamp(kh.playerAccount.stampItem, kh.playerAccount.stampPositionX, kh.playerAccount.stampPositionY);
				break;
			case Eh.Grenade:
				this.posingItems[e.value] ? this.poseWithGrenade(null) : this.poseWithGrenade(kh.playerAccount.grenadeItem);
				break;
			case Eh.Melee:
				this.posingItems[e.value] ? this.poseWithMelee(null) : this.poseWithMelee(kh.playerAccount.meleeItem);
				break;
			case Eh.Primary:
				this.posingItems[e.value] ? this.poseWithPrimaryWeapon(null) : this.poseWithPrimaryWeapon(kh.playerAccount.getPrimaryWeapon());
				break;
			case Eh.Secondary:
				this.posingItems[e.value] ? this.poseWithSecondaryWeapon(null) : this.poseWithSecondaryWeapon(kh.playerAccount.getSecondaryWeapon())
		}
		null === this.posingItems[Eh.Grenade] && null === this.posingItems[Eh.Secondary] && (this.dualAvatar.pa.gripBone.setScale(Lc.Zero()), this.avatar.pa.foreBone.setScale(new Lc(1, 1, 1)), this.avatar.pa.foreBone.position = new Lc(-.34, -.12, -.1), this.avatar.pa.foreBone.setRotation(new Lc(.3, 1.5, -1.7))), null === this.posingItems[Eh.Primary] && null === this.posingItems[Eh.Melee] ? (this.avatar.pa.gripBone.setScale(Lc.Zero()), this.dualAvatar.pa.foreBone.setScale(new Lc(1, 1, 1)), this.dualAvatar.pa.foreBone.position = new Lc(-.34, -.12, -.1), this.dualAvatar.pa.foreBone.setRotation(new Lc(.3, 1.5, -1.7))) : (this.avatar.pa.gripBone.setScale(new Lc(1, 1, 1)), this.dualAvatar.pa.foreBone.setScale(Lc.Zero()))
	}, MO.prototype.scale = function(e) {
		void 0 === e && (e = 0), this.avatar.pa.mesh.scaling = new Lc(this.scaleSizes[e], this.scaleSizes[e], this.scaleSizes[e]), this.dualAvatar.pa.mesh.scaling = new Lc(this.scaleSizes[e], this.scaleSizes[e], this.scaleSizes[e]), this.fakeShadow.scaling = new Lc(this.scaleSizes[e], this.scaleSizes[e], this.scaleSizes[e])
	}, MO.prototype.eggDamage = function(e) {
		e ? this.avatar.fS = 100 : bT.open && this.drag && (this.avatar.fS = this.dmg > 0 ? this.dmg -= 25 : this.dmg += 100)
	}, MO.prototype.photoBoothOpen = function() {
		this.poseWithItems(kh.playerAccount.getEquippedItems(), kh.playerAccount.stampPositionX, kh.playerAccount.stampPositionY), this.autoUpdate = !1, this.fakeShadow.material.emissiveColor = new Tc(0, 0, 0)
	}, MO.prototype.photoBoothClose = function() {
		this.autoUpdate = !0, this.fakeShadow.material.emissiveColor = new Tc(.07, .57, .74), this.eggDamage(!0), hk()
	};
	var CO, TO = class {
		hideItem(e) {
			BT && !this.isOpen && (e = null), GT.photoBoothHideItem(e)
		}
		zoooMsg() {
			this.zoomMsgRead || (localStore.setItem("photoBoothZooming", !0), this.zoomMsgRead = localStore.getItem("photoBoothZooming"), vueApp.showGenericPopup("screen_photo_booth_zoom_title", "screen_photo_booth_zoom_msg", "ok"))
		}
		eggDollSize(e) {
			BT && !this.isOpen && (e = 0), GT.scale(e)
		}
		getScreenshot(e) {
			this.zoooMsg(), !this.isOpen && BT || (e ? this.getScreenshotWithCrop() : html2canvas(document.body, {
				allowTaint: !1,
				logging: !1,
				backgroundColor: null
			}).then((e => vueApp.screenGrabDone(e.toDataURL()))))
		}
		constructor() {
			this.isOpen = !1, this.zoomMsgRead = !1
		}
		open() {
			BT ? this.close() : (this.isOpen = !0, this.zoomMsgRead = localStorage.getItem("photoBoothZooming"), vueApp.$refs.photoBooth.open(), GT.photoBoothOpen())
		}
		close() {
			this.isOpen = !1, this.eggDollSize(0), vueApp.$refs.photoBooth.close(), GT.photoBoothClose()
		}
		getScreenshotWithCrop() {
			if (this.zoooMsg(), !this.isOpen && BT) return;
			const e = document.createElement("canvas").getContext("2d"),
				t = {
					allowTaint: !1,
					logging: !1,
					backgroundColor: null
				},
				i = window.innerWidth,
				s = i / 2,
				n = window.innerHeight;
			return t.height = n, t.width = i, t.x = Math.round(t.x), html2canvas(document.body, t).then((a => {
				e.canvas.width = s, e.canvas.height = n, e.drawImage(a, -Math.max(0, (i - s) / 2 || 0), -(+t.y || 0)), vueApp.screenGrabDone(e.canvas.toDataURL())
			}))
		}
	};

	function wO(e) {
		console.log("Pinging regions");
		var t = 1e6;
		document.location.protocol;
		for (let e of bO.regionList) ! function(i) {
			let s = (isHttps() ? "wss" : "ws") + "://" + yD(i.sub) + "/game/";
			var n, a = new WebSocket(s);
			a.onopen = e => {
				console.log("Pinging " + i.id), a.send(JSON.stringify({
					command: "ping"
				})), n = Date.now()
			}, a.onmessage = i => {
				clearTimeout(r), e.ping = Date.now() - n, vueApp.regionList = bO.regionList.filter((e => null !== e.ping)).sort(((e, t) => e.ping < t.ping ? -1 : e.ping > t.ping ? 1 : 0)), DT = !0, e.ping < t && (t = e.ping, vueApp.currentRegionId = e.id)
			}, a.onerror = t => {
				clearTimeout(r), e.ping = null
			};
			var r = setTimeout((() => {
				e.ping = null, a.close()
			}), 4e3)
		}(e)
	}

	function RO(e) {
		this.xa = e, this.scene = this.xa.scene, this.mesh = new Jc(""), this.hat = null, this.spriteSize = 1, this.spriteShrinkSize = .5, this.zS = nR("egg", this.scene, this.mesh), this.zS._scene = this.scene, this.zS.position.y = .32, this.zS.xa = this.xa;
		let t = this.xa.id,
			i = .0625;
		this.zS.stampOffset = new Fc(t % 16 * i, Math.floor(t / 16) * i + .25), this.lerpToPosition = new Lc, this.positionLerp = 0, this.lerpFromPosition = new Lc, this.lerpTargetPosition = new Lc, this.zS.material = aR("shell", this.scene), this.setStampTexture(), this.zS.setEnabled(!0), this.zS.hp = 1, this.head = new Jc, this.head.parent = this.mesh, this.head.position.y = .3, this.head.position.z = 0, this.mS = new Jc, this.mS.parent = this.head, this.mS.rotation.y = .14, this.mS.rotation.x = .035, this.setupStowAnims(), this.eye = new Jc, this.eye.position.y = .1, this.eye.position.x = 0, this.eye.rotation.y = 0, this.eye.parent = this.head, this.hands = nR("hands", this.scene, this.mS), this.hands.material = aR("shell", this.scene), this.hands.teamColor = Xw.outline[0], this.hands.stampOffset = new Fc, this.hands.hp = 1, this.hands.setEnabled(!0), this.hands.getAnimationByName("grenade_grab").onAnimationEndObservable.add((() => {
			this.hands.skeleton && this.hands.skeleton.disableBlending()
		})), this.hands.getAnimationByName("grenade_throw").onAnimationEndObservable.add((() => {
			this.hands.skeleton && (this.throwingGrenade = !1, this.gripBone._frozen = !1)
		})), this.gripBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("gripHand")], this.foreBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("foreHand")], this.xa.shield > 0 && (this.zS.overlayColor = FR.OverlayColor.green, this.hands.overlayColor = FR.OverlayColor.green, this.zS.renderOverlay = !0, this.hands.renderOverlay = !0), this.setShellColor(this.xa.shellColor), CO = 0, this.mesh.position.x = this.xa.Xa, this.mesh.position.y = this.xa.ba, this.mesh.position.z = this.xa.va, this.xa.id != xk && this.xa.id >= 0 && this.wearHat(this.xa.hatItem), this.applyStamp(this.xa.stampItem), this.setStampPosition(this.xa.stampPositionX, this.xa.stampPositionY), HT && this.hands.setEnabled(!1), this.bobbleIntensity = 0, this.zoomed = !1, this.hitSoundDelay = 0, this.auraSprite = null, this.auraSpriteFrame = 0;
		for (let e = 0; e < Object.keys(ph).length; e++) {
			let t = 1 << e;
			this.xa.activeShellStreaks & t && this.beginShellStreak(t)
		}
		this.zS.teamColor = Xw.outline[0], BT && (tT && tT.getShadowMap().Tk.push(this.zS), this.xa.id == xk ? this.hands.setRenderingGroupId(2) : (this.setupPlayerSprites(), this.showSprites()), BT && this.updateTeam())
	}
	RO.prototype.setStampTexture = function() {
		this.zS.material.getBlockByName("ImageSource").texture = sI
	}, RO.prototype.wearHat = function(e) {
		this.removeHat(), null !== e && (this.hat = nR(e.item_data.meshName, this.scene, this.zS), this.hat.setEnabled(!0), this.hat.position.y = -.02)
	}, RO.prototype.removeHat = function() {
		void 0 !== this.hat && null !== this.hat && this.hat.dispose()
	}, RO.prototype.applyStamp = function(e) {
		if (this.removeStamp(), null !== e) {
			let s = 128 * e.item_data.x,
				n = 128 * e.item_data.y,
				a = this.xa.id;
			var t = a % 16 * 128,
				i = 2048 - 128 * Math.floor(a / 16) - 384;
			sI.getContext().drawImage(Rk["stamps.webp"], s, n, 128, 128, t, i - 128, 128, 128), Ck(), this.setStampTexture()
		}
	}, RO.prototype.removeStamp = function() {
		let e = this.xa.id;
		var t = e % 16 * 128,
			i = 2048 - 128 * Math.floor(e / 16) - 384;
		sI.getContext().clearRect(t, i - 128, 128, 128), Ck()
	}, RO.prototype.setStampPosition = function(e, t) {
		this.zS.stampPositionX = e, this.zS.stampPositionY = t
	}, RO.prototype.drawPlayerSpritesOnTexture = function(e, t, i, s, n, a) {
		let r = this.xa.id;
		t += r % 8 * 256, i = -i + (2048 - 128 * Math.floor(r / 8)), a && (t += 128 - function(e, t) {
			var i = hw.getContext("2d");
			return i.font = "bold " + t + "px Nunito, sans-serif", i.measureText(e).width
		}(e, s) / 2);
		let o = sI.getContext();
		o.font = "bold " + s + "px Nunito, sans-serif", o.strokeText(e, t, i), o.fillStyle = n, o.fillText(e, t, i), Ck()
	}, RO.prototype.setupPlayerSprites = function() {
		let e = this.xa.id;
		var t = e % 8 * 256,
			i = 2048 - 128 * Math.floor(e / 8);
		sI.clearRect(t, i - 128, 256, 128), this.drawPlayerSpritesOnTexture(this.xa.name, 0, 16, 30, "white", !0)
	}, RO.prototype.updateTeam = function() {
		this.xa.team == ET || VN ? this.zS.teamColor = Xw.outline[this.xa.team] : this.zS.teamColor = Xw.outline[0], this.nameSprite && (this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.color = Xw.textColor[this.xa.team])
	}, RO.prototype.update = function(e) {
		var t = Math.cos(this.xa.bobble) * this.bobbleIntensity,
			i = Math.abs(Math.sin(this.xa.bobble) * this.bobbleIntensity),
			s = Math.sin(2 * this.xa.bobble) * this.bobbleIntensity;
		if (this.xa.shield > 0) {
			var n = .7 * Math.random() + .2;
			this.zS.overlayAlpha = n, this.hands.overlayAlpha = n
		}
		if (this.xa.activeShellStreaks & ph.EggBreaker) {
			n = .5 * Math.cos($N / 100) + .5;
			this.zS.overlayAlpha = n, this.hands.overlayAlpha = n
		}
		var a, r = .333 * (e = Math.min(e, 1));
		if (ST == this.xa.id ? this.xa.Wa.pa.KS.alwaysSelectAsActiveMesh = !0 : this.xa.Wa.pa.KS.alwaysSelectAsActiveMesh = !1, this.xa.id == xk)
			if (this.xa.scope && this.xa.isAtReady(!0)) iT.mk = iT.mk + (this.xa.Wa.pa.scopeFov - iT.mk) * r, this.mS.rotation.y *= r, this.mS.rotation.x *= r, this.mS.position.x += (-.24999999 - this.mS.position.x) * r, this.mS.position.y += (this.xa.Wa.pa.scopeY - this.mS.position.y) * r, this.mS.position.z += (.05 - this.mS.position.z) * r, this.xa.Wa.hasScope && !this.zoomed && iT.mk < this.xa.Wa.pa.scopeFov + .05 && (BN.show(), this.mS.setEnabled(!1), this.zoomed = !0);
			else {
				iT.mk = iT.mk + (1.25 - iT.mk) * r;
				var o = 1 - r;
				this.mS.rotation.y += (.14 + 2 * t - this.mS.rotation.y) * r, this.mS.rotation.x += (.035 + .75 * s - this.mS.rotation.x) * r, this.mS.position.x *= o, this.mS.position.y *= o, this.mS.position.z *= o, this.zoomed && iT.mk > this.xa.Wa.pa.scopeFov + .05 && (BN.hide(), this.mS.setEnabled(!0), this.zoomed = !1)
			}
		else if (this.mS.rotation.y += (.14 + 2 * t - this.mS.rotation.y) * r, this.mS.rotation.x += (.035 + .75 * s - this.mS.rotation.x) * r, this.xa.team > 0 && (this.xa.team == ET || VN) && this.nameSprite) {
			var l = Math.length3(this.xa.Xa - bk.Xa, this.xa.ba - bk.ba, this.xa.va - bk.va),
				h = Math.pow(l, 1.25);
			this.nameSprite.width = h / 10 + .6, this.nameSprite.height = h / 20 + .3
		}
		if (this.lerpToPosition.copyFromFloats(this.xa.Xa, this.xa.ba, this.xa.va), Lc.LerpToRef(this.lerpFromPosition, this.lerpToPosition, Math.min(this.positionLerp, 1), this.lerpTargetPosition), this.positionLerp += e / 2, this.mesh.position.x += .5 * (this.lerpTargetPosition.x - this.mesh.position.x), this.mesh.position.y += .5 * (this.lerpTargetPosition.y - this.mesh.position.y), this.mesh.position.z += .5 * (this.lerpTargetPosition.z - this.mesh.position.z), this.xa.id !== xk) {
			var c = Math.radDifference(this.xa.Oa, this.mesh.rotation.y),
				u = Math.radDifference(this.xa.ca, this.head.rotation.x);
			this.mesh.rotation.y += c / 2 * e, this.head.rotation.x += u / 2 * e
		} else this.mesh.rotation.y = this.xa.Oa, this.head.rotation.x = this.xa.ca;
		if (this.zS.rotation.x = this.head.rotation.x / 4, a = this.xa.onGround || this.xa.QS ? Math.length3(this.xa.dx, this.xa.dy, this.xa.Sa) : 0, this.bobbleIntensity += (a - this.bobbleIntensity) / 10, this.zS.rotation.z = 5 * t, this.zS.position.y = 1.5 * i + .32, CO > 0)
			if ((CO *= .9) < .001) CO = 0;
			else {
				var m = Math.random() * CO - .5 * CO,
					d = Math.random() * CO - .5 * CO,
					f = Math.random() * CO - .5 * CO;
				this.eye.rotation.x += (m - this.eye.rotation.x) / 10, this.eye.rotation.y += (d - this.eye.rotation.y) / 10, this.eye.rotation.z += (f - this.eye.rotation.z) / 10
			}
		else this.eye.rotation.x *= .9, this.eye.rotation.y *= .9, this.eye.rotation.z *= .9;
		if (this.xa.id != ST) {
			var p = YP(this.mesh, .31);
			this.mesh.ra(p), p ? this.showSprites() : this.hideSprites(), (this.nameSprite || this.auraSprite) && this.positionSprites()
		}
		this.hitSoundDelay = Math.max(this.hitSoundDelay - e, 0), this.xa.Wa.pa && this.xa.Wa.pa.update(e), this.zS.hp = 100 === this.xa.fS ? 1 : .008 * this.xa.fS
	}, RO.prototype.AS = function() {
		this.positionLerp = 0, this.lerpFromPosition.copyFromFloats(this.xa.Xa, this.xa.ba, this.xa.va)
	}, RO.prototype.resetLerp = function() {
		this.mesh.position.x = this.xa.Xa, this.mesh.position.y = this.xa.ba, this.mesh.position.z = this.xa.va, this.positionLerp = 0, this.lerpToPosition.copyFromFloats(this.xa.Xa, this.xa.ba, this.xa.va), this.lerpFromPosition.copyFromFloats(this.xa.Xa, this.xa.ba, this.xa.va), this.lerpTargetPosition.copyFromFloats(this.xa.Xa, this.xa.ba, this.xa.va)
	}, RO.v3_1 = new Lc, RO.v3_2 = new Lc, RO.prototype.positionSprites = function() {
		var e, t;
		this.nameSprite && ((e = RO.v3_1).copyFrom(this.mesh.position), e.y += .5 * this.nameSprite.height + .65, (t = this.nameSprite.position).copyFrom(iT.globalPosition), t.subtractInPlace(e), t.normalize(), t.scaleInPlace(.4), t.addInPlace(e));
		this.auraSprite && ((e = RO.v3_1).copyFrom(this.mesh.position), e.y += .35 * this.xa.playerScale, (t = this.auraSprite.position).copyFrom(iT.globalPosition), t.subtractInPlace(e), t.normalize(), t.scaleInPlace(.4), t.addInPlace(e), this.auraSprite.width = .7 * this.xa.playerScale, this.auraSprite.height = .7 * this.xa.playerScale)
	}, RO.prototype.showSprites = function() {
		this.xa.Ba && (this.nameSprite || (this.nameSprite = new Xv("", nI), this.nameSprite.invertV = !0, this.nameSprite.invertU = !0, this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.cellIndex = this.xa.id, this.nameSprite.color = Xw.textColor[this.xa.team], this.xa.team == ET || VN ? this.zS.teamColor = Xw.outline[this.xa.team] : this.zS.teamColor = Xw.outline[0]), !this.auraSprite && this.xa.activeShellStreaks & ph.HardBoiled && (this.auraSprite = new Xv("", aI), this.auraSprite.invertV = !0, this.auraSprite.width = .7, this.auraSprite.height = .7, this.auraSprite.playAnimation(this.auraSpriteFrame, this.auraSpriteFrame + 7, !0, 67)))
	}, RO.prototype.hideSprites = function() {
		this.nameSprite && (this.nameSprite.dispose(), this.nameSprite = null), this.auraSprite && (this.auraSprite.dispose(), this.auraSprite = null)
	}, RO.prototype.hit = function() {
		this.hitSoundDelay <= 0 && (this.xa.activeShellStreaks & ph.HardBoiled ? kN.play("shield_hit", this.zS.absolutePosition, !0) : kN.play("hit", this.zS.absolutePosition, !0), this.hitSoundDelay = 10)
	}, RO.prototype.beginShellStreak = function(e) {
		const t = {
			[ph.HardBoiled]: () => {
				this.auraSpriteFrame = 136, this.xa.id == xk && (aP(e), fP())
			},
			[ph.EggBreaker]: () => {
				this.xa.id == xk && (aP(e), GN.setPowerful(!0)), this.zS.overlayColor = FR.OverlayColor.red, this.hands.overlayColor = FR.OverlayColor.red, this.zS.renderOverlay = !0, this.hands.renderOverlay = !0
			},
			[ph.OverHeal]: () => {
				aP(e)
			},
			[ph.Restock]: () => {
				this.xa.id == xk && aP(e)
			},
			[ph.MiniEgg]: () => {
				this.shellStreakShrinkPlayer(this.mesh, new Lc(1, 1, 1), new Lc(.5, .5, .5), 60), this.xa.id == xk && aP(e)
			},
			[ph.DoubleEggs]: () => {
				this.xa.id == xk && aP(e)
			}
		};
		t[e] && t[e](), this.xa.id == xk && oP(e, !0), this.showSprites()
	}, RO.prototype.endShellStreak = function(e) {
		const t = {
			[ph.HardBoiled]: () => {
				this.xa.id == xk && fP(), this.auraSprite && (this.auraSprite.dispose(), this.auraSprite = null)
			},
			[ph.EggBreaker]: () => {
				this.xa.id == xk && GN.setPowerful(!1), this.zS.renderOverlay = !1, this.hands.renderOverlay = !1
			},
			[ph.MiniEgg]: () => {
				this.shellStreakShrinkPlayer(this.mesh, new Lc(.5, .5, .5), new Lc(1, 1, 1), 60)
			}
		};
		t[e] ? t[e]() : console.warn(`Unknown ksType: ${e}`), this.xa.id == xk && oP(e, !1)
	}, RO.prototype.removeFromPlay = function() {
		this.zoomed = !1, this.throwingGrenade = !1, this.gripBone._frozen = !1, this.wieldingMelee = !1, this.mesh.setEnabled(!1), this.hideSprites()
	}, RO.prototype.restoreToPlay = function() {
		this.mesh.setEnabled(!0), this.mS.setEnabled(!0), this.xa.id != xk && this.showSprites()
	}, RO.prototype.remove = function() {
		this.mesh.dispose(), this.hideSprites()
	}, RO.prototype.fire = function() {
		this.zoomed && this.xa.Wa.hasScope ? (CO = .15, this.eye.rotation.x = .05) : FT.shakeEnabled && (CO = .08 * iT.mk), this.wieldingMelee && this.wieldGun()
	}, RO.prototype.inspect = function() {
		this.xa.Wa && !this.xa.scope && this.xa.canSwapOrReload() && this.xa.Wa.pa.inspect()
	}, RO.prototype.melee = function() {
		this.xa.id === xk && (CO = .05), this.wieldingMelee || this.wieldMelee(), this.xa.meleeWeapon.pa.attack()
	}, RO.prototype.wieldMelee = function() {
		this.wieldingMelee = !0, this.xa.Wa.pa.restPose(), this.setWeaponSkeleton(this.xa.meleeWeapon.pa.skeleton), this.xa.meleeWeapon.pa.weaponMesh.setEnabled(!0), this.xa.Wa.pa.KS.setEnabled(!1)
	}, RO.prototype.inspectMelee = function() {
		this.wieldingMelee = !0, this.xa.Wa.pa.restPose(), this.setWeaponSkeleton(this.xa.meleeWeapon.pa.skeleton), this.xa.meleeWeapon.pa.weaponMesh.setEnabled(!0), this.xa.Wa.pa.KS.setEnabled(!1), this.xa.meleeWeapon.pa.inspect()
	}, RO.prototype.wieldGun = function() {
		this.wieldingMelee = !1, this.setWeaponSkeleton(this.xa.Wa.pa.skeleton), this.xa.meleeWeapon.pa.weaponMesh.setEnabled(!1), this.xa.Wa.pa.KS.setEnabled(!0)
	}, RO.prototype.reachForGrenade = function() {
		var e;
		this.throwingGrenade = !0, (e = this.xa.Wa.pa.KS).currentAnimation && e.currentAnimation.stop(), oR(this.xa.Wa.pa.KS, "fire"), rR(this.hands, "grenade_grab")
	}, RO.prototype.throwGrenade = function() {
		this.xa.id == xk && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), rR(this.hands, "grenade_throw")
	}, RO.prototype.setShellColor = function(e) {
		(e < 0 || e >= shellColors.length) && (console.log("Shell color out of bounds: " + e), e = 0);
		var t = Tc.FromHexString(shellColors[e]);
		this.zS.shellColor = t, this.hands.shellColor = t
	}, RO.prototype.setWeaponSkeleton = function(e) {
		this.skeleton = e, this.weaponGripBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("gripHand")], this.weaponForeBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("foreHand")]
	}, RO.prototype.handsToWeaponSkeleton = function() {
		this.gripBone.position = this.weaponGripBone.position, this.gripBone.setRotationQuaternion(this.weaponGripBone.rotationQuaternion), 1 != this.throwingGrenade && (this.foreBone.position = this.weaponForeBone.position, this.foreBone.setRotationQuaternion(this.weaponForeBone.rotationQuaternion))
	}, RO.prototype.setupStowAnims = function(e, t) {
		e = void 0 === e ? .14 : e, t = t ? -1 : 1;
		var i = new Wg("", "rotation", 60, Wg.ANIMATIONTYPE_VECTOR3, Wg.ANIMATIONLOOPMODE_CONSTANT),
			s = new Wg("", "scaling", 60, Wg.ANIMATIONTYPE_VECTOR3, Wg.ANIMATIONLOOPMODE_CONSTANT),
			n = new Wg("", "position", 60, Wg.ANIMATIONTYPE_VECTOR3, Wg.ANIMATIONLOOPMODE_CONSTANT),
			a = new kg;
		a.setEasingMode(Pg.EASINGMODE_EASEINOUT), i.setEasingFunction(a);
		var r = new kg;
		r.setEasingMode(Pg.EASINGMODE_EASEINOUT), s.setEasingFunction(r);
		var o = new kg;
		o.setEasingMode(Pg.EASINGMODE_EASEINOUT), n.setEasingFunction(o);
		var l = [{
				frame: 0,
				value: new Lc(.035, e * t, 0)
			}, {
				frame: 25,
				value: new Lc(-1, 1.5 * t, 0)
			}, {
				frame: 30,
				value: new Lc(1, 1.5 * t, 0)
			}, {
				frame: 55,
				value: new Lc(.035, e * t, 0)
			}],
			h = [{
				frame: 0,
				value: new Lc(1, 1, 1)
			}, {
				frame: 25,
				value: new Lc(.25 * t, .25, .25)
			}, {
				frame: 30,
				value: new Lc(.25 * t, .25, .25)
			}, {
				frame: 55,
				value: new Lc(1 * t, 1, 1)
			}],
			c = [{
				frame: 0,
				value: new Lc(0, 0, 0)
			}, {
				frame: 25,
				value: new Lc(.1 * t, .1, .2)
			}, {
				frame: 30,
				value: new Lc(.1 * t, 0, .2)
			}, {
				frame: 55,
				value: new Lc(0, 0, 0)
			}];
		i.setKeys(l), s.setKeys(h), n.setKeys(c), this.mS.animations.push(i), this.mS.animations.push(s), this.mS.animations.push(n)
	}, RO.prototype.shellStreakShrinkPlayer = function(e, t, i, s) {
		const n = new Wg("scalingAnimation", "scaling", 30, Wg.ANIMATIONTYPE_VECTOR3, Wg.ANIMATIONLOOPMODE_CONSTANT),
			a = [];
		a.push({
			frame: 0,
			value: t
		}), a.push({
			frame: s / 2,
			value: i
		}), n.setKeys(a);
		const r = new Dg;
		r.setEasingMode(Pg.EASINGMODE_EASEINOUT), n.setEasingFunction(r), e.animations = [], e.animations.push(n), this.scene.beginAnimation(e, 0, s, !1)
	}, FR.OverlayColor = {
		green: new Tc(0, 1, 0),
		red: new Tc(1, 0, 0)
	};
	var NO = class {
			reroll(e) {
				this.rerollId = e, cN((() => {
					var t, i, s;
					kh.playerAccount.isUpgraded() ? dN(e, this.rerollVipSuccess.bind(this), this.rerollVipError.bind(this)) : (t = e, i = this.rerollSuccess.bind(this), s = this.rerollError.bind(this), lN({
						cmd: "challengeRerollSlotCheck",
						sessionId: kh.playerAccount.sessionId,
						challengeId: t
					}, i, s))
				}), (e => {
					this.rerollId = null, Mw.challengeRerollRequest = null, this.log(1, `reroll() ${JSON.stringify(e)}`)
				}))
			}
			getNew() {
				fN(this.getNewSuccess.bind(this), this.getNewError.bind(this))
			}
			timer() {
				let e = Math.floor(kh.playerAccount.challengesDailyEnd - Date.now() / 1e3);
				e < 0 && (e = 0, this.playerChallengesRequestNew || (this.playerChallengesRequestNew = !0, clearInterval(this.playerChallengesTimerInterval), this.playerChallengesTimerInterval = null, this.getNew()));
				const t = {
					days: Math.floor(e / 86400),
					hours: this.timeFormat(Math.floor(e % 86400 / 3600)),
					minutes: this.timeFormat(Math.floor(e % 3600 / 60)),
					seconds: this.timeFormat(e % 60)
				};
				vueApp.player.challengeDailyData = t
			}
			rerollSuccess() {
				this.log(0, "Reroll check"), Mw.adInPlayActive || window.crazySdk.initialized ? (Mw.challengeRerollRequest = this.rerollId, this.rerollId = null, Mw.play("shellshock.io_rpreroll_30s")) : (vueApp.showGenericPopup("ad_blocker_nugget_title", "ad_blocker_nugget_content", "ok"), this.log(1, "Reroll no video ads!"))
			}
			timeFormat(e) {
				return e < 10 ? "0" + e : e.toString()
			}
			resizeTextToFit(e, t) {
				const i = e.querySelector(".dynamic-text");
				if (!i) return;
				const s = e.clientWidth;
				e.clientHeight;
				let n = 1;
				for (i.style.fontSize = n + "em"; i.scrollWidth <= s && n < t;) n += .1, i.style.fontSize = n + "em";
				for (n = Math.min(n, t), i.style.fontSize = n + "em"; i.scrollWidth > s && n > .5;) n -= .01, i.style.fontSize = n + "em"
			}
			getNewSuccess(e) {
				kh.playerAccount.challenges = e, this.dailyTimerStart(), this.resetInGame()
			}
			constructor() {
				this.playerChallengesTimerInterval = null, this.playerChallengesRequestNew = !1, this.rerollId = null
			}
			getNewError() {
				clearInterval(this.playerChallengesTimerInterval), this.playerChallengesTimerInterval = null, this.playerChallengesRequestNew = !1
			}
			iconSrc(e) {
				const t = e.toLowerCase(),
					i = Object.entries({
						kill_streak: "kill_streak.svg",
						time: "timed.svg",
						kill_kills: "kills-kills.svg",
						grenade: "grenade.svg",
						kill_con: "kills-shot.svg",
						cluck9mm: "cluck9mm.svg",
						scrambler: "scrambler.svg",
						rpegg: "rpegg.svg",
						whipper: "whipper.svg",
						eggk47: "eggk47.svg",
						freeranger: "freeranger.svg",
						crackshot: "crackshot.svg",
						trihard: "trihard.svg",
						melee: "melee.svg",
						damage: "damage.svg",
						deaths: "deaths.svg",
						distance: "distance.svg",
						jump: "jump.svg",
						collect: "collect.svg",
						kotc: "kotc.svg",
						cts: "cts.svg"
					}).find((([e]) => t.includes(e)));
				return i ? `img/challenges/${i[1]}` : ""
			}
			rerollError(e) {
				this.rerollId = null, e.error && (vueApp.showGenericPopup("uh_oh", "chlg_no_challenges", "ok"), this.log(1, e.error))
			}
			rerollVipError(e) {
				this.rerollId = null, this.log(1, "Reroll VIP error"), console.log("playerChallengesReroll error: ", e.error), vueApp.showGenericPopup("uh_oh", "chlg_no_challenges", "ok")
			}
			claim(e) {
				var t, i;
				t = t => {
					if (kh.playerAccount.challenges = t.challenges, t.reward) {
						const i = this.challengeGet(e);
						ga("send", "event", "dailyChallenge", "claim", i.loc_ref), vueApp.showGiveStuffPopup("challenge_reward", t.reward), hN()
					}
				}, i = e => {
					this.log(1, e.error)
				}, lN({
					cmd: "challengeClaimReward",
					slotId: e,
					sessionId: kh.playerAccount.sessionId
				}, t, i)
			}
			resizeAllText() {
				setTimeout((() => {
					document.querySelectorAll(".dynamic-text").forEach((e => {
						this.resizeTextToFit(e, 1)
					}))
				}), 10)
			}
			resetInGame() {
				BT && hasValue(bk) && void 0 !== bk.ik && setTimeout((() => {
					var e, t;
					e = bk.ik, (t = Rh.getBuffer()).BkKlQQwL(sh.Uk), t.AABkKlQQwL(e), t.send(mk)
				}), 100)
			}
			challengeGet(e) {
				return Qw && Qw.length > 0 ? Qw.find((t => t.id === e)) : null
			}
			rerollVipSuccess(e) {
				if (e.challengeId === this.rerollId) this.log(1, "Challenge slot already rerolled!!!");
				else {
					const t = this.challengeGet(this.rerollId);
					this.rerollId = null, ga("send", "event", "dailyChallenge", "reroll", t.loc_ref), kh.playerAccount.challenges = e, this.resetInGame()
				}
			}
			dailyTimerStart() {
				null === this.playerChallengesTimerInterval && (this.playerChallengesRequestNew = !1, this.playerChallengesTimerInterval = setInterval(this.timer.bind(this), 1e3))
			}
			log(e, t) {
				console.log(`PlayerChallenges ${["success","error"][e]}: ${t}`)
			}
		},
		IO = () => {
			pokiActive && (thirdPartyAdblocker || "undefined" != typeof googletag && window.googletag && googletag.apiReady && googletag.pubads().addEventListener("impressionViewable", (e => {
				const t = e.slot.getSlotElementId(),
					i = document.getElementById(t).parentNode.id;
				i && ga("send", "event", "Poki", "Display ad", i)
			})))
		},
		PO = e => {
			pokiActive && PokiSDK.happyTime(e)
		},
		kO = () => {},
		DO = () => {
			pokiActive && (vueData.isPokiGameLoad = !0)
		},
		OO = () => {
			pokiActive && (console.log("clearPokiRewardTimer"), vueData.isPokiGameLoad = !1, vueData.isPokiNewRewardTimer = !1, vueData.pokiRewardReady = !1)
		},
		FO = class {
			replaceItemProduct(e) {
				const t = this.categories.item.map(((e, t) => ({
					product: e,
					index: t
				}))).filter((({
					product: e
				}) => e.inStore && e.isActive));
				if (!e) return void console.warn("Invalid product provided to replaceItemProduct");
				const i = t.findIndex((t => t.product.id === e)),
					s = t.filter(((e, t) => t !== i)).map((e => e.product.itemIds)).flat();
				if (this.hideItemIdsInStore = s, -1 === i) return void console.warn(`Product with id ${e} not found in categories`);
				const n = t[i].index;
				this.categories.item[n].showInStore = !0, this.categories.item[n].isActive = !0, this.categories.item[n].inStore = !0
			}
			storeItemsFilterPassBundle(e) {
				const t = kh.catalog.findItemById(Ow);
				if (!t) return e.filter((e => "pass" !== e.type));
				return kh.playerAccount.isItemOwned(t) ? e.filter((e => "pass" !== e.type)) : e.filter((e => 1 !== e.id))
			}
			getPassByItemId(e) {
				return this.categories.pass.filter((t => this.matchItemIds(t.itemIds, e)))
			}
			getBundles() {
				return this.getActiveByType("bundle")
			}
			getStoreItems() {
				if (!this.isInitialized()) return [];
				const e = Jw.filter((e => !("item" === e.type || !e.inStore || !e.isActive) || !!e.showInStore));
				return e.length ? this.categories.pass && this.categories.pass.length > 0 ? this.storeItemsFilterPassBundle(e) : e : []
			}
			constructor() {
				this.categories = {
					currency: [],
					item: [],
					subscription: [],
					pass: [],
					bundle: []
				}, this.hideItemIdsInStore = [], this.initialized = !1, this.welcomeBundleItemId = Ow
			}
			getProductTitleByEggValue(e) {
				if (!this.isInitialized()) return null;
				const t = this.categories.currency.find((t => t.currency === e));
				return t?.sku || null
			}
			getBundlesByItemId(e) {
				return this.getBundles().filter((t => this.matchItemIds(t.itemIds, e)))
			}
			matchItemIds(e, t) {
				return !(!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length) && e.every(((e, i) => e === t[i]))
			}
			getActiveByType(e) {
				return this.isInitialized() && this.categories[e]?.filter((e => e.isActive)) || []
			}
			getBySku(e) {
				if (this.isInitialized()) return Jw.find((t => t.sku === e)) || null
			}
			isInitialized() {
				return !!this.initialized || (console.warn("Product class not initialized."), !1)
			}
			getSubscriptions() {
				return this.getActiveByType("subscription")
			}
			getProductsById(e) {
				if (!this.isInitialized()) return null;
				return Jw.find((t => t.id === e)) || null
			}
			getProductByItemIds(e, t) {
				return this.isInitialized() && this.categories[e] ? this.categories[e].filter((e => this.matchItemIds(e.itemIds, t))) : []
			}
			init() {
				Jw && Array.isArray(Jw) ? (Object.keys(this.categories).forEach((e => {
					this.categories[e] = Jw.filter((t => t.type === e))
				})), this.initialized = !0) : console.log("No products")
			}
			getProductType(e) {
				const t = this.getBySku(e);
				return t?.type || null
			}
			getShopItems() {
				return this.isInitialized() ? this.categories.item.filter((e => e.isActive)) : []
			}
		},
		LO = class {
			_onerror(e) {
				this.reconnectTimeoutTime > 4 && (this.queue = [], this.onerror(e))
			}
			send(e) {
				this.ws.readyState === WebSocket.OPEN ? this.ws.send(e) : (this.queue.push(e), this.ws.readyState !== WebSocket.CONNECTING && this.connect())
			}
			onerror(e) {}
			onmessage(e) {}
			constructor(e) {
				this.url = e, this.ws = null, this.queue = [], this.reconnectTimeout = null, this.reconnectTimeoutTime = 0, this.pingInterval = null, this.connect(e)
			}
			connect() {
				if (!this.ws || this.ws.readyState !== WebSocket.CONNECTING && this.ws.readyState !== WebSocket.OPEN) {
					console.log(`ReliableWebSocket: Connecting to ${this.url}`);
					try {
						this.ws = new WebSocket(this.url)
					} catch (e) {
						return void this._onerror(e)
					}
					this.ws.onopen = () => {
						console.log(`ReliableWebSocket: Connected to ${this.url}`), this.reconnectTimeoutTime = 0, this.queue.forEach((e => {
							this.ws.send(e)
						})), this.queue = [], this.pingInterval = setInterval((() => {
							this.ws.send("ping")
						}), 3e4), this.onopen()
					}, this.ws.onclose = e => {
						console.log(`ReliableWebSocket: Disconnected from ${this.url} with code ${e.code} - Attempting to reconnect in ${this.reconnectTimeoutTime} seconds...`), clearInterval(this.pingInterval), 4444 !== e.code && (e.code === th.NORMAL_CLOSURE || this.reconnectTimeout || (this.reconnectTimeout = setTimeout((() => {
							this.reconnectTimeout = null, this.connect()
						}), 1e3 * this.reconnectTimeoutTime), this.reconnectTimeoutTime = Math.min(this.reconnectTimeoutTime + 1, 10)), this.onclose(e))
					}, this.ws.onerror = e => this._onerror(e), this.ws.onmessage = e => this.onmessage(e)
				}
			}
			onopen() {}
			onclose(e) {}
		},
		BO = class {
			doReward() {
				vueApp.giveStuffPopup.titleLoc = this.locGiveGrenade, this.rewardedItem = kh.catalog.findItemById(this.itemId), mN("abTestReward", (() => {
					this.addItemToInventory(), vueApp.showGiveStuffPopup("abTestReward_title", 0, [this.rewardedItem], "abTestReward")
				}))
			}
			isItemOwned() {
				const e = kh.catalog.findItemById(this.itemId);
				return kh.playerAccount.isItemOwned(e)
			}
			constructor(e = 16029, t = 1250) {
				this.eggs = t, this.itemId = e, this.locGiveEggs = "ab_test_inventory_title", this.locGiveGrenade = "ab_test_inventory_title_grenade", this.accountLength = 12096e5
			}
			isEligible() {
				if (this.isItemOwned()) return !1;
				return localStore.getItem("lastPreRoll") && kh.playerAccount.accountAge < this.accountLength
			}
			addItemToInventory() {
				this.rewardedItem && kh.playerAccount.addToInventory(this.rewardedItem, !0)
			}
			tryReward() {
				this.isEligible() && (BT || this.doReward())
			}
		};

	function GO(e) {
		this.rocket = e, this.scene = e.scene, this.armed = !1, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("rocket").createInstance(""), this.mesh.setEnabled(!1)
	}
	GO.v3_1 = new Lc, GO.prototype.fire = function() {
		this.armed = !1, this.delayFrames = 2, this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z;
		var e = GO.v3_1;
		e.set(this.rocket.x + this.rocket.dx, this.rocket.y + this.rocket.dy, this.rocket.z + this.rocket.Sa), this.mesh.lookAt(e)
	}, GO.prototype.update = function() {
		if (--this.delayFrames <= 0 && this.mesh.setEnabled(!0), !this.armed && this.rocket.minRange <= 0 && (this.armed = !0, kN.play("gun_rpegg_rocket_fly", this.mesh.position, !0)), this.delayFrames % 2 == 0) {
			var e = .04 * Math.random() - .02,
				t = .04 * Math.random() - .02,
				i = .04 * Math.random() - .02;
			this.armed && (DI(DN, 30, this.rocket.x, this.rocket.y, this.rocket.z, e, t, i, .4, 0, null), DI(ON, 10, this.rocket.x, this.rocket.y, this.rocket.z, e, t, i, .4, 0, null))
		}
		this.mesh.position.x += .5 * (this.rocket.x - this.mesh.position.x), this.mesh.position.y += .5 * (this.rocket.y - this.mesh.position.y), this.mesh.position.z += .5 * (this.rocket.z - this.mesh.position.z)
	}, GO.prototype.remove = function() {
		this.mesh.setEnabled(!1)
	};
	var HO = !1,
		UO = location.hostname.startsWith("localshelldev"),
		VO = location.hostname.startsWith("localhost");
	kh.servicesServer = `${isHttps()?"wss":"ws"}://${location.hostname}/services/`;
	var WO = new URLSearchParams(location.search).get("portalTest");
	WO && (dynamicContentRoot = `${WO}.shellshock.io`, dynamicContentPrefix = `https://${WO}.shellshock.io/`), dynamicContentRoot ? kh.servicesServer = (isHttps() ? "wss" : "ws") + "://" + dynamicContentRoot + "/services/" : (VO || UO || location.hostname.startsWith("staging")) && (HO = !0);
	var zO = class {
		get kills() {
			return this._kills
		}
		constructor() {
			this.kills = 0, this.deaths = 0, this.suicides = 0, this.streak = 0, this.weapons = {}, this.sessionStart = 0, this.sessionEnd = 0, this.endTime = 0, this.playTime = 0, this.ratio = 0, this.charClass = {}, this.init()
		}
		set kills(e) {
			this._kills = e, this.getRatio()
		}
		getPlayTimeInGame() {
			if (!this.sessionStart) return "0:00";
			const e = Date.now() - this.sessionStart,
				t = (e % 6e4 / 1e3).toFixed(0);
			return Math.floor(e / 6e4) + ":" + (t < 10 ? "0" : "") + t
		}
		start() {
			this.sessionStart = Date.now()
		}
		get deaths() {
			return this._deaths
		}
		updateTerminus(e, t, i, s) {
			this.charClass[e][t][i]++, this.charClass[e][i]++, this.weapons[t][i]++, this[i]++, s && this.suicides++
		}
		getPlayTime() {
			this.sessionEnd = Date.now() - this.sessionStart;
			const e = (this.sessionEnd % 6e4 / 1e3).toFixed(0);
			this.playTime = Math.floor(this.sessionEnd / 6e4) + ":" + (e < 10 ? "0" : "") + e
		}
		getStats() {
			return {
				kills: this.kills,
				deaths: this.deaths,
				suicides: this.suicides,
				weapons: this.weapons,
				charClass: this.charClass,
				playTime: this.getPlayTimeInGame(),
				endTime: this.endTime,
				ratio: this.ratio
			}
		}
		set deaths(e) {
			this._deaths = e, this.getRatio()
		}
		getRatio() {
			this.ratio = Math.floor(this.kills / Math.max(this.kills + this.deaths, 1) * 100)
		}
		setupWeapons() {
			uh.forEach((e => this.weapons[e.name] = {
				deaths: 0,
				kills: 0
			})), Object.keys(Ah).forEach((e => this.charClass[e] = JSON.parse(JSON.stringify(this.weapons)))), Object.keys(this.charClass).forEach((e => {
				this.charClass[e].kills = 0, this.charClass[e].deaths = 0
			})), console.log(this.charClass)
		}
		end() {
			this.endTime = this.getPlayTimeInGame(), this.getPlayTime()
		}
		init() {
			this.setupWeapons(), this.start()
		}
	};

	function XO() {
		(FT = {
			volume: getStoredNumber("volume", .6),
			mouseSensitivity: getStoredNumber("mouseSensitivity", null),
			mouseSpeed: getStoredNumber("mouseSpeed", 50),
			mouseInvert: getStoredNumber("mouseInvert", 1),
			fastPollMouse: getStoredBool("fastPollMouse", !1),
			holdToAim: getStoredBool("holdToAim", !0),
			enableChat: getStoredBool("enableChat", !0),
			safeNames: getStoredBool("safeNames", !1),
			autoDetail: getStoredBool("autoDetail", !0),
			shadowsEnabled: getStoredBool("shadowsEnabled", !0),
			highRes: getStoredBool("highRes", !0),
			controllerSpeed: getStoredNumber("controllerSpeed", 20),
			deadzone: getStoredNumber("deadzone", .3),
			controllerInvert: getStoredNumber("controllerInvert", 1),
			controls: getStoredObject("controls", {
				keyboard: {
					game: {
						up: "W",
						down: "S",
						left: "A",
						right: "D",
						jump: "SPACE",
						melee: "F",
						inspect: "G",
						fire: "MOUSE 0",
						scope: "SHIFT",
						reload: "R",
						swap_weapon: "E",
						grenade: "Q",
						despawn: "P"
					},
					spectate: {
						ascend: "SPACE",
						descend: "SHIFT",
						toggle_freecam: "V",
						slow: "MOUSE 0"
					}
				},
				gamepad: {
					game: {
						jump: 0,
						fire: 7,
						scope: 6,
						reload: 2,
						swap_weapon: 3,
						grenade: 5,
						melee: 1,
						inspect: 4
					},
					spectate: {
						ascend: 6,
						descend: 7
					}
				}
			}),
			musicVolume: getStoredNumber("musicVolume", .5),
			musicStatus: getStoredBool("musicStatus", !0),
			hideBadge: getStoredBool("hideBadge", !1),
			closeWindowAlert: getStoredBool("closeWindowAlert", !1),
			shakeEnabled: getStoredBool("shakeEnabled", !0),
			centerDot: getStoredBool("centerDot", !0),
			hitMarkers: getStoredBool("hitMarkers", !0)
		}).mouseSpeed || null === FT.mouseSensitivity || (FT.mouseSpeed = Math.floor(Math.sqrt(350 * FT.mouseSensitivity) + 19), localStore.removeItem("mouseSensitivity")),
			function() {
				function e(t, i) {
					Object.keys(t).forEach((s => {
						"object" == typeof t[s] ? (i[s] || (i[s] = {}), e(t[s], i[s])) : i[s] || (i[s] = t[s])
					}))
				}
				e({
					keyboard: {
						game: {
							up: "W",
							down: "S",
							left: "A",
							right: "D",
							jump: "SPACE",
							melee: "F",
							inspect: "G",
							fire: "MOUSE 0",
							scope: "SHIFT",
							reload: "R",
							swap_weapon: "E",
							grenade: "Q",
							despawn: "P"
						},
						spectate: {
							ascend: "SPACE",
							descend: "SHIFT",
							toggle_freecam: "V",
							slow: "MOUSE 0"
						}
					},
					gamepad: {
						game: {
							jump: 0,
							fire: 7,
							scope: 6,
							reload: 2,
							swap_weapon: 3,
							grenade: 5,
							melee: 1,
							inspect: 4
						},
						spectate: {
							ascend: 6,
							descend: 7
						}
					}
				}, FT.controls)
			}(), jO(FT.controls), vueApp.setUiSettings(FT)
	}

	function YO() {
		localStore.setItem("volume", FT.volume), localStore.setItem("mouseSpeed", FT.mouseSpeed), localStore.setItem("mouseInvert", FT.mouseInvert), localStore.setItem("fastPollMouse", FT.fastPollMouse), localStore.setItem("holdToAim", FT.holdToAim), localStore.setItem("enableChat", FT.enableChat), localStore.setItem("safeNames", FT.safeNames), localStore.setItem("autoDetail", FT.autoDetail), localStore.setItem("shadowsEnabled", FT.shadowsEnabled), localStore.setItem("highRes", FT.highRes), localStore.setItem("controllerSpeed", FT.controllerSpeed), localStore.setItem("deadzone", FT.deadzone), localStore.setItem("controllerInvert", FT.controllerInvert), localStore.setItem("controls", JSON.stringify(FT.controls)), localStore.setItem("musicVolume", FT.musicVolume), localStore.setItem("musicStatus", FT.musicStatus), localStore.setItem("hideBadge", FT.hideBadge), localStore.setItem("closeWindowAlert", FT.closeWindowAlert), localStore.setItem("shakeEnabled", FT.shakeEnabled), localStore.setItem("centerDot", FT.centerDot), localStore.setItem("hitMarkers", FT.hitMarkers)
	}

	function jO(e) {
		UT = {
			keyboard: {
				game: {},
				spectate: {}
			},
			gamepad: {
				game: {},
				spectate: {}
			}
		}, Object.keys(e.keyboard).forEach((t => {
			Object.keys(e.keyboard[t]).forEach((i => {
				UT.keyboard[t][e.keyboard[t][i]] = i
			}))
		})), Object.keys(e.gamepad).forEach((t => {
			Object.keys(e.gamepad[t]).forEach((i => {
				UT.gamepad[t][e.gamepad[t][i]] = i
			}))
		}))
	}

	function KO(e, t) {
		if (0 === e) return console.log("game volume suspended"), vueApp.volume = 0, BAWK.setVolume(0), BAWK.suspend();
		e = e || FT.volume, console.log("volume set to: " + e), BAWK.resume(), BAWK.setVolume(e), vueApp.volume = e
	}

	function $O(e) {
		FT.mouseSpeed = e
	}

	function JO(e) {
		FT.controllerSpeed = e
	}

	function qO(e) {
		FT.deadzone = e
	}

	function QO(e, t) {
		this.spatula = e, this.scene = e.scene, this.mesh = nR("spatula", t), this.mesh.material = JN.getMaterialByName("emissive"), this.mesh.emissiveColor = new Tc(.8, .6, .2), this.mesh.setRenderingGroupId(1)
	}

	function ZO() {
		this.dx = 0, this.dy = 0, this.Sa = 0, this.speedMultiplier = 1, this.dampenLambda = .2, this.playerIdx = 0
	}
	QO.prototype.dispose = function() {
		this.mesh.dispose()
	}, QO.prototype.drop = function() {
		this.mesh.parent = null, BAWK.play("drop_spatula")
	}, QO.prototype.capture = function(e) {
		this.mesh.parent = e.pa.zS, this.mesh.position.set(0, -.2, .3), this.mesh.rotation.y = 0
	}, QO.prototype.update = function(e) {
		255 == this.spatula.HS ? (this.mesh.position.x += .5 * (this.spatula.x - this.mesh.position.x), this.mesh.position.y += .5 * (this.spatula.y + .1 - this.mesh.position.y), this.mesh.position.z += .5 * (this.spatula.z - this.mesh.position.z), this.mesh.rotation.y += .1 * e) : this.mesh.parent.parent.ra(!0)
	};
	var eF = {
		freeCamera: 0,
		firstPerson: 1
	};
	FR.Ua = new Lc, FR.na = new Lc, FR.ray = new Yv, FR.matrix = new Hc;
	var tF = function(e, t, i, s) {
		return Ac.Lerp(e, t, 1 - Math.exp(-i * s))
	};

	function iF(e) {
		let t = Date.now() - sF;
		ga("send", "event", "onLoad", e ? "loaded" : "loading", Math.floor(t / 1e3) + " - seconds"), e && clearInterval(nF)
	}
	ZO.prototype.firstPerson = function() {
		let e = iI[this.playerIdx];
		e && e.Ba && this.playerIdx !== xk || (e = this.findNextPlayer()), e && this.spectatePlayer(e)
	}, ZO.prototype.freeCamera = function() {
		ST !== xk && (bk.ca = iT.rotation.x, bk.Oa = iT.rotation.y), iT.parent = null, iT.lockedTarget = null, ST = xk, eI = bk, zN = 0, vueData.ui.game.spectatingPlayerName = null, this.restorePreviousPlayerActor()
	}, ZO.prototype.restorePreviousPlayerActor = function() {
		let e = iI[this.playerIdx];
		e && e.pa.hat && e.pa.hat.ra(!0)
	}, ZO.prototype.spectatePlayer = function(e) {
		this.restorePreviousPlayerActor(), this.playerIdx = e.id, ST = e.id, eI = e, e.pa.mesh.ra(!0), e.pa.hat && e.pa.hat.ra(!1), iT.lockedTarget = null, LN = !1, EP(), vueData.ui.game.spectatingPlayerName = e.name, JN.autoClear = !0, JN.autoClearDepthAndStencil = !0
	}, ZO.prototype.spectateNextPlayer = function(e = 1) {
		let t = this.findNextPlayer(e);
		t && this.spectatePlayer(t)
	}, ZO.prototype.findNextPlayer = function(e = 1) {
		let t = null;
		for (var i = [], s = 0; s < Mk; s++) {
			let e = iI[s];
			e && i.push(e.id)
		}
		if (0 === i.length) return this.unlock(), null;
		fk.sortPlayerList(i);
		for (let e = 0; e < i.length; e++)
			if (iI[i[e]].id === this.playerIdx) {
				t = e;
				break
			} null === t && (t = 0);
		let n = t;
		for (; n = Math.mod(n + e, i.length), n !== t;) {
			let e = iI[i[n]];
			if (e && e.Ba && e.id !== xk) return e
		}
		return this.unlock(), null
	}, ZO.prototype.unlock = function() {
		ST = null, eI = null, this.playerIdx = null
	}, ZO.prototype.update = function(e) {
		if (WN === eF.firstPerson) eI && eI.Ba && (iT.position.copyFrom(eI.pa.eye.getAbsolutePosition()), iT.rotation.y = eI.pa.mesh.rotation.y + Math.PI, iT.rotation.x = -eI.pa.head.rotation.x);
		else {
			var t = 0,
				i = 0,
				s = 0;
			zN & IR.left && (t += Math.cos(bk.Oa), s -= Math.sin(bk.Oa)), zN & IR.right && (t -= Math.cos(bk.Oa), s += Math.sin(bk.Oa)), zN & IR.up && (t += Math.sin(bk.Oa), s += Math.cos(bk.Oa)), zN & IR.down && (t -= Math.sin(bk.Oa), s -= Math.cos(bk.Oa)), zN & IR.ascend && (i = 1), zN & IR.descend && (i = -1);
			var n = new Lc(t, i, s).normalize(),
				a = this.dx,
				r = this.dy,
				o = this.Sa;
			this.dx += .016 * n.x, this.dy += .008 * n.y, this.Sa += .016 * n.z;
			var l = .5 * (this.dx + a),
				h = .5 * (this.dy + r),
				c = .5 * (this.Sa + o);
			iT.position.x += l * e * this.speedMultiplier, iT.position.y += h * e * this.speedMultiplier, iT.position.z += c * e * this.speedMultiplier, iT.position.y = Math.min(Math.max(1.5, iT.position.y), 50), bk.Xa = iT.position.x, bk.ba = iT.position.y, bk.va = iT.position.z, this.dx = tF(this.dx, 0, this.dampenLambda, e), this.dy = tF(this.dy, 0, this.dampenLambda, e), this.Sa = tF(this.Sa, 0, this.dampenLambda, e), iT.rotation.x = -bk.ca, iT.rotation.y = bk.Oa
		}
	}, ZO.prototype.startSlow = function() {
		this.speedMultiplier = .1, this.dampenLambda = .075
	}, ZO.prototype.endSlow = function() {
		this.speedMultiplier = 1, this.dampenLambda = .2
	}, document.addEventListener("contextmenu", (function(e) {
		e.preventDefault()
	}), !1), window.onresize = function() {
		rD()
	}, window.mobileAndTabletcheck = function() {
		var e = !1;
		return function(t) {
			(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
		}(navigator.userAgent || navigator.vendor || window.opera), /Googlebot/i.test(navigator.userAgent) && (e = !1), e
	}, window.onloadingcomplete = function() {
		if ("undefined" == typeof startVue || "undefined" == typeof firebase) return void setTimeout(window.onloadingcomplete, 100);
		if (Iw = new URL(window.location.href).searchParams.get("abTest"), Nw = new ZR({
				a: 20
			}), WD(), BD()) return console.log("startShellShockers"), Ik(), void(window.onload = null);
		const e = location.protocol + "//" + location.host;
		window.location.href = e + "/portals"
	}, window.addEventListener("beforeunload", (e => {
		if (BT && FT.closeWindowAlert) {
			const t = "Are you sure you want to exit?";
			return e.preventDefault(), e.returnValue = t, hasValue(MT.sessionStart) && (sO(sT, CR[oT].name), TD(MT.end()), wD()), t
		}
	}));
	var sF = Date.now(),
		nF = setInterval((() => {
			Date.now();
			iF(!1)
		}), 5e3);

	function aF(e, t) {
		const i = function() {
			let e = "Shell Shockers";
			return pokiActive ? e = "Poki" : crazyGamesActive && (e = "Crazy Games"), e
		}();
		if (console.log("getXsollaToken called (firebase ID: {0})".format(kh.playerAccount.firebaseId), t), fw = e, function(e) {
				const t = e === Dw,
					{
						isAnonymous: i,
						isEmailVerified: s,
						firebaseId: n
					} = kh.playerAccount;
				if (t) {
					const e = !!n;
					return e || vueApp.showGenericPopup("player_not_found_title", "player_not_found_welcome_bundle_desc", "ok"), e
				}
				return !(i || !s) || (vueApp.denyAnonUser(), !1)
			}(e)) {
			! function(e, t, i, s, n) {
				s = s || !1, lN({
					cmd: "xsollaToken",
					firebaseId: kh.playerAccount.firebaseId,
					productSku: e,
					subscription: s,
					playerSource: n
				}, t, i)
			}(e, (function(e) {
				e.error ? (console.log("xsollaTokenResponse Error: " + JSON.stringify(e)), disableProductPurchasing()) : (console.log("response: " + JSON.stringify(e)), "SUCCESS" == e.result ? (console.log("Got Xsolla token: " + e.token), function(e) {
					var t = {
							access_token: e,
							sandbox: location.hostname.startsWith("localshelldev") || location.hostname.startsWith("staging"),
							lightbox: {
								spinner: "round",
								overlayOpacity: .8
							}
						},
						i = document.createElement("script");
					i.type = "text/javascript", i.async = !0, i.src = "//static.xsolla.com/embed/paystation/1.0.7/widget.min.js", i.addEventListener("load", (function(e) {
						XPayStationWidget.on("init", (function(e) {
							console.log("Xsolla PayStation initialized"), XPayStationWidget.open()
						})), XPayStationWidget.on("close", (function(e) {
							console.log("Xsolla PayStation closed"), BT ? (vueApp.showGameMenu(), vueApp.setDarkOverlay(!1)) : vueApp.toggleTitleScreenAd(!0), setTimeout((function() {
								hN(), cN()
							}), 3e3)
						})), XPayStationWidget.on("open", (function(e) {
							BT ? vueApp.hideGameMenu() : vueApp.toggleTitleScreenAd(!1), console.log("Xsolla PayStation open"), console.log(fw)
						})), XPayStationWidget.on("status", (function(e) {
							console.log("Xsolla PayStation status"), console.log("status", e), console.log(fw)
						})), XPayStationWidget.on("status-invoice", (function(e) {
							console.log("Xsolla PayStation status-invoice"), console.log("status-invoice", e), console.log(fw)
						})), XPayStationWidget.on("status-delivering", (function(e) {
							console.log("Xsolla PayStation status-delivering"), console.log("status-delivering", e), console.log(fw)
						})), XPayStationWidget.on("status-done", (function(e) {
							console.log("Xsolla PayStation status-done"), console.log("status-done", e), console.log(fw), localStore.setItem("xsollaPurchase", !0), "golden_chicken_pass" === fw && PO(1), rF()
						})), XPayStationWidget.init(t)
					}), !1), document.getElementsByTagName("head")[0].appendChild(i), xsollaSetup = !0
				}(e.token), console.log(e)) : (console.log("Failed to get Xsolla token"), oF()))
			}), (function(e) {
				console.log("Error getting Xsolla token: " + JSON.stringify(e)), oF()
			}), t, i)
		}
	}
	iF(0);
	var rF = () => {
		if (!hasValue(fw)) return;
		let e = vueData.eggStoreItems.filter((e => e.sku === fw))[0],
			t = e.sku,
			i = e.salePrice ? Math.round(e.salePrice) : "",
			s = Math.round(e.price),
			n = i || s;
		if (!hasValue(t) && !hasValue(n)) return console.log("No Price no sku"), void(fw = null);
		let a = vueApp.eggStoreReferral ? t + " " + vueApp.eggStoreReferral : t;
		return fw = null, ga("send", "event", vueApp.googleAnalytics.cat.purchases, vueApp.googleAnalytics.action.purchaseComplete, a, n)
	};

	function oF() {
		vueApp.showGenericPopup("uh_oh", "purchase_disabled", "ok", !0)
	}
	ik.state = {
		start: 0,
		aS: 1,
		win: 2,
		capturing: 3,
		contested: 4,
		takeover: 5,
		abandoned: 6,
		unclaimed: 7
	}, ik.captureSpeeds = [1.2, 1.5, 2.04, 3, 4.8], ik.goalScore = 5, ik.takeOverTime = 90, ik.takeOverSpeed = 1;
	var lF = class {
		static normalizeManhattan(e) {
			var t = Math.abs(e.x),
				i = Math.abs(e.y),
				s = Math.abs(e.z),
				n = Math.max(t, Math.max(i, s));
			return 0 == n ? (e.x = 0, e.y = 0, e.z = 0) : (e.x = .5 * Math.trunc(e.x / n), e.y = .5 * Math.trunc(e.y / n), e.z = .5 * Math.trunc(e.z / n)), e.x * e.y != 0 || e.x * e.z != 0 || e.y * e.z != 0
		}
		static stripTris(e, t, i, s) {
			for (var n = i.getIndices(), a = i.getVerticesData(eu.PositionKind), r = i.getVerticesData(eu.NormalKind), o = new Lc, l = new Lc, h = [], c = {
					x: 0,
					y: 0,
					z: 0
				}, u = 0; u < n.length; u += 3) {
				for (var m = !1, d = 0, f = 0, p = 0, _ = 0, g = 0, v = 0, y = 0; y < 3; y++) {
					var S = n[u + y],
						E = s[S];
					if (S *= 3, !E) {
						m = !0;
						break
					} {
						d = a[S + 0], f = a[S + 1], p = a[S + 2];
						let i = 1024,
							s = .5 / i;
						d = Math.floor((d + s) * i) / i, f = Math.floor((f + s) * i) / i, p = Math.floor((p + s) * i) / i, c.x = d - E.x, c.y = f - E.y, c.z = p - E.z;
						var A = this.normalizeManhattan(c);
						_ = .75 * r[S + 0], g = .75 * r[S + 1], v = .75 * r[S + 2];
						if (A) {
							if (o.set(_, g, v).normalize(), l.set(c.x, c.y, c.z).normalize(), Lc.Dot(o, l) < .5) {
								m = !0;
								break
							}
							var b = Math.floor(E.x + _ + .5),
								x = Math.floor(E.y + g + .5),
								M = Math.floor(E.z + v + .5)
						} else b = Math.floor(d + c.x + .5), x = Math.floor(f + c.y + .5), M = Math.floor(p + c.z + .5);
						if (!m) try {
							var C = e[b][x][M];
							if (!C || !C.idx) {
								m = !0;
								break
							}
							if (!t[C.idx].name.endsWith(".full") || "SPECIAL" === t[C.idx].theme) {
								m = !0;
								break
							}
						} catch (e) {
							m = !0;
							break
						}
					}
				}
				m && (h.push(n[u + 0]), h.push(n[u + 1]), h.push(n[u + 2]))
			}
			return console.log("stripped " + (n.length - h.length) + " tris", n.length, h.length), i.setIndices(h), i
		}
		static uS(e, t, i, s, n, a) {
			var r;
			if (s) {
				if (!i.data[s]) return void a();
				r = [s]
			} else r = Object.keys(i.data);
			var o = [],
				l = new AS("SPS", e, {
					updatable: !0,
					autoFixFaceOrientation: !1
				});
			l.computeParticleColor = !1, l.computeParticleTexture = !1, l.computeParticleRotation = !1, l.recomputeNormals = !1;
			var h = function e(h) {
				if (h != r.length) {
					var c = r[h],
						u = i.data[c],
						m = t[c];
					void 0 === (v = kR[m]) && console.log("mesh not found: " + c);
					var d = c.split(".");
					if (v.theme = d[0], v.colliderType = d[2], v.softness = d[3], "SPECIAL" != v.theme && ("DYNAMIC" != v.theme || s)) {
						var f, p = 0,
							_ = Object.values(u).filter((e => !n || e.zone == n));
						l.addShape(v, _.length, {
							positionFunction: function(e, t, s) {
								var n = _[p].rx || 0,
									a = _[p].ry || 0,
									r = _[p].rz || 0;
								e.position.x = _[p].x + i.extents.x.min, e.position.y = _[p].y + i.extents.y.min, e.position.z = _[p].z + i.extents.z.min, e.rotation.x = n * hP, e.rotation.y = a * hP, e.rotation.z = r * hP, e.alive = !1, f = c.endsWith(".full") || c.includes("capture-zone") ? {
									x: e.position.x,
									y: e.position.y,
									z: e.position.z
								} : 0, p++
							},
							vertexFunction: function(e, t, i) {
								o.push(f)
							}
						})
					}
					var g = e.bind(this, h + 1);
					window.requestAnimationFrame(g)
				} else {
					var v = l.buildMesh();
					a(v, o)
				}
			}.bind(this, 0);
			window.requestAnimationFrame(h)
		}
	};
	window.extern = {
		catalog: kh.catalog,
		play: _D,
		getLanguageData: sD,
		continueStartup: function() {
			if (window.mobileAndTabletcheck()) {
				location.protocol, location.host;
				window.location.href = "https://shellshock.io/mobile"
			} else(function() {
				if (navigator.userAgent.indexOf("Edge") >= 0) return vueApp.showUnsupportedPlatformPopup("unsupported_oldmsedge"), !0;
				return !1
			})() || function() {
				document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
				var e = [];
				Fd.isSupported() || e.push('{0} (<a href="https://shellshock.io/faq.html#webgl" target="_window">{1}</a>)'.format(vueApp.loc.missing_webgl, vueApp.loc.missing_moreinfo));
				(!document.exitPointerLock || navigator.userAgent.indexOf("10.1.2 Safari") >= 0) && e.push('{0} (<a href="https://shellshock.io/faq.html#pointerlock" target="_window">{1}</a>)'.format(vueApp.loc.missing_pointerlock, vueApp.loc.missing_moreinfo));
				localStore || e.push(vueApp.loc.missing_localstorage);
				void 0 === new KeyboardEvent("").key && e.push(vueApp.loc.missing_keyboardevent);
				if (vueApp.missingFeatures = e, e.length > 0) return vueApp.showMissingFeaturesPopup(), !0;
				return !1
			}() || (navigator.userAgent.indexOf("Chrome/84"), async function(e) {
				Tk = new bg(kh.engine);
				let t = new Ng("camera", Lc.Zero(), Tk);
				if (Tk.activeCameras.push(t), bO.getRegions().then(wO), console.log("loadResources()"), HR(Tk), function(e, t) {
						(kR = [null]).push(GR("SPECIAL.barrier.full.verysoft", e, new Tc(1, 0, 0))), kR.push(GR("SPECIAL.barrier.full", e, new Tc(0, 1, 0))), kR.push(GR("SPECIAL.barrier.none", e, new Tc(1, 1, 1)));
						for (var i = [], s = 0; s <= 1; s += .125) {
							var n = -Math.PI / 2 + Math.PI * s,
								a = Math.cos(n),
								r = .5 * Math.sin(n + .05) + .5;
							a = .25 * Math.pow(a, 1.3), r = .6 * Math.pow(r, 1.3) - .48, i.push(new Lc(a, r, 0))
						}
						var o, l = cS.ka("SPECIAL.spawn-blue.none", {
							shape: i,
							tessellation: 12
						}, e);
						(o = new Wv("", e, !0)).diffuseColor = new Tc(0, .5, 1), o.specularColor = new Tc(.1, .2, .4), o.specularPower = 8, l.material = o, l.setEnabled(!1), kR.push(l), l = cS.ka("SPECIAL.spawn-red.none", {
							shape: i,
							tessellation: 12
						}, e), (o = new Wv("", e, !0)).diffuseColor = new Tc(1, .25, .25), o.specularColor = new Tc(.4, .3, .3), o.specularPower = 8, l.material = o, l.setEnabled(!1), kR.push(l), UR(e, ["map"], (function(e) {
							e.parent || "__root__" == e.name ? e.freezeWorldMatrix() : kR.push(e)
						}), (function() {
							for (var e = 1; e < kR.length; e++) {
								var i = kR[e].getChildMeshes()[0];
								i && (kR[e].colliderMesh = i)
							}
							t()
						}))
					}(Tk, (() => {
						var e = {
							name: "SPECIAL.spatula.none"
						};
						kR.push(e), kT = !0
					})), Fw) {
					console.log("Start resource loading");
					try {
						await Promise.all([new Promise((e => {
							var t;
							t = () => {
								console.log("Sounds loaded"), e()
							}, BAWK.load("sound/sounds.json?" + Ch).then((() => t()))
						})), new Promise((e => {
							const t = pw ? "Loading all object meshes" : "Loading default object meshes";
							console.log(t), UR(Tk, ["egg", "gun_eggk47", "gun_csg1", "gun_cluck9mm", "gun_dozenGauge", "gun_rpegg", "gun_smg", "gun_m24", "gun_aug", "munitions", "muzzleFlash", "items", "reticle", "melee"], null, (() => {
								console.log("Object meshes loaded"), Gw = pw, e()
							}), pw)
						})), new Promise((e => {
							! function(e) {
								let t = 0;

								function i(i) {
									let s = PR.addTask(),
										n = new Image;
									n.src = `img/${i}?${Ch}`, n.onload = function() {
										let a = document.createElement("canvas");
										a.width = n.width, a.height = n.height, a.getContext("2d").drawImage(n, 0, 0), Rk[i] = a, PR.finish(s), 2 == ++t && e()
									}
								}
								i("stamps.webp"), i("particles.webp")
							}((() => {
								console.log("Textures loaded"), e()
							}))
						}))]), Tk.cleanCachedTextureBuffer(), gO = new AO, vueApp.chwRewardIds = [...vueApp.chwRewardIds, ...Zw], e()
					} catch (e) {
						console.error("Error during resource loading:", e)
					}
				}
			}(Dk))
		},
		showSignInDialog: Sk,
		signOut: function() {
			firebase.auth().signOut().then((function() {
				kh.playerAccount = new Bh, kh.playerAccount.loggingOut(), kh.playerAccount.applyRandomLoadout(), productBlockAds = !1, pokiActive || crazyGamesActive || (kk(), vueApp.showTitleScreenAd()), setTimeout((() => vueApp.setDarkOverlay(!1)), 1500)
			}), (function(e) {
				console.log(e)
			})), ga("set", "dimension4", "noVip"), ga("send", "event", vueData.googleAnalytics.cat.playerStats, vueData.googleAnalytics.action.signIn, vueData.googleAnalytics.label.signInOut), vueApp.photoUrl = null, iD(), sN(), gw = !1
		},
		sendFirebaseVerificationEmail: _k,
		selectRegion: function(e) {
			let t = bO.regionList.find((function(t) {
				return t.id === e
			}));
			hasValue(t) || (t = bO.regionList[0]), vueApp.currentRegionId = t.id, localStore.setItem("selectedRegionId", t.id)
		},
		generateRandomName: qR,
		changeClass: function(e) {
			kh.playerAccount.setClass(e), vueData.selectedWeaponDisabled = dR.isSelectedWeaponDisabled(e)
		},
		toggleFullscreen: function() {
			if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
				(e = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen) && e.call(document)
			} else {
				var e, t = document.documentElement;
				(e = t.requestFullscreen || t.webkitRequestFullscreen || t.mozRequestFullScreen || t.msRequestFullscreen) && e.call(t)
			}
		},
		applyUiSettings: function(e, t) {
			var i;
			Object.values(e.adjusters).forEach((e => {
				e.forEach((e => {
					FT[e.id] = e.value
				}))
			})), Object.values(e.togglers).forEach((e => {
				e.forEach((e => {
					"mouseInvert" === e.id || "controllerInvert" == e.id ? FT[e.id] = e.value ? -1 : 1 : FT[e.id] = e.value
				}))
			})), e.controls.keyboard.game.forEach((e => {
				FT.controls.keyboard.game[e.id] = e.value
			})), e.controls.keyboard.spectate.forEach((e => {
				FT.controls.keyboard.spectate[e.id] = e.value
			})), e.controls.gamepad.game.forEach((e => {
				FT.controls.gamepad.game[e.id] = e.value
			})), e.controls.gamepad.spectate.forEach((e => {
				FT.controls.gamepad.spectate[e.id] = e.value
			})), jO(FT.controls), KO(), $O(FT.mouseSpeed), JO(FT.controllerSpeed), qO(FT.deadzone), i = FT.enableChat, console.log("setting chat: " + i), i ? (FT.enableChat = !0, localStore.setItem("enableChat", !0), BT && (kP() ? (fT.value = nD("ingame_press_enter_to_chat"), fT.style.pointerEvents = "auto") : (fT.value = nD("ingame_sign_in_to_chat"), fT.style.pointerEvents = "none"), pT.style.display = "block", fT.style.display = "block")) : (FT.enableChat = !1, localStore.setItem("enableChat", !1), BT && (pT.style.display = "none", fT.style.display = "none")), JN && (FT.autoDetail ? t.autoDetail || (hD(!0), cD(!0), oD()) : (hD(FT.highRes), cD(FT.shadowsEnabled), lD()), FT.centerDot ? GN.showDot() : GN.hideDot(), FT.hitMarkers ? UN.show() : UN.hide()), YO()
		},
		resetSettings: function() {
			localStore.removeItem("volume"), localStore.removeItem("mouseSensitivity"), localStore.removeItem("mouseSpeed"), localStore.removeItem("mouseInvert"), localStore.removeItem("fastPollMouse"), localStore.removeItem("holdToAim"), localStore.removeItem("enableChat"), localStore.removeItem("safeNames"), localStore.removeItem("autoDetail"), localStore.removeItem("shadowsEnabled"), localStore.removeItem("highRes"), localStore.removeItem("controlConfig"), localStore.removeItem("controllerSpeed"), localStore.removeItem("deadzone"), localStore.removeItem("controllerInvert"), localStore.removeItem("controls"), localStore.removeItem("hideBadge"), localStore.removeItem("closeWindowAlert"), localStore.removeItem("shakeEnabled"), localStore.removeItem("centerDot"), XO()
		},
		setVolume: KO,
		setSafeNames: function(e) {
			if (BT) {
				for (var t = 0; t < Mk; t++) {
					var i = iI[t];
					i && (i.name = e ? i.safeName : i.Ha, i.pa.setupNameSprite())
				}
				EP()
			}
		},
		setMouseSpeed: $O,
		setControllerSpeed: JO,
		setDeadzone: qO,
		setShadows: cD,
		renderItemToCanvas: function(e, t, i) {
			e || gO.clearCanvas(t), e.item_type_id === Eh.Stamp ? gO.renderStampToCanvas(e, t, i) : gO.renderToCanvas(e, t, i)
		},
		getEquippedItems: function() {
			return kh.playerAccount.getEquippedItems()
		},
		getTaggedItems: function(e, t) {
			return kh.catalog.getTaggedItems(e, t)
		},
		getPremiumItems: function() {
			return kh.catalog.getPremiumItems()
		},
		getItemsOfType: function(e) {
			switch (e) {
				case Eh.Hat:
					return kh.catalog.hats;
				case Eh.Stamp:
					return kh.catalog.stamps;
				case Eh.Primary:
					return kh.catalog.forClass[kh.playerAccount.classIdx].forWeaponSlot[yh];
				case Eh.Secondary:
					return kh.catalog.forClass[kh.playerAccount.classIdx].forWeaponSlot[Sh];
				case Eh.Grenade:
					return kh.catalog.grenades;
				case Eh.Melee:
					return kh.catalog.melee;
				default:
					return []
			}
		},
		isItemOwned: lk,
		tryEquipItem: function(e, t) {
			if (t = t || e.item_type_id, null === e || lk(e) || "default" === e.unlock) switch (t) {
				case Eh.Hat:
					kh.playerAccount.hatItem = e;
					break;
				case Eh.Stamp:
					kh.playerAccount.stampItem = e;
					break;
				case Eh.Primary:
					kh.playerAccount.pickWeapon(yh, e);
					break;
				case Eh.Secondary:
					kh.playerAccount.pickWeapon(Sh, e);
					break;
				case Eh.Grenade:
					kh.playerAccount.grenadeItem = e;
					break;
				case Eh.Melee:
					kh.playerAccount.meleeItem = e
			}
		},
		poseWithItems: (e, t, i) => GT.poseWithItems(e, t, i),
		setShellColor: function(e) {
			kh.playerAccount.colorIdx = e, GT.poseWithColor(e)
		},
		setStampPosition: function(e, t) {
			GT.poseWithStamp(void 0, e, t)
		},
		api_checkBalance: hN,
		checkUpgrade: cN,
		api_buy: function(e, t, i) {
			lN({
				cmd: "buy",
				firebaseId: kh.playerAccount.firebaseId,
				itemId: e.id,
				save: "undefined" == typeof checkStatus || checkStatus()
			}, (function(e) {
				switch (console.log("purchase response: " + e.result), e.result) {
					case "SUCCESS":
						if (hasValue(e.itemId)) {
							var s = kh.catalog.findItemById(e.itemId);
							kh.playerAccount.addToInventory(s, !0)
						}
						kh.playerAccount.currentBalance = e.currentBalance, vueApp.statsLoading(), GD(), PO(.5), t();
						break;
					case "INSUFFICIENT_FUNDS":
						vueApp.needMoreEggsPopupCall();
						break;
					case "ALREADY_OWNED":
						vueApp.showGenericPopup("p_buy_owned_title", "error", "reload", !0);
						break;
					case "ERROR_CODE_4225":
						vueApp.showGenericPopup("p_error_4225_title", "error", "reload", !0);
						break;
					default:
						i()
				}
			}), (function() {
				i()
			}))
		},
		api_redeem: function(e, t, i) {
			if (5831 == e) return vueApp.giveStuffPopup.eggOrg = !0, void vueApp.showGiveStuffPopup("p_give_stuff_title");
			lN({
				cmd: "redeem",
				firebaseId: kh.playerAccount.firebaseId,
				id: kh.playerAccount.id,
				code: e
			}, (function(e) {
				switch (console.log("Redeem Code response: " + e.result), e.result) {
					case "SUCCESS":
						e.eggs_given || (e.eggs_given = 0), e.item_ids || (e.item_ids = []), e.eggs_given && e.eggs_given > 0 && hN();
						var s = [];
						if (e.item_ids)
							for (var n = 0; n < e.item_ids.length; n++) {
								var a = kh.catalog.findItemById(e.item_ids[n]);
								kh.playerAccount.addToInventory(a), s.push(a)
							}
						PO(.5), t(e.eggs_given, s);
						break;
					case "PLAYER_NOT_FOUND":
						vueApp.showGenericPopup("p_redeem_error_no_player_title", "p_redeem_error_no_player_content", "ok");
						break;
					case "CODE_DOUBLE_DOUBLE":
						vueApp.showGenericPopup("p_redeem_code_redeem_in_progress_title", "p_redeem_code_redeem_in_progress_content", "ok");
						break;
					case "CODE_PREV_REDEEMED":
						vueApp.showGenericPopup("p_redeem_prev_title", "p_redeem_prev_content", "ok");
						break;
					case "CODE_NOT_FOUND":
						vueApp.showGenericPopup("p_redeem_badcode_title", "p_redeem_badcode_content", "ok");
						break;
					case "RATE_LIMIT_REACHED":
						vueApp.showGenericPopup("p_redeem_ratelimited_title", "p_redeem_ratelimited_content", "ok");
						break;
					default:
						i()
				}
			}), (function() {
				console.log("there be an error"), i()
			}))
		},
		saveEquipment: fD,
		buyGoldenChicken: function() {
			aF("golden_chicken_pass")
		},
		checkStartChicknWinner: sN,
		api_feedback: function(e, t, i) {
			const s = () => vueApp.showGenericPopup("uh_oh", "feedback_error_msg", "ok");
			for (var n = kh.engine.getGlInfo(), a = kh.engine.getCaps(), r = [], o = 0; o < Ah.length; o++) r.push([kh.playerAccount.pickedWeapons[o][0].id, kh.playerAccount.pickedWeapons[o][1].id]);
			var l = "";
			if (e !== fh || hasValue(kh.playerAccount.firebaseId)) {
				try {
					l = JSON.stringify({
						debugObject: ew,
						debugArray: ZT
					})
				} catch (e) {
					console.log(e)
				}
				lN({
					cmd: "feedback",
					feedbackType: e,
					gameVersion: TT,
					userAgent: window.navigator.userAgent,
					username: vueApp.playerName,
					comments: i,
					email: t,
					firebaseId: kh.playerAccount.firebaseId || null,
					fromEU: isFromEU,
					gameServer: vueApp.loc[vueApp.currentRegionLocKey] || null,
					session: kh.playerAccount.session || null,
					ping: cT > 0 ? Math.floor(hT / cT) : null,
					highestPing: tw || null,
					fps: mT > 0 ? Math.ceil(uT / mT) : null,
					gameType: aT || null,
					privateGame: null,
					localKills: XN || 0,
					localDeaths: YN || 0,
					localStreak: jN || 0,
					url: parsedUrl.root,
					referrer: document.referrer,
					TS: rT || null,
					screenSize: screen.width + "x" + screen.height,
					colorDepth: screen.colorDepth,
					pixelDepth: screen.pixelDepth,
					innerSize: window.innerWidth + "x" + window.innerHeight,
					glVendor: n.vendor,
					renderer: n.renderer,
					glVersion: n.version,
					maxTextureSize: a.maxTextureSize,
					mk: iT ? iT.mk : null,
					controls: localStorage.getItem("controls"),
					ofAge: RT ? RT.ofAge : null,
					targetedAds: RT ? RT.targetedAds : null,
					volume: FT.volume,
					mouseSpeed: FT.mouseSpeed,
					mouseInvert: FT.mouseInvert,
					holdToAim: FT.holdToAim,
					enableChat: FT.enableChat,
					safeNames: FT.safeNames,
					autoDetail: FT.autoDetail,
					shadowsEnabled: FT.shadowsEnabled,
					highRes: FT.highRes,
					selectedClass: kh.playerAccount.classIdx,
					selectedColor: kh.playerAccount.colorIdx,
					hat: kh.playerAccount.hatItem ? kh.playerAccount.hatItem.id : null,
					stamp: kh.playerAccount.stampItem ? kh.playerAccount.stampItem.id : null,
					stampPositionX: kh.playerAccount.stampPositionX,
					stampPositionY: kh.playerAccount.stampPositionY,
					grenade: kh.playerAccount.grenadeItem ? kh.playerAccount.grenadeItem.id : null,
					weapons: "[[0,0],[0,0],[0,0]]",
					timesPlayed: null,
					xsollaToken: null,
					current_balance: kh.playerAccount.currentBalance,
					log: "",
					debug: l
				}, (function(e) {
					const t = {
						title: "",
						desc: ""
					};
					e.status ? e.type === fh ? (t.title = "feedback_delete_title", t.desc = "feedback_delete_msg") : (t.title = "feedback_sent_title", t.desc = "feedback_sent_msg") : (t.title = "uh_oh", t.desc = "feedback_error_msg");
					setTimeout((function() {
						vueApp.showGenericPopup(t.title, t.desc, "ok")
					}), 1e3)
				}), (function(e) {
					s()
				}))
			} else s()
		},
		releaseKeys: CP,
		captureKeys: MP,
		respawn: function() {
			return HT ? (bk.Ba = !0, void canvas.requestPointerLock({
				unadjustedMovement: FT.fastPollMouse
			})) : (console.log("Respawn pressed - respawnTime: " + gN), gN < 0 ? (xD.clearAll(), MD.clearAll(), xD.set((() => {
				"IFRAME" == document.activeElement.tagName && (console.log("iframe attempted to steal focus:", document.activeElement), document.activeElement.blur())
			}), 100), FT.autoDetail && oD(), wI() ? (wN = !0, void Mw.play("shellshock.io_preroll", AI)) : function() {
				if (!Pw) return console.log("requestRespawn - isChromeSuxPointerAllowed"), void vueApp.chromeIsABuggerPopupShow();
				if (console.log(`requestRespawnBlocked ${RI}`), RI) return;
				if (RI = !0, setTimeout((() => RI = !1), 1e3), pI) {
					bk.changeCharacter(kh.playerAccount.classIdx, kh.playerAccount.getPrimaryWeapon(), kh.playerAccount.getSecondaryWeapon(), kh.playerAccount.colorIdx, kh.playerAccount.hatItem, kh.playerAccount.stampItem, kh.playerAccount.stampPositionX, kh.playerAccount.stampPositionY, kh.playerAccount.grenadeItem, kh.playerAccount.meleeItem), (e = Rh.getBuffer()).BkKlQQwL(sh.M), e.BkKlQQwL(kh.playerAccount.classIdx), e.send(mk), pI = !1
				}
				var e;
				(e = Rh.getBuffer()).BkKlQQwL(sh.Gk), e.send(mk), vueApp.setPause(!1), crazySdk.gameplayStart()
			}()) : void 0)
		},
		leaveGame: function(e) {
			kh.engine && kh.engine.stopRenderLoop(), xk = 0, ST = 0, vueApp.resetGameOptions(), BT ? (bk && (kh.playerAccount.kills += XN, kh.playerAccount.deaths += YN, kh.playerAccount.streak = Math.max(jN, kh.playerAccount.streak), MT.streak = jN), xD.clearAll(), MD.clearAll(), clearInterval(KN), mk.close(th.mainMenu), mk = null, CP(), document.exitPointerLock(), sT > 0 && (sO(sT, CR[oT].name), MT.end(), TD(), wD(), function() {
				if (CD) return;
				CD = !0;
				const e = HD();
				if (0 === Object.keys(e).length) return;
				e.kills && ga("send", "event", "player stats", "game_stats", "total_kills", e.kills);
				e.deaths && ga("send", "event", "player stats", "game_stats", "total_deaths", e.deaths);
				if (!e.hasOwnProperty("charClass")) return;
				const t = Object.keys(e.charClass);
				if (0 === t.length) return;
				t.forEach((t => {
					const i = "Ranger" === t ? "Free Ranger" : t;
					(e.charClass[t].kills || e.charClass[t].deaths) && (ga("send", "event", "player stats", "kills", i, e.charClass[t].kills), ga("send", "event", "player stats", "deaths", i, e.charClass[t].deaths), ga("send", "event", "player stats", "kill ratio", i, Math.floor(e.charClass[t].kills / Math.max(e.charClass[t].kills + e.charClass[t].deaths, 1) * 100)))
				}))
			}()), JN.dispose(), BT = !1, vueApp.setInGame(BT), wO(), GT = new MO, e(), OO(), vueApp.hideRespawnDisplayAd(), Tw = !1, pO(), VD(), CT.tryReward()) : vueApp.switchToHomeUi(), crazySdk.hideInviteButton(), ED(), GD()
		},
		openEquipInGame: jP,
		closeEquipInGame: function(e) {
			kh.engine.stopRenderLoop(), qI(e), pI = !0, AN && fT.focus()
		},
		buyProductForMoney: function(e) {
			parsedUrl.dom + parsedUrl.top !== "devshellshock" || localStore.getItem("xsollaPopupConfrim") ? (fw = e, aF(e, "subscription" === _w.getProductType(e)), localStore.removeItem("xsollaPopupConfrim")) : vueApp.openDevXsollaPopup(e)
		},
		clickedHouseAdSmall: function(e) {
			ga("send", "event", {
				eventCategory: "House banner ad",
				eventAction: "click",
				eventLabel: e.label
			}), _O(e)
		},
		clickedHouseAdBig: function(e) {
			ga("send", "event", {
				eventCategory: "Big ad",
				eventAction: "click",
				eventLabel: e.label
			}), _O(e)
		},
		clickedHouseLink: _O,
		doConsent: function() {
			ga("send", "event", "privacy", "age gate", "agree"), RT = {
				ofAge: !0,
				targetedAds: !0
			}, googletag.consented = !0, vueApp.setPrivacySettings(!0, !0), localStore.setItem("consent", JSON.stringify(RT))
		},
		doNotConsent: function() {
			ga("send", "event", "privacy", "age gate", "disagree"), googletag.consented = !1, vueApp.setPrivacySettings(!1, !1), localStore.setItem("consent", JSON.stringify(RT))
		},
		setOfAge: function(e) {
			RT.ofAge = e, ga("send", "event", "privacy", "of age", e ? "yes" : "no"), e || (RT.targetedAds = !1, googletag.consented = !1), localStore.setItem("consent", JSON.stringify(RT))
		},
		setTargetedAds: function(e) {
			RT.targetedAds = e, googletag.consented = e, ga("send", "event", "privacy", "targetedAds", e ? "yes" : "no"), localStore.setItem("consent", JSON.stringify(RT))
		},
		settingsMenuOpened: function() {
			BT && 1 == FT.enableChat && DP()
		},
		copyFriendCode: function(e) {
			! function() {
				const e = vueData.gameTypes.find((({
						value: e
					}) => e === aT)),
					t = vueData.googleAnalytics;
				iO([
					[t.cat.play, t.action.shareGameCopy, `Map - ${QN.name}`, ""],
					[t.cat.play, t.action.shareGameCopy, e.locKey ? `Game type - ${e.locKey}` : "n/a", ""],
					[t.cat.play, t.action.shareGameCopy, `Play type - ${vT}`, ""]
				])
			}();
			try {
				navigator.clipboard.writeText(e)
			} catch (e) {
				console.log("Unable to copy to clipboard")
			}
		},
		switchTeam: function() {
			if (uw) {
				console.log("Team switch requested");
				var e = Rh.getBuffer();
				e.BkKlQQwL(sh.j), e.send(mk)
			}
		},
		onChatKeyDown: function(e) {
			var t = (e = e || window.event).key;
			switch (fT.value = RD(fT.value, 280), t) {
				case "Enter":
					var i = fT.value.trim();
					if ("" != i && i.indexOf("<") < 0) {
						FP(i);
						var s = function(e) {
							if (!e.startsWith("/")) return nh;
							let t = e.slice(1).split(" ");
							switch (t[0].toLowerCase()) {
								case "t":
								case "team":
									return t[1] ? wk ? rh : nh : null;
								case "p":
								case "pin":
									return yT ? ah : nh;
								default:
									return nh
							}
						}(i);
						s != nh && (i = function(e) {
							let t = e.split(" ");
							return e.slice(t[0].length + 1)
						}(i)), VT || OP(i, s, xk), kh.adminRoles || yT || (bk.chatLines++, bk.chatLines > 2 && (fT.style.visibility = "hidden")), 1 === ++CN && ga("send", "event", "game", "stats", "chat", CN)
					}
				case "Tab":
					e.preventDefault(), e.stopPropagation(), BP()
			}
		},
		startChat: LP,
		stopChat: BP,
		selectGameType: function(e) {
			aT = e, localStore.setItem("gameType", e)
		},
		inviteFriends: XP,
		hasHouseLink: function(e) {
			return e.link || e.linksToTaggedItems || e.linksToItemId || e.linksToPass || e.linksToPhotoBooth
		},
		enterSpectatorMode: function() {
			JI || (JI = !0, setTimeout((() => JI = !1), 1e3), gN < 0 && (LN = !1, VN = !0, WN = eF.freeCamera, vueApp.setPause(!1), vueApp.setInGame(VN), bN.freeCamera(), xI(), TI(), bk.Oa = Math.radRange(iT.rotation.y), bk.ca = -iT.rotation.x, xN = xD.set((function() {
				var e = Rh.getBuffer();
				e.BkKlQQwL(sh.Ek), e.send(bk.ws)
			}), 15e3), lP()))
		},
		fixStringWidth: RD,
		filterUnicode: ID,
		clickedWebFeedItem: function(e) {
			function t(e) {
				ga("send", "event", "newsItem", "clicked", e)
			}
			if ("linksToItemId" in e) {
				let i = kh.catalog.findItemById(parseInt(e.linksToItemId, 10));
				return vueApp.showItemOnEquipScreen(i), void t(`item=${i.name}`)
			}
			return "linksToTaggedItems" in e ? (iw = 1 == e.linksToTaggedItems ? lw.specialItemsTag : e.linksToTaggedItems, Ew = !0, Kk(), void t(`tagged=${e.linksToTaggedItems}`)) : "linksToChangeLog" in e ? (vueApp.showChangelogPopup(), void t("sschangelog")) : "link" in e ? (window.open(e.link, "_window"), void t(e.link)) : "linksToPhotoBooth" in e ? (UD(), void t("openPhotoBooth")) : ("linksToPass" in e && (Jk(), t("pass")), "linksToEggStoreItem" in e ? (vueApp.showPopupEggStoreSingle(e.linksToEggStoreItem), void t(`skuItem=${e.linksToEggStoreItem}`)) : void("linksToVipStore" in e && (vueApp.showSubStorePopup(), t(`skuItem=${e.linksToVipStore}`))))
		},
		pokiRewardedBreak: (e, t) => {
			pokiActive && (KO(0), PokiSDK.rewardedBreak().then((() => {
				kO(), e && e(dh.video), KO(), console.log("POKI Reward given")
			})).catch((e => {
				console.log("Reward failed. ", e), t && t(), KO()
			})))
		},
		api_inGameReward: function(e, t, i) {
			const s = {
				cmd: "inGameReward",
				firebaseId: kh.playerAccount.firebaseId
			};
			vueApp.showSpinner(), lN(s, (s => {
				switch (console.log("In Game reward response: " + s.result), vueApp.hideSpinner(), s.result) {
					case "SUCCESS":
					case "SUCCESS_FIRST":
						e();
						break;
					case "REACHED_DAILY_LIMIT":
						i();
						break;
					case "ERROR":
						t()
				}
			}), t)
		},
		socialReward: function(e) {
			const t = e + "Rewarded";
			if (Hw[t] >= 1) return void localStore.setItem(t, !0);
			Hw[t]++, vueApp.showSpinner();
			const i = {};
			i.tag = dh[e],
				function(e, t, i) {
					lN({
						cmd: "reward",
						firebaseId: kh.playerAccount.firebaseId,
						rewardTag: e.tag
					}, t, i)
				}(i, (function(e) {
					vueApp.hideSpinner();
					FD(e, {
						name: "Social media reward",
						success() {
							localStore.setItem(t, !0)
						},
						prevGiven() {
							this.success()
						},
						expired() {
							this.succces()
						},
						notFound() {
							localStore.setItem(t, !1)
						},
						playerNotFound() {
							localStore.getItem(t) && localStore.removeItem(t)
						},
						error() {
							this.playerNotFound()
						},
						default () {
							this.playerNotFound()
						}
					})
				}), (function(e) {
					console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), vueApp.showGenericPopup("uh_oh", "generic_conn_failed", "ok"), vueApp.hideSpinner()
				}))
		},
		getHouseAd: e => {
			if (!lw.length) return;
			const t = lw[e].filter((e => e.active));
			if (!t.length) return;
			const i = [],
				s = t.filter((e => e.label.includes("VIP"))).length;
			let n = Math.round(.5 * t.length / s);
			isFinite(n) || (n = 1);
			const a = t.map((e => {
				const t = e.label.toUpperCase();
				return e.priority = 1, t.includes("VIP") && (e.priority = n), e
			}));
			for (let e = 0; e < a.length; ++e)
				for (let t = 0; t < a[e].priority; ++t) i.push(a[e]);
			return i[Math.floor(Math.random() * i.length)]
		},
		getLocText: nD,
		GameType: hh,
		resize: rD,
		giveBasketBrosReward: function() {
			var e, t, i, s;
			e = 16039, t = "giveBasketBrosReward", kh.playerAccount.isItemOwned({
				id: e
			}) ? console.log(t, "already owned!!!") : mN(t, (e => {
				FD(e, {
					name: t,
					success: () => (i && i(), !0),
					error: () => (s && s(), !1)
				}, t)
			}), (e => {
				console.log(t, " error", e)
			}))
		},
		resetPaperDoll: hk,
		getSessionStats: HD,
		getProductTitle: function(e, t) {
			return _w.getProductByItemIds(["bundles", "passes"][t], e)
		},
		chwTryPlay: function() {
			vw.count <= _h && vw.ready ? (Mw.isChwRequest = !0, vueApp.chicknWinnerError(!1), 0 === vw.count ? (eN("chwTryPlay() First play!"), nN()) : cN((() => {
				kh.playerAccount.isUpgraded() ? (eN("chwTryPlay() VIP. No ads for you! Thank you!"), nN()) : (eN("chwTryPlay() No vip. Subscribe today for no video ads!"), Mw.adInPlayActive || window.crazySdk.initialized ? Mw.play("shellshock.io_rpreroll_30s") : (vueApp.showGenericPopup("ad_blocker_nugget_title", "ad_blocker_nugget_content", "ok"), aN("chwTryPlay()", "No video ads!")))
			}), (e => {
				Mw.isChwRequest = !1, aN("chwTryPlay()", e)
			}))) : (eN("checkStartChicknWinner not ready"), sN())
		},
		api_incentivizedVideoRewardRequest: uN,
		getProductTitleByEggVaule: function(e) {
			return _w.getProductTitleByEggVaule(e)
		},
		accountCreationNotification: Wk,
		sendChat: FP,
		getActiveBundles: function() {
			return _w.getBundles()
		},
		requestJson: function(e, t) {
			getRequest(e + "?" + Date.now(), ((e, i) => {
				let s = [];
				if (404 === e) console.log("Accept it and move on.");
				else try {
					const e = JSON.parse(i);
					e.length > 0 && e.forEach((e => s.push(e)))
				} catch (e) {
					console.log("News request error: ", e)
				}
				t(s)
			}))
		},
		sendGameOptions: AD,
		sendGameOptionsMetrics: function() {
			Object.keys(dR.value).forEach((e => {
				switch (e) {
					case "flags":
						Object.keys(fR).forEach((e => {
							let t = dR.value.flags & fR[e] ? 1 : 0;
							ga("send", "event", "game settings", "flags", e, t)
						}));
						break;
					case "weaponDisabled":
						for (let e = 0; e < kh.classes.length; e++) {
							if (dR.value.weaponDisabled[e]) {
								let t = kh.classes[e].name;
								ga("send", "event", "game settings", "weapon disabled", t)
							}
						}
						break;
					default:
						let t = dR.value[e];
						ga("send", "event", "game settings", "setting", e, t)
				}
			}))
		},
		sendGameAction: function(e) {
			let t = Rh.getBuffer();
			t.BkKlQQwL(sh.H), t.BkKlQQwL(e), t.send(mk);
			let i = Object.keys(pR).find((t => pR[t] === e));
			ga("send", "event", "game settings", "action", i)
		},
		GameOptions: dR,
		GameActions: pR,
		GameFlags: fR,
		chwResetWithEggs: function() {
			lN({
				cmd: "chwReset"
			}, (e => {
				const t = e.result;
				console.log("chwResetWithEggs: ", t), "SUCCESS" === t && (sN(), vueApp.chwHomeForceReset(), BAWK.play("ui_playconfirm")), hN()
			}), (e => {
				console.error("chwResetWithEggs error: ", e.error)
			}))
		},
		prepRespawnButton: CI,
		onChromeIsABuggerPopupConfirm: function() {
			BT && !uw && SI()
		},
		loadAllMeshesOnDemand: async function() {
			if (Gw) return !0;
			if (await Ok()) return vueApp.hideSpinner(), !0
		},
		testPremiumItem: function(e) {
			Gk(e), Hk()
		},
		get metaGame() {
			return dk
		},
		get ShellNews() {
			return Rw
		},
		set gameIsOwnerLocked(e) {
			0
		},
		get metaGameUI() {
			return fk
		},
		get isPrivateGame() {
			return gT
		},
		get observingGame() {
			return VT
		},
		get isGameOwner() {
			return yT
		},
		get adminRoles() {
			return kh.adminRoles
		},
		get photoBooth() {
			return bT
		},
		get isGameReady() {
			return Fk()
		},
		get inGame() {
			return BT
		},
		get gamePaused() {
			return uw
		},
		get gameType() {
			return aT
		},
		get specialItemsTag() {
			return lw.specialItemsTag
		},
		get getPwaEvent() {
			return ""
		},
		get account() {
			return kh.playerAccount
		},
		get productBlockAds() {
			return kh.productBlockAds
		},
		get adBlocker() {
			return LT
		},
		get version() {
			return TT
		},
		get changelogData() {
			return $w
		},
		get onJoinGameClick() {
			return Sw
		},
		get adsLoaded() {
			return jw
		},
		get openShopOnly() {
			return Ew
		},
		set openShopOnly(e) {
			Ew = e
		},
		set onJoinGameClick(e) {
			Sw = e
		},
		get fuseOptions() {
			return Yw
		},
		get Challenges() {
			return Qw
		},
		get gameOptions() {
			return xT
		},
		set gameOptions(e) {
			xT = e
		},
		get playerChallenges() {
			return ww
		},
		get getIsWelcomeBundlePurchased() {
			return kw
		},
		get getWelcomePassSku() {
			return Dw
		},
		get LoadingTips() {
			return eR
		},
		get LoadingTipsNew() {
			return tR
		},
		get LoadingMsgs() {
			return iR
		},
		get firebaseUrl() {
			return Lw
		},
		testGameUI: function() {
			vueApp.hideGameMenu(), document.getElementById("deathBox").style.display = "none", document.getElementById("weaponBox").style.display = "block", document.getElementById("healthContainer").style.display = "block", document.getElementById("killTicker").style.display = "block", AN && fT.focus(), $I(), GN.show(), document.getElementById("gameAdContainer").style.display = "none"
		}
	}
})();
''